[
    {
        "title": "Can Convert String in K Moves",
        "question_content": "Given two strings&nbsp;s&nbsp;and&nbsp;t, your goal is to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in&nbsp;k&nbsp;moves or less.\nDuring the&nbsp;ith&nbsp;(1 <= i <= k)&nbsp;move you can:\n\n\tChoose any index&nbsp;j&nbsp;(1-indexed) from&nbsp;s, such that&nbsp;1 <= j <= s.length&nbsp;and j&nbsp;has not been chosen in any previous move,&nbsp;and shift the character at that index&nbsp;i&nbsp;times.\n\tDo nothing.\n\nShifting a character means replacing it by the next letter in the alphabet&nbsp;(wrapping around so that&nbsp;'z'&nbsp;becomes&nbsp;'a'). Shifting a character by&nbsp;i&nbsp;means applying the shift operations&nbsp;i&nbsp;times.\nRemember that any index&nbsp;j&nbsp;can be picked at most once.\nReturn&nbsp;true&nbsp;if it's possible to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in no more than&nbsp;k&nbsp;moves, otherwise return&nbsp;false.\n&nbsp;\nExample 1:\n\nInput: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\nExample 2:\n\nInput: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\nExample 3:\n\nInput: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 10^5\n\t0 <= k <= 10^9\n\ts, t contain&nbsp;only lowercase English letters.",
        "solutions": [
            {
                "id": 779903,
                "title": "java-python-3-o-n-count-the-shift-displacement-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: Where in the problem do you derive to get the following step `3`?\\nA1: From the following description:\\n\" ...\\nDuring the ith (1 <= i <= k) move you can:\\n\\n1. Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\\n2. Do nothing.\\n\\n...\"\\n\\n**End of Q & A**\\n\\n----\\n\\n# Brief Explanation:\\n\\n\\n1. Check if the 2 strings `s` and `t` have same length, if not, return `false`; \\n2. Loop through the input strings and count the shift displacement, in case negative, plus 26 to make it positive;\\n3. If same displacement appears multiple times, the 1st time use the displacement itself, the 2nd time add `26 `to it, the 3rd time add `26 * (3 - 1) = 52 `, the 4th time add `26 * (4 - 1) = 78`, etc.; if after adding the result is greater than `k`, return `false`;\\n4. If never encounter `false` in the above 3, return `true`.\\n\\n```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779908,
                "title": "c-o-n-track-multiplier",
                "content": "#### Intuition\\nYou can only shift a letter once, and you cannot change more than once letter by the same number of shifts (`i`). In other words, if you shift one letter by `1`, no other letters can be shifted by `1`. If you need to shift by `1` again, you need to use \"wrapping\" and shift by `27` (which is `1 + 26`).\\n\\nTherefore, if our strings are `\"aaa\"` and `\"bbb\"`, we need to shift the first letter by `1`, the second by `27` (`1 + 26`), and the third - by `53` (`1 + 2 * 26`). So, you  can accomplish the task if `k` is equal or greater than `53`.\\n\\n#### Algorithm\\nGo through the strings and determine `shift` for each letter. If letter in `t` is smaller, we need to \"wrap\" it by adding 26 (e.g. changing `b` into `a` needs 25 shifts).\\n\\nAfter we use a certain number of shifts, we need to add 26, 52, and so on if we need to use it again. So we track the multiplier for each number of shifts in `mul`. If, at any time, the needed number of shifts exceeds `k`, we return `false`.\\n\\n```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779932,
                "title": "o-n-c-simple-solution-with-explanation",
                "content": "Basic idea is to convert str1 to str2 using less or equal to k iterations where in ith iteration you can choose **atmost** one character to shift **exactly** i places.\\n\\nIntuition :\\n1. if string size is not equal, return false;\\n2. use a hashmap to check how many times the diff is same and keep using the iteration with the formula (26 *(num of occurreces of same diff) + diff;\\n\\nFor eg. \"abc\" -> \"bcd\", diff for a -> b is 1 and we can check hashmap for occurences of diff as following:\\n\\n\\n```hashMap = {....... {1 = 0}....}```\\nWe can use iteration 1 in this case and we update the hashmap to the following to denote that 1 iteration has already been used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nNow to shift b -> c also we need 1 Iteration,which is already being used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nSince 1 iteration is already being used, we can use 26 + 1, and update hash map :\\n```hashMap = {....... {1 = 2}....}```\\nand we also keep track of the maximum iteration found so far.\\n...\\n...\\nand so on.\\n\\nFinally if max iteration <= k return true.\\n\\nNote: Please upvote if you find this useful, this motivates me to write more descriptive solutions\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```\\n\\nMore Concise solution\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            count = max(count, (mp[diff] * 26) + diff);\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```hashMap = {....... {1 = 0}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 2}....}```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779938,
                "title": "python-o-n-explained",
                "content": "The logic is as follows:\\nFirst we need to calculate the difference of the conversion. for example conversion from a to be will have difference of 1.\\nThen we hold a hash map ```diff``` to see how many times we want to convert each difference.\\nFor example to go from \"aa\" to \"bb\" we want to go ```difference 1``` for 2 times.\\nThis is possible only if we will have k of 27 or above, because to go from ```a``` to ```b``` we need 1, and each loop starts at 26 (alphabet count).\\n\\nQuick way to check that is: ``` ((diff[d] - 1) * 26) + d > k ```\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```diff```\n```difference 1```\n```a```\n```b```\n``` ((diff[d] - 1) * 26) + d > k ```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780012,
                "title": "can-anyone-explain",
                "content": "I didnt understand the second test case\\n\\n```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```\\n\\nWhy is the answer false? Shouldnt this be possible in three moves?",
                "solutionTags": [],
                "code": "```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 782335,
                "title": "python-simple-array-lookup-o-n-time-o-1-space",
                "content": "**Idea:**\\n\\nTest Cases:\\n* Check if length of strings are equal \\n\\nLogic\\n* Check the distance between between the s[i] and t[i] using the ord()\\n* Record the distance in an array which tracks used shifts\\n* Check the array to see if shift has been used\\n* If shift has been used take the number of times it has been used and multiply by 26\\n* If shift > k return False \\n\\n**Tricks**\\n* Use mod 26 when taking the ord() difference between the chars\\n* Example: s[i] = \\'b\\' and t[i] = \\'a\\' which requires 25 shifts\\n* ord(s[i]) - ord(t[i]) = -1\\n* (-1) % 26 = 25 \\n*  Makes logic simpler \\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780269,
                "title": "java-simple-hashmap",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779955,
                "title": "simple-c-solution-with-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779906,
                "title": "transform-to-math-question",
                "content": "imagine the first round we can do x steps, x is min(26, k)\\nfor each different char, we can change it to the destination char in the first round, after that, we have to always wait for another 26 times\\n\\nfor example, \"ab\" -> \"cd\"\\n\\n\\'a\\' to \\'c\\' needs 2 steps;\\n\\'b\\' to \\'d\\' needs 2 steps;\\n\\nbut we can only do ONE replacing with 2 steps to make \\'a\\' to \\'c\\'\\nto make \\'b\\' to \\'d\\' happen, we will need to wait for next round, which is 2+26 = 28. \\n\\nso simply check how many cases(C) exist for a N steps operation.\\nif N + (c-1)*26 > K then we can\\'t make it happen. \\n\\n```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189629,
                "title": "simple-c-solution-8-lines",
                "content": "Here we simply calculate the shift required for each character of ```s``` and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of ```k```.\\n* ```ar[i] = x``` implies that there are x characters in ```string s``` that need a shift of i to match the charcters in ```string t```.\\n* Now it is given in the question that each shift can be used only once. \\n* So if two charcters need a shift of 1, only one of them will be allowed.\\n* The next charcter will get a shift of 1 + 26 which makes the efective shift to be 1. \\nEg: lets say ```s = \"aa\"``` and ```t = \"cc\"```\\nThen ```ar[2] = 2```\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s```\n```k```\n```ar[i] = x```\n```string s```\n```string t```\n```s = \"aa\"```\n```t = \"cc\"```\n```ar[2] = 2```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881255,
                "title": "python-3-3-lines-counter-w-example-t-m-93-19",
                "content": "Here\\'s the plan:\\n* We construct a `Counter` to keep track of the shifts.\\n\\n* We check whether `k` is sufficient to accomodate the shifts for each position of like difference. For example, if `c[2] = 3` (that is, three positions each have a difference of 2)  the third char is shifted `2+26+26 = 54`, so it must be that `k >= 54`.\\n* If so, we return `True`; if not `False`.\\n\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```\\n[https://leetcode.com/submissions/detail/855147141/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657022,
                "title": "detailed-explanation-well-coded-92-faster",
                "content": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1268156,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779987,
                "title": "java-hashmap-o-n",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779911,
                "title": "simple-c-o-n-solution-no-hashmap-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286937,
                "title": "java-string-greedy-10ms-beats-90-t-c-o-n-s-c-o-n",
                "content": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 981234,
                "title": "python-3-beats-91-with-explanation",
                "content": "For example, we want to transform \"ad\" to \"be\".\\nApparently, we can shift \"a\" by 1 move, to \"b\", however, in order to shift \"d\" to \"e\", we can no longer shift \"d\" by 1 move since we have already done it before, so we have to find the next smallest number which residue is 1, which is 27. So once we shift \"a\" by 1 move, we can wait for 25 following steps with 0 move, then, we shift d by 27 moves to get \"e\"\\nTherefore it is pretty clear that we just need to sort the characters pairs in s and t, by the residue of ord different after mod 26.\\nSo the dictionary for our example is d={1:2}, which means the char pairs have 2 residue of 1. Then the smallest K should be 1+(2-1)* 26.\\n\\nDo not forget to pick the alphabitically largest character if multiple characters have same values.\\n\\n```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 895168,
                "title": "python-sol-explained-in-great-detail",
                "content": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 858863,
                "title": "python-breifly-explained-remember-the-recent-longest-shift-o-n",
                "content": "Each character at index j in both source and target string have some expected shifts. For example,\\n```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\\nAlgorithm:\\n1.  Expected shifts are ```(ord(\"e\") - ord(\"a\"))%26```, since alphabets arranged in cycle. Here, ```shifts = 4```\\n\\n2.  Maintain a hashmap for used i number of shifts. Ask hashmap whether 4 shifts are available. If yes update the ```eyesUsed[4] = 4```\\n\\n3.  if any other pair of chars in s and t also asking for 4 shifts which are occupied, then previously saved hashmap[4] can lead us where to look next, which is  ```26 + eyesUsed[4]```  because next valid way to reach target char is to shift through all alphabets once.\\n\\n4.  Repeat **step 2** and **step3** untill vacant shifts found if number of shifts exceeded the K value then abort the loop and return False\\n\\n5.  After successfully shifting all the characters return True\\n\\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\\n\\n**Base cases:** \\n* ```If source s[i]  == target t[j] then skip shifting```\\n* ```if lengths of source != target then return False```\\n\\nUnderStood? Any Improvements?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\n```(ord(\"e\") - ord(\"a\"))%26```\n```shifts = 4```\n```eyesUsed[4] = 4```\n```26 + eyesUsed[4]```\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\n```If source s[i]  == target t[j] then skip shifting```\n```if lengths of source != target then return False```",
                "codeTag": "Python3"
            },
            {
                "id": 836489,
                "title": "java-o-n-method",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781884,
                "title": "c-o-n-beat-100",
                "content": "Got TLE using set, so i use a int array to store the numbers of move. 100% time\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780437,
                "title": "python-o-n-solution-with-explanation",
                "content": "**Technique:**\\n\\n1. Create a `diffArr` (Difference Array) which will store the ascii difference between the characters in the string `t` & `s`. Since we can only increment & not reduce, for all the negative values(When we sustract `a` with `z`) we have to subtract it with 26 & store the difference. \\n2. Next step is to crate a set (`diffSet`) to keep track of the shifts which we have already used between `1-k`. \\n3. As we iterate through the `diffArr` we have to check if we already have the `ith` step in set, if not we\\'ll add it to the set since that is the first time we\\'re using it. And if it is already present - here\\'s where the real logic is. We have to keep incrementing the number of shifts by 26 as that would result in the same character. We have to increment it until we get the number of moves which have not been used until now (which is what the while loop within else statement is responsible for). \\n\\ni.e., difference 1 can take values 1, 27, 53, 79... & so on\\n\\nMeanwhile while moving itself, we can check if the number of shifts is going to exceed k or not, if yes return False\\n\\n**TLE Issue Code**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\\n\\n**Whats the problem with this approach?**\\n\\nSince we\\'re having a while loop which starts from i (which is less than 26) and loop until we find the next number of shifts for every value in `diffArr` we will end up in ***`TLE`***\\n\\n**How to solve this?**\\n\\nHere\\'s where memoization comes into picture. Instead of looping through by incrementing values by 26, we can store what is the value for the original `i` which will store the most recently used value for `i`\\n\\nFor eg., \\nif i = 1, we can have the number of shifts as 1,27,53,79... and so on.\\nInstead of calculating this from 1 upto... the limit k or next free value, mem[1] will store the most recently used value which will fit it. \\n\\nFor 1st iteration\\n```mem[1] = 1```\\n2nd\\n```mem[1] = 27```\\n3rd\\n```mem[1] = 53```\\n& so on\\n\\n**Working code with Single Loop**\\n\\nWe don\\'t have to store and then iterate the `diffArr`, we can perform the memoization & checks while iterating through the strings itself.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```\\n\\nJust checking for the base conditions if both strings are same, we return `True`. And if the lengths don\\'t match, we return `False`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\n```mem[1] = 1```\n```mem[1] = 27```\n```mem[1] = 53```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780066,
                "title": "java-6-lines-o-n-time-o-1-space",
                "content": "Just compute required swaps for each position modulo 26, and confirm that k is large enough to satisfy all required swappings.\\n\\n```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039833,
                "title": "can-convert-string-in-k-moves",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it checks if the length of two strings are not equal, it returns false\\nIt calculates the number of shift required for each character to convert the first string to the second one.\\nThen it iterates over the number of shift required and for each shift, it checks if the number of shift * 26 + the current shift greater than k, if so it returns false.\\nIf all the indexes can be shifted in k moves or less, it returns true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) where n is the length of the string.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is O(1) since we are using a fixed size array of size 26 to store the shift count.\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963839,
                "title": "python3-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666958,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915299,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int round = k / 26;\\n        int remaining = k % 26;\\n        int[] record = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            if (i < remaining) {\\n                record[i] += 1;\\n            }\\n            record[i] += round;\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            if (c1 == c2) continue;\\n            int index = (c2 - c1 + 26) % 26 - 1;\\n            if (record[index] > 0) {\\n                record[index] -= 1;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409548,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff<0)\\n            {\\n                diff=diff+26;\\n            }\\n            if(diff!=0)\\n            {\\n                if(v[diff].size()==0)\\n                {\\n                    v[diff].push_back(diff);\\n                }\\n                else\\n                {\\n                    v[diff].push_back(v[diff].back()+26);\\n                    diff=v[diff].back();\\n                }\\n            }\\n            if(diff>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315618,
                "title": "first-pass-with-len-s-second-pass-with-len-26-100-speed",
                "content": "Runtime: 260 ms, faster than 100.00% of Python3 online submissions for Can Convert String in K Moves.\\nMemory Usage: 15.7 MB, less than 16.67% of Python3 online submissions for Can Convert String in K Moves.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092769,
                "title": "c-easy-solution",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1059413,
                "title": "java-faster-than-100-o-n-time-complexity",
                "content": "\\n\\nclass Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }\\n        return true;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988808,
                "title": "c-60-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888012,
                "title": "python3-o-n-solution-beats-99",
                "content": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "solutionTags": [],
                "code": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887066,
                "title": "python3-o-n-solution-can-convert-string-in-k-moves",
                "content": "Find the largest character among those who have the highest frequency. The min steps required is the `(freq - 1) * 26 + ord(char)`.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881844,
                "title": "c-99-faster-simple-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822842,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814681,
                "title": "very-eazy-and-clear-python-3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 800729,
                "title": "java-hashmap-solution",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800282,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793074,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784683,
                "title": "python-3-explained",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782490,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int diff=t.charAt(i)-s.charAt(i);\\n                // System.out.println(t.charAt(i)+\" \"+diff+\" \"+s.charAt(i));\\n                if(diff<0){\\n                    diff=diff+26;\\n                }\\n                int a=diff;\\n                int v=0;\\n                if(li.contains(diff)){\\n                    v=map.get(a);\\n                    diff=v+26;\\n                }\\n                map.put(a,diff);\\n                if(k>=diff){\\n                \\n                    li.add(diff);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 781657,
                "title": "java-simple-o-n-time-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780785,
                "title": "easy-c-solution-using-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780454,
                "title": "javascript-python3-c-add-del-needs",
                "content": "**Synopsis:**\\n\\nUse a hash table to track `needs`.  Return `true` if and only if there are no `needs`.  There are three use cases to consider when calculating `needs` by comparing the difference (ie. `k`) between each i-th character\\'s ordinal value in `s` and `t`:\\n\\n* **Case 1:** the difference is 0, then there\\'s no need to perform any rotation, since the characters are the same\\n* **Case 2:** the difference is a positive value `x`, this means that the character `s[i]` occurs *before* the character `t[i]` lexicographically in the english latin alphabet, and so we can safely add 26 onto `x` because when we mod by 26, we end up with the same value, ie `x == (x + 26) % 26`.  (Try plugging in some positive values for `x` if you don\\'t believe me.)  Since adding 26 then mod\\'ing by 26 is a no-op for case 2, one may wonder \"what\\'s the point?\"  The purpose of adding by 26 is for case 3, the \"wrap-around\" case.\\n* **Case 3:** the difference is a negative value, this means that the character `s[i]` occurs *after* the character `t[i]` lexicographically in the english latin alphabet, per the problem statement, when we rotate this character, it \"wraps-around\" upon reaching `z` back to `a`.  So the \"wrap-around\" length is taken into account by adding 26 onto the negative value.  The result is a positive value `y` which is less than 26, and so we can safely mod `y` by 26 because any value less than 26 mod by 26 is that same value, ie. if `0 < y < 26`, then `y == y % 26`\\n\\nIn general, we can think of the difference (ie. `k`) as buckets between 1..25 inclusive which track the count of each i-th character rotation needed to transform `s` to `t` per the rules of the problem statement.\\n\\n---\\n\\n**Screenshare:** https://www.youtube.com/watch?v=xuyvk8ycHFs\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\\n\\n---\\n\\n**Concise Solutions:** it is naive to continually iterate i to find needs to delete because we know we need to rotate each k-th need bucket by 26 (ie. the cardinality of the latin alphabet) for each bucket count greater than 1.  For example to transform `aa` to `bb`, we need 1 rotation for the first difference in this bucket, plus (1 * 26) rotations for the remaining differences in this bucket for a total of 27 rotations.  Similiarly to transform `aaa` to `bbb`, we need 1 rotation for the first difference in this bucket, plus (2 * 26) rotations for the remaining differences in this bucket for a total of 53 rotations, etc, etc...\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\\n\\n*C++*\\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780288,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "**\\nIt\\'s just iterate over the length of the strings....\\nfirst case : if length of both the strings are not same simply return false ;\\nSecond case : if both char are different take the differnce of the ASCII values of the char and if it less than 0 so you need to add the differnce(i.e is diff) to 26 + diff ....as we need to see clockwise rotation from a to z.\\nand the main part comes when it asks you about if differnce is repeated then what ? Then you just need to mantain a map or set something to keep frequency of the differnce how many times it is appearing ... and formula will be like diff = 26 * m[diff] + diff ..... see the code which will help you to understand more...and make a dry run which will help you more better\\n**\\n\\n*if liked my solution please upvote :D*\\n```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780084,
                "title": "c-o-n-time-o-1-space-explained",
                "content": "If length are not same return false.\\notherwise\\nThere are 3 possible cases for each chars at same index\\n1. if s[i] == t[i] then continue;\\n2. else find difference (if -ve add 26) which will be in range [0,25], for this we take 26 size array **step** to remember the which moves we have already taken, and update **step** for next possible move we can take.\\n**example:**\\ndiff = t[i]-s[i];\\nFor diff = 1, possible moves are 1, 27, 53 ...\\nFor diff = 2, possible moves are 2, 28, 54 ...\\nFor diff = 3, possible moves are 3, 29, 55 ... \\n.\\n.\\n.\\nFor diff = 25, possible moves are 25, 51, 77 ... \\n\\n3. Whenever we found the move we need for this is greater K return false. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780078,
                "title": "python-dictionary-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif t[i] != s[i]:\\n\\t\\t\\t\\t\\tif t[i] > s[i]:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) - ord(s[i])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) + 26 - ord(s[i])\\n\\t\\t\\t\\t\\tif diff > k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif diff not in d:\\n\\t\\t\\t\\t\\t\\t\\td[diff] = diff\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif d[diff] + 26 > k:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\td[diff] += 26\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 779965,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779961,
                "title": "c-dictionary",
                "content": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4091920,
                "title": "simple-c-solution-o-n-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084270,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010225,
                "title": "c-hash-table-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002892,
                "title": "java-modulo-and-clean-code",
                "content": "# Approach\\n1. The key is to count how many group of modulos you have for the given k.\\n    - EG: 27: [1,2,3...26,27]. All of these % 26 would result [1,2,...1]. Two elements (1 and 27) % 26 = 1. So modulo[1] = 2.\\n2. For given k calculate the groups of modulos\\n3. Traverse s and t and for each index, if the chars are disting, calculate their distance.\\n    - a -> c = 2 ; y -> b = 3. \\n4. For each such distinct pair, deduct 1 from their modulo groups. If the modulo groups goes below 0, it means you do not have enough numbers to cover their modulos. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999274,
                "title": "c-8-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we simply calculate the shift required for each character of s and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of k.\\n\\nar[i] = x implies that there are x characters in string s that need a shift of i to match the charcters in string t.\\nNow it is given in the question that each shift can be used only once.\\nSo if two charcters need a shift of 1, only one of them will be allowed.\\nThe next charcter will get a shift of 1 + 26 which makes the efective shift to be 1.\\nEg: lets say s = \"aa\" and t = \"cc\"\\nThen ar[2] = 2\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately\\n\\n# Complexity\\n- Time complexity:O(s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903100,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842294,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725131,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663184,
                "title": "python-check-max-counter-of-diff-o-n",
                "content": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598436,
                "title": "small-c-solution-100-runtime-and-100-memory",
                "content": "# Code\\n```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552972,
                "title": "beats-100-must-see-approach-t-c-o-n-and-o-26-or-constant-space",
                "content": "# Intuition\\nto make a freq array and then look for value of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- O(n) -->\\n\\n- Space complexity:  O(26) \\n<!-- O(26) or basically it is constant -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549991,
                "title": "find-the-residue-of-modulo",
                "content": "# Approach\\nif two strings have different length, can\\'t convert s to t for all k.\\nFind the modulo number of shifts by i and its upper bound for i = 1,2,...,25, meaning that do nothing for the residue\\'s. \\n\\n# Complexity\\n- Time complexity: O(n), n:length of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534281,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524005,
                "title": "simple-c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438162,
                "title": "fast-and-simple-solution-with-explanation-c",
                "content": "# Intuition\\nWe can convert *s* to *t* only if for every position *i* (*0 <= i < s.size()*) where *s[i] != t[i]* we can find a unique number *1 <= n <= k* such that *s[i] + (n % 26)  == t[i]*. (26 is the number of characters in english alphabet).\\n\\n# Approach\\nFirst we check sizes of the two strings. When they differ, we return false immidiately. Next, we iterate over the strings and count only chars that do differ. When difference is negative, we add 26 to it.\\n\\nIn the last step, we iterate over the summery map and check every position, where difference greater than 0. For example, when we have a difference 2 in 3 positions, we have to use numbers 2, 28 and 54 to close gaps in all three positions (2, 2 + 1 x 26, 2 + 2 x 26). When the maximal number do not exceeds k, we return true, otherwise false. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314788,
                "title": "and-c",
                "content": "C solution:\\n```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\\n\\nC++ solution \\uFF1A\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283787,
                "title": "short-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270070,
                "title": "o-n-constant-space-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(26) ~ constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269343,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266162,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265958,
                "title": "c-o-n-o-1-frequency-array",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262977,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince for every move we can go for i steps forward, we need to track for steps..\\nAlso every j will be unique as we are traversing the string..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a map where we store the i values along with the no of times we used it.\\nIt we would like to convert a to c , we need to look for 2nd move, suppose for another j again we get a to c, then we can\\'t use 2nd move but we can use 2+26 the move. again if we get same conversion use 2+26*2... so on..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)  as map keys are from 1 to 26 only..\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3262137,
                "title": "258-ms",
                "content": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223328,
                "title": "java-using-modulo-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169455,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167267,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164248,
                "title": "c-o-n-easy-solution-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035460,
                "title": "hashing-o-n",
                "content": "used hashmap to store previous min value of difference of two alphabets in both s and t respectively \\nfirst i was using hashset which was not effeceint because that checks everytime if the number is present or not \\n\\nso i used hashmap and everything solved \\n\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928266,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927948,
                "title": "c-simple-solution-worst-question",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842168,
                "title": "python-hashmap-faster-than-100",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683473,
                "title": "c-count-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length os string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628773,
                "title": "c-o-n-simple",
                "content": "I found that many solutions check the possibility at the end of every round of the loop, but I do it later instead.\\nI wonder which one would be faster.\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593356,
                "title": "can-convert-string-in-k-moves",
                "content": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2542449,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467091,
                "title": "an-easy-o-26-space-solution-learn-new-tricks",
                "content": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }\\n        \\n        for(int i=0;i<ns;i++) {\\n            int diff = 0;\\n            if(s[i] > t[i]) {\\n                diff = 26+(t[i]-s[i]);\\n            }\\n            else if(s[i] < t[i]) {\\n                diff = t[i]-s[i];\\n            }\\n            if(diff!=0) {\\n                if(un[diff]>0) un[diff]--;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464132,
                "title": "crisp-n-clear-o-n-javascript-runtime-100-00-meaningful-vars",
                "content": "Runtime: 85 ms, faster than 100.00% of JavaScript online submissions for Can Convert String in K Moves.\\nMemory Usage: 47.5 MB, less than 57.14% of JavaScript online submissions for Can Convert String in K Moves.\\n\\n```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431379,
                "title": "c-o-n-time-o-26-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430909,
                "title": "c-modulo-arithmetics",
                "content": "We compute how many times me can and we should use `(t[i] - k[i])` shift:\\n\\n```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400825,
                "title": "c-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343164,
                "title": "c",
                "content": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341667,
                "title": "intuitive-do-as-hints-say-corner-cases",
                "content": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331947,
                "title": "c-98-optimised-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }\\n                else \\n                {\\n                    v[26+diff]=v[26+diff]+1;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<26;i++) cout<<i<<\" \"<<v[i]<<endl;\\n        int maxi=-1;\\n        for(int i=1;i<=25;i++)\\n        {\\n            if(v[i]>0)\\n            {\\n                // cout<<\"v[i] : \"<<v[i]<<endl;\\n                int step=((v[i]-1)*26)+i;\\n                // cout<<\"step : \"<<step<<endl;\\n                maxi=max(maxi,step);\\n            }\\n        }\\n        if(maxi<=k) return true;\\n        else return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2302803,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268872,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260349,
                "title": "easy-to-understand-o-n-c",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238035,
                "title": "can-convert-string-in-k-moves",
                "content": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2222696,
                "title": "c-compare-moves-needed-to-available-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155709,
                "title": "python-3-simple-o-n-o-1-solution",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2131454,
                "title": "interesting-trick-for-an-interesting-question",
                "content": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106259,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103358,
                "title": "check-is-the-shift-possible-within-k-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081314,
                "title": "javascript-step-check-176ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069898,
                "title": "simple-python-solution-space-o-1-time-o-n",
                "content": "**Steps:**\\n1. Check if the length for strings are equal. If not, then return False.\\n2. Store the counts of difference from s[i] to t[i].\\n3. Multiply the count by 26 and add the difference if s[i] != t[i]. This is done because for the first occurence of the difference, we need to add it. And for extra occurences of the difference, we need to add 26 to it each time so that i(mentioned in the question) would be unique for each occurrence.\\n4. If the above value is more than k then return False.\\n5. If the whole string gets parsed, return True.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069204,
                "title": "easy-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037161,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0});\\n        \\n        long long maxK = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            long long diff;\\n            if(s[i] == t[i]) {\\n                continue;\\n            } else if(s[i] < t[i]) {\\n                diff = t[i] - s[i];\\n            } else {\\n                diff = 26 - (s[i] - t[i]);\\n            }\\n            \\n            if(v[diff].first == 0) {\\n                v[diff].first = 1;\\n                maxK = max(maxK, diff);\\n            } else {\\n                v[diff].second += 1;\\n                diff = 26*v[diff].second + diff;\\n                maxK = max(maxK, diff);\\n            }\\n        }\\n        return (maxK>k)?false:true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2008682,
                "title": "declarative-ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1925423,
                "title": "c-very-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892437,
                "title": "python3-o-n-simple-to-understand",
                "content": "* just get an array of the shift values and if the shift value has been seen \\'n\\' times, the largest move we need is:\\n\\t* shift value + \\'n\\' * 26\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889772,
                "title": "hashmap",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870337,
                "title": "c-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774010,
                "title": "java-sharing-code",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711905,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707045,
                "title": "easy-explained-solution-using-map",
                "content": "1. If length( s ) and length( t ) are not equal, then it\\'ll never be possible to convert, because we are not allowed to add or remove character from the strings. Hence ans = false.\\n\\nWe want to store remainder, as well as frequency into the map.\\nEx.1. For \\'a\\' to \\'z\\' conversion, \\'z\\' - \\'a\\' = 25, Added with 26 and take mod 26, rem = (25+26)%26 = 25.\\nEx.2. For \\'z\\' to \\'a\\' conversion, \\'a\\' - \\'z\\' = -25, added 26 and take mod 26, rem = (-25+26)%26 = 1.\\nSo 26 is added to avoid negative remainder, as we are only allowed to move forword.\\n\\n2. Ex.3. For s = \\'aaab\\' to t = \\'bbbb\\' conversion, we want three \\'a\\' to \\'b\\' conversion.\\nSo, rem = (\\'b\\'-\\'a\\'+26)%26 = 1, frequency = 3.\\nfor s[0] = \\'a\\' to t[0] = \\'b\\', we need 1st move, we use 1st move,\\nfor s[1] = \\'a\\' to t[1] = \\'b\\', we need 1st move too, we use (1+(26\\\\*1) ) = 27th move,\\nfor s[2] = \\'a\\' to t[2] = \\'b\\', we need 1st move too, we use (1+(26\\\\*2) ) = 53rd move,\\nHence, if for a particular remainder frequency = \\'x\\', we\\'re gonna check, if \\'(x-1)\\\\*26 + rem\\' belongs to the range [0, k] or not.\\nSo, we directly check for 53 <= k, if not, then ans = false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nFeel free to comment and upvote ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701407,
                "title": "easy-map-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1668896,
                "title": "c-linq-one-liner-o-n-time",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667151,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666195,
                "title": "golang-o-n-count-group-by-shift-move",
                "content": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660061,
                "title": "count-req-and-available-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654414,
                "title": "golang",
                "content": "some examples to calc char offset:\\n\\ns[i] -> t[i]\\n\\n\\'a\\' -> \\'c\\' = 2 - 0 = 2 moves\\n\\n\\'c\\' -> \\'a\\' = 0 + 26 - 2 = 24 moves\\n\\n\\n\\n\\'a\\' -> \\'z\\' = 25 - 0 = 25 moves\\n\\n\\'z\\' -> \\'a\\' = 0 + 26 - 25 = 1 move\\n\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605985,
                "title": "c-52ms-99-45-simple-easy-small-time-on-space-o1-operators-only-and",
                "content": "Runtime: 52 ms, faster than 99.45% of C++ online submissions for Can Convert String in K Moves.\\nMemory Usage: 17.7 MB, less than 77.35% of C++ online submissions for Can Convert String in K Moves.\\n\\n```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588760,
                "title": "clearly-explained-python3-faster-than-91",
                "content": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "solutionTags": [],
                "code": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1574043,
                "title": "10-line-of-code-simple-o-n-solution-and-o-1-space-solution-easy-and-cake-walk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528283,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527738,
                "title": "java-14ms-t-c-o-n-s-c-o-26-easy",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446966,
                "title": "go-o-n-time-o-1-space-1-pass",
                "content": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428497,
                "title": "easy-c-map-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n=s.length();\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                int z=t[i]-s[i];\\n                if(z<0)\\n                    z+=26;\\n                mp[z]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first>k)\\n                return false;\\n            if(it.second>1)\\n            {\\n                mp[it.first+26]+=it.second-1;\\n            }\\n        }\\n        return true;\\n    }\\n};``\\nUpvote if you like :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423160,
                "title": "python-3-using-hashmap",
                "content": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1366245,
                "title": "c-easy-multiplier-tracker",
                "content": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312263,
                "title": "c-solution-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309687,
                "title": "go-solution",
                "content": "//credits: https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1268156/Easy-C%2B%2B-solution-using-Map\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256317,
                "title": "c-100-100",
                "content": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256309,
                "title": "python-highly-optimized",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253830,
                "title": "easy-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248115,
                "title": "js-easy-to-follow-time-o-n-space-o-1",
                "content": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240148,
                "title": "c-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234636,
                "title": "swift-solution",
                "content": "Obviously if `s.count != t.count`, then the answer is `false`. Let\\'s add that check at the beginning.\\n\\nIt makes sense to perform shifts in the range from 1 to 25. We can perform each shift `k / 26 + (k % 26 >= shift ? 1 : 0)` times. Let\\'s fill the `shifts` array with the number of available shifts.\\n\\nConsider all indexes `i` in range `0 <= i < s.count` where `s[i] != t[i]` and calculate the `shift` to get `t[i]` from `s[i]`. If `shifts[shift] == 0` then the answer is `false`, else decrement `shifts[shift]` by 1.\\n```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226937,
                "title": "python-o-n-with-constant-memory-storage",
                "content": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223574,
                "title": "map",
                "content": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 1214680,
                "title": "simple-to-understand-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185999,
                "title": "c-histogram-beats-100-of-submissions",
                "content": "## The Problem\\n\\nWhen we have to shift a letter by i spaces, we want to record that shift in some container. At some point we want to check that this shift is less or equal to k.\\n\\nOur problem is in checking if there is an existing shift of the same distance. Each time there is a letter attempting the same distance of shift, we need one of those letters to be shifted by an additional 26 spaces. The second time we find this occurance we need to shift by 2x26, and so on.\\n\\nThe insight is that we can store a count of the number of letters that shift by the same amount, then we can calculate the number of additional shifts that the final letter needs to be shifted to abide by the unique i restriction in the question.\\n\\n## The Solution\\n\\nWe can create a histogram of distances by using an array of integers initialized at zero. We then iterate over both strings, find the character distance, and then increase the histogram value at that distance location as long as the distance is not zero. \\n\\n### Histogram Checks\\n\\nThe check against K can be performed either in-loop or on its own after the main while-loop. The code below shows the in-loop solution. \\n\\nThe in-loop method allows us to quit early if we find that a histogram value is violating our K requirement. However, the in-loop solutions adds a constant-time overhead for every operation. \\n\\nChecking the histogram values after the main while-loop requires far fewer (25) checks, but we have to compare entire strings and cannot exit early.\\n\\nI have found similar performance (24ms and 28ms) submitting both solutions. This seems to be similar within the variance that leetcode has for submissions.\\n\\n### Perform fewer K checks\\n\\nWe do not need to check against K for every single item we place into the histogram. We can keep track of the max number of duplicate distances in the histogram (largest value in the histogram), and only check against K if we just increased a histogram value to an equal or greater value.\\n\\nThe reason we can avoid these checks is that if the histogram value we just placed is smaller than the max previously seen histogram value, then we cannot have just placed a value greater than K, otherwise we would have exited when we had seen that max previously seen histogram value.\\n\\n### io tricks\\n\\nLeetcode appears to include the io time in the submission benchmarking time. In C++ we can reduce that overhead by including the two lines at the top of the code. The first line removes the synchronization between C and C++ standard streams, and the second line unties cin from cout. \\n\\nThese lines reduce the runtime by about half. I\\'m not sure I like that io tricks can decrease runtime more than my other optimizations, but this is the world that we live in.\\n\\n\\n\\n```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171843,
                "title": "easy-c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169219,
                "title": "detailed-o-n-time-o-1-space-solution",
                "content": "\\t// time complexity : O(n), space complexity : O(1)\\n\\t/*\\n\\t\\tapproach :\\n\\t\\t--> find the least amount of shift we need to do, to convert s[i] to t[i].\\n\\t\\t--> if that was done, then add 26 to it(As a shift amount can not be done more than once).\\n\\t\\t--> If that was also done add 26*2 to the least shift amount and so on.\\n\\t\\t--> Well the question is how to know the # of time we need to add 26.\\n\\t\\t--> For this we create a map of size 26. Cuz least shift can be upto 25, when \\'a\\' -> \\'z\\'.\\n\\t\\t--> map[i] = j means we added 26 upto j times for a shift by i.\\n\\t\\t--> But how to ensure that a particular value of shifting is not used more than once.\\n\\t\\t--> This is beacuse a * 26 + i != b * 26 + j for any value of a and b and i!=j and 1<=i,j<=25.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1167215,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159917,
                "title": "java-hashmap-o-n",
                "content": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145426,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to use a hashtable for the required shifts to transform one letter into another. It provides the next free number of shifts which is the initial number of shifts plus a multiple of `26`. Every time we access such a free number of shifts, we check if it is greater than `k`. If it is, `false` will be returned. In any other case, the next free number of shifts will be the current one plus `26`.\\n\\nExample: To transform `a` into `b` we need `1` shift. The next free number of shifts for this initial number of shifts will be `27`. If we now are asked to transform `b` into `c`, for instance, the required shifts will be `27` and the next free number of shifts `27 + 26 = 53` and so on.\\n________________________\\n**Definitions**\\n`n`: Size of `s` and `t` if `s = t`.\\n________________________\\n**Runtime Complexity**\\n`O(n)`\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143035,
                "title": "c-solution-beats-80-o-n-time-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107285,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102036,
                "title": "c-o-n-solution-maintain-counts-of-number-of-ways-to-make-1-25-steps",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570107,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1824479,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1570421,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1574182,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2044343,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2007883,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Insertions to Balance a Parentheses String",
        "question_content": "<p>Given a parentheses string <code>s</code> containing only the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. A parentheses string is <strong>balanced</strong> if:</p>\n\n<ul>\n\t<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n\t<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n</ul>\n\n<p>In other words, we treat <code>&#39;(&#39;</code> as an opening parenthesis and <code>&#39;))&#39;</code> as a closing parenthesis.</p>\n\n<ul>\n\t<li>For example, <code>&quot;())&quot;</code>, <code>&quot;())(())))&quot;</code> and <code>&quot;(())())))&quot;</code> are balanced, <code>&quot;)()&quot;</code>, <code>&quot;()))&quot;</code> and <code>&quot;(()))&quot;</code> are not balanced.</li>\n</ul>\n\n<p>You can insert the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> at any position of the string to balance it if needed.</p>\n\n<p>Return <em>the minimum number of insertions</em> needed to make <code>s</code> balanced.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()))&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The second &#39;(&#39; has two matching &#39;))&#39;, but the first &#39;(&#39; has only &#39;)&#39; matching. We need to add one more &#39;)&#39; at the end of the string to be &quot;(())))&quot; which is balanced.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;())&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The string is already balanced.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;))())(&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Add &#39;(&#39; to match the first &#39;))&#39;, Add &#39;))&#39; to match the last &#39;(&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 780199,
                "title": "java-c-python-straight-forward-one-pass",
                "content": "# **Intuition**\\nSimilar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/181132/C++JavaPython-Straight-Forward-One-Pass).\\nJust need to pay attention:\\nleft parenthesis \\'(\\' must have a corresponding two **consecutive** right parenthesis \\'))\\'.\\n<br>\\n\\n# **Explanation**\\n`res` represents the number of left/right parentheses already added.\\n`right` represents the number of right parentheses needed.\\n\\n**1) case `)`**\\nIf we meet a right parentheses , `right--`.\\nIf `right < 0`, we need to add a left parentheses before it.\\nThen we update `right += 2` and `res++`\\nThis part is easy and normal.\\n\\n**2) case `(`**\\nIf we meet a left parentheses,\\nwe check if we have odd number `\\')\\'` before.\\nIf we `right`, we have odd `\\')\\'` before,\\nbut we want right parentheses in paires.\\nSo add one `\\')\\'` here, then update `right--; res++;`.\\nNote that this part is not necessary if two **consecutive** right parenthesis not required.\\n\\nBecause we have `)`, we update `right += 2`.\\n<br>\\n\\n# **Dry run**\\nAll by @himanshusingh11:\\n\\n**Example 1: Consider ((()(,n= 5 ,i=0,1...4**\\ni=0, we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =2\\ni=1, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =4\\ni=2, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =6\\ni=3, we have ) we subtract one from right. so.. right-- => res =0, right =5\\ni=4, we have ( but here right is odd so we need to make it even with right-- and increment res++ => res =1, right =4. Also, as we have got a left parenthesis then we need two right parenthesis (they are in pair) so.. right+=2 => res =1, right =6\\n\\nfinally ans is res + right => 1 +6 == 7\\n\\n**Example 2: ((()**\\nSimilarly, we can see when we have right<0 then we increment res by one & add 2 to right as they should be in pairs..\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**Python:**\\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779928,
                "title": "simple-o-n-stack-solution-with-detailed-explanation",
                "content": "**Brief Idea**: Maintain a stack. Every time we see a ```(``` we need to have 2 ```)``` to balance. So we would push 2 to the stack. Then when we see ```)``` we would check the top of the stack. If the top is 2, that means this is the first ```)``` that will match the previous ```(```. So we would change the top to 1. In case the top of stack had 1 it means we are seeing the second ```)``` for some ```(``` and so we just pop this 1 from the stack. \\n\\n**Details of transition**:\\n1. When we see ```(```:\\n* And the stack is empty or has a 2 at the top: we just push another 2.\\n * And the stack had 1 at the top: This means we have just seen ```()``` and now we are seeing ```(```. In this case, we need to first provide a ```)``` to the previous ```(``` and then we can process the current ```(```. So increment the answer, pop the 1 (which was for last ```(```) and push a 2 (for current ```(```).\\n2. When we see ```)```:\\n * And the stack is empty: We have encountered a lone ```)```. We would need to add ```(``` to the sequence to balance, which would match one of its ```)``` with the current ```)```. So we increment the answer.  Moreover, it would also need another ```)``` to match. So we push 1 to the top. This is like saying we have seen ```()``` (of which ```(``` was inserted by us).\\n* And the stack had 1 at the top: This the second ```)``` for some ```(```. We just pop from the stack.\\n* And the stack had 2 at the top: This the first ```)``` for some ```(```. We just pop 2 from the stack and push 1.\\nAt the end of going through the string we just add up all the numbers in stack, which represents the number of ```)``` we need to balance.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(```\n```)```\n```)```\n```)```\n```(```\n```)```\n```(```\n```(```\n```()```\n```(```\n```)```\n```(```\n```(```\n```(```\n```(```\n```)```\n```)```\n```(```\n```)```\n```)```\n```)```\n```()```\n```(```\n```)```\n```(```\n```)```\n```(```\n```)```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780221,
                "title": "python-simple-and-fast-time-o-n-space-o-1",
                "content": "# \\uD83D\\uDCA1 Idea\\n\\n* Record the number of \\'(\\' in an open bracket count int. \\n* If there is a \\'))\\' or a \\') \\'then open bracket count -= 1\\n* If there is a \\'))\\' or a \\') and open bracket count = 0 an \\'(\\' must be inserted\\n* If there is a single \\')\\' another \\')\\' must be inserted\\n* At the end of the program and if open bracket count >0 then an \\'))\\' must be added for each unmatched \\'(\\'\\n\\n---\\n\\n# \\uD83D\\uDCD1Overview\\n* Solution 1: Time O(n), Space O(n) - String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n* Solution 2: Time O(n), Space O(1) - Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n\\n---\\n\\n\\n# \\uD83C\\uDFAFSolution 1: Simple String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n\\n\\n## Tricks\\n\\n* Go through string replacing \\'))\\' with \\'}\\'\\n* This allows for easy differentiation between \\')\\'  \\'))\\' when iterating through the input string\\n* This makes checking the above conditions a breeze \\n\\n## Examples\\n**Example 1:**\\n```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\\n\\n**Example 2:**\\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\\n\\n**Example 3:**\\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\\n\\nExamples 1-3 cover all the cases of mismatching brackets there are! You should be ready to try coding a solution :) \\n\\n## Code\\n\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\\n\\n---\\n\\n# \\uD83C\\uDFAF Solution 2: Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n## Implementation\\n\\n* Implement a boolean that can track \\'))\\' in O(1) space\\n* Update logic from Solution 1 \\n\\n## Code \\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394902,
                "title": "c-with-without-stack-clear-detailed-step-by-step-explanation",
                "content": "\\n#### **Intution:**\\nThis problem is similar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/).  Note that here, for every open parantheses, there must be 2 consecutive close parantheses. \\n\\nSeeing any question involving parenthesis balancing, it becomes quite intutive to use stacks. \\nHowever, for problems involving only a single type of parenthesis (open, curly or square), we can generally (but not always) solve them without stack in the same time complexity.But as an advantage, this could solve the problem in constant space.\\n\\nIn this post, I am adding two approaches - one using stack and another without stack.\\nThe codes are well commented for your better understanding.\\n\\n##### 1. Using stack:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(n) becuase of stack\\n\\n\\n##### 2. Without  using stack : \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(1) constant space \\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780366,
                "title": "c-o-n-proper-explaination-without-stack",
                "content": "We keep 2 variables, **ans** ``A counter for manual addition brackets`` and **req** ``Number of closing brackets that we need`` .\\nWe start iterating over the string elements one by one. Now:-\\n**1. We get an open bracket**\\nIn this, we have 2 things to understand\\n* For every open bracket, we need 2 closed brackets.\\n ``req += 2``\\n* Now if I have an odd number of closed brackets, this means that we have one ``)`` for one of the ``(``, and now we have another open bracket. As the question says ``Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))``, so we need to give a ``)`` to the existing open bracket, and then process the new one.\\n``ans++   => We added a new closed bracket\\nreq--   =>  the existing lonely ) is paired and not needed now`` \\n\\n**2. We encounter a closed bracket**\\nIn this, we again have two things to understand: \\n* If we encounter a lone warrior, basically a ``) when req = 0``, this means we can manually add a ``(`` and then say that we encountered ``()``.\\n``ans++    => We added a new open bracket``\\n``req++    => Another closed bracket is required as we have ()``\\n* Otherwise, we directly reduce the number of required closed brackets.\\n ``req--``\\n \\n Code: - (C++ O(n))\\n \\n ```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 780029,
                "title": "java-solusion-count-the-left-and-right-parenthese",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780409,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```\\nPlease upvote if you liked my solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780291,
                "title": "java-linear-loop-and-o-1-space",
                "content": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779917,
                "title": "c-o-n-o-1-track-left-and-right",
                "content": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779986,
                "title": "java-stack-solution-easy-to-understand",
                "content": "Idea:\\n\\n1. if the character is closing `)` \\n\\t* stack is not empty\\n\\t\\t if last character in stack is also `)` then just pop two characters from stack `())`\\n\\t\\t else add character in stack\\n\\t* to make balance we need to insert `(` before so increment count and add `(` in stack along with `)`\\n2. if the character is closing `(` \\n\\t* stack is not empty\\n\\t\\tif stack peek is also `(` just add into stakc\\n\\t\\telse count++ and pop from stack \\n\\t*  add into stack\\n\\t\\n3. loop until stack is not empty and check \\n\\t* if peek character `(` count += 2 and pop from stack once\\n\\t* else for `)` count++ and pop from stack twice\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779956,
                "title": "java-solution-without-using-stack-just-with-counter",
                "content": "The idea is to save down the count of left parenthesis, then match it with double \\')\\'.\\nIf case of single \\')\\' or end of String happened, we did special handling as shown below.\\n\\n```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779974,
                "title": "c-solution-using-stack-and-conditions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780161,
                "title": "simple-java-solution-using-stack",
                "content": "Also viewable on [Github here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_1541.java).\\n```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797128,
                "title": "c-o-n-step-by-step-from-space-o-n-to-o-1",
                "content": "1. Naive Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n2. Concise Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n3. Final Code  [Time O(n) Space O(1)]\\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779978,
                "title": "simple-solution-in-o-n-intuitive-beats-100-python-explanation",
                "content": "1- First we replace all double closed brackets with a single squared closed bracket as that is what they behave like.\\n2- Then we find all alone closed brackets. Since they are useless alone we add one more closed bracket to all of them and again replace them with a single squared closed bracket.\\n3- Then do simple balancing\\n\\n```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779885,
                "title": "stack-like-operation-but-don-t-need-a-stack",
                "content": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214894,
                "title": "java-constant-space-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574980,
                "title": "java-solution-o-1-space-explained-in-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488865,
                "title": "simple-soln-using-stack",
                "content": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778621,
                "title": "c-100-faster-solution-o-n",
                "content": "****Please upvote me :)****\\n```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391464,
                "title": "clear-explanation-c-one-pass-greedy",
                "content": "**Intution :**\\n\\nFor such kind of balancing parenthesis first thing should strike is Greedy along with Stack to balance. \\nLets see how to solve these kind of problems.\\n\\n* Idea is simple, at every index in string we need to keep the balance of opening and closing brackets i.e.\\n\\t\\n\\tcount of \\'(\\' >= count of \\')\\'  -> for all index i from 0 to n\\n\\t\\n* And to track balance at *every index i* we have two conditions : \\n\\t\\n\\t1. if element at current index i is \\'(\\' \\n\\t\\t-> do balance + 2 , since for two \\') )\\' we have one \\'(\\' \\n\\t\\t\\n\\t2. else if element is \\')\\', then do [balance - 2]\\n\\t\\t -> if next is also \\')\\' then increment i as we got two consecutive \\'))\\'\\n\\t\\t -> else we need to insert one \\')\\' next to this. So increment number of insertions counter.\\n\\n* Also, if at any point this inequality fails i.e. \\n\\t* balance become negative or \\n\\n\\t\\t*\\t\\tcount of \\'(\\' < count of \\')\\'\\n\\t\\n\\t* We need to balance that by inserting (actually increamenting count) counter bracket .\\n\\t\\n\\t\\t\\tif balance < 0, we have two cases either balance = -1 or -2\\n\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -1, this means we have only \\'(\\'\\n\\t\\t\\t\\t\\tand we need to insert one \\'(\\' and one \\')\\'.\\n\\t\\t\\t\\t\\tSo incease the counter of number of insertions by 2.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -2, this means we have two consecutive \\')\\' i.e \\') ) \\'\\n\\t\\t\\t\\t\\t and we just need single \\'(\\' to balance it.\\n\\t\\t\\t\\t\\t Thus increase counter only by 1. \\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\tIn the end, we also need to reset balance to 0 as we have \\'( ) )\\' -> valid string\\n\\n* Now, there may be some case when balance > 0. This means we have some extra \\'(\\' which do not have their counter parts. \\n* So, we have to insert those many \\')\\' to make balance=0. Thus, increament remaining to counter.\\n\\t\\n\\t\\n# Code : \\t\\n \\t\\n```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```\\n\\n**Time : O(N) Single pass**\\n**Space : O(1)**\\n\\nAlso do try similar problems for better grip over such problems. \\n\\n**Hope this explanation was crystal clear, and in case of any query let me know.... :)**\\n***If you understood do upvote post !!!***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1146014,
                "title": "single-pass-without-extra-space",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }\\n            \\n         else if(s[i]==\\')\\' && i+1<n && s[i+1]!=\\')\\'){\\n             \\n             if(open==0) count+=2;\\n             else {\\n                 count+=1;\\n                 open--;\\n             }\\n        }\\n       \\n        else if(s[i]==\\')\\' && i+1==n){\\n            if(open==0) count+=2;\\n            else{\\n                open--;\\n                count+=1;\\n            }\\n         }\\n            \\n        }\\n        \\n        count+=(open*2);\\n        return count;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2666960,
                "title": "c-80-faster-than-all-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034943,
                "title": "java-o-n-time-and-o-1-space-with-explanation",
                "content": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "solutionTags": [],
                "code": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2028472,
                "title": "javascript-o-1-space",
                "content": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736069,
                "title": "java-one-pass-o-1-space-with-explanation",
                "content": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730396,
                "title": "python-simplest-one-pass",
                "content": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "solutionTags": [
                    "Python"
                ],
                "code": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "codeTag": "Java"
            },
            {
                "id": 1650461,
                "title": "c-left-to-right-right-to-left-most-intuitive-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779952,
                "title": "python-using-stack-o-n-100-time",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779910,
                "title": "c-easy-to-understand-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }\\n        }\\n        \\n        return count + st.size() * 2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2424596,
                "title": "c-stack-t-o-n-s-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/6d646c38-5b86-4ab9-ae05-e4a82476d06c_1660481979.6475577.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(!st.empty()){\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse count+=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!st.empty()) count+=2*st.size();\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2090219,
                "title": "python",
                "content": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "solutionTags": [],
                "code": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "codeTag": "Python3"
            },
            {
                "id": 1429325,
                "title": "c-stack",
                "content": "```\\n```\\n\\n```\\n```public:\\n    int minInsertions(string s) {\\n        long long int t,count=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(st.size()==0)\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                    i++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    count=count+2;\\n                }\\n            }\\n            else\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                  i++;   \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return count+(st.size()*2);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225658,
                "title": "python-92",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "codeTag": "Java"
            },
            {
                "id": 1223865,
                "title": "c-fully-commented",
                "content": "**please upvote it this helps :)**\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208565,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155606,
                "title": "java-stack-o-n",
                "content": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }\\n            else\\n                stk.push(c);\\n        }\\n        \\n        while(stk.size()>0)\\n        {\\n            stk.pop();\\n            count+=2;\\n        }\\n     return count;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1018761,
                "title": "o-n-solution-in-python-with-and-without-stack",
                "content": "* `O(n)` space with stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\\n\\n* `O(1)` space without stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899734,
                "title": "c-easy-to-understand-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829421,
                "title": "simplest-solution-one-pass-o-n-time-o-1-space-with-only-1-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805133,
                "title": "simple-o-n-c-solution-without-stack-w-comments",
                "content": "I previously used stack and enum to represent the current stack status and it turned out to be a disaster because there are too many cases that have to take into consider.\\nI then saw the solution from @mohitbhateja and realized that the cases can be classified (and simplied) to only a few cases. Refer to the code and comments below.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802715,
                "title": "simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781543,
                "title": "c-100-faster-fully-explained",
                "content": "What we have done is:  we will use three numbers:(-1,0,1)\\n1. 1 number states that \"))\" substring is present.\\n2. 0 number states that only \")\" substring is present and we need one more \\')\\'.  \\n3. -1 number states that \"(\" is present.\\n4. Last we will have a variable \"count\" wich will store no of insertions.\\n*  If we encounter -1 \"(\", we will push it to the stack.\\n*  If we encounter 0 \")\", this means we need to insert \")\" so we will count++. But we will check if stack is empty, this means we need  to insert \"(\" also and we will again count++ and pop.\\n*  If we encounter 1\"))\", this means pop from the stack [or remove \"(\"].\\n\\nFor eg [\" ( )) ( )\"]:- In this our array will be [-1,1,-1,0].\\narray[0]:First we will push -1 to stack.\\narray[1]:Then we will pop.\\narray[2]:Then we will push -1 to stack.\\narray[3]:Then we will count++ and pop.\\nAnswer is 1.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}\\n                else v.push_back(0);\\n                    \\n            }\\n        }\\n        for(auto num:v) cout<<num<<\" \";\\n        int count=0;\\n        stack<int> S;\\n        for(auto num:v)\\n        {\\n            if(num==-1)\\n                S.push(num);\\n            else if(num==0)\\n            {\\n                 if(S.empty())\\n                     count+=2;\\n                else\\n                    count++,S.pop();\\n            } else{\\n                     if(S.empty())\\n                         count++;\\n                      else S.pop();\\n            }   \\n        }\\n        if(!S.empty())\\n            count+=S.size()*2;\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}",
                "codeTag": "Java"
            },
            {
                "id": 780024,
                "title": "help-needed-confusing-testcase",
                "content": "Can anyone please explain why ```4``` is expected output for this input\\n\\n```\"(()))(()))()())))\"```\\n\\nShouldn\\'t it be just ```1``` ?",
                "solutionTags": [],
                "code": "```4```\n```\"(()))(()))()())))\"```\n```1```",
                "codeTag": "Unknown"
            },
            {
                "id": 779966,
                "title": "java-stack-solution-o-n-one-pass-solution-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779954,
                "title": "c-o-n-o-1-intuitive-if-else",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321179,
                "title": "java-stack-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf **left bracket we need twice on right**, if **right bracket present we need just half on left**.\\nRefer Commnets, Dry Run for better understanding !! \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295720,
                "title": "java-100-easy-to-understand",
                "content": "\\n\\n# Approach\\nUse stack to store the number of insertions, not the string itself.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047629,
                "title": "kotlin-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686697,
                "title": "python-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile seeing parentheses problem, using stack is my intuition.\\nres: record the number of times making insertion\\nidx: pointer on s\\nstk: store left parenthese\\n\\nIn this case, if we meet \\'(\\', just append left parenthese into stack.\\nIf we meet one \\')\\', there is three cases:\\n1. nothing in stack. So we need to insert one left parenthese into stack, in order to match right parenthese. So res += 1\\n2. \\'(\\' in stack, also, the next char in s is also a \\')\\'. Thus, now we have a valid right parenthese. We just need to update the index pointer, and pop the topmost left paren from stack\\n3. \\'(\\' in stack, also, the next char in s is not a \\')\\'. So we need to add one more \\')\\' to construct a valid right parenthese. After adding right paren, now we can pop left paren from stack\\n\\nwhy res += len(stk) * 2?\\nAfter traversing s completely, if there are remaining left parentheses, it means there are left parenthese having no matching right parenthese. So we have to add len(stk) * 2 to res.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303596,
                "title": "c-easy-to-understand-stack-single-pass-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }\\n                     else{\\n                         st.pop();\\n                         ans++;\\n                     }\\n                     \\n                 }\\n                 else if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ))\\n                 {\\n                     ans++;\\n                     i++;\\n                 }\\n                 else\\n                 {\\n                   ans+=2;    \\n                 }\\n            }\\n        }\\n        while(st.size()){\\n            st.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 2255977,
                "title": "c-o-n-one-pass-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218237,
                "title": "simplest-java-solution-2-pass",
                "content": "```\\n/**\\nNot the fastest but arguably simplest. Replacing )) with ] reduces this problem to a simpler balancing problem\\n**/\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }\\n                else count += ch == \\']\\' ? 1 : 2;\\n            }\\n        }\\n        return count+leftCount*2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2215666,
                "title": "python-solution-with-explantions",
                "content": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2084857,
                "title": "c-easy-to-understand-simple-code-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848462,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772757,
                "title": "c-stack-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694649,
                "title": "c-using-stack-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }\\n            }\\n            \\n            if(c==\\')\\'){\\n                if(st.empty()){\\n                    st.push(\\'(\\');\\n                    st.push(c);\\n                    ans++;\\n                }\\n                \\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                }\\n                \\n                else if(st.top()==\\'(\\')\\n                    st.push(c);\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            if(st.top()==\\'(\\'){\\n                ans+=2;\\n                st.pop();\\n            }\\n                \\n            else if(st.top()==\\')\\'){\\n                ans++;\\n                st.pop();\\n                st.pop();\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1687981,
                "title": "java-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }\\n            else\\n            {\\n                if(i+1<n&&s.charAt(i+1)==\\')\\')\\n                {\\n                    if(open==0)\\n                    {\\n                        ++ans;\\n                    }\\n                    else\\n                    {\\n                        --open;\\n                    }\\n                    ++i;\\n                }\\n                else\\n                {\\n                    if(open==0)\\n                    {\\n                        ans+=2;\\n                    }\\n                    else\\n                    {\\n                        ++ans;\\n                        --open;\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans+2*open;\\n        \\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621255,
                "title": "c-easy-to-understand-stack-solution",
                "content": "# class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s[i+1]==\\')\\'){\\n                        if(st.size()>0){st.pop(); i+=2;}\\n                        else{ans++; i+=2;}\\n                    }\\n                    else{\\n                        if(st.size()>0){\\n                            st.pop(); ans++; i++;\\n                        }\\n                        else{\\n                            ans+=2; i++;\\n                        }\\n                    }\\n                }\\n                else{\\n                    if(st.size()>0){\\n                        st.pop(); ans++;\\n                        break;\\n                    }\\n                    else{\\n                        ans+=2; break;\\n                    }\\n                }\\n            }\\n        }\\n        if(st.size()>0){\\n            ans+=st.size()*2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1597083,
                "title": "java-count-parenthesis-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582020,
                "title": "python-o-n-time-o-n-space-solution-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1552910,
                "title": "c-28ms-98-3-line-math",
                "content": "Runtime: 28 ms, faster than 97.91% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\nMemory Usage: 12.3 MB, less than 93.09% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\n```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543379,
                "title": "o-n-time-and-o-1-space-solution-10-line-of-code-simple-cake-walk-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535577,
                "title": "python-beat-100-time-complexity-with-comments-o-n-tc-and-o-1-sc",
                "content": "```class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}\")\\n        for c in s:\\n            if c ==\"(\":\\n                bal+=1\\n            elif c == \"}\":\\n                if bal == 0: ans+=1\\n                else:   bal-=1\\n            else: #####c == \\')\\'\\n                if bal == 0: ##it should be ()) wesaw 1 close we need 1 open and another close\\n                    ans+=2\\n                else:  #####() \\n                    bal-=1\\n                    ans+=1   ##()) we saw () so we need one close so ans+=1 and we saw one open so bal-=1\\n        return ans+bal*2",
                "solutionTags": [],
                "code": "class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}",
                "codeTag": "Java"
            },
            {
                "id": 1531211,
                "title": "c-simple-one-pass-solution-explained-using-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523232,
                "title": "python-straight-forward-one-pass-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434641,
                "title": "c-easiest-time-o-n-space-o-1",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433841,
                "title": "python-min-insertions-to-balance-weird-string",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384784,
                "title": "c-solution-fully-explained-o-n-solution-one-pass",
                "content": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\nIf u havent solve above given problem yet, i really recommend u solve that problem first.\\n\\nThe only difference between above given problem and this problem is, in above problem a \"()\" this is valid parentheses string and this \"())\" this is valid parentheses string, here 2 consecutive \"))\" closing bracket needed for one \"(\" opening bracket.\\n\\nwe will use same approach like valid parentheses,\\nwe will push \"(\" opening bracket in stack and whenever we find \")\" closing bracket in string\\nnow we will have 4 cases\\n\\n1. cases (when string is valid, like \"())\" )\\n2. when string is like(\"))\"): mean no opening bracket\\n3. when we have string like this(\"()\") no consecutive closing bracket\\n4. when we have only one \")\" no opening no consecutive closing.\\n\\n````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n````\\n\\nif u have any query regarding coding above approach just ask me in comments.",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341051,
                "title": "easy-to-understand-java-solution",
                "content": "Solve this problem first before going through my code : https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n\\nNow the code should be easy to understand , if you have any doubts do comment down below and I will try to help you out \\n\\n```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```\\n\\nYou can also solve this using stack , how ? solve leetcode 921 using stack and submit it  , and then try to solve this problem by making changes to the code you submitted for leetcode 921 , but since that takes linear space I did not code it up \\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295068,
                "title": "stack-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238392,
                "title": "one-pass-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222152,
                "title": "python-solution",
                "content": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "solutionTags": [],
                "code": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200203,
                "title": "python-replace-and-count",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151300,
                "title": "no-extra-space",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138473,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134665,
                "title": "c-concise-o-n-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1113079,
                "title": "python-replacement-trick",
                "content": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\\n\\n**Approach:**\\n\\nReplacing all `\\'))\\'` with `\\']\\'` pairs up all of the closed brackets into groups of 2.\\nReplacing all `\\'(\\'` with `\\'[\\'` does nothing, but it makes it easier to visualize which brackets pairs are complete.\\n\\nIterate over each character in `s` and talley the \\ntotal open / closed parentheses where `\\'[\\' = +2` and `\\']\\' = -2`.\\n\\nWhile iterating over `s` we need to make sure the count never drops below zero.\\nThis would indicate the string is unbalanced.\\n\\nThere are a few possible scenarios:\\n1. For `\\'[\\'` just add 2 to the count, no changes necessary.\\n2. For `\\']\\'` subtract 2 from the count.\\nIf `count < 2` then we must add 1 `[` to keep the string balanced. (`res += 1 ; count += 2`)\\n3. For `\\')\\'` then there are two possibilities.\\nIf `count >= 2` then we have extra `\\'[\\'` and just need to add one `\\')\\'` to keep the string balanced. (`res += 1 ; count -= 2`)\\nOtherwise we need to add one `\\'[\\'` and one `\\')\\'` (`res += 2 ; count += 0`).\\n\\nAfter iterating over `s` if `count` is `0` then the string is balanced.  \\nHowever, in cases like examples 3 and 4, where `count` &ne; `0` then `count` `\\')\\'` must be added to balance the string.\\n\\nThis brings the total insertions up to `res + count` where `res` parentheses were inserted during the traversal\\nand `count` parenetheses were inserted at the end to balance the string.\\n\\n<hr>\\n\\n**Example Replacements:**\\n\\n| Example | Before | After | res | count | answer |\\n|:---:|:---:|:---:|:---:|:---:|:---:|\\n| 1 |(())) |  [[])|1 |  0 | 1|\\n| 2 |()) |  []|0 |  0 | 0|\\n| 3 |))())( |  ][][|1 |  2 | 3|\\n| 4 |(((((( |  [[[[[[|0 |  12 | 12|\\n| 5 |))))))) |  ]]])|5 |  0 | 5|\\n\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107138,
                "title": "simple-and-short-solution-without-using-stacks-time-o-n-and-space-o-1-faster-than-90",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1) NO EXTRA SPACE USED\\n***PLEASE,UPVOTE IF THIS IS HELPFUL ***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080384,
                "title": "c-one-pass-runtime-86-memory-92",
                "content": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055510,
                "title": "c-one-pass-count-simple-solution-with-explanation",
                "content": "* when s[i] == \\')\\' && (s[i+1] == \\'(\\' or i == s.size()-1), we need to insert one \\')\\'; Otherwise, there are two consecutive \\')\\', and we skip the next one: i++\\n* when every time we face two \\')\\', subtract one \\'(\\' and check if it is < 0. If yes, we need to insert one \\'(\\' and reset left to 0.\\n* after one time pass. res += left\\\\*2 to make sure if there are not enough \\')\\'.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976074,
                "title": "c-easy-to-understand-ask-doubts-in-the-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938626,
                "title": "java-one-pass-with-code-comments",
                "content": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936597,
                "title": "one-pass-solution-with-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923816,
                "title": "python-use-count-to-simulate-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917613,
                "title": "c-intuitive-solution-with-explanation",
                "content": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885922,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879669,
                "title": "cpp-o-n-tc-and-o-1-sc-faster-than-99-97-solution",
                "content": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870862,
                "title": "c-just-do-what-is-asked",
                "content": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847974,
                "title": "my-java-solutions-with-my-thought-process",
                "content": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832536,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 793890,
                "title": "python-o-n-time-o-1-space-with-concise-explanation",
                "content": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "solutionTags": [],
                "code": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "codeTag": "Java"
            },
            {
                "id": 789594,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789453,
                "title": "c-simple-o-n-solution",
                "content": "Here we are maintaining a stack of `\\')\\'`. But for that the size of stack is enough. We start from the end of the string.\\nIf we encounter a `\\'(\\'`, then we must subtract 2 from the stack. If less than 2 `\\')\\'` are available in the stack then we add the number of `\\')\\'` required to make it balanced i.e. `2 - (stack size)`.\\nIf we encounter a `\\')\\'`, then we check if we have 2 consecutive `\\')\\'`. If yes, then we add 2 to the stack else we add 1 more to the result and 2 to the stack.\\nIn returning the result we have,\\n`res` = computed answer\\n`stack/2` = In case we have a residue of `\\')\\'` left over in stack, so we add 1 for every 2 in the result.\\n** `stack%2?2:0` = In case we have an odd number of residue, then we add 2 to the result, 1 `\\'(\\'` and 1 `\\')\\'`.\\nThis last condition is not required because we are adding `\\')\\'` into the stack in sets of 2. So we wont have any odd number of parenthesis in the stack.\\n```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785031,
                "title": "python-3-explained-using-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784566,
                "title": "javascript-extremely-simple-4-line-solution-w-explanation",
                "content": "First, we initialize a counter for the open parentheses and our answer variable.\\n\\nIterating through the string, if we find a \\'(\\', increment the counter.\\n\\nIf it\\'s not a \\'(\\', then it must be a \\')\\'. If we have a stored \\'(\\', then \\'use\\' it and decrement the counter, otherwise we\\'d need to insert a \\'(\\' here, so increment the answer. Also, if the next character is a \\')\\', then jump ahead one step by incrementing the interval, or else we\\'ll need to insert a \\')\\' here, so again increment the answer.\\n\\nFinally, any remaining stored \\'(\\'s left at the end will need to be closed off with two \\')\\'s each.\\n\\n```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780287,
                "title": "o-n-solution-in-c-using-a-temporary-string",
                "content": "#### Converting a hard question into something simpler\\n\\nIf I had a simple string that required one \\'(\\' and \\')\\', the it would have been easier right? \\nSo, why not convert to a simpler one. Start with creating a new temporary string where we have single \\')\\' for every opening \\'(\\'. But do remember, while converting to simpler one, count number of missing \\')\\', where we were supposed to have \\'))\\'.\\n```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\\n\\nNow since this problem has been converted into a simpler problem, it can be done easily.\\nFor this  problem we need to calculate difference of \\'(\\' and \\')\\'. If anytime this difference becomes less than 0, add a \\'(\\'. And, if diff is positive, we must add a \\')\\'. \\nAnd while adding diff to total count, add twice of diff as in the original question we were supposed to add \\'))\\' for every \\'(\\'.\\n\\n\\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```\\n\\nTime Complexity : O(N)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780195,
                "title": "easy-understanding-c-python-stack-solution",
                "content": "We can use stack to imitate left parenthesis.\\nWhenever we met a left parenthesis, place it into stack.\\nOtherwise, fill in left parenthesis, and pop out stack as needed.\\n\\nC++ version:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\\n\\nPython version:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\\n\\nAfter you\\'ve understood this method, we could easily replace stack with left counter.\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\\n\\npython:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779962,
                "title": "c-only-count-left-parentheses-o-n-o-1-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tif(left>0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left>0  && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left==0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse if(left==0 && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1 ))\\n\\t\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tans+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans+=left*2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 779934,
                "title": "python-using-stack",
                "content": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "solutionTags": [],
                "code": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 779897,
                "title": "java-using-stack",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }\\n                stack.push(ch);\\n            } else {\\n                if(curr == 0) {\\n                    if(stack.size() == 0) {\\n                        stack.push(\\'(\\');\\n                        count++;\\n                    }\\n                    curr = 1;\\n                } else {\\n                    if(stack.size() == 0) count++;\\n                    else stack.pop();\\n                    curr = 0;\\n                }\\n            }\\n        }\\n        while(stack.size() > 0) {\\n            if(curr == 1) {\\n                curr = 0;\\n                count++;\\n            } else count += 2;\\n            stack.pop();\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4084421,
                "title": "java-intuitive-easy-constant-space-complexity-missing-test-case-description-explanation",
                "content": "# Missing Data\\nthe opening bracket can only be balanced by pair of consecutive closing brackets. \\nFor example in the following case: \\n(()))(()))()())))\\nSee the following screenshot how the brackets are balanced with each other. Same color opening brackets will be balanced with first occurence of same color closing bracket towards it right.\\n \\n![bracketsBalanced.png](https://assets.leetcode.com/users/images/ce86266a-410c-4a01-872b-d3ebce631140_1695553126.7488647.png)\\n\\n\\nThe answer should be 4\\nExplanation: \\nThe first red brackets need 1 closing bracket to balance. \\nSimilarly the next Green Brackets need one 1 closing bracket\\nBlue Brackets need 1 closing bracket \\nBrown Brackets need 1 opening bracket\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep count of opening bracket encountered so far, \\nIf the current bracket is an closing bracket, balance it with one of the opening bracket, if there is any otherwise, we just have to insert one opening bracket. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057125,
                "title": "java-solution",
                "content": "S# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054767,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038546,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\nBasically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034396,
                "title": "go-greedy-100-less-memory-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957611,
                "title": "c-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956017,
                "title": "100-useful-minimum-number-of-swaps-to-make-the-string-balanced",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929808,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915268,
                "title": "python-o-n-time-and-o-1-space-beats-100",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914863,
                "title": "java-no-stack-used-easy-to-follow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914813,
                "title": "c-no-stack-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908008,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem using only Stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906554,
                "title": "c-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880202,
                "title": "simple-stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863528,
                "title": "java-solution-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853124,
                "title": "python-beats-98-one-pass-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3805390,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769398,
                "title": "dart-solution",
                "content": "# Intuition\\n\\n1. Consecutive `)` must be even count.\\n2. When it\\'s imbalanced, add `(`.\\n3. If there are outstanding `(`, add `))` at the end.\\n\\n# Code\\n```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756296,
                "title": "easy-python3-solution-with-an-explanation",
                "content": "\\n# Approach\\nHere is an approach to understand how the code works:\\n\\n1. Iterate through the characters of the string using a while loop until i reaches the end of the string.\\n\\n2. If openBrackets is greater than 0 and ch is equal to \\')\\', it means there are open parentheses that need to be closed.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, decrease minimumInsertions by 2 to account for the pair and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment i by 1 and decrease minimumInsertions by 1 to account for the single closing parenthesis.\\n    - Decrement openBrackets by 1 since a closing parenthesis has been balanced.\\n3. If ch is equal to \\')\\', but the above condition is not met, it means there is an unbalanced closing parenthesis.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, increment minimumInsertions by 1 to account for adding an opening parenthesis, and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment minimumInsertions by 2 to account for adding an opening and closing parenthesis, and increment i by 1.\\n4. If ch is equal to \\'(\\', it means there is an opening parenthesis that needs to be closed.\\n\\n    - Increment openBrackets by 1 to keep track of the open parentheses.\\n    - Increment minimumInsertions by 2 to account for adding a closing parenthesis.\\n    - Increment i by 1.\\n5. After the loop ends, return the value of minimumInsertions, which represents the minimum number of insertions required to balance the parentheses in the string.\\n\\nThis approach ensures that the parentheses are balanced by inserting the minimum number of additional parentheses. The algorithm scans the string from left to right and maintains a count of open parentheses encountered. It adjusts the count and the number of insertions based on the encountered characters.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659026,
                "title": "python3-following-the-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614434,
                "title": "easy-c-with-or-without-stack-beats-100",
                "content": "\\n1.  Using stack\\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\\n2. No stack , keep count of unbalanced open brackets \\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608373,
                "title": "1541-my-java-solution-with-comments",
                "content": "This is an extension quesion of LeetCode 921\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590920,
                "title": "c-easy-approach-simple-if-else-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568091,
                "title": "easy-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npush \"(\" unitl \"))\" found, then pop. if not able to pop according to rule increase the count.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554070,
                "title": "simple-implementation-without-stack-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538705,
                "title": "easy-to-understand-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527872,
                "title": "java-simple-solution-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502132,
                "title": "one-pass-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496694,
                "title": "without-stack-c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483963,
                "title": "no-need-of-stack-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447656,
                "title": "c-stack-easy-o-n-o-n",
                "content": "# Intuition - Idea is every \\')\\' should be enclosed by \\'(\\' and \\')\\'\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - \\n    1. Use a stack to store every \\'(\\'\\n    2. On \\')\\', initially consider no \\'(\\' and \\')\\' enclosing it, hence ops = 2, if there is \\'(\\' on top of stack, ops = 1 and also if there is \\')\\' after current char, ops = 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422363,
                "title": "java-3-approaches",
                "content": "# Intuition\\nFirst I thought tocode like this but somewhere I was getting lost in handling \\')\\'.\\n\\n```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Approach\\n( -> ))\\na single opening bracket requires two closing brackets\\n\\n# Complexity\\n- Time complexity:O(n)\\n \\n# Code\\n\\n- <h5>Least efficient (using stack):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (using string):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (1ms difference by just exchanging if and else condition):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Best (Using char array):</h5>\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385628,
                "title": "stack-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380979,
                "title": "c-use-int-as-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356684,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356058,
                "title": "i-ruby",
                "content": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3313348,
                "title": "java-simple-solution-beginners-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295878,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }\\n             else\\n             {\\n                 if(i+1<s.length())\\n                 {\\n                     if(s[i+1]==\\')\\')\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                             ++i;\\n                         }\\n                         else\\n                         {\\n                             cp+=1;\\n                             ++i;\\n                         }\\n                     }\\n                     else\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                              cp+=1;\\n                         }\\n                         else\\n                         {\\n                             cp+=2;\\n                         }\\n                     }\\n                 }\\n                 else\\n                 {\\n                     if(c>0)\\n                     {\\n                         cp+=1;\\n                         --c;\\n                     }\\n                     else\\n                     {\\n                         cp+=2;\\n                     }\\n                 }\\n             }\\n         }\\n        while(c>0)\\n        {\\n            cp+=2;\\n            --c;\\n        }\\n        return cp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3289051,
                "title": "python-one-pass-solution-time-o-n-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288675,
                "title": "single-pass-with-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288583,
                "title": "o-n-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214154,
                "title": "c",
                "content": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212415,
                "title": "easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212043,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-with-stack",
                "content": "\\n# Approach\\ndeclare two variables res(extra characters added) and stack(to keep track of open paranteses)\\nif we encounter a ( just add it to the stack.\\nif you encounter a )\\n\\n\\nthen check the character after that there are three cases possible.\\n1. )  -two cases possible\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n2. (  -two cases possible\\n    1. empty stack add opening first then closing \\n    2. add only closing and increase the stack by one\\n3. string get out of bounds- two cases possible similar to one just add extra )\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```\\n\\nSimilar Question:\\n \\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/solutions/3207628/easy-to-understand-solution-in-java-using-stacks-and-greedy-approach/?orderBy=hot",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168450,
                "title": "stack-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167287,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164406,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161626,
                "title": "o-n-c-solution-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to question 921\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWalk through every parantheses in input string and use two variable **insertion** and **right_need** to record the status of parantheses need.\\n- **Insertion** record the number of insertion activities needed before current char\\n- **right_need** record the number of right parantheses need\\n***\\n\\n## Cases\\n1. If current char is \\'(\\'\\n    * We need two more right parantheses: \\n        * right_need +=2\\n    * If current right_need is odd, the pattern is invalid. Thus, we need to insert one \\')\\' \\n        * insertion++, right_need--\\n2. If current char is \\')\\'\\n    * The right paranthesis we need would minus one \\n    * If the right_need is -1, it means there is a extra right paranthesis. To match the pattern \\'())\\', we insert one left paranthesis and need one more right paranthesis.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]