[
    {
        "title": "One Edit Distance",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565136,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            },
            {
                "id": 1566244,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            },
            {
                "id": 1856544,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            },
            {
                "id": 1774024,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            },
            {
                "id": 2059089,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            },
            {
                "id": 1874028,
                "content": [
                    {
                        "username": "xunrui",
                        "content": "One edit means remove/add/change 1 character.\\n\\nA tip: the problem asks if they are EXACTLY one edit distance apart"
                    },
                    {
                        "username": "nullptrexcep",
                        "content": "if s == \"\" and t == \"\", why the expected answer is false? Empty strings should be equal."
                    },
                    {
                        "username": "user3801tN",
                        "content": "[@shrined](/shrined) ya but it sounds like WITHIN 1 edit distance so a would think it means <= 1 edit_distance"
                    },
                    {
                        "username": "shrined",
                        "content": "The question is titled \"One edit distance\" not \"Zero edit distance\" :P. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "One of the purposes of this question is to check how many people will get trapped into going the dynamic programming way :)"
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "true"
                    },
                    {
                        "username": "eliasjunior",
                        "content": "I think the problem should mention that inputs like \"ab\" and \"bca\" are NOT one distance apart, to make sure we don't make wrong assumptions, I took a while to figure this out, in a real interview I'd have asked that."
                    },
                    {
                        "username": "user3801tN",
                        "content": "Did anyone else get really mad when they realized that equal string\\'s aren\\'t considered within 1 edit distance apart lmao."
                    },
                    {
                        "username": "babyfat",
                        "content": "edge cases"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Duplicate Subtrees",
        "question_content": "<p>Given the <code>root</code>&nbsp;of a binary tree, return all <strong>duplicate subtrees</strong>.</p>\n\n<p>For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them.</p>\n\n<p>Two trees are <strong>duplicate</strong> if they have the <strong>same structure</strong> with the <strong>same node values</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" style=\"width: 450px; height: 354px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,null,2,4,null,null,4]\n<strong>Output:</strong> [[2,4],[4]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" style=\"width: 321px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" style=\"width: 450px; height: 303px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,2,3,null,3,null]\n<strong>Output:</strong> [[2,3],[3]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree will be in the range <code>[1, 5000]</code></li>\n\t<li><code>-200 &lt;= Node.val &lt;= 200</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 106011,
                "title": "java-concise-postorder-traversal-solution",
                "content": "We perform postorder traversal, serializing and hashing the serials of subtrees in the process. We can recognize a duplicate subtree by its serialization.\\n\\n```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    List<TreeNode> res = new LinkedList<>();\\n    postorder(root, new HashMap<>(), res);\\n    return res;\\n}\\n\\npublic String postorder(TreeNode cur, Map<String, Integer> map, List<TreeNode> res) {\\n    if (cur == null) return \"#\";  \\n    String serial = cur.val + \",\" + postorder(cur.left, map, res) + \",\" + postorder(cur.right, map, res);\\n    map.put(serial, map.getOrDefault(serial, 0) + 1);\\n    if (map.get(serial) == 2) res.add(cur);\\n    return serial;\\n}\\n```\\n\\nThe above time complexity is O(n^2). We can improve this to O(n) by replacing full serializations with serial ids instead.\\n\\n```\\nclass Solution {\\n   int curId = 1;\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        Map<Integer, Integer> idToCount = new HashMap<>();\\n        List<TreeNode> res = new LinkedList<>();\\n        postorder(root, serialToId, idToCount, res);\\n        return res;\\n    }\\n    \\n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\\n        if (root == null) return 0;\\n        int leftId = postorder(root.left, serialToId, idToCount, res);\\n        int rightId = postorder(root.right, serialToId, idToCount, res);\\n        String curSerial = leftId + \",\" + root.val + \",\" + rightId;\\n        int serialId = serialToId.getOrDefault(curSerial, curId);\\n        if (serialId == curId) curId++;\\n        serialToId.put(curSerial, serialId);\\n        idToCount.put(serialId, idToCount.getOrDefault(serialId, 0) + 1);\\n        if (idToCount.get(serialId) == 2) res.add(root);\\n        return serialId;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    List<TreeNode> res = new LinkedList<>();\\n    postorder(root, new HashMap<>(), res);\\n    return res;\\n}\\n\\npublic String postorder(TreeNode cur, Map<String, Integer> map, List<TreeNode> res) {\\n    if (cur == null) return \"#\";  \\n    String serial = cur.val + \",\" + postorder(cur.left, map, res) + \",\" + postorder(cur.right, map, res);\\n    map.put(serial, map.getOrDefault(serial, 0) + 1);\\n    if (map.get(serial) == 2) res.add(cur);\\n    return serial;\\n}\\n```\n```\\nclass Solution {\\n   int curId = 1;\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        Map<Integer, Integer> idToCount = new HashMap<>();\\n        List<TreeNode> res = new LinkedList<>();\\n        postorder(root, serialToId, idToCount, res);\\n        return res;\\n    }\\n    \\n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\\n        if (root == null) return 0;\\n        int leftId = postorder(root.left, serialToId, idToCount, res);\\n        int rightId = postorder(root.right, serialToId, idToCount, res);\\n        String curSerial = leftId + \",\" + root.val + \",\" + rightId;\\n        int serialId = serialToId.getOrDefault(curSerial, curId);\\n        if (serialId == curId) curId++;\\n        serialToId.put(curSerial, serialId);\\n        idToCount.put(serialId, idToCount.getOrDefault(serialId, 0) + 1);\\n        if (idToCount.get(serialId) == 2) res.add(root);\\n        return serialId;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106016,
                "title": "o-n-time-and-space-lots-of-analysis",
                "content": "First the basic version, which is O(n<sup>2</sup>) time and gets accepted in about 150 ms:\\n\\n    def findDuplicateSubtrees(self, root):\\n        def tuplify(root):\\n            if root:\\n                tuple = root.val, tuplify(root.left), tuplify(root.right)\\n                trees[tuple].append(root)\\n                return tuple\\n        trees = collections.defaultdict(list)\\n        tuplify(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nI convert the entire tree of nested `TreeNode`s to a tree of nested `tuple`s. Those have the advantage that they already support hashing and deep comparison (for the very unlikely cases of hash collisions). So then I can just use each subtree's `tuple` version as a key in my dictionary. And equal subtrees have the same key and thus get collected in the same list.\\n\\nOverall this costs only O(n) memory (where n is the number of nodes in the given tree). The string serialization I've seen in other posted solutions costs O(n^2) memory (and thus also at least that much time).\\n\\n<br>\\n\\n# So far only O(n<sup>2</sup>) time\\n\\nUnfortunately, tuples don't cache their own hash value (see [this](https://mail.python.org/pipermail/python-dev/2003-August/037424.html) for a reason). So if I use a tuple as key and thus it gets asked for its hash value, it will compute it again. Which entails asking its content elements for *their* hashes. And if they're tuples, then they'll do the same and ask *their* elements for *their* hashes. And so on. So asking a tuple tree root for its hash traverses the entire tree. Which makes the above solution only O(n^2) time, as the following test demonstrates. It tests linear trees, and doubling the height quadruples the run time, exactly what's expected from a quadratic time algorithm.\\n\\nThe code:\\n```\\nfrom timeit import timeit\\nimport sys\\nsys.setrecursionlimit(5000)\\n\\ndef tree(height):\\n    if height:\\n        root = TreeNode(0)\\n        root.right = tree(height - 1)\\n        return root\\n\\nsolution = Solution().findDuplicateSubtrees\\nfor e in range(5, 12):\\n    root = tree(2**e)\\n    print(timeit(lambda: solution(root), number=1000))\\n```\\nThe printed times:\\n```\\n0.0661657641567657\\n0.08246562780375502\\n0.23728608832718473\\n0.779312441896731\\n2.909226393471882\\n10.919695348072757\\n43.52919811329259\\n```\\n\\n<br>\\n\\n# Caching hashes\\n\\nThere's an easy way to add caching, though. Simply wrap each tuple in a `frozenset`, which *does* cache its hash value:\\n\\n    def findDuplicateSubtrees(self, root):\\n        def convert(root):\\n            if root:\\n                result = frozenset([(root.val, convert(root.left), convert(root.right))])\\n                trees[result].append(root)\\n                return result\\n        trees = collections.defaultdict(list)\\n        convert(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nRunning the above test again now shows O(n) behaviour as expected, doubling of size causing doubling of run time:\\n```\\n0.06577755770063994\\n0.056785410167764075\\n0.14042076531958228\\n0.22786156533737006\\n0.4496169916643781\\n0.932876339417438\\n1.8611131309331435\\n```\\nAnd it's much faster than the original version using only tuples. That said, both solutions get accepted by LeetCode in about 150 ms, since the test suite's trees are sadly pretty small and simple.\\n\\n---\\n\\nThat of course doesn't mean that the solution is now O(n) time. Only that it's apparently O(n) time for such linear trees. But there's a catch. If two subtrees have the same hash value, then they'll still get fully compared. There are two cases:\\n1. **Different trees having the same hash value**, i.e., hash collisions. LeetCode uses 64-bit Python and thus hash collisions are very unlikely unless you have a huge number of subtrees. The largest tree in the test suite has 5841 subtrees. The probability of having no collisions for 5841 different values is about 99.9999999999078%:\\n    ```\\n    >>> reduce(lambda p, i: p * (2**64 - i) / 2**64, range(5841), 1.0)\\n    0.999999999999078\\n    ```\\n    Even if all 5841 subtrees were different and all of the test suite's 167 test cases were like that, then we'd still have about a 99.99999998460193% chance to not have any hash collisions anywhere:\\n    ```\\n    >>> 0.999999999999078**167\\n    0.9999999998460193\\n    ```\\n    Also, I could of course use a stronger hashing algorithm, like SHA256.\\n\\n2. **Equal trees having the same hash value**. Well duh, obviously equal trees have the same hash value. So how big of a problem is that? How many equal trees can we have, and of what sizes? In the above case of the whole tree being linear, there are *no* equal subtrees at all (except for the trivial empty subtrees, but they don't matter). So let's go to the other extreme end, a [perfect tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees). Then there are *lots* of equal trees. There are n subtrees but only about log<sup>2</sup>(n) *different* subtrees, one for each height. Subtrees of the same height are all equal. So pretty much *every* subtree is a duplicate and thus shares the hash with a previous subtree and thus will get completely compared to the previous one. So how costly is it to traverse all subtrees completely (in separate traversals)? The whole tree has n nodes. Its two subtrees have about n/2 nodes each, so about n nodes together (actually n-1 because they don't contain the root). The next level has 4 trees with about n/4 nodes each, again adding n nodes overall. And so on. We have log<sub>2</sub>(n) levels, so overall this takes O(n log n) time. We can again test this, doubling the size of a tree makes the run time a bit worse than double:\\n    ```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.left = tree(height - 1)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(10, 17):\\n        root = tree(e)\\n        print(timeit(lambda: solution(root), number=100))\\n    ```\\n    The printed times:\\n    ```\\n    0.10957473965829807\\n    0.22831256388730117\\n    0.48625792412907487\\n    1.010916041039311\\n    2.131317089557299\\n    4.5137782403671025\\n    9.616743290368206\\n    ```\\n    The last two trees have 15 and 16 levels, respectively. If the solution does take &Theta;(n log n) time for perfect trees, then we expect it to take 2 * 16/15 as long for the tree with 16 levels as for the tree with 15 levels. And it did: 4.51 * 2 * 16/15 is about 9.62. (If you find that suspiciously accurate, you're right: I actually ran the whole test 50 times and used the averages).\\n\\n    So is the `frozenset` solution O(n log n) time? Nope. Sadly not. It's still only O(n<sup>2</sup>). Remember how the original tuple solution took O(n<sup>2</sup>) time for linear trees? And how caching the hashes improved that to O(n), because there were no duplicate subtrees whose equal hashes would cause expensive deep comparison? Well, all we have to do to create the same nightmare scenario again is to have *two* such linear subtrees under a common root node. Then while the left subtree only takes O(n), the right subtree takes O(n<sup>2</sup>). Demonstration again:\\n    ```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(5, 12):\\n        root = TreeNode(0)\\n        root.left = tree(2**e)\\n        root.right = tree(2**e)\\n        print(timeit(lambda: solution(root), number=1000))\\n    ```\\n    The printed times:\\n    ```\\n    0.1138048859928981\\n    0.19950686963173872\\n    0.5518468952197122\\n    1.8595846431294971\\n    6.7689327267056605\\n    26.291197508748162\\n    106.77212851917264\\n    ```\\n<br>\\n\\n# O(n) time and space\\n\\nFortunately, @Danile showed an [O(n) time solution](https://discuss.leetcode.com/topic/97790/no-string-hash-python-code-o-n-time-and-space) and it's pretty simple. Here's my implementation using their idea:\\n\\n    def findDuplicateSubtrees(self, root, heights=[]):\\n        def getid(root):\\n            if root:\\n                id = treeid[root.val, getid(root.left), getid(root.right)]\\n                trees[id].append(root)\\n                return id\\n        trees = collections.defaultdict(list)\\n        treeid = collections.defaultdict()\\n        treeid.default_factory = treeid.__len__\\n        getid(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nThe idea is the same as Danile's: Identify trees by numbering them. The first unique subtree gets id 0, the next unique subtree gets id 1, the next gets 2, etc. Now the dictionary keys aren't deep nested structures anymore but just ints and triples of ints.\\n\\nRunning the \"perfect trees\" test again:\\n```\\n0.05069159040252735\\n0.09899985757750773\\n0.19695348072759256\\n0.39157652084085726\\n0.7962228593508778\\n1.5419999122629369\\n3.160187444826308\\n```\\nAnd the \"linear trees\" test again:\\n```\\n0.034597848759331834\\n0.05386034062412301\\n0.12324202869723078\\n0.22538750035305155\\n0.46485619835306713\\n0.8654176554613617\\n1.7437530910788834\\n```\\nAnd the \"two parallel linear trees\" test again:\\n```\\n0.05274439729745809\\n0.0894428275852537\\n0.18871220620853896\\n0.3264557892339413\\n0.7091321061762685\\n1.3789991725072908\\n2.7934804751983546\\n```\\nAll three tests now show nice doubling of the times, as expected from O(n).\\n\\nThis solution gets accepted in about 100 ms, and the best time I got from a handful of submissions was 92 ms.\\n\\n<br>\\n\\n# Revisiting the probability calculation for hash collisions\\n\\nAbove I calculated the probability 99.9999999999078% using *floats*. Which of course have rounding errors. So can we trust that calculation? Especially since we're multiplying so many special factors, all being close to 1? Turns out that yes, that's pretty accurate.\\n\\nWe can do the calculation using integers, which only round down. Just scale the \"probability\" by 10<sup>30</sup> or so:\\n```\\n>>> p = 10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> p\\n999999999999075407566135201054\\n```\\nSince those divisions round down, this gives us a lower bound for the true value. And if we instead work with *negative* numbers, then the divisions effectively round *up* and we get an *upper* bound for the true value:\\n```\\n>>> p = -10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> -p\\n999999999999075407566135206894\\n```\\nComparing those two bounds we can see that the true probability is 99.999999999907540756613520...%. So of the previous result 99.9999999999078% using floats, only that last digit was wrong.\\n\\nUsing this value in the subsequent calculation again, we get a 99.99999998455928% chance for not having any collisions anywhere even if all 167 test cases had 5841 subtrees without duplicates:\\n```\\n>>> 0.99999999999907540756613520**167\\n0.9999999998455928\\n```",
                "solutionTags": [],
                "code": "```\\nfrom timeit import timeit\\nimport sys\\nsys.setrecursionlimit(5000)\\n\\ndef tree(height):\\n    if height:\\n        root = TreeNode(0)\\n        root.right = tree(height - 1)\\n        return root\\n\\nsolution = Solution().findDuplicateSubtrees\\nfor e in range(5, 12):\\n    root = tree(2**e)\\n    print(timeit(lambda: solution(root), number=1000))\\n```\n```\\n0.0661657641567657\\n0.08246562780375502\\n0.23728608832718473\\n0.779312441896731\\n2.909226393471882\\n10.919695348072757\\n43.52919811329259\\n```\n```\\n0.06577755770063994\\n0.056785410167764075\\n0.14042076531958228\\n0.22786156533737006\\n0.4496169916643781\\n0.932876339417438\\n1.8611131309331435\\n```\n```\\n    >>> reduce(lambda p, i: p * (2**64 - i) / 2**64, range(5841), 1.0)\\n    0.999999999999078\\n    ```\n```\\n    >>> 0.999999999999078**167\\n    0.9999999998460193\\n    ```\n```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.left = tree(height - 1)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(10, 17):\\n        root = tree(e)\\n        print(timeit(lambda: solution(root), number=100))\\n    ```\n```\\n    0.10957473965829807\\n    0.22831256388730117\\n    0.48625792412907487\\n    1.010916041039311\\n    2.131317089557299\\n    4.5137782403671025\\n    9.616743290368206\\n    ```\n```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(5, 12):\\n        root = TreeNode(0)\\n        root.left = tree(2**e)\\n        root.right = tree(2**e)\\n        print(timeit(lambda: solution(root), number=1000))\\n    ```\n```\\n    0.1138048859928981\\n    0.19950686963173872\\n    0.5518468952197122\\n    1.8595846431294971\\n    6.7689327267056605\\n    26.291197508748162\\n    106.77212851917264\\n    ```\n```\\n0.05069159040252735\\n0.09899985757750773\\n0.19695348072759256\\n0.39157652084085726\\n0.7962228593508778\\n1.5419999122629369\\n3.160187444826308\\n```\n```\\n0.034597848759331834\\n0.05386034062412301\\n0.12324202869723078\\n0.22538750035305155\\n0.46485619835306713\\n0.8654176554613617\\n1.7437530910788834\\n```\n```\\n0.05274439729745809\\n0.0894428275852537\\n0.18871220620853896\\n0.3264557892339413\\n0.7091321061762685\\n1.3789991725072908\\n2.7934804751983546\\n```\n```\\n>>> p = 10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> p\\n999999999999075407566135201054\\n```\n```\\n>>> p = -10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> -p\\n999999999999075407566135206894\\n```\n```\\n>>> 0.99999999999907540756613520**167\\n0.9999999998455928\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106055,
                "title": "c-java-clean-code-with-explanation",
                "content": "## Description\\n\\nGiven the `root` of a binary tree, return all `duplicate subtrees`.\\n\\nFor each kind of duplicate subtrees, you only need to return the root node of any one of them.\\n\\nTwo trees are duplicate if they have the same structure with the same node values.\\n\\n\\n## Analysis\\n\\n- A unique sub-tree can be uniquely identified by its serialized string;\\n- using post order traversal we can gradualy collect all unique tree-serializations with their associated nodes, with 1 traversal;\\n- then you can see if there is any serialization is associated with more than 1 sub-tree nodes, then you know there is duplicated sub-tree nodes;\\n\\n\\n## Solutions\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, vector<TreeNode*>> map;\\n        vector<TreeNode*> dups;\\n        serialize(root, map);\\n        for (auto it = map.begin(); it != map.end(); it++)\\n            if (it->second.size() > 1) dups.push_back(it->second[0]);\\n        return dups;\\n    }\\nprivate:\\n    string serialize(TreeNode* node, unordered_map<string, vector<TreeNode*>>& map) {\\n        if (!node) return \"\";\\n        string s = \"(\" + serialize(node->left, map) + to_string(node->val) + serialize(node->right, map) + \")\";\\n        map[s].push_back(node);\\n        return s;\\n    }\\n};\\n```\\n\\n### Java\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, List<TreeNode>> map = new HashMap<String, List<TreeNode>>();\\n        List<TreeNode> dups = new ArrayList<TreeNode>();\\n        serialize(root, map);\\n        for (List<TreeNode> group : map.values())\\n            if (group.size() > 1) dups.add(group.get(0));\\n        return dups;\\n    }\\n\\n    private String serialize(TreeNode node, Map<String, List<TreeNode>> map) {\\n        if (node == null) return \"\";\\n        String s = \"(\" + serialize(node.left, map) + node.val + serialize(node.right, map) + \")\";\\n        if (!map.containsKey(s)) map.put(s, new ArrayList<TreeNode>());\\n        map.get(s).add(node);\\n        return s;\\n    }\\n}\\n```\\n\\n## Question\\n\\nBeing lazy, can anyone come up with strict proof why serialization would be uniquely identify an tree structure?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, vector<TreeNode*>> map;\\n        vector<TreeNode*> dups;\\n        serialize(root, map);\\n        for (auto it = map.begin(); it != map.end(); it++)\\n            if (it->second.size() > 1) dups.push_back(it->second[0]);\\n        return dups;\\n    }\\nprivate:\\n    string serialize(TreeNode* node, unordered_map<string, vector<TreeNode*>>& map) {\\n        if (!node) return \"\";\\n        string s = \"(\" + serialize(node->left, map) + to_string(node->val) + serialize(node->right, map) + \")\";\\n        map[s].push_back(node);\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, List<TreeNode>> map = new HashMap<String, List<TreeNode>>();\\n        List<TreeNode> dups = new ArrayList<TreeNode>();\\n        serialize(root, map);\\n        for (List<TreeNode> group : map.values())\\n            if (group.size() > 1) dups.add(group.get(0));\\n        return dups;\\n    }\\n\\n    private String serialize(TreeNode node, Map<String, List<TreeNode>> map) {\\n        if (node == null) return \"\";\\n        String s = \"(\" + serialize(node.left, map) + node.val + serialize(node.right, map) + \")\";\\n        if (!map.containsKey(s)) map.put(s, new ArrayList<TreeNode>());\\n        map.get(s).add(node);\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106020,
                "title": "python-easy-understand-solution",
                "content": "`````\\ndef findDuplicateSubtrees(self, root):\\n        def trv(root):\\n            if not root: return \"null\"\\n            struct = \"%s,%s,%s\" % (str(root.val), trv(root.left), trv(root.right))\\n            nodes[struct].append(root)\\n            return struct\\n        \\n        nodes = collections.defaultdict(list)\\n        trv(root)\\n        return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]",
                "solutionTags": [],
                "code": "`````\\ndef findDuplicateSubtrees(self, root):\\n        def trv(root):\\n            if not root: return \"null\"\\n            struct = \"%s,%s,%s\" % (str(root.val), trv(root.left), trv(root.right))\\n            nodes[struct].append(root)\\n            return struct\\n        \\n        nodes = collections.defaultdict(list)\\n        trv(root)\\n        return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]",
                "codeTag": "Python3"
            },
            {
                "id": 1571352,
                "title": "python-solution-explained-in-two-steps-for-beginners",
                "content": "Lets divide the problem into two:\\n\\n**Overview**: We need to somehow serialize the tree for every node in the tree. Then in a hash map (dict), we need to increment the count when serialization from another matches the existing key in hmap. \\n\\n```\\n\\t\\t\\t1\\n\\t\\t2     3\\n```\\nIf we serialize from each node, the output is as follows ( I am doing preorder serialization)\\n\\nfrom node with value 2: ```2,#,#``` \\nfrom node with value 3: ```3,#,# ```\\nfrom node with value 1: ```1,2,#,#,3,#,#```\\n\\n```plain\\n\\t\\t\\t1\\n\\t\\t2     1\\'\\n\\t\\t\\t 2\\'\\n\\t\\t\\n```\\nIf we serialize from each node, the output is as follows ( I am doing preorder serialization)\\n\\nfrom node with value 2\\': ```2\\',#,#``` (MATCHED)\\nfrom node with value 1\\': ```1\\',2\\',#,#,# ```\\nfrom node with value 2: ```2,#,#``` (MATCHED)\\nfrom node with value 1: ```1,2,#,#,1\\',2\\',#,#,#```\\n\\n**So step 1**: lets just generate this preorder serialization \\n\\n```\\ndef serialization(node, path):\\n\\tif node is None: return \\'#\\'\\n\\t\\n\\tpath = \\',\\'.join([str(node.val), serialization(node.left, path), serialization(node.right, path)])\\n\\t\\n\\treturn path\\n\\t\\nserialization(root,\\'\\')\\n\\t\\n```\\n\\n**Step 2**: now in the above step, lets build hmap with key as path and value as the number of times it appears\\n\\n```\\nhmap = {}\\ndef serialization(node, path):\\n\\tif node is None: return \\'#\\'\\n\\t\\n\\tpath = \\',\\'.join([str(node.val), serialization(node.left, path), serialization(node.right, path)])\\n\\tif path in hmap:\\n\\t\\thmap[path] += 1\\n\\telse:\\n\\t\\thmap[path] = 1\\n\\t\\n\\treturn path\\n\\t\\nserialization(root,\\'\\')\\n```\\n\\n**Final Solution:**\\n\\nwe collect all the paths for which hmap[path] == 2 (which means it is repeated atleast once)\\n\\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        \\n        res = []\\n        \\n        hmap = {}\\n        \\n        def recurse(node, path):\\n            if node is None:\\n                return \\'#\\'\\n            \\n            path += \\',\\'.join([str(node.val), recurse(node.left, path), recurse(node.right, path)])\\n            \\n            if path in hmap:\\n                hmap[path] += 1\\n                if hmap[path] == 2:\\n                    res.append(node)\\n            else:\\n                hmap[path] = 1\\n                \\n            \\n            return path\\n        \\n        recurse(root, \\'\\')\\n        #print(hmap) I SUGGEST YOU PRINT THIS - TO UNDERSTAND WHAT IS HAPPENING.\\n        return res\\n```\\n\\nPlease upvote if you like my explanation.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\t\\t\\t1\\n\\t\\t2     3\\n```\n```2,#,#```\n```3,#,# ```\n```1,2,#,#,3,#,#```\n```plain\\n\\t\\t\\t1\\n\\t\\t2     1\\'\\n\\t\\t\\t 2\\'\\n\\t\\t\\n```\n```2\\',#,#```\n```1\\',2\\',#,#,# ```\n```2,#,#```\n```1,2,#,#,1\\',2\\',#,#,#```\n```\\ndef serialization(node, path):\\n\\tif node is None: return \\'#\\'\\n\\t\\n\\tpath = \\',\\'.join([str(node.val), serialization(node.left, path), serialization(node.right, path)])\\n\\t\\n\\treturn path\\n\\t\\nserialization(root,\\'\\')\\n\\t\\n```\n```\\nhmap = {}\\ndef serialization(node, path):\\n\\tif node is None: return \\'#\\'\\n\\t\\n\\tpath = \\',\\'.join([str(node.val), serialization(node.left, path), serialization(node.right, path)])\\n\\tif path in hmap:\\n\\t\\thmap[path] += 1\\n\\telse:\\n\\t\\thmap[path] = 1\\n\\t\\n\\treturn path\\n\\t\\nserialization(root,\\'\\')\\n```\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        \\n        res = []\\n        \\n        hmap = {}\\n        \\n        def recurse(node, path):\\n            if node is None:\\n                return \\'#\\'\\n            \\n            path += \\',\\'.join([str(node.val), recurse(node.left, path), recurse(node.right, path)])\\n            \\n            if path in hmap:\\n                hmap[path] += 1\\n                if hmap[path] == 2:\\n                    res.append(node)\\n            else:\\n                hmap[path] = 1\\n                \\n            \\n            return path\\n        \\n        recurse(root, \\'\\')\\n        #print(hmap) I SUGGEST YOU PRINT THIS - TO UNDERSTAND WHAT IS HAPPENING.\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370456,
                "title": "java-easy-approach-with-explanation-hashmap-postorder",
                "content": "```\\nclass Solution \\n{\\n    HashMap<String, Integer> map= new HashMap<>();//String -- frequency//it store the string at every instant when we visit parent after visiting its children //it also calculates the frequency of the String in the tree\\n    ArrayList<TreeNode> res= new ArrayList<>();//it contain the list of dublicate nodes \\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n    {\\n        Mapper(root);\\n        return res;//returning the list containing a node of dublicate subtree\\n    }\\n    \\n    public String Mapper(TreeNode root)\\n    {//we are doing postorder traversal because we want to first deal with children and then the parent \\n        if(root == null)//when we reach to the null ,we return N to tell that i am null and unique \\n            return \"N\";\\n        \\n        String left= Mapper(root.left);//recursing down the left subtree and knowing about the left child //LEFT\\n        String right= Mapper(root.right);//recursing down the hright subtree and knowing abou the right child //RIGHT\\n        \\n        //ROOT\\n        String curr= root.val +\" \"+left +\" \"+ right;//after knowing about the left and right children//parent forms their own string //space is added to disinguish the string of same reapeatating root value ex- 11 N , 1 1N\\n        \\n        map.put(curr, map.getOrDefault(curr, 0)+ 1);//counting the frequency of string \\n        \\n        if(map.get(curr) == 2)//only the dublicate string node are added to the ArrayList \\n            res.add(root);\\n    \\n        return curr;//returning to the parent to that i am present, and here is my string with the informationn of my left and right child \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    HashMap<String, Integer> map= new HashMap<>();//String -- frequency//it store the string at every instant when we visit parent after visiting its children //it also calculates the frequency of the String in the tree\\n    ArrayList<TreeNode> res= new ArrayList<>();//it contain the list of dublicate nodes \\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n    {\\n        Mapper(root);\\n        return res;//returning the list containing a node of dublicate subtree\\n    }\\n    \\n    public String Mapper(TreeNode root)\\n    {//we are doing postorder traversal because we want to first deal with children and then the parent \\n        if(root == null)//when we reach to the null ,we return N to tell that i am null and unique \\n            return \"N\";\\n        \\n        String left= Mapper(root.left);//recursing down the left subtree and knowing about the left child //LEFT\\n        String right= Mapper(root.right);//recursing down the hright subtree and knowing abou the right child //RIGHT\\n        \\n        //ROOT\\n        String curr= root.val +\" \"+left +\" \"+ right;//after knowing about the left and right children//parent forms their own string //space is added to disinguish the string of same reapeatating root value ex- 11 N , 1 1N\\n        \\n        map.put(curr, map.getOrDefault(curr, 0)+ 1);//counting the frequency of string \\n        \\n        if(map.get(curr) == 2)//only the dublicate string node are added to the ArrayList \\n            res.add(root);\\n    \\n        return curr;//returning to the parent to that i am present, and here is my string with the informationn of my left and right child \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238264,
                "title": "java-easy-hashmap-with-explanation",
                "content": "**The basic intuition is to find the duplicate subtrees of the given tree. So here we just used a hashmap and we can use preorder or postorder traversal to form the subtrees of string type and will check if they are already present in hashmap. If they are not present then we will simply insert into hashmap and keep on counting the number of occurences. If its present atleast 1 time we add the root into the list.**\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res=new ArrayList<>();\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        helper(res,root,hm);\\n        return res;\\n    }\\n    public String helper(List<TreeNode> res,TreeNode root,HashMap<String,Integer> hm){\\n        if(root==null)\\n            return \"\";\\n        String left=helper(res,root.left,hm);\\n        String right=helper(res,root.right,hm);\\n        int currroot=root.val;\\n        String stringformed=currroot+\"$\"+left+\"$\"+right;\\n        if(hm.getOrDefault(stringformed,0)==1){\\n            res.add(root);\\n        }\\n        hm.put(stringformed,hm.getOrDefault(stringformed,0)+1);\\n        return stringformed;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/9ffdc614-ecbc-41d2-87e9-ac145b249fe0_1677547631.5485594.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res=new ArrayList<>();\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        helper(res,root,hm);\\n        return res;\\n    }\\n    public String helper(List<TreeNode> res,TreeNode root,HashMap<String,Integer> hm){\\n        if(root==null)\\n            return \"\";\\n        String left=helper(res,root.left,hm);\\n        String right=helper(res,root.right,hm);\\n        int currroot=root.val;\\n        String stringformed=currroot+\"$\"+left+\"$\"+right;\\n        if(hm.getOrDefault(stringformed,0)==1){\\n            res.add(root);\\n        }\\n        hm.put(stringformed,hm.getOrDefault(stringformed,0)+1);\\n        return stringformed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106014,
                "title": "8-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int>m;\\n        vector<TreeNode*>res;\\n        DFS(root, m, res);\\n        return res;\\n    }\\n    \\n    string DFS(TreeNode* root, unordered_map<string, int>& m, vector<TreeNode*>& res){\\n        if(!root) return \"\";\\n        string s = to_string(root->val) + \",\" + DFS(root->left, m, res) + \",\" + DFS(root->right, m, res);\\n        if(m[s]++ == 1) res.push_back(root);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int>m;\\n        vector<TreeNode*>res;\\n        DFS(root, m, res);\\n        return res;\\n    }\\n    \\n    string DFS(TreeNode* root, unordered_map<string, int>& m, vector<TreeNode*>& res){\\n        if(!root) return \"\";\\n        string s = to_string(root->val) + \",\" + DFS(root->left, m, res) + \",\" + DFS(root->right, m, res);\\n        if(m[s]++ == 1) res.push_back(root);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238165,
                "title": "c-easiest-solution-with-complete-explanation-easy-to-understand",
                "content": "# Intuition\\nThe problem asks to find duplicate subtrees in a given binary tree. Two trees are considered duplicate if they have the same structure and node values. The task is to return any one of the duplicate subtrees.\\n\\nTo solve this problem, we can use a post-order traversal of the binary tree and serialize the subtrees. For each subtree, we can serialize its left and right children recursively and append its own value. By serializing the subtrees in this way, we can represent each subtree as a unique string. We can then use a hash table to keep track of the frequency of each serialized subtree. If the frequency of a serialized subtree is greater than 1, it means that the subtree is a duplicate. We can add the root node of the duplicate subtree to a vector and return it as the result.\\n\\nTherefore, by using a post-order traversal and serializing the subtrees, we can efficiently find the duplicate subtrees in the given binary tree.\\n\\n# Approach\\nTo solve the problem of finding duplicate subtrees in a binary tree, we can use a post-order traversal of the binary tree and serialize each subtree.\\n\\nThe steps to solve the problem are as follows:\\n\\n1. Create a hash table to store the frequency of each serialized subtree and a vector to store the duplicate subtrees.\\n2. Traverse the binary tree using a post-order traversal. For each subtree, serialize its left and right children recursively and append its own value to create a unique string representation of the subtree.\\n3. Add the serialized subtree to the hash table and update its frequency. If the frequency of the serialized subtree is equal to 2, add the root node of the subtree to the vector of duplicate subtrees.\\n4. Return the vector of duplicate subtrees.\\n\\nBy using this approach, we can efficiently find the duplicate subtrees in the binary tree by using a hash table to store the frequency of each serialized subtree. This approach has a time complexity of O(n), where n is the number of nodes in the binary tree, and a space complexity of O(n) to store the serialized subtrees and the hash table.\\n\\n# Complexity\\nTime Complexity:\\n\\nThe time complexity of the serializeSubtrees function is O(n), where n is the number of nodes in the binary tree.\\nThe time complexity of the entire algorithm is also O(n), because the serializeSubtrees function is called once for each node in the binary tree.\\n\\nSpace Complexity:\\n\\nThe space complexity of the serializeSubtrees function is O(n), because the function creates a string for each subtree in the binary tree.\\nThe space complexity of the findDuplicateSubtrees function is O(n), because it creates an unordered map to store the serialized subtrees and their frequency, and a vector to store the duplicate subtrees.\\nTherefore, the overall space complexity of the algorithm is O(n).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class Solution {\\npublic:\\n    // Serialize subtrees and check for duplicates using a post-order traversal\\n    string serializeSubtrees(TreeNode* node, unordered_map<string, int>& subtrees, vector<TreeNode*>& duplicates) {\\n        if (!node) return \"#\"; // Null nodes are represented by \\'#\\'\\n        \\n        string left = serializeSubtrees(node->left, subtrees, duplicates);\\n        string right = serializeSubtrees(node->right, subtrees, duplicates);\\n        \\n        string s = left + \",\" + right + \",\" + to_string(node->val); // Serialize the current subtree\\n        \\n        if (subtrees[s] == 1) duplicates.push_back(node); // If a duplicate subtree is found, add to the vector\\n        \\n        subtrees[s]++;\\n        return s;\\n    }\\n vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int> subtrees; // Store serialized subtree and its frequency\\n        vector<TreeNode*> duplicates; // Store duplicate subtrees\\n        \\n        serializeSubtrees(root, subtrees, duplicates); // Traverse the tree and serialize subtrees\\n        \\n        return duplicates;\\n    }\\n    \\n};\\n\\n\\n//\\uD83D\\uDC47PLEASE UPVOTE IF YOU LIKED MY APPROACH\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class Solution {\\npublic:\\n    // Serialize subtrees and check for duplicates using a post-order traversal\\n    string serializeSubtrees(TreeNode* node, unordered_map<string, int>& subtrees, vector<TreeNode*>& duplicates) {\\n        if (!node) return \"#\"; // Null nodes are represented by \\'#\\'\\n        \\n        string left = serializeSubtrees(node->left, subtrees, duplicates);\\n        string right = serializeSubtrees(node->right, subtrees, duplicates);\\n        \\n        string s = left + \",\" + right + \",\" + to_string(node->val); // Serialize the current subtree\\n        \\n        if (subtrees[s] == 1) duplicates.push_back(node); // If a duplicate subtree is found, add to the vector\\n        \\n        subtrees[s]++;\\n        return s;\\n    }\\n vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int> subtrees; // Store serialized subtree and its frequency\\n        vector<TreeNode*> duplicates; // Store duplicate subtrees\\n        \\n        serializeSubtrees(root, subtrees, duplicates); // Traverse the tree and serialize subtrees\\n        \\n        return duplicates;\\n    }\\n    \\n};\\n\\n\\n//\\uD83D\\uDC47PLEASE UPVOTE IF YOU LIKED MY APPROACH\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064728,
                "title": "simple-c-solution-unordered-map-97-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> vec;\\n    unordered_map<string,int> ump;\\n    string solve(TreeNode* root){\\n        if(!root) return \"$\";\\n        string left = solve(root->left);\\n        string right = solve(root->right);\\n        string s = to_string(root->val) +\"$\"+left+\"$\"+right;\\n        if(ump[s]==1){\\n            vec.push_back(root);\\n        }\\n        ump[s]++;\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        if(!root) return vec;\\n        solve(root);\\n        return vec;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> vec;\\n    unordered_map<string,int> ump;\\n    string solve(TreeNode* root){\\n        if(!root) return \"$\";\\n        string left = solve(root->left);\\n        string right = solve(root->right);\\n        string s = to_string(root->val) +\"$\"+left+\"$\"+right;\\n        if(ump[s]==1){\\n            vec.push_back(root);\\n        }\\n        ump[s]++;\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        if(!root) return vec;\\n        solve(root);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106030,
                "title": "python-o-n-merkle-hashing-approach",
                "content": "We'll assign every subtree a unique *merkle* hash.  You can find more information about Merkle tree hashing here:  https://discuss.leetcode.com/topic/88520/python-straightforward-with-explanation-o-st-and-o-s-t-approaches\\n\\n```\\ndef findDuplicateSubtrees(self, root):\\n    from hashlib import sha256\\n    def hash_(x):\\n        S = sha256()\\n        S.update(x)\\n        return S.hexdigest()\\n\\n    def merkle(node):\\n        if not node:\\n            return '#'\\n        m_left = merkle(node.left)\\n        m_right = merkle(node.right)\\n        node.merkle = hash_(m_left + str(node.val) + m_right)\\n        count[node.merkle].append(node)\\n        return node.merkle\\n\\n    count = collections.defaultdict(list)\\n    merkle(root)\\n    return [nodes.pop() for nodes in count.values() if len(nodes) >= 2]\\n```",
                "solutionTags": [],
                "code": "```\\ndef findDuplicateSubtrees(self, root):\\n    from hashlib import sha256\\n    def hash_(x):\\n        S = sha256()\\n        S.update(x)\\n        return S.hexdigest()\\n\\n    def merkle(node):\\n        if not node:\\n            return '#'\\n        m_left = merkle(node.left)\\n        m_right = merkle(node.right)\\n        node.merkle = hash_(m_left + str(node.val) + m_right)\\n        count[node.merkle].append(node)\\n        return node.merkle\\n\\n    count = collections.defaultdict(list)\\n    merkle(root)\\n    return [nodes.pop() for nodes in count.values() if len(nodes) >= 2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106022,
                "title": "no-string-hash-python-code-o-n-time-and-space",
                "content": "```\\n    def findDuplicateSubtrees(self, root):\\n        self.type_id_gen = 0\\n        duplicated_subtrees = []\\n        type_to_freq = defaultdict(int)\\n        type_to_id = {}\\n        \\n        def dfs(node):\\n            if not node:\\n                return -1\\n            type_id_left, type_id_right = (dfs(ch) for ch in (node.left, node.right))\\n            tree_type = (node.val, type_id_left, type_id_right)\\n            freq = type_to_freq[tree_type]\\n            if freq == 0:\\n                type_id = self.type_id_gen\\n                self.type_id_gen += 1\\n                type_to_id[tree_type] = type_id\\n            elif freq == 1:\\n                type_id = type_to_id[tree_type]\\n                duplicated_subtrees.append(node)\\n            else:\\n                type_id = type_to_id[tree_type] \\n            type_to_freq[tree_type] += 1\\n            return type_id\\n            \\n        dfs(root)\\n        return duplicated_subtrees  \\n```\\n@StefanPochmann, I'm not sure about the time complexity of string or your tuple hash. For each time we wanna get the hash value of a string, should we regard the action as O(1) or O(length of string)? If it is the latter, then the total time complexity would be O(n ^ 2), given tree is a linked list, which conflicts with the time of actual execution of those solutions; otherwise, in what way that Python makes the operation of string with different length has the same time complexity? Thanks!",
                "solutionTags": [],
                "code": "```\\n    def findDuplicateSubtrees(self, root):\\n        self.type_id_gen = 0\\n        duplicated_subtrees = []\\n        type_to_freq = defaultdict(int)\\n        type_to_id = {}\\n        \\n        def dfs(node):\\n            if not node:\\n                return -1\\n            type_id_left, type_id_right = (dfs(ch) for ch in (node.left, node.right))\\n            tree_type = (node.val, type_id_left, type_id_right)\\n            freq = type_to_freq[tree_type]\\n            if freq == 0:\\n                type_id = self.type_id_gen\\n                self.type_id_gen += 1\\n                type_to_id[tree_type] = type_id\\n            elif freq == 1:\\n                type_id = type_to_id[tree_type]\\n                duplicated_subtrees.append(node)\\n            else:\\n                type_id = type_to_id[tree_type] \\n            type_to_freq[tree_type] += 1\\n            return type_id\\n            \\n        dfs(root)\\n        return duplicated_subtrees  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3238342,
                "title": "clean-codes-full-explanation-depth-first-search-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find all the subtrees in a binary tree that occur more than once and return their roots.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Detail Explanation to Approach :\\n- Here we are using a `depth-first search` approach to traverse the tree and encode each subtree into a string using a preorder traversal.\\n- The encoding includes the value of the current node and the encoding of its left and right subtrees, separated by a special character (\"#\").\\n-  **For example,** the subtree consisting of just the root node with value `1` would be encoded as `\"1##\"` (with two \"#\" characters to indicate that there are no left or right subtrees).\\n```\\nfinal String encoded = root.val + \"#\" + encode(root.left, count,ans)\\n + \"#\" + encode(root.right, count, ans);\\n```\\n**OR YOU CAN WRITE IT AS**\\n```\\nString left = encode(root.left, count, ans);\\nString right = encode(root.right, count, ans);\\nfinal String encoded = root.val + \"#\" + left + \"#\" + right;\\n```\\n- The encoding is then added to a HashMap that counts the number of occurrences of each subtree.\\n-  If the encoding already exists in the map, its count is incremented by 1 using the `Integer::sum` function. \\n- If it doesn\\'t exist, a new entry is added with a count of 1. This ensures that each subtree encoding is counted exactly once in the map.\\n```\\ncount.merge(encoded, 1, Integer::sum);\\n```\\n- If a subtree\\'s encoding appears more than once (i.e., its count in the HashMap is 2), its root is added to a result list. \\n```\\nif (count.get(encoded) == 2)//duplicate subtree\\n            ans.add(root);//add the roots\\n```\\n- Finally, return the list of duplicate subtrees.\\n```\\nreturn ans;\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n\\n```\\n*Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python*\\n# Codes [C++ |Java |Python3] : With Comments\\n\\n```C++ []\\nclass Solution {\\n public:\\n  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n    vector<TreeNode*> ans;\\n    unordered_map<string, int> count;\\n    encode(root, count, ans);\\n    return ans;\\n  }\\n\\n private:\\n  string encode(TreeNode* root, unordered_map<string, int>& count,\\n                vector<TreeNode*>& ans) {\\n    if (root == nullptr)\\n      return \"\";\\n\\n    const string encoded = to_string(root->val) + \"#\" +\\n                           encode(root->left, count, ans) + \"#\" +\\n                           encode(root->right, count, ans);\\n                           //# for encoding null left and right childs\\n    if (++count[encoded] == 2)//duplicate subtree\\n      ans.push_back(root);//add the roots\\n    return encoded;\\n  }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n    {\\n        List<TreeNode> ans = new ArrayList<>();\\n        Map<String, Integer> count = new HashMap<>();\\n\\n        encode(root, count, ans);\\n        return ans;\\n    }\\n    private String encode(TreeNode root, Map<String, Integer> count, List<TreeNode> ans)\\n    {\\n        if (root == null)\\n            return \"\";\\n        \\n        final String encoded = root.val + \"#\" + encode(root.left, count, ans) + \"#\" + encode(root.right, count, ans);//# for encoding null left and right childs\\n        count.merge(encoded, 1, Integer::sum);\\n        //used to add the encoding to the count map. If the encoding already exists in the map, its count is incremented by 1 using the Integer::sum function. If it doesn\\'t exist, a new entry is added with a count of 1. This ensures that each subtree encoding is counted exactly once in the map.\\n        if (count.get(encoded) == 2)//duplicate subtree\\n            ans.add(root);//add the roots\\n        return encoded;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n  def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n    ans = []\\n    count = collections.Counter()\\n\\n    def encode(root: Optional[TreeNode]) -> str:\\n      if not root:\\n        return \\'\\'\\n\\n      encoded = str(root.val) + \\'#\\' + \\\\\\n          encode(root.left) + \\'#\\' + \\\\\\n          encode(root.right)\\n      count[encoded] += 1\\n      if count[encoded] == 2:\\n        ans.append(root)\\n      return encoded\\n\\n    encode(root)\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/7812e89d-d269-4059-977f-93ea92152588_1677550633.5717204.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfinal String encoded = root.val + \"#\" + encode(root.left, count,ans)\\n + \"#\" + encode(root.right, count, ans);\\n```\n```\\nString left = encode(root.left, count, ans);\\nString right = encode(root.right, count, ans);\\nfinal String encoded = root.val + \"#\" + left + \"#\" + right;\\n```\n```\\ncount.merge(encoded, 1, Integer::sum);\\n```\n```\\nif (count.get(encoded) == 2)//duplicate subtree\\n            ans.add(root);//add the roots\\n```\n```\\nreturn ans;\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n\\n```\n```C++ []\\nclass Solution {\\n public:\\n  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n    vector<TreeNode*> ans;\\n    unordered_map<string, int> count;\\n    encode(root, count, ans);\\n    return ans;\\n  }\\n\\n private:\\n  string encode(TreeNode* root, unordered_map<string, int>& count,\\n                vector<TreeNode*>& ans) {\\n    if (root == nullptr)\\n      return \"\";\\n\\n    const string encoded = to_string(root->val) + \"#\" +\\n                           encode(root->left, count, ans) + \"#\" +\\n                           encode(root->right, count, ans);\\n                           //# for encoding null left and right childs\\n    if (++count[encoded] == 2)//duplicate subtree\\n      ans.push_back(root);//add the roots\\n    return encoded;\\n  }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n    {\\n        List<TreeNode> ans = new ArrayList<>();\\n        Map<String, Integer> count = new HashMap<>();\\n\\n        encode(root, count, ans);\\n        return ans;\\n    }\\n    private String encode(TreeNode root, Map<String, Integer> count, List<TreeNode> ans)\\n    {\\n        if (root == null)\\n            return \"\";\\n        \\n        final String encoded = root.val + \"#\" + encode(root.left, count, ans) + \"#\" + encode(root.right, count, ans);//# for encoding null left and right childs\\n        count.merge(encoded, 1, Integer::sum);\\n        //used to add the encoding to the count map. If the encoding already exists in the map, its count is incremented by 1 using the Integer::sum function. If it doesn\\'t exist, a new entry is added with a count of 1. This ensures that each subtree encoding is counted exactly once in the map.\\n        if (count.get(encoded) == 2)//duplicate subtree\\n            ans.add(root);//add the roots\\n        return encoded;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n  def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n    ans = []\\n    count = collections.Counter()\\n\\n    def encode(root: Optional[TreeNode]) -> str:\\n      if not root:\\n        return \\'\\'\\n\\n      encoded = str(root.val) + \\'#\\' + \\\\\\n          encode(root.left) + \\'#\\' + \\\\\\n          encode(root.right)\\n      count[encoded] += 1\\n      if count[encoded] == 2:\\n        ans.append(root)\\n      return encoded\\n\\n    encode(root)\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867469,
                "title": "javascript-postorder-dfs",
                "content": "```\\nvar findDuplicateSubtrees = function(root) {\\n  const map = new Map(), res = []\\n  dfs(root, map, res)\\n  return res\\n};\\n\\nfunction dfs(root, map, res){\\n  if(!root) return \\'#\\'\\n  const subtree = `${root.val}.${dfs(root.left,map,res)}.${dfs(root.right, map,res)}`\\n  map.set(subtree,(map.get(subtree)||0) + 1)\\n  if(map.get(subtree) === 2){\\n    res.push(root)\\n  }\\n  return subtree\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findDuplicateSubtrees = function(root) {\\n  const map = new Map(), res = []\\n  dfs(root, map, res)\\n  return res\\n};\\n\\nfunction dfs(root, map, res){\\n  if(!root) return \\'#\\'\\n  const subtree = `${root.val}.${dfs(root.left,map,res)}.${dfs(root.right, map,res)}`\\n  map.set(subtree,(map.get(subtree)||0) + 1)\\n  if(map.get(subtree) === 2){\\n    res.push(root)\\n  }\\n  return subtree\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668627,
                "title": "c-easy-traversing-solution-with-comments",
                "content": "**PLEASE UPVOTE IF IT HELPS A BIT**\\n```\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> ans;\\n      unordered_map<string, int>mymap;\\n  string helper(TreeNode* root)\\n    {\\n        if(root == NULL) return \"\";\\n        \\n        string l= helper(root->left);\\n        string r= helper(root->right);\\n        string s = \"(\" + l + to_string(root->val) + r + \")\"; //make unique string of each subtree\\n        if(mymap[s]!=-1) mymap[s]++; // if string is not present insert and increase count\\n      \\n      if(mymap[s]>1) // if same string found more than one time we got same subtrees\\n      {\\n          ans.push_back(root);\\n          mymap[s]=-1; // no need to insert again\\n      }\\n      return s; \\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n      helper(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> ans;\\n      unordered_map<string, int>mymap;\\n  string helper(TreeNode* root)\\n    {\\n        if(root == NULL) return \"\";\\n        \\n        string l= helper(root->left);\\n        string r= helper(root->right);\\n        string s = \"(\" + l + to_string(root->val) + r + \")\"; //make unique string of each subtree\\n        if(mymap[s]!=-1) mymap[s]++; // if string is not present insert and increase count\\n      \\n      if(mymap[s]>1) // if same string found more than one time we got same subtrees\\n      {\\n          ans.push_back(root);\\n          mymap[s]=-1; // no need to insert again\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 128612,
                "title": "post-order-traversal-post-order-pre-order-serialization",
                "content": "We can serialize subtrees while traversing the tree, and then compare the serializations to see if there are duplicates.\\n\\nThe post-order traversal is natural here.\\n\\nAs for the construction of the serialization string, we can apply either the pre-order or the post-order. The in-order is inappropriate here because trees as shown below will have the same serializations if in-order.\\n```\\n   0\\n  /\\n 0\\n```\\n\\n```\\n   0\\n    \\\\\\n     0\\n```\\n\\nSince we only need to return the root node of any one of duplicate subtrees of the same kind, we utilize a dictionary that maps a serialization string to its appearances. And we add a subtree root to result only if its serialization string appears once.\\n\\n\\n****\\n```\\nclass Solution {\\n   \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> result = new ArrayList<>();\\n        Map<String, Integer> serialToCnt = new HashMap<>();\\n        encode(root, result, serialToCnt);\\n        return result;\\n    }\\n    \\n    private String encode(TreeNode root, List<TreeNode> result, Map<String, Integer> serialToCnt) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        // String serial = encode(root.left, result, serialToCnt) + \",\" + encode(root.right, result, serialToCnt) + \",\" + root.val;\\n        String serial = root.val + encode(root.left, result, serialToCnt) + \",\" + encode(root.right, result, serialToCnt);\\n       \\n        serialToCnt.put(serial, serialToCnt.getOrDefault(serial, 0) + 1);\\n        if (serialToCnt.get(serial) == 2) {\\n            // Return once for each kind of duplicate subtrees\\n            result.add(root);\\n        }\\n        \\n        return serial;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   0\\n  /\\n 0\\n```\n```\\n   0\\n    \\\\\\n     0\\n```\n```\\nclass Solution {\\n   \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> result = new ArrayList<>();\\n        Map<String, Integer> serialToCnt = new HashMap<>();\\n        encode(root, result, serialToCnt);\\n        return result;\\n    }\\n    \\n    private String encode(TreeNode root, List<TreeNode> result, Map<String, Integer> serialToCnt) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        // String serial = encode(root.left, result, serialToCnt) + \",\" + encode(root.right, result, serialToCnt) + \",\" + root.val;\\n        String serial = root.val + encode(root.left, result, serialToCnt) + \",\" + encode(root.right, result, serialToCnt);\\n       \\n        serialToCnt.put(serial, serialToCnt.getOrDefault(serial, 0) + 1);\\n        if (serialToCnt.get(serial) == 2) {\\n            // Return once for each kind of duplicate subtrees\\n            result.add(root);\\n        }\\n        \\n        return serial;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112442,
                "title": "c-15ms-99-76",
                "content": "Running Time: 15 ms (< 99.76%)\\n```C++\\nUse \\n(root.val << 32) | (id(root.left) << 16) | id(root.right) \\nas a 64 bit key, supports up to 65535 unique nodes\\n```\\n\\n```C++\\nclass Solution {\\npublic:\\n  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n    unordered_map<long, pair<int,int>> counts;    \\n    vector<TreeNode*> ans;\\n    function<int(TreeNode*)> getId = [&](TreeNode* r) {\\n      if (!r) return 0;\\n      long key = (static_cast<long>(static_cast<unsigned>(r->val)) << 32) |\\n                 (getId(r->left) << 16) | getId(r->right);    \\n      auto& p = counts[key];\\n      if (p.second++ == 0)\\n        p.first = counts.size();\\n      else if (p.second == 2)\\n        ans.push_back(r);\\n      return p.first;  \\n    };\\n    getId(root);\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nUse \\n(root.val << 32) | (id(root.left) << 16) | id(root.right) \\nas a 64 bit key, supports up to 65535 unique nodes\\n```\n```C++\\nclass Solution {\\npublic:\\n  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n    unordered_map<long, pair<int,int>> counts;    \\n    vector<TreeNode*> ans;\\n    function<int(TreeNode*)> getId = [&](TreeNode* r) {\\n      if (!r) return 0;\\n      long key = (static_cast<long>(static_cast<unsigned>(r->val)) << 32) |\\n                 (getId(r->left) << 16) | getId(r->right);    \\n      auto& p = counts[key];\\n      if (p.second++ == 0)\\n        p.first = counts.size();\\n      else if (p.second == 2)\\n        ans.push_back(r);\\n      return p.first;  \\n    };\\n    getId(root);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178526,
                "title": "easy-clean-straightforward-python-recursive",
                "content": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        seen = collections.defaultdict(int)\\n        res = []\\n        \\n        def helper(node):\\n            if not node:\\n                return\\n            sub = tuple([helper(node.left), node.val, helper(node.right)])\\n            if sub in seen and seen[sub] == 1:\\n                res.append(node)\\n            seen[sub] += 1\\n            return sub\\n        \\n        helper(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        seen = collections.defaultdict(int)\\n        res = []\\n        \\n        def helper(node):\\n            if not node:\\n                return\\n            sub = tuple([helper(node.left), node.val, helper(node.right)])\\n            if sub in seen and seen[sub] == 1:\\n                res.append(node)\\n            seen[sub] += 1\\n            return sub\\n        \\n        helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106021,
                "title": "verbose-java-solution-tree-traversal",
                "content": "Idea is to traverse the tree and serialize each sub-tree to a string and put them into a HashMap. The first time we put ```null``` as the value and later we put the real node as the value. Then at last, every entry in the map with not null value, is an answer.\\nAn optimization is to start searching from the ```first possible``` start node which has both left and right sub-trees. Think about why tree node with only one sub-tree can't be a valid start point?\\n```\\npublic class Solution {\\n    Map<String, TreeNode> map = new HashMap<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> result = new ArrayList<>();\\n        if (root == null) return result;\\n        \\n        traverse(first(root));\\n        \\n        for (TreeNode node : map.values()) {\\n            if (node != null) {\\n                result.add(node);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private TreeNode first(TreeNode root) {\\n        if (root == null) return null;\\n        if (root.left != null && root.right != null) return root;\\n        if (root.left != null) return first(root.left);\\n        return first(root.right);\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) return;\\n        \\n        String s = path(root);\\n        if (map.containsKey(s)) {\\n            map.put(s, root);\\n        }\\n        else {\\n            map.put(s, null);\\n        }\\n        \\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n    \\n    private String path(TreeNode root) {\\n        if (root == null) return \"#\";\\n        return root.val + \",\" + path(root.left) + \",\" + path(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```null```\n```first possible```\n```\\npublic class Solution {\\n    Map<String, TreeNode> map = new HashMap<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> result = new ArrayList<>();\\n        if (root == null) return result;\\n        \\n        traverse(first(root));\\n        \\n        for (TreeNode node : map.values()) {\\n            if (node != null) {\\n                result.add(node);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private TreeNode first(TreeNode root) {\\n        if (root == null) return null;\\n        if (root.left != null && root.right != null) return root;\\n        if (root.left != null) return first(root.left);\\n        return first(root.right);\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) return;\\n        \\n        String s = path(root);\\n        if (map.containsKey(s)) {\\n            map.put(s, root);\\n        }\\n        else {\\n            map.put(s, null);\\n        }\\n        \\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n    \\n    private String path(TreeNode root) {\\n        if (root == null) return \"#\";\\n        return root.val + \",\" + path(root.left) + \",\" + path(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258318,
                "title": "c-easy-and-concise-inorder-traversal",
                "content": "```\\nstring inorder(TreeNode* root, unordered_map<string, int>& mp, vector<TreeNode*>& res)                \\n{\\n        if(!root)\\n         return \"\";\\n\\n        string str = \"(\";\\n        str += inorder(root -> left, mp, res);\\n        str += to_string(root -> val);\\n        str += inorder(root -> right, mp, res);\\n        str += \")\";\\n\\n        if(mp[str] == 1)\\n            res.push_back(root);\\n    \\n        mp[str]++;\\n\\n        return str;\\n}\\n    \\nvector<TreeNode*> findDuplicateSubtrees(TreeNode* root) \\n{\\n\\tunordered_map<string, int> mp;\\n\\tvector<TreeNode*> res;\\n\\tinorder(root, mp, res);\\n\\treturn res;\\n}\\t\\t\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring inorder(TreeNode* root, unordered_map<string, int>& mp, vector<TreeNode*>& res)                \\n{\\n        if(!root)\\n         return \"\";\\n\\n        string str = \"(\";\\n        str += inorder(root -> left, mp, res);\\n        str += to_string(root -> val);\\n        str += inorder(root -> right, mp, res);\\n        str += \")\";\\n\\n        if(mp[str] == 1)\\n            res.push_back(root);\\n    \\n        mp[str]++;\\n\\n        return str;\\n}\\n    \\nvector<TreeNode*> findDuplicateSubtrees(TreeNode* root) \\n{\\n\\tunordered_map<string, int> mp;\\n\\tvector<TreeNode*> res;\\n\\tinorder(root, mp, res);\\n\\treturn res;\\n}\\t\\t\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106054,
                "title": "python-code-easy-to-understand-postorder-traversal-serialization",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def postorder(self, node):\\n        \"\"\"\\n        :type node: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        if not node:\\n            return '#'\\n        tree_str = self.postorder(node.left) + self.postorder(node.right) + str(node.val)\\n        if self.tree_str_count[tree_str] == 1:\\n            self.result.append(node)\\n        self.tree_str_count[tree_str] += 1\\n        return tree_str\\n    \\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        self.tree_str_count, self.result = collections.defaultdict(int), []\\n        self.postorder(root)\\n        return self.result\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def postorder(self, node):\\n        \"\"\"\\n        :type node: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        if not node:\\n            return '#'\\n        tree_str = self.postorder(node.left) + self.postorder(node.right) + str(node.val)\\n        if self.tree_str_count[tree_str] == 1:\\n            self.result.append(node)\\n        self.tree_str_count[tree_str] += 1\\n        return tree_str\\n    \\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        self.tree_str_count, self.result = collections.defaultdict(int), []\\n        self.postorder(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238439,
                "title": "look-at-once-solutions-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find duplicate subtrees, we can traverse the binary tree using depth-first search (DFS) and store the subtree\\'s serialized representation in a map, where the key is the serialized string, and the value is a list of tree nodes that represent the same subtree.\\n\\nTo serialize a subtree, we can use a pre-order traversal approach and represent null nodes as \"#\". The serialized string of the subtree\\'s root node will be the concatenation of its value, left subtree, and right subtree in pre-order traversal.\\n\\nOnce we have stored all the subtrees\\' serialized representations, we can iterate over the map and add the nodes that represent the duplicate subtrees to the result list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty map, where the key is a string representation of the subtree, and the value is a list of nodes representing that subtree.\\n2. Traverse the binary tree using DFS. For each node, do the following:\\n- a. Serialize the node\\'s subtree.\\n- b. If the serialized string is already in the map, add the node to the list of nodes representing that subtree.\\n- c. Otherwise, add the serialized string to the map with the node as the only node representing that subtree.\\n3. Initialize an empty list to store the nodes representing duplicate subtrees.\\n4. Iterate over the map, and for each key-value pair, add the first node in the list of nodes representing that subtree to the result list.\\n5. Return the result list.\\n6. \\n# Video reference\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rsx_QjNOtyU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing the entire binary tree once and performing a constant amount of work for each node. Therefore, the time complexity of this algorithm is $$O(n)$$, where n is the number of nodes in the binary tree.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a map to store the serialized representations of the subtrees, which can have up to n keys and values. Therefore, the space complexity of this algorithm is $$O(n)$$.\\n\\n\\n# Code\\n``` java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    Map<String, List<TreeNode>> map = new HashMap<>();\\n    traverse(root, map);\\n    List<TreeNode> result = new ArrayList<>();\\n    for (Map.Entry<String, List<TreeNode>> entry : map.entrySet()) {\\n        List<TreeNode> nodes = entry.getValue();\\n        if (nodes.size() > 1) {\\n            result.add(nodes.get(0));\\n        }\\n    }\\nreturn result;\\n}\\n\\n\\nprivate String traverse(TreeNode node, Map<String, List<TreeNode>> map) {\\n    if (node == null) {\\n        return \"#\";\\n    }\\n    String left = traverse(node.left, map);\\n    String right = traverse(node.right, map);\\n    String serialized = node.val + \",\" + left + \",\" + right;\\n    List<TreeNode> nodes = map.getOrDefault(serialized, new ArrayList<>());\\n    nodes.add(node);\\n    map.put(serialized, nodes);\\n    return serialized;\\n}\\n}\\n```\\n\\n```python []\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        def traverse(node, map):\\n            if not node:\\n                return \"#\"\\n            left = traverse(node.left, map)\\n            right = traverse(node.right, map)\\n            serialized = str(node.val) + \",\" + left + \",\" + right\\n            nodes = map.setdefault(serialized, [])\\n            nodes.append(node)\\n            return serialized\\n\\n        map = {}\\n        traverse(root, map)\\n        result = []\\n        for nodes in map.values():\\n            if len(nodes) > 1:\\n                result.append(nodes[0])\\n        return result\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, vector<TreeNode*>> map;\\n        traverse(root, map);\\n        vector<TreeNode*> result;\\n        for (auto entry : map) {\\n            vector<TreeNode*> nodes = entry.second;\\n            if (nodes.size() > 1) {\\n                result.push_back(nodes[0]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    string traverse(TreeNode* node, unordered_map<string, vector<TreeNode*>>& map) {\\n        if (node == nullptr) {\\n            return \"#\";\\n        }\\n        string left = traverse(node->left, map);\\n        string right = traverse(node->right, map);\\n        string serialized = to_string(node->val) + \",\" + left + \",\" + right;\\n        vector<TreeNode*>& nodes = map[serialized];\\n        nodes.push_back(node);\\n        return serialized;\\n    }\\n};\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n``` java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    Map<String, List<TreeNode>> map = new HashMap<>();\\n    traverse(root, map);\\n    List<TreeNode> result = new ArrayList<>();\\n    for (Map.Entry<String, List<TreeNode>> entry : map.entrySet()) {\\n        List<TreeNode> nodes = entry.getValue();\\n        if (nodes.size() > 1) {\\n            result.add(nodes.get(0));\\n        }\\n    }\\nreturn result;\\n}\\n\\n\\nprivate String traverse(TreeNode node, Map<String, List<TreeNode>> map) {\\n    if (node == null) {\\n        return \"#\";\\n    }\\n    String left = traverse(node.left, map);\\n    String right = traverse(node.right, map);\\n    String serialized = node.val + \",\" + left + \",\" + right;\\n    List<TreeNode> nodes = map.getOrDefault(serialized, new ArrayList<>());\\n    nodes.add(node);\\n    map.put(serialized, nodes);\\n    return serialized;\\n}\\n}\\n```\n```python []\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        def traverse(node, map):\\n            if not node:\\n                return \"#\"\\n            left = traverse(node.left, map)\\n            right = traverse(node.right, map)\\n            serialized = str(node.val) + \",\" + left + \",\" + right\\n            nodes = map.setdefault(serialized, [])\\n            nodes.append(node)\\n            return serialized\\n\\n        map = {}\\n        traverse(root, map)\\n        result = []\\n        for nodes in map.values():\\n            if len(nodes) > 1:\\n                result.append(nodes[0])\\n        return result\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, vector<TreeNode*>> map;\\n        traverse(root, map);\\n        vector<TreeNode*> result;\\n        for (auto entry : map) {\\n            vector<TreeNode*> nodes = entry.second;\\n            if (nodes.size() > 1) {\\n                result.push_back(nodes[0]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    string traverse(TreeNode* node, unordered_map<string, vector<TreeNode*>>& map) {\\n        if (node == nullptr) {\\n            return \"#\";\\n        }\\n        string left = traverse(node->left, map);\\n        string right = traverse(node->right, map);\\n        string serialized = to_string(node->val) + \",\" + left + \",\" + right;\\n        vector<TreeNode*>& nodes = map[serialized];\\n        nodes.push_back(node);\\n        return serialized;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249903,
                "title": "best-python-solution-not-serializing-entire-tree",
                "content": "Most python solutions are serializing the entire tree into a string and using that as a unique key. That makes it `O(n^2)` space complexity. This is a much better solution that is `O(n)` space complexity. Instead, I map each `(node.val, left_id, right_id)` to a new unique id that I return for the parent to use. Now each key is a finite length of `3` ints. You could simplify this a lot by just blindly hashing `(node.val, left_id, right_id)`, but you can\\'t be guaranteed that you won\\'t get a hash conflict. The solution to that is to rely on python\\'s `dict` to handle hash conflicts for you by mapping each one to a unique int.\\n```\\n# need to walk trees, preorder, inorder, postorder\\n# need to store unique subtrees somewhere Map/Set\\n# need unique key for subtree hash(key left + key right + val)\\n# handle hash conflicts?\\n# use hashmap to store monotonic id for (key left + key right + val)\\n# parent uses left child\\'s mono id + right child\\'s mono id + val\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        subtrees = {}\\n        mono_id = 1\\n        visited = set()\\n        res = []\\n        def helper(node: TreeNode) -> int:\\n            nonlocal mono_id\\n            if not node:\\n                return 0\\n            left_id = helper(node.left)\\n            right_id = helper(node.right)\\n            key = (node.val, left_id, right_id)\\n            if key in subtrees:\\n                # already seen this unique subtree\\n                if key not in visited:\\n                    # first time re-visiting this unique subtree\\n                    visited.add(key)\\n                    res.append(node)\\n            else:\\n                # first time seeing this unique subtree\\n                subtrees[key] = mono_id\\n                mono_id += 1\\n            return subtrees[key]\\n        helper(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# need to walk trees, preorder, inorder, postorder\\n# need to store unique subtrees somewhere Map/Set\\n# need unique key for subtree hash(key left + key right + val)\\n# handle hash conflicts?\\n# use hashmap to store monotonic id for (key left + key right + val)\\n# parent uses left child\\'s mono id + right child\\'s mono id + val\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        subtrees = {}\\n        mono_id = 1\\n        visited = set()\\n        res = []\\n        def helper(node: TreeNode) -> int:\\n            nonlocal mono_id\\n            if not node:\\n                return 0\\n            left_id = helper(node.left)\\n            right_id = helper(node.right)\\n            key = (node.val, left_id, right_id)\\n            if key in subtrees:\\n                # already seen this unique subtree\\n                if key not in visited:\\n                    # first time re-visiting this unique subtree\\n                    visited.add(key)\\n                    res.append(node)\\n            else:\\n                # first time seeing this unique subtree\\n                subtrees[key] = mono_id\\n                mono_id += 1\\n            return subtrees[key]\\n        helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238370,
                "title": "easy-java-solution-100-faster-with-algorithm-in-steps-super-easy-to-understand",
                "content": "![image.png](https://assets.leetcode.com/users/images/2205db22-2e2e-46c5-ba60-9eeebc11dd96_1677551740.0497117.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use depth-first search (DFS) to traverse the binary tree and store information about each subtree in a map. Specifically, we create a custom node class called MyTreeNode that stores a hash value, the node value, and the left and right child nodes. The hash value is computed using a hashing function that takes into account the node value and the hash values of its left and right child nodes.\\n\\nWe maintain a map called countMap that keeps track of the frequency of each MyTreeNode object. If the frequency of a MyTreeNode object is 2, it means that we have found a duplicate subtree, so we add the corresponding node to a list called duplicates.\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a class called MyTreeNode to store information about each subtree, including a hash value, node value, and left and right child nodes.\\n\\n2. Create an empty map called countMap to keep track of the frequency of each MyTreeNode object.\\n\\n3. Create an empty list called duplicates to store the duplicate nodes.\\n\\n4. Define a recursive function called dfs that takes a TreeNode object as input and returns a MyTreeNode object. The function should perform the following steps:\\n\\n    a. If the input node is null, return null.\\n\\n    b. Recursively call the dfs function on the left and right child nodes of the input node, and store the results in left and right, respectively.\\n\\n    c. Compute the hash value of the subtree rooted at the input node using a hashing function that takes into account the node value and the hash values of its left and right child nodes.\\n\\n    d.  Create a new MyTreeNode object with the computed hash value, node value, left child, and right child.\\n\\n    e. Increment the count of the MyTreeNode object in countMap by 1.\\n\\n    f. If the count of the MyTreeNode object in countMap is 2, it means that we have found a duplicate subtree, so add the input node to duplicates.\\n\\n    g. Return the MyTreeNode object.\\n\\n5. Call the dfs function on the root of the binary tree.\\n\\n6. Return the duplicates list.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe **time complexity** of the algorithm is **O(n^2) in the worst case**, where n is the number of nodes in the binary tree. This is because the algorithm needs to compute the hash value of each subtree and compare it with the hash values of all the other subtrees, which takes O(n) time per subtree. In the worst case, there could be n nodes in the tree, and each node could be the root of a subtree with n nodes, so the total number of subtrees to be processed would be O(n^2).\\n\\n- Space complexity:\\nThe **space complexity** of the algorithm is also **O(n^2) in the worst case**, where n is the number of nodes in the binary tree. This is because the algorithm needs to store the hash values of all the subtrees in a hash map, and in the worst case, there could be n nodes in the tree, and each node could be the root of a subtree with n nodes, so the total number of subtrees to be stored would be O(n^2). In addition, the recursion stack could also have a maximum depth of n in the worst case, which would contribute an additional O(n) space complexity.\\n\\n![image.png](https://assets.leetcode.com/users/images/72625055-bc3b-452e-a8f2-308b39b542de_1677551758.3074343.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n//2L4LnRnRn\\n//  2\\n//(4LnRn) (n)\\n// \\n//   2\\n//  4 (n)\\n// (n) (n)\\n\\nclass Solution {\\n\\n    private Map<MyTreeNode, Integer> countMap = new HashMap<>();\\n    private List<TreeNode> duplicates = new LinkedList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        dfs(root);\\n        return duplicates;\\n    }\\n\\n    private MyTreeNode dfs(TreeNode node) {\\n        if(node == null) {\\n            return null;\\n        }\\n\\n        MyTreeNode left = dfs(node.left);\\n        MyTreeNode right = dfs(node.right);\\n\\n        int prime = 31;\\n        int hash = 1;\\n        hash = hash * prime + node.val;\\n        if(left != null) {\\n            hash = hash * prime + left.hash;\\n        }\\n\\n        if(right != null) {\\n            hash = hash * prime + right.hash;\\n        }\\n\\n        MyTreeNode myNode = new MyTreeNode(hash, node.val, left, right);\\n        int count = countMap.getOrDefault(myNode, 0) + 1;\\n        countMap.put(myNode, count);\\n        if(count == 2) {\\n            duplicates.add(node);\\n        }\\n\\n        return myNode;\\n    }\\n\\n    private class MyTreeNode {\\n        private int hash;\\n        private int val;\\n        private MyTreeNode left;\\n        private MyTreeNode right;\\n\\n        public MyTreeNode(int h, int v, MyTreeNode l, MyTreeNode r) {\\n            this.hash = h;\\n            this.val = v;\\n            this.left = l;\\n            this.right = r;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            MyTreeNode node = (MyTreeNode) o;\\n            return this.hash == node.hash && this.val == node.val && equals(node.left, this.left) && equals(node.right, this.right);\\n        }\\n\\n        private boolean equals(MyTreeNode a, MyTreeNode b) {\\n            if(a == null && b == null) {\\n                return true;\\n            }\\n\\n            if(a == null || b == null) {\\n                return false;\\n            }\\n\\n            return a.equals(b);\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n//2L4LnRnRn\\n//  2\\n//(4LnRn) (n)\\n// \\n//   2\\n//  4 (n)\\n// (n) (n)\\n\\nclass Solution {\\n\\n    private Map<MyTreeNode, Integer> countMap = new HashMap<>();\\n    private List<TreeNode> duplicates = new LinkedList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        dfs(root);\\n        return duplicates;\\n    }\\n\\n    private MyTreeNode dfs(TreeNode node) {\\n        if(node == null) {\\n            return null;\\n        }\\n\\n        MyTreeNode left = dfs(node.left);\\n        MyTreeNode right = dfs(node.right);\\n\\n        int prime = 31;\\n        int hash = 1;\\n        hash = hash * prime + node.val;\\n        if(left != null) {\\n            hash = hash * prime + left.hash;\\n        }\\n\\n        if(right != null) {\\n            hash = hash * prime + right.hash;\\n        }\\n\\n        MyTreeNode myNode = new MyTreeNode(hash, node.val, left, right);\\n        int count = countMap.getOrDefault(myNode, 0) + 1;\\n        countMap.put(myNode, count);\\n        if(count == 2) {\\n            duplicates.add(node);\\n        }\\n\\n        return myNode;\\n    }\\n\\n    private class MyTreeNode {\\n        private int hash;\\n        private int val;\\n        private MyTreeNode left;\\n        private MyTreeNode right;\\n\\n        public MyTreeNode(int h, int v, MyTreeNode l, MyTreeNode r) {\\n            this.hash = h;\\n            this.val = v;\\n            this.left = l;\\n            this.right = r;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            MyTreeNode node = (MyTreeNode) o;\\n            return this.hash == node.hash && this.val == node.val && equals(node.left, this.left) && equals(node.right, this.right);\\n        }\\n\\n        private boolean equals(MyTreeNode a, MyTreeNode b) {\\n            if(a == null && b == null) {\\n                return true;\\n            }\\n\\n            if(a == null || b == null) {\\n                return false;\\n            }\\n\\n            return a.equals(b);\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238474,
                "title": "optimised-and-simple-solution-in-javascript",
                "content": "\\n# Approach\\n1) Define a recursive function to traverse the binary tree. The function should take a node as input and return a string representation of the subtree rooted at that node.\\n2) In the \"traverse\" function, if the node is null, return a special symbol to represent it.\\n3) Construct a string representation of the subtree rooted at the current node. The representation should include the node\\'s value and the string representations of its left and right subtrees.\\n4) Create a hash map to store the subtrees and their counts. The keys of the hash map should be the string representations of the subtrees, and the values should be the number of times each subtree has been seen.\\n5) Get the count of the subtree from the hash map. If the count is 1, it means we\\'ve seen this subtree before and it\\'s a duplicate. Add the current node to the result array.\\n6) Increment the count of the subtree in the hash map.\\n7) Return the string representation of the subtree from the traverse function.\\n8) Start the traversal from the root node of the binary tree.\\n9) Return the array of duplicate subtrees.\\n\\n**By following this approach, we can traverse the binary tree and keep track of the subtrees that have been seen before. We can then return an array of root nodes for all the duplicate subtrees.**\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of this code is O(n^2) in the worst case, where n is the number of nodes in the binary tree. This is because the traverse function is called recursively for each node in the tree, and for each node, it constructs a string representation of the subtree rooted at that node, which takes O(n) time in the worst case. The hash map lookup and insertion take O(1) time on average, but in the worst case, when all the subtrees are unique, the hash map can contain up to n entries, so the overall time complexity is O(n^2).\\n\\nHowever, we can improve the time complexity of this code to O(n) by using a post-order traversal instead of a pre-order traversal. In a post-order traversal, we visit the left subtree, then the right subtree, and then the root node. By doing this, we can construct the string representation of each subtree by concatenating the string representations of its left and right subtrees, and then the root node\\'s value. This way, we don\\'t need to construct the string representation of the same subtree multiple times, and we can do the duplicate check and hash map lookup in O(1) time.\\n\\nWith this optimization, the time complexity of the code becomes O(n), which is optimal because we need to visit each node in the tree at least once.\\n\\n- Space complexity:\\n\\nThe space complexity of this code is O(n), where n is the number of nodes in the binary tree. This is because we need to store the string representations of all the subtrees in the hash map, and in the worst case, when all the subtrees are unique, the hash map can contain up to n entries. Additionally, the recursive call stack can go up to the height of the tree, which is O(log n) in the average case for a balanced binary tree, and O(n) in the worst case for a degenerate binary tree. Therefore, the overall space complexity is O(n) in the worst case.\\n\\n# Code\\n```\\nfunction findDuplicateSubtrees(root) {\\n  // Create a hash map to store the subtrees and their counts\\n  const map = new Map();\\n  // Create an array to store the duplicate subtrees\\n  const result = [];\\n\\n  // Traverse the binary tree recursively\\n  function traverse(node) {\\n    // If the node is null, return a special symbol to represent it\\n    if (!node) return \\'#\\';\\n\\n    // Construct a string representation of the subtree rooted at the current node\\n    const subtree = `${node.val},${traverse(node.left)},${traverse(node.right)}`;\\n    // Get the count of the subtree from the hash map, default to 0 if not found\\n    const count = map.get(subtree) || 0;\\n\\n    // If the count is 1, it means we\\'ve seen this subtree before and it\\'s a duplicate\\n    if (count === 1) {\\n      // Add the current node to the result array\\n      result.push(node);\\n    }\\n\\n    // Increment the count of the subtree in the hash map\\n    map.set(subtree, count + 1);\\n\\n    // Return the string representation of the subtree\\n    return subtree;\\n  }\\n\\n  // Start the traversal from the root node\\n  traverse(root);\\n\\n  // Return the array of duplicate subtrees\\n  return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nfunction findDuplicateSubtrees(root) {\\n  // Create a hash map to store the subtrees and their counts\\n  const map = new Map();\\n  // Create an array to store the duplicate subtrees\\n  const result = [];\\n\\n  // Traverse the binary tree recursively\\n  function traverse(node) {\\n    // If the node is null, return a special symbol to represent it\\n    if (!node) return \\'#\\';\\n\\n    // Construct a string representation of the subtree rooted at the current node\\n    const subtree = `${node.val},${traverse(node.left)},${traverse(node.right)}`;\\n    // Get the count of the subtree from the hash map, default to 0 if not found\\n    const count = map.get(subtree) || 0;\\n\\n    // If the count is 1, it means we\\'ve seen this subtree before and it\\'s a duplicate\\n    if (count === 1) {\\n      // Add the current node to the result array\\n      result.push(node);\\n    }\\n\\n    // Increment the count of the subtree in the hash map\\n    map.set(subtree, count + 1);\\n\\n    // Return the string representation of the subtree\\n    return subtree;\\n  }\\n\\n  // Start the traversal from the root node\\n  traverse(root);\\n\\n  // Return the array of duplicate subtrees\\n  return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387417,
                "title": "easy-peasy-recursive-preorder-solution",
                "content": "\\tdef findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        if root is None:\\n            return []\\n        self.mp = {}\\n        self.rs = []\\n        self.preorder(root)\\n        return self.rs\\n    \\n    def preorder(self, root):\\n        if root:\\n            ls = str(root.val) + \"-\" + self.preorder(root.left) + \"-\" + self.preorder(root.right)\\n            count = self.mp.get(ls, 0)\\n            if count == 1:\\n                self.rs.append(root)\\n            \\n            self.mp[ls] = count + 1\\n            return ls\\n        else:\\n            return \"#\"",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "\\tdef findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        if root is None:\\n            return []\\n        self.mp = {}\\n        self.rs = []\\n        self.preorder(root)\\n        return self.rs\\n    \\n    def preorder(self, root):\\n        if root:\\n            ls = str(root.val) + \"-\" + self.preorder(root.left) + \"-\" + self.preorder(root.right)\\n            count = self.mp.get(ls, 0)\\n            if count == 1:\\n                self.rs.append(root)\\n            \\n            self.mp[ls] = count + 1\\n            return ls\\n        else:\\n            return \"#\"",
                "codeTag": "Python3"
            },
            {
                "id": 2787941,
                "title": "simple-c-solution-o-n-postorder",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    vector<TreeNode *>res;\\n\\n    string solve(TreeNode *root){\\n        if(!root) return \"\";\\n\\n        string left = solve(root->left);\\n        string right = solve(root->right);\\n\\n        string curr = to_string(root->val) + \" \" + left + \" \" + right;\\n\\n        if(mp[curr] == 1){\\n            res.push_back(root);\\n        }\\n        mp[curr]++;\\n        return curr;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string dummy = solve(root);\\n        return res;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    vector<TreeNode *>res;\\n\\n    string solve(TreeNode *root){\\n        if(!root) return \"\";\\n\\n        string left = solve(root->left);\\n        string right = solve(root->right);\\n\\n        string curr = to_string(root->val) + \" \" + left + \" \" + right;\\n\\n        if(mp[curr] == 1){\\n            res.push_back(root);\\n        }\\n        mp[curr]++;\\n        return curr;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string dummy = solve(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843401,
                "title": "go-12ms-100-map-solution",
                "content": "```go\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n\\thashAll := map[string]int{}\\n\\tduplicate := []*TreeNode{}\\n\\tdfs(root, hashAll, &duplicate)\\n\\treturn duplicate\\n}\\n\\nfunc dfs(node *TreeNode, hashAll map[string]int, duplicate *[]*TreeNode) string {\\n\\tif node == nil {\\n\\t\\treturn \"nil\"\\n\\t}\\n    lString := dfs(node.Left, hashAll, duplicate)\\n    rString := dfs(node.Right, hashAll, duplicate)\\n    buildString := fmt.Sprintf(\"(%s)(%v)(%s)\", lString, node.Val, rString)\\n\\thashAll[buildString]++\\n\\tif hashAll[buildString] == 2 {\\n\\t\\t*duplicate = append(*duplicate, node)\\n\\t}\\n    return buildString\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n\\thashAll := map[string]int{}\\n\\tduplicate := []*TreeNode{}\\n\\tdfs(root, hashAll, &duplicate)\\n\\treturn duplicate\\n}\\n\\nfunc dfs(node *TreeNode, hashAll map[string]int, duplicate *[]*TreeNode) string {\\n\\tif node == nil {\\n\\t\\treturn \"nil\"\\n\\t}\\n    lString := dfs(node.Left, hashAll, duplicate)\\n    rString := dfs(node.Right, hashAll, duplicate)\\n    buildString := fmt.Sprintf(\"(%s)(%v)(%s)\", lString, node.Val, rString)\\n\\thashAll[buildString]++\\n\\tif hashAll[buildString] == 2 {\\n\\t\\t*duplicate = append(*duplicate, node)\\n\\t}\\n    return buildString\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225987,
                "title": "c-o-n-time-space-8ms-beats-100-and-scales-to-2-64-unique-nodes",
                "content": "This solution builds up on the fantastic work of @Danile, @StefanPochman. This C++ implmentation uses a bitset that encodes the root\\'s value in the most significant bits, followed by a concatenation of the left\\'s node id and the right node\\'s id. Since these node id\\'s are actually just an incremened counter we can have as many unique ids as supported by the counter\\'s underlying type. Unlike other C++ solutions which used a long or some other 64-bit primitive POD, I used bitset which is able to acomodate 64 bits for both left and right child node ids and the full 32 bits for the root\\'s value. This allows the solution to scale well beyond 2^16 nodes.\\n\\nHere\\'s the 8ms submission that seems to currently beat 100%.\\n\\n```\\nclass Solution {\\npublic:\\n    using id_type = bitset<8*(2*sizeof(uint64_t) + sizeof(int))>;\\n    const int ValByteOffset = 16*sizeof(uint64_t);\\n    const int IdByteOffset = 8*sizeof(uint64_t);\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<id_type, pair<uint64_t, int>> tree_map;\\n        vector<TreeNode*> result;\\n        getId(root, tree_map, result);\\n        return result;\\n    }\\n    \\nprivate:\\n    uint64_t getId(TreeNode* root, unordered_map<id_type, pair<uint64_t, int>>& tree_map, vector<TreeNode*>& result)\\n    {\\n        if (root == nullptr) return 0UL;\\n        \\n        id_type id = id_type(root->val) << ValByteOffset | id_type(getId(root->left, tree_map, result)) << IdByteOffset | id_type(getId(root->right, tree_map, result));\\n        auto it = tree_map.find(id);\\n        if (it == tree_map.end())\\n            it = tree_map.insert({id, {tree_map.size() + 1, 0}}).first;\\n        \\n        if (++it->second.second == 2)\\n            result.push_back(root);\\n\\n        return it->second.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using id_type = bitset<8*(2*sizeof(uint64_t) + sizeof(int))>;\\n    const int ValByteOffset = 16*sizeof(uint64_t);\\n    const int IdByteOffset = 8*sizeof(uint64_t);\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<id_type, pair<uint64_t, int>> tree_map;\\n        vector<TreeNode*> result;\\n        getId(root, tree_map, result);\\n        return result;\\n    }\\n    \\nprivate:\\n    uint64_t getId(TreeNode* root, unordered_map<id_type, pair<uint64_t, int>>& tree_map, vector<TreeNode*>& result)\\n    {\\n        if (root == nullptr) return 0UL;\\n        \\n        id_type id = id_type(root->val) << ValByteOffset | id_type(getId(root->left, tree_map, result)) << IdByteOffset | id_type(getId(root->right, tree_map, result));\\n        auto it = tree_map.find(id);\\n        if (it == tree_map.end())\\n            it = tree_map.insert({id, {tree_map.size() + 1, 0}}).first;\\n        \\n        if (++it->second.second == 2)\\n            result.push_back(root);\\n\\n        return it->second.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193164,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def helper(root):\\n            if not root:\\n                return \"None,\"\\n            l = helper(root.left)\\n            r = helper(root.right)\\n            encode = str(root.val)+\",\"+l+r\\n            if encode not in dic:\\n                dic[encode] = 1\\n            else:\\n                dic[encode] += 1\\n                if dic[encode] == 2:\\n                    res.append(root)\\n            return encode\\n\\t\\t\\t\\t\\t\\t\\n        res = []\\n        dic = {}\\n        helper(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def helper(root):\\n            if not root:\\n                return \"None,\"\\n            l = helper(root.left)\\n            r = helper(root.right)\\n            encode = str(root.val)+\",\"+l+r\\n            if encode not in dic:\\n                dic[encode] = 1\\n            else:\\n                dic[encode] += 1\\n                if dic[encode] == 2:\\n                    res.append(root)\\n            return encode\\n\\t\\t\\t\\t\\t\\t\\n        res = []\\n        dic = {}\\n        helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505749,
                "title": "easy-java-dfs-code",
                "content": "Uniquely identify each subtree by a String key , and if that key occurs more than once , then the subtree to which that key is mapped is a duplicate subtree \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        HashMap<String,Pair> map = new HashMap();\\n        \\n        dfs(root,map);\\n        \\n        List<TreeNode> list = new ArrayList();\\n        for(String key : map.keySet()){\\n            Pair pair = map.get(key);\\n            if(pair.count>1) list.add(pair.node);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private String dfs(TreeNode node ,HashMap<String,Pair> map){\\n        if(node==null) return \"N\";\\n        \\n        String left = dfs(node.left,map);\\n        String right = dfs(node.right,map);\\n        \\n        String curr = node.val+\"#\"+left+\"#\"+right;\\n        \\n        if(map.containsKey(curr)){\\n            map.get(curr).count++;\\n        }else{\\n            map.put(curr,new Pair(node));\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Pair{\\n    TreeNode node;\\n    int count;\\n    \\n    public Pair(TreeNode node){\\n        this.node = node;\\n        this.count = 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        HashMap<String,Pair> map = new HashMap();\\n        \\n        dfs(root,map);\\n        \\n        List<TreeNode> list = new ArrayList();\\n        for(String key : map.keySet()){\\n            Pair pair = map.get(key);\\n            if(pair.count>1) list.add(pair.node);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private String dfs(TreeNode node ,HashMap<String,Pair> map){\\n        if(node==null) return \"N\";\\n        \\n        String left = dfs(node.left,map);\\n        String right = dfs(node.right,map);\\n        \\n        String curr = node.val+\"#\"+left+\"#\"+right;\\n        \\n        if(map.containsKey(curr)){\\n            map.get(curr).count++;\\n        }else{\\n            map.put(curr,new Pair(node));\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Pair{\\n    TreeNode node;\\n    int count;\\n    \\n    public Pair(TreeNode node){\\n        this.node = node;\\n        this.count = 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306223,
                "title": "c-easy-to-understand-hashing-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,vector<TreeNode*>>mp;\\n    \\n    string recurs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string a=recurs(root->left);\\n        string b=recurs(root->right);\\n        \\n        string temp=\"\";\\n        temp+=to_string(root->val)+\"-\"+a+\"-\"+b;\\n        mp[temp].push_back(root);\\n        return temp;\\n    }\\n\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n\\n        recurs(root);\\n        \\n        for(auto x:mp)\\n        {\\n            if(x.second.size()>1)\\n                res.push_back(x.second[0]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,vector<TreeNode*>>mp;\\n    \\n    string recurs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string a=recurs(root->left);\\n        string b=recurs(root->right);\\n        \\n        string temp=\"\";\\n        temp+=to_string(root->val)+\"-\"+a+\"-\"+b;\\n        mp[temp].push_back(root);\\n        return temp;\\n    }\\n\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n\\n        recurs(root);\\n        \\n        for(auto x:mp)\\n        {\\n            if(x.second.size()>1)\\n                res.push_back(x.second[0]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106040,
                "title": "java-super-easy-postorder-with-hashmap-string-treenode-solution",
                "content": "No fancy tricks, just a post order traversal.\\nUse HashMap<String, TreeNode> to store the founded subtree and its root node. Use postorder traversal to get the left and right subtree and form the full subtree string with the current node. If the subtree is found first time, put <postorder string, null>. If the subtree is found again, put <postorder string, node> . Finally, go through the HashMap to get those not-null value.\\n```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        if(root == null) return new LinkedList<>();\\t\\n\\t\\n\\tHashMap<String, TreeNode> map = new HashMap<>();\\n\\t\\n\\thelper(root, map);\\n\\t\\n\\tList<TreeNode> res = new LinkedList<>();\\t\\n\\t\\n\\tfor(Map.Entry<String, TreeNode> e : map.entrySet()){\\n\\t     if(e.getValue() != null) res.add(e.getValue());\\n\\t}\\n\\t\\n\\treturn res;\\n    \\n}\\n\\npublic String helper(TreeNode node, HashMap<String, TreeNode> map){\\n\\t//leaves node\\n       if(node.left == null && node.right == null){\\n\\t\\tString str = \"\" + node.val;\\n\\t\\tif(!map.containsKey(str))\\t\\t\\t\\n\\t\\t    map.put(str, null);\\n\\t\\telse\\n                    map.put(str, node);\\t\\t\\t\\n\\t\\t\\n\\t\\treturn str;\\n\\t}\\n\\t//post order\\n\\tString left = \"\";\\n\\tif(node.left != null)\\n\\t    left = helper(node.left, map);\\t\\n\\t\\n\\tString right = \"\";\\n\\tif(node.right != null)\\n\\t    right = helper(node.right, map);\\n\\t\\n\\t//new subtree found, put null; subtree found again, put the subtree's root node.\\n\\tString str = left +\" # \"+ right +\" # \"+ node.val;        \\n\\tif(!map.containsKey(str))\\t\\t\\n\\t    map.put(str, null);\\n\\telse\\n            map.put(str, node);\\t\\t\\n\\t\\t\\n\\treturn str;\\n}\\n```\\nEasy to understand? Any suggestion on efficiency?",
                "solutionTags": [],
                "code": "```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        if(root == null) return new LinkedList<>();\\t\\n\\t\\n\\tHashMap<String, TreeNode> map = new HashMap<>();\\n\\t\\n\\thelper(root, map);\\n\\t\\n\\tList<TreeNode> res = new LinkedList<>();\\t\\n\\t\\n\\tfor(Map.Entry<String, TreeNode> e : map.entrySet()){\\n\\t     if(e.getValue() != null) res.add(e.getValue());\\n\\t}\\n\\t\\n\\treturn res;\\n    \\n}\\n\\npublic String helper(TreeNode node, HashMap<String, TreeNode> map){\\n\\t//leaves node\\n       if(node.left == null && node.right == null){\\n\\t\\tString str = \"\" + node.val;\\n\\t\\tif(!map.containsKey(str))\\t\\t\\t\\n\\t\\t    map.put(str, null);\\n\\t\\telse\\n                    map.put(str, node);\\t\\t\\t\\n\\t\\t\\n\\t\\treturn str;\\n\\t}\\n\\t//post order\\n\\tString left = \"\";\\n\\tif(node.left != null)\\n\\t    left = helper(node.left, map);\\t\\n\\t\\n\\tString right = \"\";\\n\\tif(node.right != null)\\n\\t    right = helper(node.right, map);\\n\\t\\n\\t//new subtree found, put null; subtree found again, put the subtree's root node.\\n\\tString str = left +\" # \"+ right +\" # \"+ node.val;        \\n\\tif(!map.containsKey(str))\\t\\t\\n\\t    map.put(str, null);\\n\\telse\\n            map.put(str, node);\\t\\t\\n\\t\\t\\n\\treturn str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3239053,
                "title": "c-easy-solution-beats-95-unordered-map-post-order-traversal",
                "content": "# Approach\\n Store a node\\'s value + it\\'s child values recursively in form of string. check if this string already exists in unordered map. \\nIf this string exists in map, push the node into v(answer vector).\\nelse add this string into map. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<string,int> s;\\n    vector<TreeNode*> v;\\n    string fun(TreeNode* root)\\n    {\\n        string r1=\"\",r2=\"\";\\n        if(root->right!=NULL)\\n        {\\n            r2=r2+fun(root->right);\\n        } \\n        if(root->left!=NULL)\\n        {\\n            r1=r1+fun(root->left);\\n        }   \\n        string r=to_string(root->val)+\",\"+r1+\",\"+r2;\\n        if(s.find(r)!=s.end())\\n            {\\n                if(s[r]==1)\\n                {\\n                   v.push_back(root);\\n                } \\n                s[r]++;\\n            }\\n            else\\n            {\\n                s[r]=1;\\n            }\\n        return r;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string k=fun(root);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<string,int> s;\\n    vector<TreeNode*> v;\\n    string fun(TreeNode* root)\\n    {\\n        string r1=\"\",r2=\"\";\\n        if(root->right!=NULL)\\n        {\\n            r2=r2+fun(root->right);\\n        } \\n        if(root->left!=NULL)\\n        {\\n            r1=r1+fun(root->left);\\n        }   \\n        string r=to_string(root->val)+\",\"+r1+\",\"+r2;\\n        if(s.find(r)!=s.end())\\n            {\\n                if(s[r]==1)\\n                {\\n                   v.push_back(root);\\n                } \\n                s[r]++;\\n            }\\n            else\\n            {\\n                s[r]=1;\\n            }\\n        return r;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string k=fun(root);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016516,
                "title": "python-dfs-dictionary-o-n-time-o-n-space",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        seen = defaultdict(int)\\n        dup = []\\n        \\n        def find(root):\\n            if root is None:    \\n                return \"#\"                              # at leaf node, add # to key\\n            \\n            l = find(root.left)\\n            r = find(root.right)\\n            \\n            k = str(root.val) + \".\" + l + \".\" + r + \".\" # essential to add special char to distinguish value \\n                                                        # e.g. 1, 11 or 11, 1\\n            seen[k] += 1\\n            \\n            if seen[k] == 2:\\n                dup.append(root)\\n            \\n            return k                                    # return key to save to seen\\n        \\n        find(root)\\n        return dup\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        seen = defaultdict(int)\\n        dup = []\\n        \\n        def find(root):\\n            if root is None:    \\n                return \"#\"                              # at leaf node, add # to key\\n            \\n            l = find(root.left)\\n            r = find(root.right)\\n            \\n            k = str(root.val) + \".\" + l + \".\" + r + \".\" # essential to add special char to distinguish value \\n                                                        # e.g. 1, 11 or 11, 1\\n            seen[k] += 1\\n            \\n            if seen[k] == 2:\\n                dup.append(root)\\n            \\n            return k                                    # return key to save to seen\\n        \\n        find(root)\\n        return dup\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424971,
                "title": "short-c-solution",
                "content": "```\\n unordered_map<string,int> m;\\n    vector<TreeNode*> v;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n       solve(root);\\n        return v;\\n    }\\n    string solve(TreeNode* root)\\n    {\\n     if(root==nullptr) return \"#\";\\n        string s=\"\";\\n        s=s+to_string(root->val)+\\',\\';\\n        s=s+solve(root->left);\\n        s=s+solve(root->right);\\n        m[s]++;\\n        if(m[s]==2)\\n        {\\n            v.push_back(root);\\n        } \\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n unordered_map<string,int> m;\\n    vector<TreeNode*> v;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n       solve(root);\\n        return v;\\n    }\\n    string solve(TreeNode* root)\\n    {\\n     if(root==nullptr) return \"#\";\\n        string s=\"\";\\n        s=s+to_string(root->val)+\\',\\';\\n        s=s+solve(root->left);\\n        s=s+solve(root->right);\\n        m[s]++;\\n        if(m[s]==2)\\n        {\\n            v.push_back(root);\\n        } \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269235,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "Intuition consists of 3 steps:\\n\\n1) Create a signature for each node. \\n2) Add node to the result if you have already seen that signature before.\\n3) Make sure to add prefix for sub-left tree and sub-right tree representations in order to avoid some cases at which signature are same but trees are not duplicate.\\n\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> map = new HashMap<>();\\n        List<TreeNode> result = new ArrayList<>();\\n        traverse(root, map, result);\\n        return result;\\n    }\\n    \\n    public String traverse(TreeNode node, Map<String, Integer> map, List<TreeNode> result) {\\n        if (node == null) {\\n            return \"#\";\\n        }\\n        String key = new StringBuilder()\\n            .append(\"l\")\\n            .append(traverse(node.left, map, result))\\n            .append(node.val)\\n            .append(\"r\")\\n            .append(traverse(node.right, map, result))\\n            .toString();\\n        int freq = map.getOrDefault(key, 0);\\n        if (freq == 1) {\\n            result.add(node);\\n        }\\n        map.put(key, freq + 1);\\n        return key;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> map = new HashMap<>();\\n        List<TreeNode> result = new ArrayList<>();\\n        traverse(root, map, result);\\n        return result;\\n    }\\n    \\n    public String traverse(TreeNode node, Map<String, Integer> map, List<TreeNode> result) {\\n        if (node == null) {\\n            return \"#\";\\n        }\\n        String key = new StringBuilder()\\n            .append(\"l\")\\n            .append(traverse(node.left, map, result))\\n            .append(node.val)\\n            .append(\"r\")\\n            .append(traverse(node.right, map, result))\\n            .toString();\\n        int freq = map.getOrDefault(key, 0);\\n        if (freq == 1) {\\n            result.add(node);\\n        }\\n        map.put(key, freq + 1);\\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717283,
                "title": "easy-javascript-solution",
                "content": "```\\nvar findDuplicateSubtrees = function(root) {\\n    const rtn = [];\\n\\t// Map keeping track of the subtrees\\n    const map = new Map();\\n    const helper = root => {\\n\\t   // Use \"#\" to represent null nodes\\n        if (!root) return \"#\";\\n\\t\\t// Adding \".\" is necessary, for ex, differentiating \"1\" and \"11\"\\n        let subtree = root.val.toString() + \".\" + helper(root.left) + \".\" + helper(root.right);\\n\\t\\t// If not saved, save\\n        if (!map[subtree]) {\\n            map[subtree] = 1;\\n\\t\\t  // If encountered once already, store the result\\n        } else if (map[subtree] === 1) {\\n            rtn.push(root);\\n\\t\\t\\t// Adding once more is necessary because we want to make sure we only add duplicates once\\n            map[subtree]++;\\n        } \\n        return subtree;\\n    }\\n    helper(root);\\n    return rtn;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findDuplicateSubtrees = function(root) {\\n    const rtn = [];\\n\\t// Map keeping track of the subtrees\\n    const map = new Map();\\n    const helper = root => {\\n\\t   // Use \"#\" to represent null nodes\\n        if (!root) return \"#\";\\n\\t\\t// Adding \".\" is necessary, for ex, differentiating \"1\" and \"11\"\\n        let subtree = root.val.toString() + \".\" + helper(root.left) + \".\" + helper(root.right);\\n\\t\\t// If not saved, save\\n        if (!map[subtree]) {\\n            map[subtree] = 1;\\n\\t\\t  // If encountered once already, store the result\\n        } else if (map[subtree] === 1) {\\n            rtn.push(root);\\n\\t\\t\\t// Adding once more is necessary because we want to make sure we only add duplicates once\\n            map[subtree]++;\\n        } \\n        return subtree;\\n    }\\n    helper(root);\\n    return rtn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106041,
                "title": "c-19-ms-o-n-2-sort-by-subtree-height",
                "content": "If two subtrees are the same, they have to have same height. The idea is to sort subtrees by its height using post order traversal, and then to work on each group with the same height. \\n\\nThe run time is O(n^2), the same as the string serialization solution. The analysis is as below. It takes O(n) time to sort subtrees into groups. It takes O(m) time to check whether two trees are the same, with m is the total node number in the tree. For a group with the same height, there are O(k^2) same tree comparisons, and k is the number of subtrees in the group. For height i, assuming there are ki subtrees, so there are about n/ki nodes in each subtree. The run time for this group is O(ki^2) x O(n/ki) = O(nki). The sum of all ki, i.e. all nodes, is n, so the total run time is O(n^2).  \\n\\nI have tried to incorporate the total nodes for each subtree, because the same subtree will also have the same amount of nodes, however it didn't improve the run time due to performance of hash table. The comparison to check whether it is the same tree is still potentially time consuming. If anyone have good optimization, please leave a comment. Thanks!\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        if (root == NULL) return ans;\\n        vector<vector<TreeNode*>> height(1, vector<TreeNode*>());\\n        find_height(height, root);\\n        for (int i = 1; i < height.size(); i++) {\\n            for (int j = 0; j < height[i].size(); j++) {\\n                if (height[i][j] == NULL) continue;\\n                bool exist = false;\\n                for (int k = j+1; k < height[i].size(); k++) {\\n                    if (sametree(height[i][j], height[i][k])) {\\n                        height[i][k] = NULL;\\n                        exist = true;\\n                    }\\n                }\\n                if (exist) ans.push_back(height[i][j]);\\n            }   \\n        }\\n        return ans;\\n    }\\nprivate:\\n    int find_height(vector<vector<TreeNode*>>& height, TreeNode* p) {\\n        if (p == NULL) return 0;\\n        int left = find_height(height, p->left), right = find_height(height, p->right), h = max(left, right)+1;\\n        if (h == height.size()) \\n            height.push_back({p});\\n        else \\n            height[h].push_back(p);\\n        return h;\\n    }\\n    bool sametree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) return true;\\n        if (p == NULL || q == NULL) return false;\\n        if (p->val != q->val) return false;\\n        return sametree(p->left, q->left) && sametree(p->right, q->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        if (root == NULL) return ans;\\n        vector<vector<TreeNode*>> height(1, vector<TreeNode*>());\\n        find_height(height, root);\\n        for (int i = 1; i < height.size(); i++) {\\n            for (int j = 0; j < height[i].size(); j++) {\\n                if (height[i][j] == NULL) continue;\\n                bool exist = false;\\n                for (int k = j+1; k < height[i].size(); k++) {\\n                    if (sametree(height[i][j], height[i][k])) {\\n                        height[i][k] = NULL;\\n                        exist = true;\\n                    }\\n                }\\n                if (exist) ans.push_back(height[i][j]);\\n            }   \\n        }\\n        return ans;\\n    }\\nprivate:\\n    int find_height(vector<vector<TreeNode*>>& height, TreeNode* p) {\\n        if (p == NULL) return 0;\\n        int left = find_height(height, p->left), right = find_height(height, p->right), h = max(left, right)+1;\\n        if (h == height.size()) \\n            height.push_back({p});\\n        else \\n            height[h].push_back(p);\\n        return h;\\n    }\\n    bool sametree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) return true;\\n        if (p == NULL || q == NULL) return false;\\n        if (p->val != q->val) return false;\\n        return sametree(p->left, q->left) && sametree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238511,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    Map<String,Integer> map=new HashMap<>();\\n    List<TreeNode> res=new ArrayList<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    public String helper(TreeNode root){\\n        if(root==null) return \"\";\\n        String left= helper(root.left);\\n        String right= helper(root.right);\\n        String curr= root.val +\" \"+left +\" \"+ right;\\n        map.put(curr, map.getOrDefault(curr, 0)+ 1);\\n        if(map.get(curr) == 2)\\n            res.add(root);\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,Integer> map=new HashMap<>();\\n    List<TreeNode> res=new ArrayList<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    public String helper(TreeNode root){\\n        if(root==null) return \"\";\\n        String left= helper(root.left);\\n        String right= helper(root.right);\\n        String curr= root.val +\" \"+left +\" \"+ right;\\n        map.put(curr, map.getOrDefault(curr, 0)+ 1);\\n        if(map.get(curr) == 2)\\n            res.add(root);\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238177,
                "title": "python-dfs-with-hashing",
                "content": "```python []\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n\\n        hmap = defaultdict(int)\\n        res = []\\n        def dfs(node):\\n            if not node: return \\'\\'\\n            l, r = dfs(node.left), dfs(node.right)\\n            struct = f\\'l{l}{node.val}{r}r\\'\\n            hmap[struct] += 1\\n            if hmap[struct] == 2:\\n                res.append(node)\\n            return struct\\n        dfs(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n\\n        hmap = defaultdict(int)\\n        res = []\\n        def dfs(node):\\n            if not node: return \\'\\'\\n            l, r = dfs(node.left), dfs(node.right)\\n            struct = f\\'l{l}{node.val}{r}r\\'\\n            hmap[struct] += 1\\n            if hmap[struct] == 2:\\n                res.append(node)\\n            return struct\\n        dfs(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238153,
                "title": "python3-easy-solution-compare-serialisations-of-treenodes",
                "content": "## Approach\\nSerialize each TreeNode and compare with memorized TreeNode serialization. Please see comments in code.\\n\\nExample of serialization. For the tree in example one, each tree is serialized into the following form:\\n```\\n4,#,#,\\n2,4,#,#,#,\\n4,#,#,\\n2,4,#,#,#,\\n4,#,#,\\n3,2,4,#,#,#,4,#,#,\\n1,2,4,#,#,#,3,2,4,#,#,#,4,#,#,\\n```\\n\\n## Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        res = [] # store all root TreeNodes\\n        dic = {} # memo: map serialized data to root TreeNode\\n        \\n        self.find(root, dic, res)\\n        return res\\n    \\n    \\n    def find(self, root, dic, res):\\n        if not root:\\n            return\\n        \\n        # find left and right duplicate subtrees\\n        self.find(root.left, dic, res)\\n        self.find(root.right, dic, res)\\n        # serialize a new subtree for every TreeNode\\n        data = []\\n        self.serialize(root, data)\\n        data = \\'\\'.join(data)\\n        # only add one TreeNode for each duplication\\n        if dic.get(data, 0) == 1:\\n            res.append(root)\\n        # update memo dictionary\\n        dic[data] = dic.get(data, 0) + 1\\n            \\n\\n    def serialize(self, root, data):\\n        if not root:\\n            data.append(\\'#,\\')\\n            return\\n        # preorder serialization\\n        data.append(str(root.val))\\n        data.append(\\',\\')\\n        self.serialize(root.left, data)\\n        self.serialize(root.right, data)\\n```\\n\\n## **Congratulations on your FINAL question for February!!!**",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n4,#,#,\\n2,4,#,#,#,\\n4,#,#,\\n2,4,#,#,#,\\n4,#,#,\\n3,2,4,#,#,#,4,#,#,\\n1,2,4,#,#,#,3,2,4,#,#,#,4,#,#,\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        res = [] # store all root TreeNodes\\n        dic = {} # memo: map serialized data to root TreeNode\\n        \\n        self.find(root, dic, res)\\n        return res\\n    \\n    \\n    def find(self, root, dic, res):\\n        if not root:\\n            return\\n        \\n        # find left and right duplicate subtrees\\n        self.find(root.left, dic, res)\\n        self.find(root.right, dic, res)\\n        # serialize a new subtree for every TreeNode\\n        data = []\\n        self.serialize(root, data)\\n        data = \\'\\'.join(data)\\n        # only add one TreeNode for each duplication\\n        if dic.get(data, 0) == 1:\\n            res.append(root)\\n        # update memo dictionary\\n        dic[data] = dic.get(data, 0) + 1\\n            \\n\\n    def serialize(self, root, data):\\n        if not root:\\n            data.append(\\'#,\\')\\n            return\\n        # preorder serialization\\n        data.append(str(root.val))\\n        data.append(\\',\\')\\n        self.serialize(root.left, data)\\n        self.serialize(root.right, data)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238139,
                "title": "daily-leetcoding-challenge-february-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-duplicate-subtrees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-duplicate-subtrees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1666527,
                "title": "python-o-n-simple-beats-97",
                "content": "```\\n\\tdef dfs(self,root):\\n        if not root:\\n            return \\' \\'\\n        n=str(root.val)+\",\"+self.dfs(root.left)+\",\"+self.dfs(root.right)\\n        if n in self.s and n not in self.counted:\\n            self.counted.add(n)\\n            self.ans.append(root)\\n            return n\\n        self.s.add(n)\\n        return n\\n        \\n        \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        self.s=set()\\n        self.ans=[]\\n        self.counted=set()\\n        self.dfs(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tdef dfs(self,root):\\n        if not root:\\n            return \\' \\'\\n        n=str(root.val)+\",\"+self.dfs(root.left)+\",\"+self.dfs(root.right)\\n        if n in self.s and n not in self.counted:\\n            self.counted.add(n)\\n            self.ans.append(root)\\n            return n\\n        self.s.add(n)\\n        return n\\n        \\n        \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        self.s=set()\\n        self.ans=[]\\n        self.counted=set()\\n        self.dfs(root)\\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1580269,
                "title": "clean-javascript-post-order-solution",
                "content": "```\\nvar findDuplicateSubtrees = function(root) {\\n    let seen = {};\\n    let output = [];\\n    \\n    traverse(root);\\n    \\n    return output; \\n    \\n    function traverse(node){\\n        if(!node) return \"null\";\\n        \\n        let left = traverse(node.left);\\n        let right = traverse(node.right);\\n        \\n        let key = `${node.val}-${left}-${right}`;\\n        \\n        seen[key] = (seen[key] || 0) + 1;\\n        if(seen[key] == 2) output.push(node);\\n        \\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findDuplicateSubtrees = function(root) {\\n    let seen = {};\\n    let output = [];\\n    \\n    traverse(root);\\n    \\n    return output; \\n    \\n    function traverse(node){\\n        if(!node) return \"null\";\\n        \\n        let left = traverse(node.left);\\n        let right = traverse(node.right);\\n        \\n        let key = `${node.val}-${left}-${right}`;\\n        \\n        seen[key] = (seen[key] || 0) + 1;\\n        if(seen[key] == 2) output.push(node);\\n        \\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1574487,
                "title": "c-hashcode",
                "content": "I ended up using hash codes here and it worked well enough to get accepted. It is not guaranteed to be unique, in order for that you need to do deep comparision. Some of the solutions serialize the tree into a string which seems to work well. In terms of performance, this solution is pretty dang fast!\\n\\n```cs\\npublic IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n    var map = new Dictionary<int, List<TreeNode>>();\\n    int f(TreeNode n) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        int hash = HashCode.Combine(n.val, f(n.left), f(n.right));\\n        if (!map.TryGetValue(hash, out var list)) {\\n            map.Add(hash, list = new List<TreeNode>());\\n        }\\n        list.Add(n);\\n        return hash;\\n    }\\n    f(root);\\n    var res = new List<TreeNode>();\\n    foreach (var pair in map.Where(p => p.Value.Count > 1)) {\\n        res.Add(pair.Value.First());\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cs\\npublic IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n    var map = new Dictionary<int, List<TreeNode>>();\\n    int f(TreeNode n) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        int hash = HashCode.Combine(n.val, f(n.left), f(n.right));\\n        if (!map.TryGetValue(hash, out var list)) {\\n            map.Add(hash, list = new List<TreeNode>());\\n        }\\n        list.Add(n);\\n        return hash;\\n    }\\n    f(root);\\n    var res = new List<TreeNode>();\\n    foreach (var pair in map.Where(p => p.Value.Count > 1)) {\\n        res.Add(pair.Value.First());\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230307,
                "title": "easy-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String,TreeNode> map = new HashMap<>();\\n        postOrderTraversal(root, map, new StringBuilder());\\n        \\n        List<TreeNode> res = new ArrayList<>();\\n        for(TreeNode tree : map.values()){\\n            if(tree != null) res.add(tree);\\n        }\\n        return res;\\n    }\\n    public void postOrderTraversal(TreeNode root, Map<String,TreeNode> map, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"#|\");\\n            return;\\n        }\\n        \\n        StringBuilder left = new StringBuilder();\\n        StringBuilder right = new StringBuilder();\\n        \\n        postOrderTraversal(root.left,map,left);\\n        postOrderTraversal(root.right,map,right);\\n        sb.append(left.toString());\\n        sb.append(right.toString());\\n        sb.append(String.valueOf(root.val)+\"|\");\\n        \\n        String key = sb.toString();\\n        if(!map.containsKey(key))\\n            map.put(key,null);\\n        else\\n            map.put(key,root);       \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String,TreeNode> map = new HashMap<>();\\n        postOrderTraversal(root, map, new StringBuilder());\\n        \\n        List<TreeNode> res = new ArrayList<>();\\n        for(TreeNode tree : map.values()){\\n            if(tree != null) res.add(tree);\\n        }\\n        return res;\\n    }\\n    public void postOrderTraversal(TreeNode root, Map<String,TreeNode> map, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"#|\");\\n            return;\\n        }\\n        \\n        StringBuilder left = new StringBuilder();\\n        StringBuilder right = new StringBuilder();\\n        \\n        postOrderTraversal(root.left,map,left);\\n        postOrderTraversal(root.right,map,right);\\n        sb.append(left.toString());\\n        sb.append(right.toString());\\n        sb.append(String.valueOf(root.val)+\"|\");\\n        \\n        String key = sb.toString();\\n        if(!map.containsKey(key))\\n            map.put(key,null);\\n        else\\n            map.put(key,root);       \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883495,
                "title": "python-o-n-hashmap-solution",
                "content": "1. We ask the question : **FOR EACH SUBTREE, WHAT ARE ITS ROOTS?**\\n\\n2. In other words, we want to keep track of **{subtree1: [root1, root2, ...], ...}**, where root1 and root2 are the roots of subtree1, in `sub_roots_map`\\n\\n3. During the `preorder` traversal, we shall return the **string representation of the subtree (since subtree is the key and hence must be hashable)** rooted at `root`, then update `sub_roots_map` accordingly\\n\\n<br>\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        # KEEP TRACK OF {SUBTREE: [ROOT1, ROOT2, ...]} - {STR: [TREENODE, TREENODE, ...]}\\n        sub_roots_map = defaultdict(list)\\n        \\n        # START A PRE-ORDER TRAVERSAL TO FILL UP THE MAP\\n        self.preorder(root, sub_roots_map)\\n        \\n        # RETURN ANY ROOT FOR SUBTREES WITH MULTIPLE ROOTS\\n        return [root[0] for sub, root in sub_roots_map.items() if len(root) > 1]\\n\\n\\n    def preorder(self, root, sub_roots_map):\\n        if not root:\\n            return \"null\"\\n        \\n        # OBTAIN THE STRING REPRESENTATION OF THIS SUBTREE\\n        sub =f\"{root.val},{self.preorder(root.left, sub_roots_map)},{self.preorder(root.right, sub_roots_map)}\"\\n        \\n        # SAVE IT TO OUR MAP\\n        sub_roots_map[sub].append(root)\\n        \\n        # RETURN THE STRING REPRESENTATION OF THIS SUBTREE\\n        return sub\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        # KEEP TRACK OF {SUBTREE: [ROOT1, ROOT2, ...]} - {STR: [TREENODE, TREENODE, ...]}\\n        sub_roots_map = defaultdict(list)\\n        \\n        # START A PRE-ORDER TRAVERSAL TO FILL UP THE MAP\\n        self.preorder(root, sub_roots_map)\\n        \\n        # RETURN ANY ROOT FOR SUBTREES WITH MULTIPLE ROOTS\\n        return [root[0] for sub, root in sub_roots_map.items() if len(root) > 1]\\n\\n\\n    def preorder(self, root, sub_roots_map):\\n        if not root:\\n            return \"null\"\\n        \\n        # OBTAIN THE STRING REPRESENTATION OF THIS SUBTREE\\n        sub =f\"{root.val},{self.preorder(root.left, sub_roots_map)},{self.preorder(root.right, sub_roots_map)}\"\\n        \\n        # SAVE IT TO OUR MAP\\n        sub_roots_map[sub].append(root)\\n        \\n        # RETURN THE STRING REPRESENTATION OF THIS SUBTREE\\n        return sub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870779,
                "title": "c-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n        var res = new List<TreeNode>();\\n        if (root == null) return res;\\n        var dict = new Dictionary<string, int>(); // the string representation and the occurences\\n        DFS(root, res, dict);\\n        return res;\\n    }\\n    \\n    public string DFS(TreeNode root, IList<TreeNode> res, Dictionary<string, int> dict) {\\n        if (root == null) return \"#\";\\n        var serial = root.val + \",\" + DFS(root.left, res, dict) + \",\" + DFS(root.right, res, dict);\\n        \\n        if (dict.ContainsKey(serial)) {\\n            dict[serial] += 1;\\n            // only add to the result at the second time, otherwise, there is duplicate. cannot use hashset here because there are different node\\n            if (dict[serial] == 2) res.Add(root);\\n        } else {\\n            dict[serial] = 1;\\n        }\\n        \\n        return serial;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n        var res = new List<TreeNode>();\\n        if (root == null) return res;\\n        var dict = new Dictionary<string, int>(); // the string representation and the occurences\\n        DFS(root, res, dict);\\n        return res;\\n    }\\n    \\n    public string DFS(TreeNode root, IList<TreeNode> res, Dictionary<string, int> dict) {\\n        if (root == null) return \"#\";\\n        var serial = root.val + \",\" + DFS(root.left, res, dict) + \",\" + DFS(root.right, res, dict);\\n        \\n        if (dict.ContainsKey(serial)) {\\n            dict[serial] += 1;\\n            // only add to the result at the second time, otherwise, there is duplicate. cannot use hashset here because there are different node\\n            if (dict[serial] == 2) res.Add(root);\\n        } else {\\n            dict[serial] = 1;\\n        }\\n        \\n        return serial;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417511,
                "title": "java-simple-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    Map<String,Integer> subTrees = new HashMap<>();\\n    List<TreeNode> duplicates = new ArrayList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        traverse(root);\\n        return duplicates;\\n    }\\n    \\n    \\n    \\n    private String traverse(TreeNode node){\\n        if(node == null)\\n            return \"\";\\n        String left = traverse(node.left);\\n        String right = traverse(node.right);\\n        String res =  node.val+\"#\"+left+\"#\"+right;\\n        subTrees.put(res,subTrees.getOrDefault(res,0)+1);\\n        if(subTrees.get(res) == 2)\\n          duplicates.add(node);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    Map<String,Integer> subTrees = new HashMap<>();\\n    List<TreeNode> duplicates = new ArrayList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        traverse(root);\\n        return duplicates;\\n    }\\n    \\n    \\n    \\n    private String traverse(TreeNode node){\\n        if(node == null)\\n            return \"\";\\n        String left = traverse(node.left);\\n        String right = traverse(node.right);\\n        String res =  node.val+\"#\"+left+\"#\"+right;\\n        subTrees.put(res,subTrees.getOrDefault(res,0)+1);\\n        if(subTrees.get(res) == 2)\\n          duplicates.add(node);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239977,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string f(TreeNode* root,vector<TreeNode*>&ans, map<string,int> &mp){\\n        if(!root) return \"%\";\\n        string l = f(root->left,ans,mp);\\n        string r = f(root->right,ans,mp);\\n        string s = to_string(root->val) +\"%\"+l+\"%\"+r;\\n        if(mp[s]==1){\\n            ans.push_back(root);\\n        }\\n        mp[s]++;\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        map<string,int> mp;\\n        if(!root) return ans;\\n        f(root,ans,mp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string f(TreeNode* root,vector<TreeNode*>&ans, map<string,int> &mp){\\n        if(!root) return \"%\";\\n        string l = f(root->left,ans,mp);\\n        string r = f(root->right,ans,mp);\\n        string s = to_string(root->val) +\"%\"+l+\"%\"+r;\\n        if(mp[s]==1){\\n            ans.push_back(root);\\n        }\\n        mp[s]++;\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        map<string,int> mp;\\n        if(!root) return ans;\\n        f(root,ans,mp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239945,
                "title": "o-n-solution-very-easy-to-understand",
                "content": "**1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.**\\n**3.Store the string representation in a hash map along with the node that is the root of the subtree.**\\n**4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.**\\n**5.Return the list of duplicate subtree roots.**\\n\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        HashMap<String,Integer>map=new HashMap<>();\\n        List<TreeNode>ans=new ArrayList<>();\\n        traverse(map,ans,root);\\n        return ans;\\n    }\\n    public String traverse(HashMap<String,Integer>map,List<TreeNode>list,TreeNode root){\\n        if(root==null){\\n            return \"#\";\\n        }\\n        String ans=root.val+\",\"+traverse(map,list,root.left)+\",\"+traverse(map,list,root.right);\\n        map.put(ans,map.getOrDefault(ans,0)+1);\\n        if(map.get(ans)==2){\\n            list.add(root);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# UpVoting Is Much Appreciated",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        HashMap<String,Integer>map=new HashMap<>();\\n        List<TreeNode>ans=new ArrayList<>();\\n        traverse(map,ans,root);\\n        return ans;\\n    }\\n    public String traverse(HashMap<String,Integer>map,List<TreeNode>list,TreeNode root){\\n        if(root==null){\\n            return \"#\";\\n        }\\n        String ans=root.val+\",\"+traverse(map,list,root.left)+\",\"+traverse(map,list,root.right);\\n        map.put(ans,map.getOrDefault(ans,0)+1);\\n        if(map.get(ans)==2){\\n            list.add(root);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238581,
                "title": "easy-solution-java-80-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using HashMap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:18ms || Beats 80% of Solution\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res=new ArrayList<>();\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        helper(res,root,hm);\\n        return res;\\n    }\\n    public String helper(List<TreeNode> res,TreeNode root,HashMap<String,Integer> hm){\\n        if(root==null)\\n            return \"\";\\n        String left=helper(res,root.left,hm);\\n        String right=helper(res,root.right,hm);\\n        int currroot=root.val;\\n        String stringformed=currroot+\"$\"+left+\"$\"+right;\\n        if(hm.getOrDefault(stringformed,0)==1){\\n            res.add(root);\\n        }\\n        hm.put(stringformed,hm.getOrDefault(stringformed,0)+1);\\n        return stringformed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res=new ArrayList<>();\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        helper(res,root,hm);\\n        return res;\\n    }\\n    public String helper(List<TreeNode> res,TreeNode root,HashMap<String,Integer> hm){\\n        if(root==null)\\n            return \"\";\\n        String left=helper(res,root.left,hm);\\n        String right=helper(res,root.right,hm);\\n        int currroot=root.val;\\n        String stringformed=currroot+\"$\"+left+\"$\"+right;\\n        if(hm.getOrDefault(stringformed,0)==1){\\n            res.add(root);\\n        }\\n        hm.put(stringformed,hm.getOrDefault(stringformed,0)+1);\\n        return stringformed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393305,
                "title": "c-postorder-traversal-map",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp ;\\n    vector<TreeNode*> ans ;\\n    \\n    string solve(TreeNode * root){\\n        if(!root) return \"\" ;\\n        \\n        string left = solve(root->left) ;\\n        string right = solve(root->right) ;\\n        \\n        string code = to_string(root->val) + \" \" + left + \" \" + right ;\\n        if(dp[code] == 1) ans.push_back(root) ;\\n        dp[code]++ ;\\n        \\n        return code ;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string dummy = solve(root) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp ;\\n    vector<TreeNode*> ans ;\\n    \\n    string solve(TreeNode * root){\\n        if(!root) return \"\" ;\\n        \\n        string left = solve(root->left) ;\\n        string right = solve(root->right) ;\\n        \\n        string code = to_string(root->val) + \" \" + left + \" \" + right ;\\n        if(dp[code] == 1) ans.push_back(root) ;\\n        dp[code]++ ;\\n        \\n        return code ;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        string dummy = solve(root) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210082,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    vector<TreeNode*> ans;\\n    string dfs(TreeNode *p)\\n    {\\n        if(!p) return \"\";\\n        string res = to_string(p->val) + \"|\" + dfs(p->left) + \"|\" + dfs(p->right);\\n        mp[res] ++;\\n        if(mp[res] == 2) ans.push_back(p);\\n        return res;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    vector<TreeNode*> ans;\\n    string dfs(TreeNode *p)\\n    {\\n        if(!p) return \"\";\\n        string res = to_string(p->val) + \"|\" + dfs(p->left) + \"|\" + dfs(p->right);\\n        mp[res] ++;\\n        if(mp[res] == 2) ans.push_back(p);\\n        return res;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920027,
                "title": "java-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Set<TreeNode> set;\\n    Map<String, TreeNode> map;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        set = new HashSet<>();\\n        map = new HashMap<>();\\n        traverse(root);\\n        List<TreeNode> ans = new LinkedList<>();\\n        for (TreeNode node : set) {\\n            ans.add(node);\\n        }\\n        return ans;\\n    }\\n    \\n    public String traverse(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        String left = traverse(root.left);\\n        String right = traverse(root.right);\\n        String cur = left +\" \"+ right +\" \"+ root.val;\\n        if (map.containsKey(cur)) {\\n            set.add(map.get(cur));\\n        } else {\\n            map.put(cur, root);\\n        }\\n        \\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Set<TreeNode> set;\\n    Map<String, TreeNode> map;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        set = new HashSet<>();\\n        map = new HashMap<>();\\n        traverse(root);\\n        List<TreeNode> ans = new LinkedList<>();\\n        for (TreeNode node : set) {\\n            ans.add(node);\\n        }\\n        return ans;\\n    }\\n    \\n    public String traverse(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        String left = traverse(root.left);\\n        String right = traverse(root.right);\\n        String cur = left +\" \"+ right +\" \"+ root.val;\\n        if (map.containsKey(cur)) {\\n            set.add(map.get(cur));\\n        } else {\\n            map.put(cur, root);\\n        }\\n        \\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848525,
                "title": "golang-o-n-solution-with-map",
                "content": "```\\nfunc PrettyPrint(data interface{}) {\\n\\tvar p []byte\\n\\t//    var err := error\\n\\tp, err := json.MarshalIndent(data, \"\", \"\\\\t\")\\n\\tif err != nil {\\n\\t\\tfmt.Println(err)\\n\\t\\treturn\\n\\t}\\n\\tfmt.Printf(\"%s \\\\n\", p)\\n}\\n\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n    var res []*TreeNode\\n    \\n    record := make(map[string][]*TreeNode)\\n    \\n    debugInfo := serialize(root, record)\\n    \\n    for _, value := range record {\\n        if len(value) > 1 {\\n            res = append(res, value[0])\\n        }\\n    }\\n    \\n    PrettyPrint(debugInfo)\\n    \\n    return res\\n}\\n\\nfunc serialize(root *TreeNode, record map[string][]*TreeNode) string {\\n    if root == nil {\\n        return \"\"\\n    }\\n    \\n    left := serialize(root.Left, record)\\n    right := serialize(root.Right, record)\\n    \\n    key := \"[\" + left + \",\" + fmt.Sprintf(\"%v\", root.Val) + \",\" + right + \"]\"\\n    \\n    record[key] = append(record[key], root)\\n\\n    return key\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc PrettyPrint(data interface{}) {\\n\\tvar p []byte\\n\\t//    var err := error\\n\\tp, err := json.MarshalIndent(data, \"\", \"\\\\t\")\\n\\tif err != nil {\\n\\t\\tfmt.Println(err)\\n\\t\\treturn\\n\\t}\\n\\tfmt.Printf(\"%s \\\\n\", p)\\n}\\n\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n    var res []*TreeNode\\n    \\n    record := make(map[string][]*TreeNode)\\n    \\n    debugInfo := serialize(root, record)\\n    \\n    for _, value := range record {\\n        if len(value) > 1 {\\n            res = append(res, value[0])\\n        }\\n    }\\n    \\n    PrettyPrint(debugInfo)\\n    \\n    return res\\n}\\n\\nfunc serialize(root *TreeNode, record map[string][]*TreeNode) string {\\n    if root == nil {\\n        return \"\"\\n    }\\n    \\n    left := serialize(root.Left, record)\\n    right := serialize(root.Right, record)\\n    \\n    key := \"[\" + left + \",\" + fmt.Sprintf(\"%v\", root.Val) + \",\" + right + \"]\"\\n    \\n    record[key] = append(record[key], root)\\n\\n    return key\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799802,
                "title": "python-simple",
                "content": "```\\ndef findDuplicateSubtrees(self, root: Optional[TreeNode]) -> list[Optional[TreeNode]]:\\n\\n    result = []\\n    paths = defaultdict(int)\\n\\t\\n    def get_path(node):\\n        if not node:\\n            return \"None\"\\n        else:\\n            path = str(node.val)\\n        path += \\'.\\' + get_path(node.left)\\n        path += \\'.\\' + get_path(node.right)\\n        paths[path] += 1\\n        if paths[path] == 2:\\n            result.append(node)\\n        return path\\n\\t\\t\\n    get_path(root)\\n    return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findDuplicateSubtrees(self, root: Optional[TreeNode]) -> list[Optional[TreeNode]]:\\n\\n    result = []\\n    paths = defaultdict(int)\\n\\t\\n    def get_path(node):\\n        if not node:\\n            return \"None\"\\n        else:\\n            path = str(node.val)\\n        path += \\'.\\' + get_path(node.left)\\n        path += \\'.\\' + get_path(node.right)\\n        paths[path] += 1\\n        if paths[path] == 2:\\n            result.append(node)\\n        return path\\n\\t\\t\\n    get_path(root)\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577669,
                "title": "post-order-traversal-unordered-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    vector<TreeNode*> result;\\n    string calc(TreeNode *root) {\\n        if (root == nullptr) return to_string(\\'#\\');\\n        string node = \"\";\\n        string left = calc(root->left);\\n        string right = calc(root->right);\\n        node += left + \":\" + to_string(root->val) + \":\" + right + \\':\\';\\n        if (mp[node] == 1) {\\n            result.push_back(root);\\n        }\\n        ++mp[node];\\n        return node;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        calc(root);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    vector<TreeNode*> result;\\n    string calc(TreeNode *root) {\\n        if (root == nullptr) return to_string(\\'#\\');\\n        string node = \"\";\\n        string left = calc(root->left);\\n        string right = calc(root->right);\\n        node += left + \":\" + to_string(root->val) + \":\" + right + \\':\\';\\n        if (mp[node] == 1) {\\n            result.push_back(root);\\n        }\\n        ++mp[node];\\n        return node;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        calc(root);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532597,
                "title": "c-great-question-conceptual",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<TreeNode*> res;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,int> m;\\n        solve(root,m);\\n        return res;\\n    }\\n    \\n    string solve(TreeNode* root,unordered_map<string,int>& m){\\n        if(!root) return \"x\";\\n        string l=solve(root->left,m);\\n        string r=solve(root->right,m);\\n        string temp=to_string(root->val)+\" \"+l+\" \"+r+\" \";\\n        m[temp]++;\\n        if(m[temp]==2)\\n            res.push_back(root);\\n        return temp;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<TreeNode*> res;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,int> m;\\n        solve(root,m);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1487212,
                "title": "java-o-n-time-beats-98-52-clean-code-with-explanation-merkle-tree",
                "content": "To find if the duplicate exists or not in the subtree we need a good way of converting a sub-tree to some `canonical format`.\\n\\nThis canonical representation (i.e. which allows it to be identified in a unique way) can be a string representation of the \\npost order traversal of sub-tree. For example, our unique representation of the tree - `left-subtree` - `node.val` - `right-subtree`.\\n\\n**The catch**: when working with string in java it\\'s quite easy to make O(N^2) from O(N) by [inefficiently](https://stackoverflow.com/questions/58309852/why-is-the-complexity-of-simple-string-concatenation-on2) concatenating strings.\\n\\nTime: O(N)\\nSpace: O(N)\\n\\nRuntime: 10 ms, faster than 96.72% of Java\\n\\n```java\\nclass Solution {\\n    private final String NULL = new String(new byte[]{0x0});\\n    private final String DELIMITER = new String(new byte[]{0x1});\\n    private Map<String, Integer> map;\\n    private List<TreeNode> ans;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        this.ans = new ArrayList<>();\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    private String dfs(final TreeNode node) {\\n        if (node == null) {\\n            return NULL;\\n        }\\n        \\n        String left = dfs(node.left),\\n               right = dfs(node.right);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(left)\\n          .append(right)  \\n          .append(node.val)\\n          .append(DELIMITER);\\n        \\n        String key = sb.toString();\\n        \\n        map.merge(key, 1, Integer::sum);\\n        if (map.get(key) == 2) {\\n            ans.add(node);\\n        }\\n        \\n        return key;\\n    }\\n   \\n}\\n```\\n\\n\\n**Merkle Tree Approach**\\n\\nCompute a hash function on top of key to reduce space as serializing a full binary tree path might be expensive.\\n\\n\\nAdopted from [here](https://leetcode.com/problems/find-duplicate-subtrees/discuss/1203500/Java-Merkle-Tree-using-String-HashCode)\\n\\nRuntime: 5 ms, faster than 98.52% of Java \\n\\n```\\nclass Solution {\\n    private final String NULL = new String(new byte[]{0x0});\\n    private Map<String, Integer> map;\\n    private List<TreeNode> ans;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        this.ans = new ArrayList<>();\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    private String dfs(final TreeNode node) {\\n        if (node == null) {\\n            return NULL;\\n        }\\n        \\n        String left = dfs(node.left),\\n               right = dfs(node.right);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(left)\\n          .append(right)  \\n          .append(node.val);\\n        \\n        String key = getHash(sb.toString());\\n        \\n        map.merge(key, 1, Integer::sum);\\n        if (map.get(key) == 2) {\\n            ans.add(node);\\n        }\\n        \\n        return key;\\n    }\\n    \\n    private String getHash(String value) {\\n        return String.valueOf(value.hashCode());\\n    }\\n}\\n```\\n\\nPlease don\\'t forget to **Up Vote** if you like the solution \\u30C4\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private final String NULL = new String(new byte[]{0x0});\\n    private final String DELIMITER = new String(new byte[]{0x1});\\n    private Map<String, Integer> map;\\n    private List<TreeNode> ans;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        this.ans = new ArrayList<>();\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    private String dfs(final TreeNode node) {\\n        if (node == null) {\\n            return NULL;\\n        }\\n        \\n        String left = dfs(node.left),\\n               right = dfs(node.right);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(left)\\n          .append(right)  \\n          .append(node.val)\\n          .append(DELIMITER);\\n        \\n        String key = sb.toString();\\n        \\n        map.merge(key, 1, Integer::sum);\\n        if (map.get(key) == 2) {\\n            ans.add(node);\\n        }\\n        \\n        return key;\\n    }\\n   \\n}\\n```\n```\\nclass Solution {\\n    private final String NULL = new String(new byte[]{0x0});\\n    private Map<String, Integer> map;\\n    private List<TreeNode> ans;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        this.ans = new ArrayList<>();\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    private String dfs(final TreeNode node) {\\n        if (node == null) {\\n            return NULL;\\n        }\\n        \\n        String left = dfs(node.left),\\n               right = dfs(node.right);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(left)\\n          .append(right)  \\n          .append(node.val);\\n        \\n        String key = getHash(sb.toString());\\n        \\n        map.merge(key, 1, Integer::sum);\\n        if (map.get(key) == 2) {\\n            ans.add(node);\\n        }\\n        \\n        return key;\\n    }\\n    \\n    private String getHash(String value) {\\n        return String.valueOf(value.hashCode());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424214,
                "title": "python3-dfs-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    \\n    def traverse(self, node: TreeNode, dups: Dict, subs: Set) -> Tuple:\\n        \\n        # If node not null\\n        if node:\\n            \\n            # Get left subtree\\n            l_subtree = self.traverse(node.left, dups, subs)\\n            \\n            # Get right subtree\\n            r_subtree = self.traverse(node.right, dups, subs)\\n            \\n            # Make current subtree\\n            subtree = (node.val, l_subtree, r_subtree)\\n            \\n            # Increament the duplicated variable, this stores\\n            # number of occurrence of a subtree\\n            dups[subtree] = dups[subtree] + 1\\n            \\n            # If subtree occurs twice store it to a list.\\n            # Here comparing number of occurrence excatly to 2 has some\\n            # benifits. As each tree node is different object, using\\n            # a set also doesn\\'t work.\\n            if dups[subtree] == 2:\\n                subs.add(node)\\n            \\n            # Return the newly formed subtree\\n            return subtree\\n        \\n        # Return None\\n        return None\\n    \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        dups = defaultdict(lambda: 0)\\n        res = set()\\n        self.traverse(root, dups, res)\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    \\n    def traverse(self, node: TreeNode, dups: Dict, subs: Set) -> Tuple:\\n        \\n        # If node not null\\n        if node:\\n            \\n            # Get left subtree\\n            l_subtree = self.traverse(node.left, dups, subs)\\n            \\n            # Get right subtree\\n            r_subtree = self.traverse(node.right, dups, subs)\\n            \\n            # Make current subtree\\n            subtree = (node.val, l_subtree, r_subtree)\\n            \\n            # Increament the duplicated variable, this stores\\n            # number of occurrence of a subtree\\n            dups[subtree] = dups[subtree] + 1\\n            \\n            # If subtree occurs twice store it to a list.\\n            # Here comparing number of occurrence excatly to 2 has some\\n            # benifits. As each tree node is different object, using\\n            # a set also doesn\\'t work.\\n            if dups[subtree] == 2:\\n                subs.add(node)\\n            \\n            # Return the newly formed subtree\\n            return subtree\\n        \\n        # Return None\\n        return None\\n    \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        dups = defaultdict(lambda: 0)\\n        res = set()\\n        self.traverse(root, dups, res)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341630,
                "title": "java-solution-simple-logic-using-map",
                "content": "Approach- make a string of subtree element ,chekh if that string is already present in map,if not return a default value 0 ,it tells that the given subtree is not present in map.And further we insert that subtree in map with an increased value by 1.If we get a value equal to 1 , then the subtree has duplicate already and we add that in the list.\\n\\n\\n```\\nclass Solution {\\n     List<TreeNode> list=new ArrayList<>();\\n        Map<String,Integer> map=new HashMap<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        helper(root);\\n        return list;\\n    }\\n    public String helper(TreeNode root){\\n        if(root==null){\\n            return \"#\";\\n        }\\n        String leftsub=helper(root.left);\\n         String rightsub=helper(root.right);\\n        String subtree=root.val+\" \"+left+right;       //full subtree \\n    int frequency=map.getOrDefault(subtree,0);     //checking existence of subree in map \\n        if(frequency==1){        //means the subtree has a duplicate already\\n         list.add(root);\\n        }\\n        map.put(subtree,frequency+1);    //inserting the  subtree into the map\\n    return subtree;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     List<TreeNode> list=new ArrayList<>();\\n        Map<String,Integer> map=new HashMap<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        helper(root);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 980457,
                "title": "clean-and-simple-c",
                "content": "```\\nunordered_map<string,int> hashmap;\\nstring dfs(TreeNode *root,vector<TreeNode*> &v)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn \"#\";\\n\\tstring left=dfs(root->left,v);\\n\\tstring right=dfs(root->right,v);\\n\\tstring str;\\n\\tstr=to_string(root->val)+\",\"+left+ \",\"+right;\\n\\thashmap[str]++;\\n\\tif(hashmap[str]==2)\\n\\t\\tv.push_back(root);\\n\\treturn str;\\n}\\nvector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n\\tvector<TreeNode*> v;\\n\\tdfs(root,v);\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<string,int> hashmap;\\nstring dfs(TreeNode *root,vector<TreeNode*> &v)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn \"#\";\\n\\tstring left=dfs(root->left,v);\\n\\tstring right=dfs(root->right,v);\\n\\tstring str;\\n\\tstr=to_string(root->val)+\",\"+left+ \",\"+right;\\n\\thashmap[str]++;\\n\\tif(hashmap[str]==2)\\n\\t\\tv.push_back(root);\\n\\treturn str;\\n}\\nvector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n\\tvector<TreeNode*> v;\\n\\tdfs(root,v);\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 321362,
                "title": "8-lines-python-solution-beats-85",
                "content": "\\'\\'\\'\\nclass Solution:\\n\\n    def findDuplicateSubtrees(self, root):\\n        dic=collections.defaultdict(list)\\n        def inorder(root):\\n            if not root:return \\'#\\'\\n            strings=str(root.val)+inorder(root.left)+inorder(root.right)\\n            dic[strings].append(root)\\n            return strings\\n        inorder(root)\\n        return [nodes[0] for nodes in dic.values() if len(nodes)>1]\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n\\n    def findDuplicateSubtrees(self, root):\\n        dic=collections.defaultdict(list)\\n        def inorder(root):\\n            if not root:return \\'#\\'\\n            strings=str(root.val)+inorder(root.left)+inorder(root.right)\\n            dic[strings].append(root)\\n            return strings\\n        inorder(root)\\n        return [nodes[0] for nodes in dic.values() if len(nodes)>1]\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 193065,
                "title": "javascript-merkle-tree-based-in-subtree-of-another-tree",
                "content": "Based in https://leetcode.com/problems/subtree-of-another-tree\\n\\nSimilarly to Subtree of Another Tree (and [@awice \\'s answer](https://leetcode.com/problems/subtree-of-another-tree/discuss/102741/Python-Straightforward-with-Explanation-(O(ST)-and-O(S+T)-approaches))), we generate the hash of every subtree (known as Merkle tree). We store this hash and and of the nodes that led to it. At the end we return those hashes that have been set more than once.\\n\\n```\\nconst crypto = require(\\'crypto\\');\\n\\nfunction hash(str) {\\n    return crypto.createHash(\\'sha256\\').update(str).digest(\\'hex\\');\\n}\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode[]}\\n */\\nvar findDuplicateSubtrees = function(root) {\\n    const merkleNodes = new Map();\\n    merkle(root, merkleNodes);\\n    const duplicates = [];\\n    for (const [count, node] of merkleNodes.values()) {\\n        if (count > 1) {\\n            duplicates.push(node);\\n        }\\n    }\\n    return duplicates;\\n};\\n\\nfunction merkle(node, merkleNodes) {\\n    if (!node) {\\n        return \\'\\';\\n    }\\n    \\n    const left = merkle(node.left, merkleNodes);\\n    const right = merkle(node.right, merkleNodes);\\n    const treeHash = hash(`${left}${node.val}${right}`);\\n    \\n    const previousMerkleNode = merkleNodes.get(treeHash) || [0, node];\\n    previousMerkleNode[0] += 1;\\n    merkleNodes.set(treeHash, previousMerkleNode);\\n    \\n    return treeHash;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst crypto = require(\\'crypto\\');\\n\\nfunction hash(str) {\\n    return crypto.createHash(\\'sha256\\').update(str).digest(\\'hex\\');\\n}\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode[]}\\n */\\nvar findDuplicateSubtrees = function(root) {\\n    const merkleNodes = new Map();\\n    merkle(root, merkleNodes);\\n    const duplicates = [];\\n    for (const [count, node] of merkleNodes.values()) {\\n        if (count > 1) {\\n            duplicates.push(node);\\n        }\\n    }\\n    return duplicates;\\n};\\n\\nfunction merkle(node, merkleNodes) {\\n    if (!node) {\\n        return \\'\\';\\n    }\\n    \\n    const left = merkle(node.left, merkleNodes);\\n    const right = merkle(node.right, merkleNodes);\\n    const treeHash = hash(`${left}${node.val}${right}`);\\n    \\n    const previousMerkleNode = merkleNodes.get(treeHash) || [0, node];\\n    previousMerkleNode[0] += 1;\\n    merkleNodes.set(treeHash, previousMerkleNode);\\n    \\n    return treeHash;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3241581,
                "title": "java-post-order-traversal-10-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<TreeNode> ans = new ArrayList<>();\\n  Map<String, Integer> map = new HashMap<>();\\n\\n  private String postOrder(TreeNode node) {\\n    if (node == null) return \" \";\\n\\n    var s = postOrder(node.left) + \" \" + postOrder(node.right) + \" \" + node.val;\\n    map.put(s, map.getOrDefault(s, 0) + 1);\\n    if (map.get(s) == 2) ans.add(node);\\n    \\n    return s;\\n  }\\n\\n  public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    postOrder(root);\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  List<TreeNode> ans = new ArrayList<>();\\n  Map<String, Integer> map = new HashMap<>();\\n\\n  private String postOrder(TreeNode node) {\\n    if (node == null) return \" \";\\n\\n    var s = postOrder(node.left) + \" \" + postOrder(node.right) + \" \" + node.val;\\n    map.put(s, map.getOrDefault(s, 0) + 1);\\n    if (map.get(s) == 2) ans.add(node);\\n    \\n    return s;\\n  }\\n\\n  public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    postOrder(root);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240235,
                "title": "python3-42-ms-faster-than-97-10-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/e71a4150-2520-4a25-9696-b9220352f313_1677593807.5801833.png)\\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        map = {}\\n        res = set()\\n        def check(node):\\n            if not node:\\n                return \\'#\\'\\n            s = \\'\\'\\n            if not node.left and not node.right:\\n                s += str(node.val)\\n                map[s] = map.get(s,0)+1\\n                if map[s]==2:\\n                    res.add(node)\\n                return s\\n            s  = s + str(node.val)\\n            s = s + \",\" + check(node.left)\\n            s = s+ \",\" + check(node.right)\\n            map[s]  = map.get(s,0)+1\\n            if map[s]==2:\\n                res.add(node)\\n            return s\\n        \\n        check(root)\\n        return res\\n```\\nThe given code finds all the duplicate subtrees in a given binary tree. Here\\'s a step-by-step explanation of the code:\\n1. Define a class named Solution.\\n1. Define a function findDuplicateSubtrees that takes the root of the binary tree as input and returns a list of nodes that are duplicate.\\n1. Create a dictionary named \\'map\\' that will store the subtree string and its frequency.\\n1. Create a set named \\'res\\' that will store the duplicate subtrees.\\n1. Define a nested function named \\'check\\' that takes a node as input and returns a string.\\n1. If the node is None, return a string \\'#\\'. This represents a null node in the subtree string.\\n1. Create an empty string \\'s\\'.\\n1. If the node has no children (i.e., it is a leaf node), append its value to \\'s\\' as a string.\\n1. Add the subtree string \\'s\\' to the dictionary \\'map\\' with its frequency increased by 1.\\n1. If the frequency of the subtree \\'s\\' in the dictionary is 2, add the current node to the set \\'res\\'.\\n1. Return the subtree string \\'s\\'.\\n1. If the node has children, append the value of the node to \\'s\\' as a string.\\n1. Recursively call the \\'check\\' function on the left and right subtrees of the node.\\n1. Append the result of calling the \\'check\\' function on the left and right subtrees to \\'s\\' with \\',\\' as a separator.\\n1. Add the subtree string \\'s\\' to the dictionary \\'map\\' with its frequency increased by 1.\\n1. If the frequency of the subtree \\'s\\' in the dictionary is 2, add the current node to the set \\'res\\'.\\n1. Return the subtree string \\'s\\'.\\n1. Call the \\'check\\' function with the root of the binary tree as input.\\n1. Return the set \\'res\\' containing the duplicate subtrees.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        map = {}\\n        res = set()\\n        def check(node):\\n            if not node:\\n                return \\'#\\'\\n            s = \\'\\'\\n            if not node.left and not node.right:\\n                s += str(node.val)\\n                map[s] = map.get(s,0)+1\\n                if map[s]==2:\\n                    res.add(node)\\n                return s\\n            s  = s + str(node.val)\\n            s = s + \",\" + check(node.left)\\n            s = s+ \",\" + check(node.right)\\n            map[s]  = map.get(s,0)+1\\n            if map[s]==2:\\n                res.add(node)\\n            return s\\n        \\n        check(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239191,
                "title": "c-dfs-hashmap-faster-easy-to-understand",
                "content": "* ***Using DFS && Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, int> mp;\\n    \\n    // declare a res array\\n    \\n    vector<TreeNode*> res;\\n    \\n    // function for finding duplicate subtree\\n    \\n    string dfs(TreeNode* root)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return \"\";\\n        }\\n        \\n        // find the subtree for the curr node and store in str\\n        \\n        string str = \"\";\\n        \\n        str += to_string(root -> val);\\n        \\n        // provide delimeter\\n        \\n        str += \"#\";\\n        \\n        // call for left subtree\\n        \\n        string left = dfs(root -> left);\\n        \\n        str += left;\\n        \\n        // provide delimeter\\n        \\n        str += \"#\";\\n        \\n        // call for right subtree\\n        \\n        string right = dfs(root -> right);\\n        \\n        str += right;\\n        \\n        // increment the count of str\\n        \\n        mp[str]++;\\n        \\n        // if we found duplicate subtree then include the root into result\\n        \\n        if(mp[str] == 2)\\n        {\\n            res.push_back(root);\\n        }\\n        \\n        // return str\\n        \\n        return str;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        \\n        dfs(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, int> mp;\\n    \\n    // declare a res array\\n    \\n    vector<TreeNode*> res;\\n    \\n    // function for finding duplicate subtree\\n    \\n    string dfs(TreeNode* root)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return \"\";\\n        }\\n        \\n        // find the subtree for the curr node and store in str\\n        \\n        string str = \"\";\\n        \\n        str += to_string(root -> val);\\n        \\n        // provide delimeter\\n        \\n        str += \"#\";\\n        \\n        // call for left subtree\\n        \\n        string left = dfs(root -> left);\\n        \\n        str += left;\\n        \\n        // provide delimeter\\n        \\n        str += \"#\";\\n        \\n        // call for right subtree\\n        \\n        string right = dfs(root -> right);\\n        \\n        str += right;\\n        \\n        // increment the count of str\\n        \\n        mp[str]++;\\n        \\n        // if we found duplicate subtree then include the root into result\\n        \\n        if(mp[str] == 2)\\n        {\\n            res.push_back(root);\\n        }\\n        \\n        // return str\\n        \\n        return str;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        \\n        dfs(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238720,
                "title": "python-concise-dfs-solution-with-detailed-explaination-fastest-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        # create a dictionary to store subtrees\\n        subTrees = defaultdict(list)\\n        \\n        # define a DFS function to traverse the binary tree and find duplicate subtrees\\n        def dfs(node):\\n            # if the node is empty, return \\'null\\'\\n            if not node:\\n                return \\'null\\'\\n            \\n            # create a string representation of the current node and its subtrees\\n            s = \\',\\'.join([str(node.val), dfs(node.left), dfs(node.right)])\\n            \\n            # if the string representation is already in subTrees, then it\\'s a duplicate subtree\\n            if len(subTrees[s]) == 1:\\n                # add the root node of one of the duplicate subtrees to the result list\\n                res.append(node)\\n                \\n            # add the current node to the list of nodes with the same string representation\\n            subTrees[s].append(node)\\n            \\n            # return the string representation of the current node and its subtrees\\n            return s\\n        \\n        # initialize an empty result list\\n        res = []\\n        \\n        # traverse the binary tree and find duplicate subtrees\\n        dfs(root)\\n        \\n        # return the root nodes of all the duplicate subtrees\\n        return res\\n```\\n\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/find-duplicate-subtrees-in-binary-tree.html\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        # create a dictionary to store subtrees\\n        subTrees = defaultdict(list)\\n        \\n        # define a DFS function to traverse the binary tree and find duplicate subtrees\\n        def dfs(node):\\n            # if the node is empty, return \\'null\\'\\n            if not node:\\n                return \\'null\\'\\n            \\n            # create a string representation of the current node and its subtrees\\n            s = \\',\\'.join([str(node.val), dfs(node.left), dfs(node.right)])\\n            \\n            # if the string representation is already in subTrees, then it\\'s a duplicate subtree\\n            if len(subTrees[s]) == 1:\\n                # add the root node of one of the duplicate subtrees to the result list\\n                res.append(node)\\n                \\n            # add the current node to the list of nodes with the same string representation\\n            subTrees[s].append(node)\\n            \\n            # return the string representation of the current node and its subtrees\\n            return s\\n        \\n        # initialize an empty result list\\n        res = []\\n        \\n        # traverse the binary tree and find duplicate subtrees\\n        dfs(root)\\n        \\n        # return the root nodes of all the duplicate subtrees\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238607,
                "title": "python3-hashmap-store-duplicates-with-same-height",
                "content": "# Intuition\\nThe idea is to for duplicates subTrees to exist there will be nodes in tress with duplicates values. For two subtrees to be duplicate at two nodes will have -\\n1. same heights\\n2.  same Tree structure\\n\\nWe need to take care of edge cases where two nodes might be at same heights but they might have different structure. We need to track all nodes as well.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # check is two trees are having same structure\\n    def isSame(self,root1,root2):\\n        if root1 is None and root2 is None:\\n            return True\\n        if root1 is None or root2 is None:\\n            return False\\n        return self.isSame(root1.left,root2.left) and self.isSame(root1.right,root2.right) and root1.val == root2.val\\n\\n\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        #stores every node with its values & its height\\n        self.nodeMap = defaultdict(list)\\n        # stores unique( taken set) nodes which are duplicates in Tree\\n        ans = defaultdict(set)\\n\\n        def traverseAndMap(root):\\n            if root is None:\\n                return 0\\n            l = traverseAndMap(root.left)\\n            r = traverseAndMap(root.right)\\n            height = max(l,r)\\n            duplicate = False\\n            # if this value at this height is seen\\n            if (root.val,height) in self.nodeMap:\\n                for node in self.nodeMap[(root.val,height)]:\\n                    if self.isSame(root,node): # if duplicates with other node already found\\n                        ans[(root.val,height)].add(node)\\n                        duplicate = True\\n                        break\\n            if not duplicate: # node with this structure is not seen\\n                self.nodeMap[(root.val,height)].append(root) \\n            return height + 1\\n\\n        traverseAndMap(root)\\n        result = []\\n        for k in ans:\\n            for node in ans[k]:\\n                result.append(node)\\n        return result\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # check is two trees are having same structure\\n    def isSame(self,root1,root2):\\n        if root1 is None and root2 is None:\\n            return True\\n        if root1 is None or root2 is None:\\n            return False\\n        return self.isSame(root1.left,root2.left) and self.isSame(root1.right,root2.right) and root1.val == root2.val\\n\\n\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        #stores every node with its values & its height\\n        self.nodeMap = defaultdict(list)\\n        # stores unique( taken set) nodes which are duplicates in Tree\\n        ans = defaultdict(set)\\n\\n        def traverseAndMap(root):\\n            if root is None:\\n                return 0\\n            l = traverseAndMap(root.left)\\n            r = traverseAndMap(root.right)\\n            height = max(l,r)\\n            duplicate = False\\n            # if this value at this height is seen\\n            if (root.val,height) in self.nodeMap:\\n                for node in self.nodeMap[(root.val,height)]:\\n                    if self.isSame(root,node): # if duplicates with other node already found\\n                        ans[(root.val,height)].add(node)\\n                        duplicate = True\\n                        break\\n            if not duplicate: # node with this structure is not seen\\n                self.nodeMap[(root.val,height)].append(root) \\n            return height + 1\\n\\n        traverseAndMap(root)\\n        result = []\\n        for k in ans:\\n            for node in ans[k]:\\n                result.append(node)\\n        return result\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238542,
                "title": "find-duplicate-subtree-easy-to-understand-beginner-s-friendly",
                "content": "# Intuition\\nBy reading this qston first things which came to my mind was mapping.So, here is its implementation :\\n\\n# Approach\\n- make a helper function ans pass the root and an answer vector.\\n- first check the base case if root is null or not if yes then return a \"#\",\\n- declare a string and inside that string keep on adding the the values of nodes in a postorder traversal method\\n- and keep on incresing the frequency of s in map\\n- if frewuency is 2 then push it inside the answer vector\\n- return that string s.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<string,int> mp;\\n    string solve(TreeNode* root,vector<TreeNode*>& res)\\n    {\\n        if(!root)\\n            return \"#\";\\n        string s=solve(root->left,res)+ \\',\\' +solve(root->right,res)+ \\',\\' +to_string(root->val);\\n        mp[s]++;\\n        if(mp[s]==2)\\n            res.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```\\nHope u guys like it and upvote\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB //Happy Coding",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<string,int> mp;\\n    string solve(TreeNode* root,vector<TreeNode*>& res)\\n    {\\n        if(!root)\\n            return \"#\";\\n        string s=solve(root->left,res)+ \\',\\' +solve(root->right,res)+ \\',\\' +to_string(root->val);\\n        mp[s]++;\\n        if(mp[s]==2)\\n            res.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238509,
                "title": "c-simplest-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #include<bits/stdc++.h>\\nclass Solution {\\n    public:\\n    string solution(TreeNode*root, vector<TreeNode*>&ans,unordered_map<string,int>&m){\\n        if(root == NULL) return \"\";\\n        string s = solution(root->left,ans,m) + \",\" + solution(root->right,ans,m) + \",\" + to_string(root->val);\\n        m[s]++;\\n        if(m[s] == 2) \\n        ans.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*>ans;\\n        unordered_map<string,int>m;\\n        solution(root,ans,m);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #include<bits/stdc++.h>\\nclass Solution {\\n    public:\\n    string solution(TreeNode*root, vector<TreeNode*>&ans,unordered_map<string,int>&m){\\n        if(root == NULL) return \"\";\\n        string s = solution(root->left,ans,m) + \",\" + solution(root->right,ans,m) + \",\" + to_string(root->val);\\n        m[s]++;\\n        if(m[s] == 2) \\n        ans.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*>ans;\\n        unordered_map<string,int>m;\\n        solution(root,ans,m);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3238486,
                "title": "simple-solution-using-postorder-traversal",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #include<bits/stdc++.h>\\nclass Solution {\\n    public:\\n    string solution(TreeNode*root, vector<TreeNode*>&ans,unordered_map<string,int>&m){\\n        if(root == NULL) return \"\";\\n        string s = solution(root->left,ans,m) + \",\" + solution(root->right,ans,m) + \",\" + to_string(root->val);\\n        m[s]++;\\n        if(m[s] == 2) \\n        ans.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*>ans;\\n        unordered_map<string,int>m;\\n        solution(root,ans,m);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #include<bits/stdc++.h>\\nclass Solution {\\n    public:\\n    string solution(TreeNode*root, vector<TreeNode*>&ans,unordered_map<string,int>&m){\\n        if(root == NULL) return \"\";\\n        string s = solution(root->left,ans,m) + \",\" + solution(root->right,ans,m) + \",\" + to_string(root->val);\\n        m[s]++;\\n        if(m[s] == 2) \\n        ans.push_back(root);\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*>ans;\\n        unordered_map<string,int>m;\\n        solution(root,ans,m);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3238423,
                "title": "php-easy-understanding-beats-100",
                "content": "# Explain\\n\\nSave the structure as string while travel the nodes.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return TreeNode[]\\n     */\\n    function findDuplicateSubtrees($root) {\\n        $this->subTrees = [];\\n        $this->result = [];\\n        $this->runNode($root);\\n\\n        return $this->result;\\n    }\\n\\n    function runNode($node) {\\n        if (!$node) {\\n            return \\'null\\';\\n        }\\n\\n        $leftString = $this->runNode($node->left);\\n        $rightString = $this->runNode($node->right);\\n        $string = \\'v-\\' . $node->val . \\'l-\\' . $leftString . \\'r-\\' . $rightString;\\n        if (empty($this->subTrees[$string])) {\\n            $this->subTrees[$string] = [\\n                \\'count\\' => 1,\\n                \\'tree\\' => $node,\\n            ];\\n        } else {\\n            $this->subTrees[$string][\\'count\\']++;\\n            // put into answer only at second times\\n            if ($this->subTrees[$string][\\'count\\'] === 2) {\\n                $this->result[] = $node;\\n            }\\n        }\\n\\n        return $string;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return TreeNode[]\\n     */\\n    function findDuplicateSubtrees($root) {\\n        $this->subTrees = [];\\n        $this->result = [];\\n        $this->runNode($root);\\n\\n        return $this->result;\\n    }\\n\\n    function runNode($node) {\\n        if (!$node) {\\n            return \\'null\\';\\n        }\\n\\n        $leftString = $this->runNode($node->left);\\n        $rightString = $this->runNode($node->right);\\n        $string = \\'v-\\' . $node->val . \\'l-\\' . $leftString . \\'r-\\' . $rightString;\\n        if (empty($this->subTrees[$string])) {\\n            $this->subTrees[$string] = [\\n                \\'count\\' => 1,\\n                \\'tree\\' => $node,\\n            ];\\n        } else {\\n            $this->subTrees[$string][\\'count\\']++;\\n            // put into answer only at second times\\n            if ($this->subTrees[$string][\\'count\\'] === 2) {\\n                $this->result[] = $node;\\n            }\\n        }\\n\\n        return $string;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238350,
                "title": "c-solution-90-runtime-and-memory",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, pair<int, int>> mp;\\n    int id;\\n    vector<TreeNode*> res;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        id = 1;\\n        postOrder(root);\\n        return res;\\n    }\\n\\n    string postOrder(TreeNode* root)\\n    {\\n        if(root == NULL)\\n        return \"0\";\\n        string left = postOrder(root->left);\\n        string right = postOrder(root->right);\\n        string cur = left + \",\"+ to_string(root->val)+\",\"+right;\\n        if(mp.find(cur) == mp.end())\\n        {\\n            mp[cur] = {id++, 1};\\n        }\\n        else\\n        {\\n            ++mp[cur].second;\\n            if(mp[cur].second == 2)\\n            res.push_back(root);\\n        }\\n        return to_string(mp[cur].first);\\n    }\\n};\\n```\\n\\nPlease feel free to upvote the solution! Thanks!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, pair<int, int>> mp;\\n    int id;\\n    vector<TreeNode*> res;\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        id = 1;\\n        postOrder(root);\\n        return res;\\n    }\\n\\n    string postOrder(TreeNode* root)\\n    {\\n        if(root == NULL)\\n        return \"0\";\\n        string left = postOrder(root->left);\\n        string right = postOrder(root->right);\\n        string cur = left + \",\"+ to_string(root->val)+\",\"+right;\\n        if(mp.find(cur) == mp.end())\\n        {\\n            mp[cur] = {id++, 1};\\n        }\\n        else\\n        {\\n            ++mp[cur].second;\\n            if(mp[cur].second == 2)\\n            res.push_back(root);\\n        }\\n        return to_string(mp[cur].first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904628,
                "title": "the-simplest-c-solution-with-stack-and-postorder-traversal",
                "content": "# Approach\\nPostorder traversal.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        var visited = new Dictionary<TreeNode, string>();\\n        var duplicates = new Dictionary<string, List<TreeNode>>();\\n        stack.Push(root);\\n        \\n        while(stack.Count != 0){\\n            var top = stack.Peek();\\n            if(top.left != null && !visited.ContainsKey(top.left)){\\n                stack.Push(top.left);\\n                continue;\\n            }\\n            \\n            if(top.right != null && !visited.ContainsKey(top.right)){\\n                stack.Push(top.right);\\n                continue;\\n            }\\n            \\n            var newStructure = $\"{top.val}\";\\n            if(top.left != null && visited.ContainsKey(top.left)){\\n                newStructure = $\"{visited[top.left]} < {newStructure}\";\\n            }\\n            \\n            if(top.right != null && visited.ContainsKey(top.right)){\\n                newStructure = $\"{newStructure} > {visited[top.right]}\";\\n            }\\n            \\n            visited.Add(stack.Pop(), newStructure);\\n            if(duplicates.ContainsKey(newStructure)){\\n                duplicates[newStructure].Add(top);\\n            } else {\\n                duplicates.Add(newStructure, new List<TreeNode>(){top});\\n            }\\n            \\n        }\\n        \\n        return duplicates.Values.Where(v => v.Count > 1).Select(v => v[0]).ToList();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        var visited = new Dictionary<TreeNode, string>();\\n        var duplicates = new Dictionary<string, List<TreeNode>>();\\n        stack.Push(root);\\n        \\n        while(stack.Count != 0){\\n            var top = stack.Peek();\\n            if(top.left != null && !visited.ContainsKey(top.left)){\\n                stack.Push(top.left);\\n                continue;\\n            }\\n            \\n            if(top.right != null && !visited.ContainsKey(top.right)){\\n                stack.Push(top.right);\\n                continue;\\n            }\\n            \\n            var newStructure = $\"{top.val}\";\\n            if(top.left != null && visited.ContainsKey(top.left)){\\n                newStructure = $\"{visited[top.left]} < {newStructure}\";\\n            }\\n            \\n            if(top.right != null && visited.ContainsKey(top.right)){\\n                newStructure = $\"{newStructure} > {visited[top.right]}\";\\n            }\\n            \\n            visited.Add(stack.Pop(), newStructure);\\n            if(duplicates.ContainsKey(newStructure)){\\n                duplicates[newStructure].Add(top);\\n            } else {\\n                duplicates.Add(newStructure, new List<TreeNode>(){top});\\n            }\\n            \\n        }\\n        \\n        return duplicates.Values.Where(v => v.Count > 1).Select(v => v[0]).ToList();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234480,
                "title": "python-o-n-using-hashmap-simply-and-easy",
                "content": "Similar to LC297  `preorder serialization binary tree`, recursively serialize every node,  using a hashmap to record every serialized string, if there is duplicate, record it.\\nTime Complexity O(n)\\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        res = []\\n        map = defaultdict(int)\\n        def dfs(node):\\n            if node is None:\\n                return \\'#\\'\\n            path = str(node.val) + \\'#\\' + dfs(node.left)+ \\'#\\' + dfs(node.right)\\n            map[path] += 1\\n            if map[path] == 2:\\n                res.append(node)\\n            return path\\n        dfs(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        res = []\\n        map = defaultdict(int)\\n        def dfs(node):\\n            if node is None:\\n                return \\'#\\'\\n            path = str(node.val) + \\'#\\' + dfs(node.left)+ \\'#\\' + dfs(node.right)\\n            map[path] += 1\\n            if map[path] == 2:\\n                res.append(node)\\n            return path\\n        dfs(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083678,
                "title": "c-clean-and-easy-solution",
                "content": "```\\nclass Solution\\n{\\nprivate:\\n    map<string, vector<TreeNode *>> mp;\\n    string postOrder(TreeNode *root)\\n    {\\n        if (!root)\\n        {\\n            return \"\";\\n        }\\n        string leftAns = postOrder(root->left);\\n        string rightAns = postOrder(root->right);\\n        string currentString = \"L\" + leftAns + to_string(root->val) + \"R\" + rightAns;\\n        mp[currentString].push_back(root);\\n        return currentString;\\n    }\\n\\npublic:\\n    vector<TreeNode *> findDuplicateSubtrees(TreeNode *root)\\n    {\\n        postOrder(root);\\n        vector<TreeNode *> ans;\\n        for (auto [key, value] : mp)\\n        {\\n            if (value.size() > 1)\\n            {\\n                ans.push_back(value[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    map<string, vector<TreeNode *>> mp;\\n    string postOrder(TreeNode *root)\\n    {\\n        if (!root)\\n        {\\n            return \"\";\\n        }\\n        string leftAns = postOrder(root->left);\\n        string rightAns = postOrder(root->right);\\n        string currentString = \"L\" + leftAns + to_string(root->val) + \"R\" + rightAns;\\n        mp[currentString].push_back(root);\\n        return currentString;\\n    }\\n\\npublic:\\n    vector<TreeNode *> findDuplicateSubtrees(TreeNode *root)\\n    {\\n        postOrder(root);\\n        vector<TreeNode *> ans;\\n        for (auto [key, value] : mp)\\n        {\\n            if (value.size() > 1)\\n            {\\n                ans.push_back(value[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061251,
                "title": "python-hashmap-dfs-simple-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def dfs(self, root, lookup, duplicates):\\n        if not root:\\n            return \\'.\\'\\n        subtree = str(root.val) + \\'-\\' + self.dfs(root.left, lookup, duplicates) + \\'-\\' + self.dfs(root.right, lookup, duplicates) \\n        if subtree in lookup:\\n            if lookup[subtree] == 1:\\n                duplicates.append(root)\\n            lookup[subtree] += 1\\n        else:\\n            lookup[subtree] = 1\\n        return subtree\\n    \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:    \\n        lookup, duplicates = {}, []\\n        self.dfs(root, lookup, duplicates)\\n        return duplicates\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def dfs(self, root, lookup, duplicates):\\n        if not root:\\n            return \\'.\\'\\n        subtree = str(root.val) + \\'-\\' + self.dfs(root.left, lookup, duplicates) + \\'-\\' + self.dfs(root.right, lookup, duplicates) \\n        if subtree in lookup:\\n            if lookup[subtree] == 1:\\n                duplicates.append(root)\\n            lookup[subtree] += 1\\n        else:\\n            lookup[subtree] = 1\\n        return subtree\\n    \\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:    \\n        lookup, duplicates = {}, []\\n        self.dfs(root, lookup, duplicates)\\n        return duplicates\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980686,
                "title": "c-easy-solution-with-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> d;\\n    unordered_map<string, int> mp;\\n    \\n    string postorder(TreeNode* root) {\\n        if(!root) return \"\";\\n        \\n        string left = postorder(root->left);\\n        string right = postorder(root->right);\\n        \\n        string current = to_string(root->val) + \"L\" + left + \"R\" +  right;\\n         mp[current]++;\\n        if(mp[current] == 2)\\n            d.push_back(root);\\n        \\n        return current;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        postorder(root);\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> d;\\n    unordered_map<string, int> mp;\\n    \\n    string postorder(TreeNode* root) {\\n        if(!root) return \"\";\\n        \\n        string left = postorder(root->left);\\n        string right = postorder(root->right);\\n        \\n        string current = to_string(root->val) + \"L\" + left + \"R\" +  right;\\n         mp[current]++;\\n        if(mp[current] == 2)\\n            d.push_back(root);\\n        \\n        return current;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        postorder(root);\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791364,
                "title": "c-dfs-string-and-hashmap",
                "content": "The main idea is to store the tree as a string and keep incrementing it.\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    string help(TreeNode* root, unordered_map<string, int>& um,vector<TreeNode*>& ans){\\n        if(root == NULL){\\n            return \" \";\\n        };\\n        string s = to_string(root->val) + \" \"+ help(root->left,um,ans)+ \" \"+ help(root->right,um,ans);\\n        if(um[s]++ == 1){\\n            ans.push_back(root);\\n        }\\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,int> um;\\n        \\n        vector<TreeNode*> ans;\\n        help(root,um,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n    \\n    string help(TreeNode* root, unordered_map<string, int>& um,vector<TreeNode*>& ans){\\n        if(root == NULL){\\n            return \" \";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1760891,
                "title": "easy-hashmap-based-solution",
                "content": "```\\nclass Solution {\\n    List<TreeNode> res = new ArrayList<>();\\n    HashMap<String, Integer> map = new HashMap<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        find(root);\\n        return res;\\n    }\\n    \\n    String find(TreeNode root){\\n        if(root==null) return \"\";\\n        \\n        int cur = root.val;\\n        String left = find(root.left);\\n        String right = find(root.right);\\n        String temp = cur+\",\"+left+\",\"+right;\\n        \\n        if(map.getOrDefault(temp, 0) == 1)\\n            res.add(root);\\n        map.put(temp, map.getOrDefault(temp, 0)+1);\\n\\t\\t\\n        return temp;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<TreeNode> res = new ArrayList<>();\\n    HashMap<String, Integer> map = new HashMap<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        find(root);\\n        return res;\\n    }\\n    \\n    String find(TreeNode root){\\n        if(root==null) return \"\";\\n        \\n        int cur = root.val;\\n        String left = find(root.left);\\n        String right = find(root.right);\\n        String temp = cur+\",\"+left+\",\"+right;\\n        \\n        if(map.getOrDefault(temp, 0) == 1)\\n            res.add(root);\\n        map.put(temp, map.getOrDefault(temp, 0)+1);\\n\\t\\t\\n        return temp;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618197,
                "title": "simpe-postorder-recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> map = new HashMap<>();\\n        List<TreeNode> list = new LinkedList<>();\\n        helper(root, map, list);\\n        return list;\\n    }\\n\\n    private String helper(TreeNode root, Map<String, Integer> map, List<TreeNode> list) {\\n        if(root == null) return \"#\";\\n\\n        String key = helper(root.left, map, list) + \"#\" +\\n                helper(root.right, map, list) + \"#\" +\\n                root.val;\\n\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n        if(map.get(key) == 2) list.add(root);\\n\\n        return key;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> map = new HashMap<>();\\n        List<TreeNode> list = new LinkedList<>();\\n        helper(root, map, list);\\n        return list;\\n    }\\n\\n    private String helper(TreeNode root, Map<String, Integer> map, List<TreeNode> list) {\\n        if(root == null) return \"#\";\\n\\n        String key = helper(root.left, map, list) + \"#\" +\\n                helper(root.right, map, list) + \"#\" +\\n                root.val;\\n\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n        if(map.get(key) == 2) list.add(root);\\n\\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372508,
                "title": "python-dfs",
                "content": "```\\nfrom typing import List\\nfrom collections import defaultdict\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n\\n        seen = defaultdict(int)\\n        output = []\\n\\n        def dfs(node):\\n            if not node:\\n                return\\n            subtree = tuple([dfs(node.left), node.val, dfs(node.right)])\\n            if seen[subtree] == 1:\\n                output.append(node)\\n            seen[subtree] += 1\\n            return subtree\\n\\n        dfs(root)\\n        return output",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n\\n        seen = defaultdict(int)\\n        output = []\\n\\n        def dfs(node):\\n            if not node:\\n                return\\n            subtree = tuple([dfs(node.left), node.val, dfs(node.right)])\\n            if seen[subtree] == 1:\\n                output.append(node)\\n            seen[subtree] += 1\\n            return subtree\\n\\n        dfs(root)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1340817,
                "title": "simple-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    vector<TreeNode*> ans;\\n    \\n    string dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"#\";\\n        \\n        string left=dfs(root->left);\\n        string right=dfs(root->right);\\n        \\n        string key=left+\" \"+right+\" \"+to_string(root->val);\\n        mp[key]++;\\n        \\n        if(mp[key]==2)\\n            ans.push_back(root);\\n        \\n        return key;\\n        \\n    }\\n    \\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    vector<TreeNode*> ans;\\n    \\n    string dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"#\";\\n        \\n        string left=dfs(root->left);\\n        string right=dfs(root->right);\\n        \\n        string key=left+\" \"+right+\" \"+to_string(root->val);\\n        mp[key]++;\\n        \\n        if(mp[key]==2)\\n            ans.push_back(root);\\n        \\n        return key;\\n        \\n    }\\n    \\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288778,
                "title": "c-solution-using-string-and-hashmap",
                "content": "Create a hashmap storing vector of TreeNodes with a string as a key. The string can uniquely identify the subtree because we are using \"(\" and \")\" values to mark each left and right subtree recursively , so even if the node values are same, the structure is checked if and only if the parans too are same.\\nFor example: 000 can match with 000 but (((0)0)0) will reject (0(0(0))) and only match with (((0)0)0).\\n(((0)0)0) tree is as follows:- [0, 0, null, 0, null].\\nNow, we maintain a hashmap to keep track of all the strings and keep adding vectors of TreeNodes to them. Atlast, if any string is has 2 or more vectors, then it is present more than 1 time, hence we return that vector of TreeNodes.\\n```\\nclass Solution {\\n    string inorder(unordered_map<string, vector<TreeNode*>> &A, TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s = \"(\" + inorder(A, root->left) + to_string(root->val) + inorder(A, root->right) + \")\";\\n        A[s].push_back(root);\\n        return s;\\n    }\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ret;\\n        unordered_map<string, vector<TreeNode*>> A; //vector of TreeNodes so as to keep pushing\\n\\t\\t//the TreeNodes and at last compare if more than 1 TreeNodes when traversed, give the same\\n\\t\\t//string check more than one by vector.size()\\n        if(root==NULL)\\n            return ret;\\n        inorder(A, root);\\n        for(auto it=A.begin(); it!=A.end(); it++)\\n            if(it->second.size()>1) ret.push_back(it->second[0]);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    string inorder(unordered_map<string, vector<TreeNode*>> &A, TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s = \"(\" + inorder(A, root->left) + to_string(root->val) + inorder(A, root->right) + \")\";\\n        A[s].push_back(root);\\n        return s;\\n    }\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ret;\\n        unordered_map<string, vector<TreeNode*>> A; //vector of TreeNodes so as to keep pushing\\n\\t\\t//the TreeNodes and at last compare if more than 1 TreeNodes when traversed, give the same\\n\\t\\t//string check more than one by vector.size()\\n        if(root==NULL)\\n            return ret;\\n        inorder(A, root);\\n        for(auto it=A.begin(); it!=A.end(); it++)\\n            if(it->second.size()>1) ret.push_back(it->second[0]);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214107,
                "title": "sumple-c-soln-hashing-serialization",
                "content": "```\\n    string helper(TreeNode* root,vector<TreeNode*> &ans, unordered_map<string, int>&m ){\\n        if(!root)\\n            return \"# \";\\n        string node=to_string(root->val)+\" \";\\n        node+=helper(root->left, ans,m);\\n        node+=helper(root->right, ans,m);\\n        if(m.count(node) && m[node]==1){\\n            ans.push_back(root);\\n            m[node]++;\\n        }\\n        else if(!m.count(node)){\\n            m[node]=1;\\n        }\\n        return node;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        unordered_map<string, int> m;\\n        helper(root, ans, m);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string helper(TreeNode* root,vector<TreeNode*> &ans, unordered_map<string, int>&m ){\\n        if(!root)\\n            return \"# \";\\n        string node=to_string(root->val)+\" \";\\n        node+=helper(root->left, ans,m);\\n        node+=helper(root->right, ans,m);\\n        if(m.count(node) && m[node]==1){\\n            ans.push_back(root);\\n            m[node]++;\\n        }\\n        else if(!m.count(node)){\\n            m[node]=1;\\n        }\\n        return node;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        unordered_map<string, int> m;\\n        helper(root, ans, m);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212254,
                "title": "java-tree-hashing-2-solutions-4ms-beats-99-in-both-time-and-memory",
                "content": "\\n\\t// O(n^2) O(n)\\n\\tpublic List<TreeNode> findDuplicateSubtrees1(TreeNode root) {\\n\\n\\t\\tList<TreeNode> ans = new ArrayList<TreeNode>();\\n\\t\\tHashMap<String, Integer> map = new HashMap<>();\\n\\t\\tfindDuplicateSubtrees1(root, ans, map);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\tpublic StringBuilder findDuplicateSubtrees1(TreeNode root, List<TreeNode> ans, HashMap<String, Integer> map) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn new StringBuilder(\"#\");\\n\\n\\t\\tStringBuilder left = findDuplicateSubtrees1(root.left, ans, map);\\n\\t\\tStringBuilder right = findDuplicateSubtrees1(root.right, ans, map);\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tsb.append(root.val);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(left);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(right);\\n\\n\\t\\tString key = sb.toString();\\n\\t\\tint freq = map.getOrDefault(key, 0);\\n\\t\\tif (freq == 1) {\\n\\t\\t\\tans.add(root);\\n\\t\\t\\tmap.put(key, 2);\\n\\t\\t} else if (freq == 0)\\n\\t\\t\\tmap.put(key, 1);\\n\\n\\t\\treturn sb;\\n\\t}\\n\\n\\tint currId = 1;\\n\\n\\t// O(n) O(n)\\n\\tpublic List<TreeNode> findDuplicateSubtrees2(TreeNode root) {\\n\\n\\t\\tList<TreeNode> ans = new ArrayList<>();\\n\\t\\tHashMap<String, Integer> serial2Id = new HashMap<>();\\n\\t\\tHashMap<Integer, Integer> freq = new HashMap<>();\\n\\t\\tfindDuplicateSubtrees2(root, serial2Id, freq, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int findDuplicateSubtrees2(TreeNode root, HashMap<String, Integer> serial2Id, HashMap<Integer, Integer> map,\\n\\t\\t\\tList<TreeNode> ans) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint left = findDuplicateSubtrees2(root.left, serial2Id, map, ans);\\n\\t\\tint right = findDuplicateSubtrees2(root.right, serial2Id, map, ans);\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tsb.append(root.val);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(left);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(right);\\n\\n\\t\\tString serial = sb.toString();\\n\\t\\tint id = serial2Id.getOrDefault(serial, currId++);\\n\\t\\tint freq = map.getOrDefault(id, 0);\\n\\t\\tserial2Id.put(serial, id);\\n\\n\\t\\tif (freq == 1) {\\n\\t\\t\\tans.add(root);\\n\\t\\t\\tmap.put(id, 2);\\n\\t\\t} else if (freq == 0)\\n\\t\\t\\tmap.put(id, 1);\\n\\n\\t\\treturn id;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// O(n^2) O(n)\\n\\tpublic List<TreeNode> findDuplicateSubtrees1(TreeNode root) {\\n\\n\\t\\tList<TreeNode> ans = new ArrayList<TreeNode>();\\n\\t\\tHashMap<String, Integer> map = new HashMap<>();\\n\\t\\tfindDuplicateSubtrees1(root, ans, map);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\tpublic StringBuilder findDuplicateSubtrees1(TreeNode root, List<TreeNode> ans, HashMap<String, Integer> map) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn new StringBuilder(\"#\");\\n\\n\\t\\tStringBuilder left = findDuplicateSubtrees1(root.left, ans, map);\\n\\t\\tStringBuilder right = findDuplicateSubtrees1(root.right, ans, map);\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tsb.append(root.val);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(left);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(right);\\n\\n\\t\\tString key = sb.toString();\\n\\t\\tint freq = map.getOrDefault(key, 0);\\n\\t\\tif (freq == 1) {\\n\\t\\t\\tans.add(root);\\n\\t\\t\\tmap.put(key, 2);\\n\\t\\t} else if (freq == 0)\\n\\t\\t\\tmap.put(key, 1);\\n\\n\\t\\treturn sb;\\n\\t}\\n\\n\\tint currId = 1;\\n\\n\\t// O(n) O(n)\\n\\tpublic List<TreeNode> findDuplicateSubtrees2(TreeNode root) {\\n\\n\\t\\tList<TreeNode> ans = new ArrayList<>();\\n\\t\\tHashMap<String, Integer> serial2Id = new HashMap<>();\\n\\t\\tHashMap<Integer, Integer> freq = new HashMap<>();\\n\\t\\tfindDuplicateSubtrees2(root, serial2Id, freq, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int findDuplicateSubtrees2(TreeNode root, HashMap<String, Integer> serial2Id, HashMap<Integer, Integer> map,\\n\\t\\t\\tList<TreeNode> ans) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint left = findDuplicateSubtrees2(root.left, serial2Id, map, ans);\\n\\t\\tint right = findDuplicateSubtrees2(root.right, serial2Id, map, ans);\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tsb.append(root.val);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(left);\\n\\t\\tsb.append(\"_\");\\n\\t\\tsb.append(right);\\n\\n\\t\\tString serial = sb.toString();\\n\\t\\tint id = serial2Id.getOrDefault(serial, currId++);\\n\\t\\tint freq = map.getOrDefault(id, 0);\\n\\t\\tserial2Id.put(serial, id);\\n\\n\\t\\tif (freq == 1) {\\n\\t\\t\\tans.add(root);\\n\\t\\t\\tmap.put(id, 2);\\n\\t\\t} else if (freq == 0)\\n\\t\\t\\tmap.put(id, 1);\\n\\n\\t\\treturn id;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1081364,
                "title": "java-dfs-with-serializing-and-stringbuilder-beats-98-7",
                "content": "```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        // serial to id map\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        // id to count map\\n        Map<Integer, Integer> count = new HashMap<>();\\n        dfs(serialToId, count, ans, root);\\n        \\n        return ans;\\n    }\\n    \\n    private int dfs(Map<String, Integer> serialToId,  Map<Integer, Integer> count, List<TreeNode> ans, TreeNode n) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        \\n        int left = dfs(serialToId, count, ans, n.left);\\n        int right = dfs(serialToId, count, ans, n.right);\\n        StringBuilder sb = new StringBuilder();\\n        String serial = sb.append(n.val).append(\",\").append(left).append(\",\").append(right).toString();\\n        int id = serialToId.computeIfAbsent(serial, k -> serialToId.size() + 1);\\n        count.put(id, count.getOrDefault(id, 0) + 1);\\n        if (count.get(id) == 2) {\\n            ans.add(n);\\n        }\\n        \\n        return id;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        // serial to id map\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        // id to count map\\n        Map<Integer, Integer> count = new HashMap<>();\\n        dfs(serialToId, count, ans, root);\\n        \\n        return ans;\\n    }\\n    \\n    private int dfs(Map<String, Integer> serialToId,  Map<Integer, Integer> count, List<TreeNode> ans, TreeNode n) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        \\n        int left = dfs(serialToId, count, ans, n.left);\\n        int right = dfs(serialToId, count, ans, n.right);\\n        StringBuilder sb = new StringBuilder();\\n        String serial = sb.append(n.val).append(\",\").append(left).append(\",\").append(right).toString();\\n        int id = serialToId.computeIfAbsent(serial, k -> serialToId.size() + 1);\\n        count.put(id, count.getOrDefault(id, 0) + 1);\\n        if (count.get(id) == 2) {\\n            ans.add(n);\\n        }\\n        \\n        return id;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1014835,
                "title": "time-space-beating-99-the-reasoning-behind-hashing-rabin-karp",
                "content": "This problem is quite simple and straightforward indeed. We are to find the \"equal\" binary trees among all the subtrees.\\n\\nFirst, how do we define an \"equality\" between two binary trees? It can be defined recursively: two trees are equal if and only if their root node has the same value and their respective left and right subtrees are equal (including `null`).\\n\\nNext, if we can decide whether two trees are equal now, how to tackle the problem? It\\'s trivial to scan all the subtrees (amounting to n, where n is the total number of nodes), and maintain all the distinct subtrees. Output the subtrees that occur more than once.\\n\\nThe most important step is to efficiently decide whether two trees are distinct or equal. It is intuitive to use hashing. Generally, hashing avoids costly comparison between objects and reduces time complexity to O(1) on average. But here is a binary tree which has a recursive structure. We cannot afford computing the same substructure (subtree) repeatedly.\\n\\nThe key to overcoming this difficulty is rolling hash in Rabin Karp algorithm. We can use precomputed hashing of other subtrees to calculate its own hash. The basic idea is similar to dynamic programming or caching, where results of solved duplicate subproblems can be reused. Let\\'s suppose a hash value is stored in each subtree which will be computed only once during execution. By definition, we need to compute the hash by the value of root node and the hash of two subtrees. Note that left and right subtrees should be distinguished.\\n\\n```\\nint h = root.val + CONST * root.left.hashCode() + CONST * CONST * root.right.hashCode();\\n```\\n\\nHere is an example of hashing method. `CONST` can be any value, but for efficiency a prime number is desired.\\n\\nAs long as we have the crucial hashing method now, we can make use of another powerful weapon, *hash table*, to crack the original problem now.\\n\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        var newRoot = new HashableTreeNode(root);\\n        \\n        var subtrees = new HashMap<HashableTreeNode, Integer>();\\n        traverse(newRoot, subtrees);\\n        \\n        return subtrees.entrySet().stream()\\n            .filter(entry -> entry.getValue() > 1)\\n            .map(entry -> entry.getKey().original)\\n            .collect(Collectors.toList());\\n    }\\n    \\n    private void traverse(HashableTreeNode root, Map<HashableTreeNode, Integer> subtrees) {\\n        subtrees.merge(root, 1, (oldVal, val) -> oldVal + 1);\\n        if (root.left != null) traverse(root.left, subtrees);\\n        if (root.right != null) traverse(root.right, subtrees);\\n    }\\n}\\n\\nclass HashableTreeNode extends TreeNode {\\n    private static final int BASE = 201;\\n    private int hash = 0;\\n    \\n    HashableTreeNode left;\\n    HashableTreeNode right;\\n    TreeNode original;\\n    \\n    HashableTreeNode(TreeNode node) {\\n        val = node.val;\\n        original = node;\\n        if (node.left != null) left = new HashableTreeNode(node.left);\\n        if (node.right != null) right = new HashableTreeNode(node.right);\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        int h = hash;\\n        if (h == 0) {\\n            h = (val + BASE)\\n                + 31 * ((left == null) ? 0 : left.hashCode())\\n                + 31 * 31 * ((right == null) ? 0 : right.hashCode());\\n            hash = h;\\n        }\\n        return h;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n        if (obj == null) return false;\\n        if (obj == this) return true;\\n        if (!(obj instanceof HashableTreeNode)) return false;\\n        \\n        var node = (HashableTreeNode)obj;\\n        return val == node.val && Objects.equals(left, node.left) && Objects.equals(right, node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint h = root.val + CONST * root.left.hashCode() + CONST * CONST * root.right.hashCode();\\n```\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        var newRoot = new HashableTreeNode(root);\\n        \\n        var subtrees = new HashMap<HashableTreeNode, Integer>();\\n        traverse(newRoot, subtrees);\\n        \\n        return subtrees.entrySet().stream()\\n            .filter(entry -> entry.getValue() > 1)\\n            .map(entry -> entry.getKey().original)\\n            .collect(Collectors.toList());\\n    }\\n    \\n    private void traverse(HashableTreeNode root, Map<HashableTreeNode, Integer> subtrees) {\\n        subtrees.merge(root, 1, (oldVal, val) -> oldVal + 1);\\n        if (root.left != null) traverse(root.left, subtrees);\\n        if (root.right != null) traverse(root.right, subtrees);\\n    }\\n}\\n\\nclass HashableTreeNode extends TreeNode {\\n    private static final int BASE = 201;\\n    private int hash = 0;\\n    \\n    HashableTreeNode left;\\n    HashableTreeNode right;\\n    TreeNode original;\\n    \\n    HashableTreeNode(TreeNode node) {\\n        val = node.val;\\n        original = node;\\n        if (node.left != null) left = new HashableTreeNode(node.left);\\n        if (node.right != null) right = new HashableTreeNode(node.right);\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        int h = hash;\\n        if (h == 0) {\\n            h = (val + BASE)\\n                + 31 * ((left == null) ? 0 : left.hashCode())\\n                + 31 * 31 * ((right == null) ? 0 : right.hashCode());\\n            hash = h;\\n        }\\n        return h;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n        if (obj == null) return false;\\n        if (obj == this) return true;\\n        if (!(obj instanceof HashableTreeNode)) return false;\\n        \\n        var node = (HashableTreeNode)obj;\\n        return val == node.val && Objects.equals(left, node.left) && Objects.equals(right, node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898239,
                "title": "java-hashmap-recursive",
                "content": "```java\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    List<TreeNode> res = new ArrayList<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private String traverse(TreeNode node) {\\n        if (node == null) {\\n            return \"\";\\n        }\\n        \\n        String curr = new StringBuilder()\\n            .append(node.val).append(\":\")\\n            .append(traverse(node.left)).append(\",\")\\n            .append(traverse(node.right)).append(\";\")\\n            .toString();\\n        \\n        int count = map.getOrDefault(curr, 0);\\n        if (count == 1) {\\n            res.add(node);\\n        }\\n        map.put(curr, count+1);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    List<TreeNode> res = new ArrayList<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private String traverse(TreeNode node) {\\n        if (node == null) {\\n            return \"\";\\n        }\\n        \\n        String curr = new StringBuilder()\\n            .append(node.val).append(\":\")\\n            .append(traverse(node.left)).append(\",\")\\n            .append(traverse(node.right)).append(\";\")\\n            .toString();\\n        \\n        int count = map.getOrDefault(curr, 0);\\n        if (count == 1) {\\n            res.add(node);\\n        }\\n        map.put(curr, count+1);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726926,
                "title": "c-concise-postorder-traversal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        unordered_map<string, int> m;\\n        postorder(root, m, res);\\n        return res;\\n    }\\n    \\n    string postorder(TreeNode* root, unordered_map<string, int>& m, vector<TreeNode*>& res) {\\n        if(!root) return \"#\";\\n        string s = to_string(root->val) + \",\" + postorder(root->left, m, res) + \",\" + postorder(root->right, m, res);\\n        if(m[s] == 1) res.push_back(root);\\n        m[s]++;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        unordered_map<string, int> m;\\n        postorder(root, m, res);\\n        return res;\\n    }\\n    \\n    string postorder(TreeNode* root, unordered_map<string, int>& m, vector<TreeNode*>& res) {\\n        if(!root) return \"#\";\\n        string s = to_string(root->val) + \",\" + postorder(root->left, m, res) + \",\" + postorder(root->right, m, res);\\n        if(m[s] == 1) res.push_back(root);\\n        m[s]++;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620847,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    map<string, TreeNode*> subs;\\n    set<TreeNode*> res;\\n    set<string> dups;\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        serialize(root);\\n        return vector<TreeNode*>(res.begin(), res.end());\\n    }\\n    \\n    string serialize(TreeNode* root){\\n        if (!root) return \"#\";\\n        string str = to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\\n        if (subs.count(str)>0 && dups.find(str)==dups.end()){ \\n            res.insert(root);\\n            dups.insert(str);\\n        }else{\\n            subs[str] = root;\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<string, TreeNode*> subs;\\n    set<TreeNode*> res;\\n    set<string> dups;\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        serialize(root);\\n        return vector<TreeNode*>(res.begin(), res.end());\\n    }\\n    \\n    string serialize(TreeNode* root){\\n        if (!root) return \"#\";\\n        string str = to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\\n        if (subs.count(str)>0 && dups.find(str)==dups.end()){ \\n            res.insert(root);\\n            dups.insert(str);\\n        }else{\\n            subs[str] = root;\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608869,
                "title": "java-solution-in-12ms-step-by-step",
                "content": "Method1 Naive method to loop all:\\n1. Iterate all nodes and save the into a list.\\n2. for for loop to compare all nodes of list if current subtree is same as any of subtree in list, but not the same.\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res = new ArrayList<>();\\n        List<TreeNode> subtrees = new ArrayList<>();\\n        Set<TreeNode> set = new HashSet<>();\\n        preOrder(root, subtrees);\\n        // checkPreorder(root, subtrees, res, set);\\n        for(TreeNode node1 : subtrees) {\\n            for(TreeNode node2 : subtrees) {\\n                if(node1 != node2 && isSameSubTree(node1, node2) && !set.contains(node1) && !set.contains(node2)) {\\n                    res.add(node1);\\n                    set.add(node1);\\n                    set.add(node2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<TreeNode> subtrees) {\\n        if(root == null) {\\n            return;\\n        }\\n        subtrees.add(root);\\n        preOrder(root.left, subtrees);\\n        preOrder(root.right, subtrees);   \\n    }\\n    \\n    public boolean isSameSubTree(TreeNode root, TreeNode node) {\\n        if(root == null && node == null) {\\n            return true;\\n        }\\n        if(root == null || node == null) {\\n            return false;\\n        }\\n        if(root.val == node.val) {\\n            return isSameSubTree(root.left, node.left) && isSameSubTree(root.right, node.right);\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```\\nTC: O(n^3)\\nSC: O(n)\\n\\nMethod2: Serialize\\n1. Using Post order to add string signature for each TreeNode in form of (x.value, (all nodes of leftSubtree), (all nodes of rightSubtree))\\n2. While traversal, put string and frequency + 1 into map, if frequency == 2 ==> add node into list\\n```\\nclass Solution {\\n    Map<String, Integer> map;\\n    List<TreeNode> res;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        map = new HashMap<>();\\n        res = new ArrayList<>();\\n        serializeTree(root);\\n        return res;\\n    }\\n    \\n    //Get a root of a tree\\n    //return the string signature\\n    //Each Level: 1. build serial string; 2. put current into map\\n    public String serializeTree(TreeNode root) {\\n        if(root == null) return \"#\";\\n        String serial = root.val + \",\" + serializeTree(root.left) + \",\" + serializeTree(root.right);\\n        Integer freq = map.get(serial);\\n        map.put(serial, map.getOrDefault(serial, 0) + 1);\\n        if (map.get(serial) == 2) {\\n            res.add(root);\\n        }\\n        return serial;\\n    }\\n}\\n```\\nTC: O(n^2) n for post order traversal and each node has O(n) to concate string\\nSC: O(n^2) n level tree with n string maximum each level\\n   \\n    \\nMethod3: Global value numbering\\nSignature: \\n1. Map<Integer, Integer> count; Integer is the unique global number, Integer is frequency\\n2. Map<String, Integer> map;    String is the unique serial string for each subtree Node, Integer is the unique global number.\\n\\npostordertraverse(TreeNode node)\\nGet: the each subtree node\\nreturn: the unique global number\\neach level: \\n1. pass left and right to two child and build serial number\\n2. put serial number into count map(either put a new one or increment)\\n3. if new frequency is 2, add current node to result. (2 means current node has already been explored)\\n```\\nclass Solution {\\n    Map<Integer, Integer> count;\\n    Map<String, Integer> map;\\n    List<TreeNode> res;\\n    int globalId;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        count = new HashMap<>();\\n        map = new HashMap<>();\\n        res = new ArrayList<>();\\n        globalId = 1;\\n        postorderTraverse(root);\\n        return res;\\n    }\\n    public int postorderTraverse(TreeNode node) {\\n        if(node == null) return 0;\\n        String serial = node.val + \",\" + postorderTraverse(node.left) + \",\" + postorderTraverse(node.right);\\n        int uniqueId = map.computeIfAbsent(serial, x->globalId++); //get/create a uniqueId; computeIfAbsent only compute if key doesn\\'t exist\\n        count.put(uniqueId, count.getOrDefault(uniqueId, 0) + 1);\\n        if(count.get(uniqueId) == 2){\\n            res.add(node);\\n        }\\n        return uniqueId;\\n        \\n        // if(uniqueIdentifier == null) {\\n        //     uniqueIdentifier = globalIdenfier;\\n        //     map.put(serial, uniqueIdentifier);\\n        //     count.put(globalIdenfier, 1);\\n        //     globalIdenfier++;\\n        // }\\n        // else {\\n        //     count.put(uniqueIdentifier, count.get(uniqueIdentifier) + 1);\\n        //     if(count.get(uniqueIdentifier) == 2) {\\n        //         res.add(node);\\n        //     }\\n        // }\\n    }\\n}\\n```\\nTC: O(n)\\nSC: O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> res = new ArrayList<>();\\n        List<TreeNode> subtrees = new ArrayList<>();\\n        Set<TreeNode> set = new HashSet<>();\\n        preOrder(root, subtrees);\\n        // checkPreorder(root, subtrees, res, set);\\n        for(TreeNode node1 : subtrees) {\\n            for(TreeNode node2 : subtrees) {\\n                if(node1 != node2 && isSameSubTree(node1, node2) && !set.contains(node1) && !set.contains(node2)) {\\n                    res.add(node1);\\n                    set.add(node1);\\n                    set.add(node2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<TreeNode> subtrees) {\\n        if(root == null) {\\n            return;\\n        }\\n        subtrees.add(root);\\n        preOrder(root.left, subtrees);\\n        preOrder(root.right, subtrees);   \\n    }\\n    \\n    public boolean isSameSubTree(TreeNode root, TreeNode node) {\\n        if(root == null && node == null) {\\n            return true;\\n        }\\n        if(root == null || node == null) {\\n            return false;\\n        }\\n        if(root.val == node.val) {\\n            return isSameSubTree(root.left, node.left) && isSameSubTree(root.right, node.right);\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<String, Integer> map;\\n    List<TreeNode> res;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        map = new HashMap<>();\\n        res = new ArrayList<>();\\n        serializeTree(root);\\n        return res;\\n    }\\n    \\n    //Get a root of a tree\\n    //return the string signature\\n    //Each Level: 1. build serial string; 2. put current into map\\n    public String serializeTree(TreeNode root) {\\n        if(root == null) return \"#\";\\n        String serial = root.val + \",\" + serializeTree(root.left) + \",\" + serializeTree(root.right);\\n        Integer freq = map.get(serial);\\n        map.put(serial, map.getOrDefault(serial, 0) + 1);\\n        if (map.get(serial) == 2) {\\n            res.add(root);\\n        }\\n        return serial;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, Integer> count;\\n    Map<String, Integer> map;\\n    List<TreeNode> res;\\n    int globalId;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        count = new HashMap<>();\\n        map = new HashMap<>();\\n        res = new ArrayList<>();\\n        globalId = 1;\\n        postorderTraverse(root);\\n        return res;\\n    }\\n    public int postorderTraverse(TreeNode node) {\\n        if(node == null) return 0;\\n        String serial = node.val + \",\" + postorderTraverse(node.left) + \",\" + postorderTraverse(node.right);\\n        int uniqueId = map.computeIfAbsent(serial, x->globalId++); //get/create a uniqueId; computeIfAbsent only compute if key doesn\\'t exist\\n        count.put(uniqueId, count.getOrDefault(uniqueId, 0) + 1);\\n        if(count.get(uniqueId) == 2){\\n            res.add(node);\\n        }\\n        return uniqueId;\\n        \\n        // if(uniqueIdentifier == null) {\\n        //     uniqueIdentifier = globalIdenfier;\\n        //     map.put(serial, uniqueIdentifier);\\n        //     count.put(globalIdenfier, 1);\\n        //     globalIdenfier++;\\n        // }\\n        // else {\\n        //     count.put(uniqueIdentifier, count.get(uniqueIdentifier) + 1);\\n        //     if(count.get(uniqueIdentifier) == 2) {\\n        //         res.add(node);\\n        //     }\\n        // }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606861,
                "title": "ruby-solution",
                "content": "```\\ndef find_duplicate_subtrees(root)\\n    @path = {}\\n    @duplicates = []\\n    \\n    find_duplicates(root)\\n    \\n    @duplicates\\nend\\n\\ndef find_duplicates(root)\\n    return \"\" if root.nil?\\n    \\n    path = [root.val,find_duplicates(root.left),find_duplicates(root.right)].join(\\',\\')\\n    \\n    if @path[path]\\n        @duplicates << root if @path[path] == 1\\n        @path[path] += 1\\n    else\\n        @path[path] = 1\\n    end\\n    \\n    path\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_duplicate_subtrees(root)\\n    @path = {}\\n    @duplicates = []\\n    \\n    find_duplicates(root)\\n    \\n    @duplicates\\nend\\n\\ndef find_duplicates(root)\\n    return \"\" if root.nil?\\n    \\n    path = [root.val,find_duplicates(root.left),find_duplicates(root.right)].join(\\',\\')\\n    \\n    if @path[path]\\n        @duplicates << root if @path[path] == 1\\n        @path[path] += 1\\n    else\\n        @path[path] = 1\\n    end\\n    \\n    path\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 314034,
                "title": "python-solution-with-clear-explanation",
                "content": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        \\n        # let\\'s create a result list\\n        self.ans = []\\n        \\n        # let\\'s create a dict to store each unique path and it\\'s count kind of a hash\\n        self.count = collections.defaultdict(int)\\n        \\n        # let\\'s call our helper method which is \\n        # going to parse inorder\\n        self.helper(root)\\n        \\n        return self.ans\\n    \\n    def helper(self, root):\\n        # if root is none then we just return a random filler like \\'#\\' may be\\n        if not root:\\n            return \\'#\\'\\n        \\n        # let\\'s store the path by traversing inorder way\\n        path = str(root.val) + self.helper(root.left) + self.helper(root.right)\\n        \\n        # let\\'s see if the evaluated hash of the path exist in our dict,\\n        # if it does then it\\'s a duplicate and let\\'s append the current root to our ans list\\n        if self.count[path] == 1:\\n            self.ans.append(root)\\n        \\n        # if code reached here means the current path does not exist \\n        # in our count dict and as we are using defaultdict from collections\\n        # this won\\'t raise a keyerror and instead during the check it was inserted with 0 int val\\n        \\n        self.count[path] += 1\\n        \\n        # let\\'s return the created path\\n        return path\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        \\n        # let\\'s create a result list\\n        self.ans = []\\n        \\n        # let\\'s create a dict to store each unique path and it\\'s count kind of a hash\\n        self.count = collections.defaultdict(int)\\n        \\n        # let\\'s call our helper method which is \\n        # going to parse inorder\\n        self.helper(root)\\n        \\n        return self.ans\\n    \\n    def helper(self, root):\\n        # if root is none then we just return a random filler like \\'#\\' may be\\n        if not root:\\n            return \\'#\\'\\n        \\n        # let\\'s store the path by traversing inorder way\\n        path = str(root.val) + self.helper(root.left) + self.helper(root.right)\\n        \\n        # let\\'s see if the evaluated hash of the path exist in our dict,\\n        # if it does then it\\'s a duplicate and let\\'s append the current root to our ans list\\n        if self.count[path] == 1:\\n            self.ans.append(root)\\n        \\n        # if code reached here means the current path does not exist \\n        # in our count dict and as we are using defaultdict from collections\\n        # this won\\'t raise a keyerror and instead during the check it was inserted with 0 int val\\n        \\n        self.count[path] += 1\\n        \\n        # let\\'s return the created path\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106026,
                "title": "c-postorder-traversal-without-serialization-with-explaination-beat-95",
                "content": "We can solve this problem if each subtree can be assign a unique key and a global integer id incrementing from 0. The unique key of subtree can be represent as a tuple:\\n(root->val, left subtree id, right subtree id).\\n\\t1. For empty tree, the unique id is 0 and the key is something that can never be found in a real tree like (INT_MAX,INT_MAX,INT_MAX) as it is almost impossible to have any subtree whose id is INT_MAX\\n\\t2. For leaf node, the key is just the (root->val, 0, 0) as both of its children are empty tree\\n\\t3. For other nodes, if we do a post-order traversal of the tree, we can always know the id of their children and therefore can form their key tuple. We can use this key tuple to find whether the subtree has already been found, otherwise assign a new id to it.\\n\\n```\\nstruct Subtree {\\n    int v;\\n    int lid; // id for left subtree\\n    int rid; // id for right subtree\\n    Subtree(int x, int l, int r) : v(x), lid(l), rid(r) {}\\n    bool operator==(const Subtree &r) const {\\n        return v==r.v && lid==r.lid && rid==r.rid;\\n    }\\n};\\nstruct Hasher {\\n    size_t operator() (const Subtree& k) const{\\n        size_t key=k.v;\\n        return (key<<32)+(k.lid^k.rid);\\n    }\\n  };   \\nstruct Comp {\\n    bool operator() (const Subtree& l, const Subtree& r) const {\\n        return l.v==r.v && l.lid==r.lid && l.rid==r.rid;\\n    }\\n  };\\n\\nclass Solution {\\npublic:     \\n    unordered_map<Subtree, int, Hasher, Comp> fmap; // Subtree=>Subtree id map\\n    vector<int> count; // id => count map\\n    vector<TreeNode*> rmap; // subtree id => real root map\\n    int PostTraverse(TreeNode* root) {\\n        if (root==NULL)\\n            return 0;\\n        int lid = PostTraverse(root->left);\\n        int rid = PostTraverse(root->right);\\n        Subtree st(root->val, lid, rid);\\n        if (fmap.find(st)==fmap.end()) {\\n            // a new subtree is found\\n            int newid = count.size(); // new id is always the number of all subtrees traversed\\n            fmap[st] = newid;\\n            count.push_back(1);\\n            rmap.push_back(root);\\n        } else {\\n            // this subtree has been found\\n            count[fmap[st]]++;\\n        }\\n        return fmap[st];\\n    }\\n\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {       \\n        fmap[Subtree(INT_MAX,INT_MAX,INT_MAX)] = 0; // id 0 indicates a NULL tree\\n        count.push_back(1); // count[0] = 1;\\n        rmap.push_back(NULL); // id 0 indicate null tree\\n        PostTraverse(root);\\n        vector<TreeNode*> res;\\n        for (int i=0; i<count.size(); ++i)\\n            if (count[i]>1)\\n                res.push_back(rmap[i]);\\n        return res;   \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Subtree {\\n    int v;\\n    int lid; // id for left subtree\\n    int rid; // id for right subtree\\n    Subtree(int x, int l, int r) : v(x), lid(l), rid(r) {}\\n    bool operator==(const Subtree &r) const {\\n        return v==r.v && lid==r.lid && rid==r.rid;\\n    }\\n};\\nstruct Hasher {\\n    size_t operator() (const Subtree& k) const{\\n        size_t key=k.v;\\n        return (key<<32)+(k.lid^k.rid);\\n    }\\n  };   \\nstruct Comp {\\n    bool operator() (const Subtree& l, const Subtree& r) const {\\n        return l.v==r.v && l.lid==r.lid && l.rid==r.rid;\\n    }\\n  };\\n\\nclass Solution {\\npublic:     \\n    unordered_map<Subtree, int, Hasher, Comp> fmap; // Subtree=>Subtree id map\\n    vector<int> count; // id => count map\\n    vector<TreeNode*> rmap; // subtree id => real root map\\n    int PostTraverse(TreeNode* root) {\\n        if (root==NULL)\\n            return 0;\\n        int lid = PostTraverse(root->left);\\n        int rid = PostTraverse(root->right);\\n        Subtree st(root->val, lid, rid);\\n        if (fmap.find(st)==fmap.end()) {\\n            // a new subtree is found\\n            int newid = count.size(); // new id is always the number of all subtrees traversed\\n            fmap[st] = newid;\\n            count.push_back(1);\\n            rmap.push_back(root);\\n        } else {\\n            // this subtree has been found\\n            count[fmap[st]]++;\\n        }\\n        return fmap[st];\\n    }\\n\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {       \\n        fmap[Subtree(INT_MAX,INT_MAX,INT_MAX)] = 0; // id 0 indicates a NULL tree\\n        count.push_back(1); // count[0] = 1;\\n        rmap.push_back(NULL); // id 0 indicate null tree\\n        PostTraverse(root);\\n        vector<TreeNode*> res;\\n        for (int i=0; i<count.size(); ++i)\\n            if (count[i]>1)\\n                res.push_back(rmap[i]);\\n        return res;   \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314746,
                "title": "652-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty dictionary freq to store the frequency of each subtree.\\n2. Define a helper function traverse(node) to traverse the binary tree recursively and get the string representation of each subtree:\\n    - If the current node is None, return an empty string.\\n    - Traverse the left and right subtrees recursively by calling traverse(node.left) and traverse(node.right) respectively, and store the results in left and right.\\n    - Combine the string representations of left, right, and node.val to form the string representation of the current subtree subtree.\\n    - Update the frequency of subtree in the dictionary freq by incrementing its value by 1.\\n    - If the frequency of subtree is 2, append the current node to the result list res.\\n    - Return subtree.\\n4. Call traverse(root) to traverse the binary tree and update the frequency of each subtree in the dictionary.\\n5. Create an empty list res to store the duplicate subtree nodes.\\nIterate through the items in freq:\\n    - If the frequency of the current subtree is greater than 1, append the corresponding node to res.\\n6. Return res.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n    # Step 1: Create a dictionary to store the frequency of each subtree\\n    freq = {}\\n    res = []\\n    # Step 2: Define a function called \"traverse\" to get the string representation of a subtree\\n    def traverse(node):\\n        # If node is None, return an empty string\\n        if not node:\\n            return \"\"\\n        # Get the string representation of left and right subtrees recursively\\n        left = traverse(node.left)\\n        right = traverse(node.right)\\n        # Combine the string representations to form the string representation of the current subtree\\n        subtree = left + \",\" + right + \",\" + str(node.val)\\n        # Update the frequency of the current subtree in the dictionary\\n        freq[subtree] = freq.get(subtree, 0) + 1\\n        # If the frequency of the current subtree is 2, add it to the result list\\n        if freq[subtree] == 2:\\n            res.append(node)\\n        # Return the string representation of the current subtree\\n        return subtree\\n    \\n    # Step 3: Traverse the tree recursively and update the frequency of each subtree in the dictionary\\n    traverse(root)\\n    \\n    # Step 4: Return the list of subtrees which have a frequency greater than 1\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n    # Step 1: Create a dictionary to store the frequency of each subtree\\n    freq = {}\\n    res = []\\n    # Step 2: Define a function called \"traverse\" to get the string representation of a subtree\\n    def traverse(node):\\n        # If node is None, return an empty string\\n        if not node:\\n            return \"\"\\n        # Get the string representation of left and right subtrees recursively\\n        left = traverse(node.left)\\n        right = traverse(node.right)\\n        # Combine the string representations to form the string representation of the current subtree\\n        subtree = left + \",\" + right + \",\" + str(node.val)\\n        # Update the frequency of the current subtree in the dictionary\\n        freq[subtree] = freq.get(subtree, 0) + 1\\n        # If the frequency of the current subtree is 2, add it to the result list\\n        if freq[subtree] == 2:\\n            res.append(node)\\n        # Return the string representation of the current subtree\\n        return subtree\\n    \\n    # Step 3: Traverse the tree recursively and update the frequency of each subtree in the dictionary\\n    traverse(root)\\n    \\n    # Step 4: Return the list of subtrees which have a frequency greater than 1\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241146,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Encode each path as String.\\n- Use tree postorder traversal to get to leafs.\\n- If counted path ones, add node to solutions.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        var duplicates = new ArrayList<TreeNode>();\\n        var pathsCounter = new HashMap<String, Integer>();\\n        postorder(root, pathsCounter, duplicates);\\n        return duplicates;\\n    }\\n\\n    private String postorder(TreeNode root, Map<String, Integer> pathsCounter, List<TreeNode> duplicates) {\\n        if (root == null) return \"\";\\n\\n        var path = new StringBuilder()\\n            .append(root.val)\\n            .append(\\'-\\').append(postorder(root.left, pathsCounter, duplicates))\\n            .append(\\'-\\').append(postorder(root.right, pathsCounter, duplicates))\\n            .toString();\\n        \\n        var counter = pathsCounter.getOrDefault(path, 0);\\n        if (counter == 1)\\n            duplicates.add(root);\\n\\n        pathsCounter.put(path, counter + 1);\\n\\n        return path;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        var duplicates = new ArrayList<TreeNode>();\\n        var pathsCounter = new HashMap<String, Integer>();\\n        postorder(root, pathsCounter, duplicates);\\n        return duplicates;\\n    }\\n\\n    private String postorder(TreeNode root, Map<String, Integer> pathsCounter, List<TreeNode> duplicates) {\\n        if (root == null) return \"\";\\n\\n        var path = new StringBuilder()\\n            .append(root.val)\\n            .append(\\'-\\').append(postorder(root.left, pathsCounter, duplicates))\\n            .append(\\'-\\').append(postorder(root.right, pathsCounter, duplicates))\\n            .toString();\\n        \\n        var counter = pathsCounter.getOrDefault(path, 0);\\n        if (counter == 1)\\n            duplicates.add(root);\\n\\n        pathsCounter.put(path, counter + 1);\\n\\n        return path;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239935,
                "title": "c-comparing-treenode-s-by-subtree-hash-codes",
                "content": "```\\npublic class Solution\\n{\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root)\\n    {\\n        var comparer = new TreeNodeComparer();\\n        var uniques = new HashSet<TreeNode>(comparer);\\n        var duplicates = new HashSet<TreeNode>(comparer);\\n        var nodes = new Stack<TreeNode>();\\n\\n        nodes.Push(root);\\n        while (nodes.Any())\\n        {\\n            var node = nodes.Pop();\\n            if (!uniques.Add(node))\\n            {\\n                duplicates.Add(node);\\n            }\\n\\n            if (node.left != null)\\n            {\\n                nodes.Push(node.left);\\n            }\\n\\n            if (node.right != null)\\n            {\\n                nodes.Push(node.right);\\n            }\\n        }\\n\\n        return duplicates.ToList();\\n    }\\n\\n    private class TreeNodeComparer : IEqualityComparer<TreeNode>\\n    {\\n        private Dictionary<TreeNode, int> hashCodes = new();\\n\\n        public int GetHashCode(TreeNode node)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }\\n\\n            if (!hashCodes.ContainsKey(node))\\n            {\\n                var left = GetHashCode(node.left);\\n                var right = GetHashCode(node.right);\\n                var hashCode = (node.val, left, right).GetHashCode();\\n                hashCodes[node] = hashCode;\\n            }\\n\\n            return hashCodes[node];\\n        }\\n\\n        public bool Equals(TreeNode node1, TreeNode node2)\\n        {\\n            return (node1, node2) switch\\n            {\\n                (null, null) => true,\\n                (null, _) or (_, null) => false,\\n                _ => node1.val == node2.val &&\\n                    Equals(node1.left, node2.left) &&\\n                    Equals(node1.right, node2.right),\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root)\\n    {\\n        var comparer = new TreeNodeComparer();\\n        var uniques = new HashSet<TreeNode>(comparer);\\n        var duplicates = new HashSet<TreeNode>(comparer);\\n        var nodes = new Stack<TreeNode>();\\n\\n        nodes.Push(root);\\n        while (nodes.Any())\\n        {\\n            var node = nodes.Pop();\\n            if (!uniques.Add(node))\\n            {\\n                duplicates.Add(node);\\n            }\\n\\n            if (node.left != null)\\n            {\\n                nodes.Push(node.left);\\n            }\\n\\n            if (node.right != null)\\n            {\\n                nodes.Push(node.right);\\n            }\\n        }\\n\\n        return duplicates.ToList();\\n    }\\n\\n    private class TreeNodeComparer : IEqualityComparer<TreeNode>\\n    {\\n        private Dictionary<TreeNode, int> hashCodes = new();\\n\\n        public int GetHashCode(TreeNode node)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }\\n\\n            if (!hashCodes.ContainsKey(node))\\n            {\\n                var left = GetHashCode(node.left);\\n                var right = GetHashCode(node.right);\\n                var hashCode = (node.val, left, right).GetHashCode();\\n                hashCodes[node] = hashCode;\\n            }\\n\\n            return hashCodes[node];\\n        }\\n\\n        public bool Equals(TreeNode node1, TreeNode node2)\\n        {\\n            return (node1, node2) switch\\n            {\\n                (null, null) => true,\\n                (null, _) or (_, null) => false,\\n                _ => node1.val == node2.val &&\\n                    Equals(node1.left, node2.left) &&\\n                    Equals(node1.right, node2.right),\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239581,
                "title": "find-duplicates-subtrees-c-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n\\tunordered_map<string, vector<TreeNode *>> map;\\n\\tstring solve(TreeNode *root)\\n\\t{\\n\\t\\tif (!root)\\n\\t\\t\\treturn \"\";\\n\\t\\tstring s = \"(\" + solve(root->left) + to_string(root->val) + solve(root->right) + \")\";\\n\\t\\tmap[s].push_back(root);\\n\\t\\treturn s;\\n\\t}\\n\\npublic:\\n\\tvector<TreeNode *> findDuplicateSubtrees(TreeNode *root)\\n\\t{\\n\\t\\tvector<TreeNode *> ans;\\n\\t\\tsolve(root);\\n\\t\\tfor (auto [a, b] : map)\\n\\t\\t{\\n\\t\\t\\tif (b.size() > 1)\\n\\t\\t\\t\\tans.push_back(b[0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n\\tunordered_map<string, vector<TreeNode *>> map;\\n\\tstring solve(TreeNode *root)\\n\\t{\\n\\t\\tif (!root)\\n\\t\\t\\treturn \"\";\\n\\t\\tstring s = \"(\" + solve(root->left) + to_string(root->val) + solve(root->right) + \")\";\\n\\t\\tmap[s].push_back(root);\\n\\t\\treturn s;\\n\\t}\\n\\npublic:\\n\\tvector<TreeNode *> findDuplicateSubtrees(TreeNode *root)\\n\\t{\\n\\t\\tvector<TreeNode *> ans;\\n\\t\\tsolve(root);\\n\\t\\tfor (auto [a, b] : map)\\n\\t\\t{\\n\\t\\t\\tif (b.size() > 1)\\n\\t\\t\\t\\tans.push_back(b[0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239376,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   int curId = 1;\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        Map<Integer, Integer> idToCount = new HashMap<>();\\n        List<TreeNode> ans = new LinkedList<>();\\n        postorder(root, serialToId, idToCount, ans);\\n        return ans;\\n    }\\n    \\n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\\n        if (root == null) return 0;\\n        int l = postorder(root.left, serialToId, idToCount, res);\\n        int r = postorder(root.right, serialToId, idToCount, res);\\n        String curSerial = l + \",\" + root.val + \",\" + r;\\n        int sid = serialToId.getOrDefault(curSerial, curId);\\n        if (sid == curId) curId++;\\n        serialToId.put(curSerial, sid);\\n        idToCount.put(sid, idToCount.getOrDefault(sid, 0) + 1);\\n        if (idToCount.get(sid) == 2) res.add(root);\\n        return sid;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   int curId = 1;\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, Integer> serialToId = new HashMap<>();\\n        Map<Integer, Integer> idToCount = new HashMap<>();\\n        List<TreeNode> ans = new LinkedList<>();\\n        postorder(root, serialToId, idToCount, ans);\\n        return ans;\\n    }\\n    \\n    private int postorder(TreeNode root, Map<String, Integer> serialToId, Map<Integer, Integer> idToCount, List<TreeNode> res) {\\n        if (root == null) return 0;\\n        int l = postorder(root.left, serialToId, idToCount, res);\\n        int r = postorder(root.right, serialToId, idToCount, res);\\n        String curSerial = l + \",\" + root.val + \",\" + r;\\n        int sid = serialToId.getOrDefault(curSerial, curId);\\n        if (sid == curId) curId++;\\n        serialToId.put(curSerial, sid);\\n        idToCount.put(sid, idToCount.getOrDefault(sid, 0) + 1);\\n        if (idToCount.get(sid) == 2) res.add(root);\\n        return sid;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239144,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private Map<MyTreeNode, Integer> countMap = new HashMap<>();\\n    private List<TreeNode> duplicates = new LinkedList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        dfs(root);\\n        return duplicates;\\n    }\\n\\n    private MyTreeNode dfs(TreeNode node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        MyTreeNode left = dfs(node.left);\\n        MyTreeNode right = dfs(node.right);\\n\\n        int prime = 31;\\n        int hash = 1;\\n        hash = hash * prime + node.val;\\n        if (left != null) {\\n            hash = hash * prime + left.hash;\\n        }\\n\\n        if (right != null) {\\n            hash = hash * prime + right.hash;\\n        }\\n\\n        MyTreeNode myNode = new MyTreeNode(hash, node.val, left, right);\\n        int count = countMap.getOrDefault(myNode, 0) + 1;\\n        countMap.put(myNode, count);\\n        if (count == 2) {\\n            duplicates.add(node);\\n        }\\n\\n        return myNode;\\n    }\\n\\n    private class MyTreeNode {\\n        private int hash;\\n        private int val;\\n        private MyTreeNode left;\\n        private MyTreeNode right;\\n\\n        public MyTreeNode(int h, int v, MyTreeNode l, MyTreeNode r) {\\n            this.hash = h;\\n            this.val = v;\\n            this.left = l;\\n            this.right = r;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            MyTreeNode node = (MyTreeNode) o;\\n            return this.hash == node.hash && this.val == node.val && equals(node.left, this.left) && equals(node.right, this.right);\\n        }\\n\\n        private boolean equals(MyTreeNode a, MyTreeNode b) {\\n            if (a == null && b == null) {\\n                return true;\\n            }\\n\\n            if (a == null || b == null) {\\n                return false;\\n            }\\n\\n            return a.equals(b);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private Map<MyTreeNode, Integer> countMap = new HashMap<>();\\n    private List<TreeNode> duplicates = new LinkedList<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        dfs(root);\\n        return duplicates;\\n    }\\n\\n    private MyTreeNode dfs(TreeNode node) {\\n        if (node == null) {\\n            return null;\\n        }\\n\\n        MyTreeNode left = dfs(node.left);\\n        MyTreeNode right = dfs(node.right);\\n\\n        int prime = 31;\\n        int hash = 1;\\n        hash = hash * prime + node.val;\\n        if (left != null) {\\n            hash = hash * prime + left.hash;\\n        }\\n\\n        if (right != null) {\\n            hash = hash * prime + right.hash;\\n        }\\n\\n        MyTreeNode myNode = new MyTreeNode(hash, node.val, left, right);\\n        int count = countMap.getOrDefault(myNode, 0) + 1;\\n        countMap.put(myNode, count);\\n        if (count == 2) {\\n            duplicates.add(node);\\n        }\\n\\n        return myNode;\\n    }\\n\\n    private class MyTreeNode {\\n        private int hash;\\n        private int val;\\n        private MyTreeNode left;\\n        private MyTreeNode right;\\n\\n        public MyTreeNode(int h, int v, MyTreeNode l, MyTreeNode r) {\\n            this.hash = h;\\n            this.val = v;\\n            this.left = l;\\n            this.right = r;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            MyTreeNode node = (MyTreeNode) o;\\n            return this.hash == node.hash && this.val == node.val && equals(node.left, this.left) && equals(node.right, this.right);\\n        }\\n\\n        private boolean equals(MyTreeNode a, MyTreeNode b) {\\n            if (a == null && b == null) {\\n                return true;\\n            }\\n\\n            if (a == null || b == null) {\\n                return false;\\n            }\\n\\n            return a.equals(b);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239020,
                "title": "convert-into-string-and-check-for-equality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry About think about making string for inorder traversal of every node. and store them somewhere and then check for the duplicates.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string serialize(TreeNode* root, map<string,vector<TreeNode*>>& mp)\\n    {\\n        if(root==NULL)\\n        return\"\";\\n    string str =\"(\"+serialize(root->left,mp)+to_string(root->val)+serialize(root->right,mp) + \")\";\\n    mp[str].push_back(root);\\n    return str;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n          map<string,vector<TreeNode*>> mp;\\n          vector<TreeNode*> duplicate;\\n          serialize(root,mp);\\n          for(auto x: mp)\\n          if(x.second.size() > 1)\\n          duplicate.push_back(x.second[0]);\\n          return duplicate;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string serialize(TreeNode* root, map<string,vector<TreeNode*>>& mp)\\n    {\\n        if(root==NULL)\\n        return\"\";\\n    string str =\"(\"+serialize(root->left,mp)+to_string(root->val)+serialize(root->right,mp) + \")\";\\n    mp[str].push_back(root);\\n    return str;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n          map<string,vector<TreeNode*>> mp;\\n          vector<TreeNode*> duplicate;\\n          serialize(root,mp);\\n          for(auto x: mp)\\n          if(x.second.size() > 1)\\n          duplicate.push_back(x.second[0]);\\n          return duplicate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238868,
                "title": "c-and-typescript-solution",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n# Approach\\n1. Traverse the tree in postorder and get a unique identifier for each subtree.\\n2. Use a dictionary to count the number of times each subtree occurs in the tree.\\n3. Return all subtrees with more than one occurrence.\\n\\n# Runtime & Memory\\n![image.png](https://assets.leetcode.com/users/images/ee7db999-c0f3-42fc-a2d6-6c5d4641587f_1677564167.397355.png)\\n\\n# Complexity\\n- Time complexity:\\nO(N^2) to traverse the tree and count the number of subtrees.\\n\\n- Space complexity:\\nO(N^2) to keep the entire tree.\\n\\n# C# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution \\n{\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) \\n    {\\n        var result = new List<TreeNode>();\\n        var visited = new Dictionary<string, int>();\\n        Traverse(root, visited, result);\\n        return result;\\n    }\\n\\n    private string Traverse(TreeNode node, Dictionary<string, int> visited, List<TreeNode> result)\\n    {\\n        if (node == null)\\n            return \"#\";\\n\\n        var left = Traverse(node.left, visited, result);\\n        var right = Traverse(node.right, visited, result);\\n\\n        var key = $\"{node.val},{left},{right}\";\\n        if (visited.ContainsKey(key))\\n        {\\n            if (visited[key] == 1)\\n                result.Add(node);\\n            visited[key]++;\\n        }\\n        else\\n        {\\n            visited.Add(key, 1);\\n        }\\n\\n        return key;\\n    }\\n}\\n```\\n\\n# TypeScript Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction findDuplicateSubtrees(root: TreeNode | null): Array<TreeNode | null> {\\n    const result: Array<TreeNode | null> = [];\\n    const visited: Map<string, number> = new Map();\\n    traverse(root, visited, result);\\n    return result;\\n};\\n\\nfunction traverse(node: TreeNode | null, visited: Map<string, number>, result: Array<TreeNode | null>): string {\\n    if (node === null) return \\'#\\';\\n\\n    const left = traverse(node.left, visited, result);\\n    const right = traverse(node.right, visited, result);\\n\\n    const key = `${node.val},${left},${right}`;\\n    if (visited.has(key)) {\\n        if (visited.get(key) === 1) result.push(node);\\n        visited.set(key, visited.get(key) + 1);\\n    } else {\\n        visited.set(key, 1);\\n    }\\n\\n    return key;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "TypeScript",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution \\n{\\n    public IList<TreeNode> FindDuplicateSubtrees(TreeNode root) \\n    {\\n        var result = new List<TreeNode>();\\n        var visited = new Dictionary<string, int>();\\n        Traverse(root, visited, result);\\n        return result;\\n    }\\n\\n    private string Traverse(TreeNode node, Dictionary<string, int> visited, List<TreeNode> result)\\n    {\\n        if (node == null)\\n            return \"#\";\\n\\n        var left = Traverse(node.left, visited, result);\\n        var right = Traverse(node.right, visited, result);\\n\\n        var key = $\"{node.val},{left},{right}\";\\n        if (visited.ContainsKey(key))\\n        {\\n            if (visited[key] == 1)\\n                result.Add(node);\\n            visited[key]++;\\n        }\\n        else\\n        {\\n            visited.Add(key, 1);\\n        }\\n\\n        return key;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction findDuplicateSubtrees(root: TreeNode | null): Array<TreeNode | null> {\\n    const result: Array<TreeNode | null> = [];\\n    const visited: Map<string, number> = new Map();\\n    traverse(root, visited, result);\\n    return result;\\n};\\n\\nfunction traverse(node: TreeNode | null, visited: Map<string, number>, result: Array<TreeNode | null>): string {\\n    if (node === null) return \\'#\\';\\n\\n    const left = traverse(node.left, visited, result);\\n    const right = traverse(node.right, visited, result);\\n\\n    const key = `${node.val},${left},${right}`;\\n    if (visited.has(key)) {\\n        if (visited.get(key) === 1) result.push(node);\\n        visited.set(key, visited.get(key) + 1);\\n    } else {\\n        visited.set(key, 1);\\n    }\\n\\n    return key;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238510,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> res;\\n    HashMap<String, Integer> serialCount;\\n    String pos(TreeNode root)\\n    {\\n\\t    if(root == null) return \"#\";\\n\\t    String serial = root.val + \",\" + pos(root.left) + pos(root.right);\\n\\t    int freq = serialCount.getOrDefault(serial, 0);\\n\\t    serialCount.put(serial, ++freq);\\n\\t    if (freq == 2) res.add(root);\\n\\t    return serial;\\n    }\\n    public List<TreeNode> findDuplicateSubtrees (TreeNode root){\\n\\t    res = new LinkedList<>();\\n\\t    serialCount = new HashMap<>();\\n\\t    pos(root);\\n\\t    return res;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> res;\\n    HashMap<String, Integer> serialCount;\\n    String pos(TreeNode root)\\n    {\\n\\t    if(root == null) return \"#\";\\n\\t    String serial = root.val + \",\" + pos(root.left) + pos(root.right);\\n\\t    int freq = serialCount.getOrDefault(serial, 0);\\n\\t    serialCount.put(serial, ++freq);\\n\\t    if (freq == 2) res.add(root);\\n\\t    return serial;\\n    }\\n    public List<TreeNode> findDuplicateSubtrees (TreeNode root){\\n\\t    res = new LinkedList<>();\\n\\t    serialCount = new HashMap<>();\\n\\t    pos(root);\\n\\t    return res;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238240,
                "title": "javascript-3-lines-simple-string-map-time-o-n-space-o-n",
                "content": "# Approach\\n1. Create object `roots` and array `dupes`.\\n2. Create a recursive DFS function to traverse each `node`. In it:\\n    1. If `node` does not exist, return `\\'()\\'`.\\n    2. Set variable `s` as a string made from `node.val` and the results of DFS performed on `node.left` and `node.right`, inside parenthesis.\\n    3. If `roots[s]` exists and equals `1`, push `node` into `dupes`.\\n    4. Increment `roots[s]`, or set to `1` if it does not yet exist.\\n    5. Return `s`.\\n6. Return `dupes`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n\\n6 Lines:\\n```\\nconst findDuplicateSubtrees = root => {\\n    let r = {}, d = [], \\n        f = n => {\\n            if ( !n ) return \\'()\\'\\n            let s = \\'(\\' + n.val+f(n.left)+f(n.right)+\\')\\'\\n            r[s] ? r[s]++ == 1 && d.push(n) : r[s] = 1\\n            return s\\n        }\\n    return f(root) && d\\n}\\n```\\n\\n3 Lines:\\n```\\nconst findDuplicateSubtrees = root => {\\n    let r = {}, d = [], f = (n,s) =>\\n        n ? ( r[s=\\'(\\'+n.val+f(n.left)+f(n.right)+\\')\\'] ? r[s]++ == 1 ? d.push(n) : 1 : r[s] = 1 ) && s : \\'()\\'\\n    return f(root) && d\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findDuplicateSubtrees = root => {\\n    let r = {}, d = [], \\n        f = n => {\\n            if ( !n ) return \\'()\\'\\n            let s = \\'(\\' + n.val+f(n.left)+f(n.right)+\\')\\'\\n            r[s] ? r[s]++ == 1 && d.push(n) : r[s] = 1\\n            return s\\n        }\\n    return f(root) && d\\n}\\n```\n```\\nconst findDuplicateSubtrees = root => {\\n    let r = {}, d = [], f = (n,s) =>\\n        n ? ( r[s=\\'(\\'+n.val+f(n.left)+f(n.right)+\\')\\'] ? r[s]++ == 1 ? d.push(n) : 1 : r[s] = 1 ) && s : \\'()\\'\\n    return f(root) && d\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238187,
                "title": "swift-fast-no-string-no-counter",
                "content": "**Use HashValues / visitedOnce flag (accepted answer)**\\n```\\nclass Solution {\\n    func findDuplicateSubtrees(_ root: TreeNode?) -> [TreeNode?] {\\n        var hashMap = [Int: Bool]()\\n        var result = [TreeNode?]()\\n        \\n        func dfs(_ node: TreeNode?) -> Int {\\n            guard let node = node else { return 0 }\\n            let hashValue = [node.val, dfs(node.left), dfs(node.right)].hashValue\\n            if hashMap[hashValue] == true {\\n                result.append(node)\\n            }\\n            hashMap[hashValue] = hashMap[hashValue] == nil\\n            return hashValue\\n        }\\n        \\n        dfs(root)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findDuplicateSubtrees(_ root: TreeNode?) -> [TreeNode?] {\\n        var hashMap = [Int: Bool]()\\n        var result = [TreeNode?]()\\n        \\n        func dfs(_ node: TreeNode?) -> Int {\\n            guard let node = node else { return 0 }\\n            let hashValue = [node.val, dfs(node.left), dfs(node.right)].hashValue\\n            if hashMap[hashValue] == true {\\n                result.append(node)\\n            }\\n            hashMap[hashValue] = hashMap[hashValue] == nil\\n            return hashValue\\n        }\\n        \\n        dfs(root)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345472,
                "title": "java-simple-two-hashset",
                "content": "```\\nclass Solution {\\n        \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> out = new ArrayList<>();\\n        Set<String> set = new HashSet<>(); \\n        Set<String> added = new HashSet<>();\\n        preorder(root, out, set, added);        \\n        return out;\\n        \\n    }\\n     \\n    String preorder(TreeNode root, List<TreeNode> out, Set<String> set , Set<String> added){\\n        \\n        if( root == null) return \"\";\\n        \\n        String left = preorder(root.left, out, set, added);\\n        String right = preorder(root.right, out, set, added);\\n        \\n        String cur = left + \"#\"+ right + \"#\" + root.val;\\n        \\n       if(set.contains(cur) && !added.contains(cur)){\\n           added.add(cur);\\n           out.add(root);\\n       }\\n        \\n        set.add(cur);  \\n        \\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> out = new ArrayList<>();\\n        Set<String> set = new HashSet<>(); \\n        Set<String> added = new HashSet<>();\\n        preorder(root, out, set, added);        \\n        return out;\\n        \\n    }\\n     \\n    String preorder(TreeNode root, List<TreeNode> out, Set<String> set , Set<String> added){\\n        \\n        if( root == null) return \"\";\\n        \\n        String left = preorder(root.left, out, set, added);\\n        String right = preorder(root.right, out, set, added);\\n        \\n        String cur = left + \"#\"+ right + \"#\" + root.val;\\n        \\n       if(set.contains(cur) && !added.contains(cur)){\\n           added.add(cur);\\n           out.add(root);\\n       }\\n        \\n        set.add(cur);  \\n        \\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193083,
                "title": "python3-very-simple-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        ## RC ##\\n        ## APPROACH : POST ORDER TRAVERSAL ##\\n        ## Similar to Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal ##\\n        \\n        visited= collections.defaultdict(list)\\n        def dfs(node):\\n            if not node:\\n                return \",\"\\n            \\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            # edge case # only pre-order or post order works\\n            nodes_str = str(left) + \",\" + str(right) + \",\" + str(node.val)\\n            visited[nodes_str].append(node)\\n            return nodes_str\\n        dfs(root)\\n        return [ visited[node][0] for node in visited if len(visited[node]) > 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        ## RC ##\\n        ## APPROACH : POST ORDER TRAVERSAL ##\\n        ## Similar to Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal ##\\n        \\n        visited= collections.defaultdict(list)\\n        def dfs(node):\\n            if not node:\\n                return \",\"\\n            \\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            # edge case # only pre-order or post order works\\n            nodes_str = str(left) + \",\" + str(right) + \",\" + str(node.val)\\n            visited[nodes_str].append(node)\\n            return nodes_str\\n        dfs(root)\\n        return [ visited[node][0] for node in visited if len(visited[node]) > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163703,
                "title": "jave-solution-using-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Set<TreeNode> result = new HashSet<>();\\n        Map<String,TreeNode> map = new HashMap<>();\\n        \\n        getDuplicate(result,root,map,false,false);\\n        \\n        return new ArrayList<>(result);\\n    }\\n    \\n    public String getDuplicate( Set<TreeNode> result,TreeNode root,Map<String,TreeNode> map,boolean left,boolean right){\\n        \\n\\t\\t//to get the unique value for null on the left and right \\n        if(root==null && left)\\n            return \"lnull\";\\n        if(root==null && right)\\n            return \"rnull\";\\n        if(root==null)\\n            return \"null\";\\n        \\n        int val = root.val;\\n        \\n        String leftstr =  getDuplicate(result,root.left,map,true,false);\\n        String rightstr =  getDuplicate(result,root.right,map,false,true);\\n        \\n        String combined = leftstr+val+rightstr;\\n        \\n        if(map.containsKey(combined)){\\n            result.add(map.get(combined));\\n        }\\n        else{\\n            map.put(combined, root);\\n        }\\n        \\n        return combined;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Set<TreeNode> result = new HashSet<>();\\n        Map<String,TreeNode> map = new HashMap<>();\\n        \\n        getDuplicate(result,root,map,false,false);\\n        \\n        return new ArrayList<>(result);\\n    }\\n    \\n    public String getDuplicate( Set<TreeNode> result,TreeNode root,Map<String,TreeNode> map,boolean left,boolean right){\\n        \\n\\t\\t//to get the unique value for null on the left and right \\n        if(root==null && left)\\n            return \"lnull\";\\n        if(root==null && right)\\n            return \"rnull\";\\n        if(root==null)\\n            return \"null\";\\n        \\n        int val = root.val;\\n        \\n        String leftstr =  getDuplicate(result,root.left,map,true,false);\\n        String rightstr =  getDuplicate(result,root.right,map,false,true);\\n        \\n        String combined = leftstr+val+rightstr;\\n        \\n        if(map.containsKey(combined)){\\n            result.add(map.get(combined));\\n        }\\n        else{\\n            map.put(combined, root);\\n        }\\n        \\n        return combined;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116169,
                "title": "java-clean-dfs-solution",
                "content": "```\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> dup = new ArrayList<>();\\n        find(root, new HashMap<>(), dup);\\n        return dup;\\n    }\\n    \\n    private String find(TreeNode root, Map<String, Boolean> set, List<TreeNode> dup) {\\n        if (root == null) return \"null\";\\n        \\n        String left = find(root.left, set, dup);\\n        String right = find(root.right, set, dup);\\n        \\n        String val = root.val + \"#\" + left + \"#\" + right;\\n        if (set.containsKey(val)) {\\n            if (!set.get(val)) {\\n                dup.add(root);\\n                set.put(val, true);\\n            }\\n        } else {\\n            set.put(val, false);\\n        }\\n        \\n        return val;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> dup = new ArrayList<>();\\n        find(root, new HashMap<>(), dup);\\n        return dup;\\n    }\\n    \\n    private String find(TreeNode root, Map<String, Boolean> set, List<TreeNode> dup) {\\n        if (root == null) return \"null\";\\n        \\n        String left = find(root.left, set, dup);\\n        String right = find(root.right, set, dup);\\n        \\n        String val = root.val + \"#\" + left + \"#\" + right;\\n        if (set.containsKey(val)) {\\n            if (!set.get(val)) {\\n                dup.add(root);\\n                set.put(val, true);\\n            }\\n        } else {\\n            set.put(val, false);\\n        }\\n        \\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2041157,
                "title": "c-easy-hashmap-inorder",
                "content": "```\\nclass Solution {\\npublic:\\n    string solve(TreeNode* root, unordered_map<string, int>& map,vector<TreeNode*> &ans){\\n        if(root == NULL){\\n            return \"$\";\\n        }\\n\\n        string temp = to_string(root->val) + \"&\"+ solve(root->left,map,ans) +\"&\"+ solve(root->right,map,ans);;\\n        map[temp]++;\\n        if(map[temp] == 2)\\n            ans.push_back(root);\\n        \\n        return temp;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int> map;\\n        vector<TreeNode*> ans;\\n        if(root==NULL){\\n            return ans;\\n        }\\n        solve(root,map,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(TreeNode* root, unordered_map<string, int>& map,vector<TreeNode*> &ans){\\n        if(root == NULL){\\n            return \"$\";\\n        }\\n\\n        string temp = to_string(root->val) + \"&\"+ solve(root->left,map,ans) +\"&\"+ solve(root->right,map,ans);;\\n        map[temp]++;\\n        if(map[temp] == 2)\\n            ans.push_back(root);\\n        \\n        return temp;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, int> map;\\n        vector<TreeNode*> ans;\\n        if(root==NULL){\\n            return ans;\\n        }\\n        solve(root,map,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959635,
                "title": "java-simple-solution-with-hashmap-easy-to-understand",
                "content": "\\n\\tclass Solution {\\n\\t\\tHashMap<String, Integer> hm;\\n\\t\\tList<TreeNode> ansLst;\\n\\n\\t\\tpublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n\\t\\t\\thm = new HashMap<>();\\n\\t\\t\\tansLst = new ArrayList<>();\\n\\t\\t\\thelper(root, \"\");\\n\\n\\t\\t\\treturn ansLst;\\n\\t\\t}\\n\\n\\t\\tpublic String helper(TreeNode root, String prevStr) {\\n\\t\\t\\tif(root == null) return \",\";\\n\\n\\t\\t\\tprevStr =+ root.val + \",\";\\n\\n\\t\\t\\tStringBuilder curSb = new StringBuilder(prevStr);\\n\\n\\t\\t\\t// add values path of its chlidren\\n\\t\\t\\tcurSb.append(helper(root.left, prevStr));\\n\\t\\t\\tcurSb.append(helper(root.right, prevStr));\\n\\n\\t\\t\\t// count the current string paths.\\n\\t\\t\\thm.put(curSb.toString(), hm.getOrDefault(curSb.toString(), 0) + 1);\\n\\n\\t\\t\\t// Even though there are more than 2 same structures, we only need one root.\\n\\t\\t\\t// So we need to check whether HashMap value is strictly 2 or not.\\n\\t\\t\\tif(hm.get(curSb.toString()) == 2) {\\n\\t\\t\\t\\tansLst.add(root);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn curSb.toString();\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tHashMap<String, Integer> hm;\\n\\t\\tList<TreeNode> ansLst;\\n\\n\\t\\tpublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n\\t\\t\\thm = new HashMap<>();\\n\\t\\t\\tansLst = new ArrayList<>();\\n\\t\\t\\thelper(root, \"\");\\n\\n\\t\\t\\treturn ansLst;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1938713,
                "title": "duplicate-subtree-similar-to-serialize-tree-map-java",
                "content": "```\\n\\nclass Solution {\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        \\n     Map<String, Integer> map = new HashMap<>();   \\n     \\n     List<TreeNode> list = new ArrayList<>();    \\n        \\n     serialize(root, map, list);\\n        \\n        return list;\\n        \\n    }\\n    \\n    \\n    public String serialize(TreeNode root, Map<String, Integer> map, List<TreeNode> list)\\n    {\\n        if(root == null)\\n            return \"x\";\\n        \\n        String left = serialize(root.left, map, list);\\n        String right = serialize(root.right, map, list);\\n        \\n        String str = root.val + \"-\"+ left +\"-\"+right;\\n        \\n        map.put(str, map.getOrDefault(str,0)+1);\\n         \\n        if(map.get(str) == 2)\\n            list.add(root);\\n        \\n        return str;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        \\n     Map<String, Integer> map = new HashMap<>();   \\n     \\n     List<TreeNode> list = new ArrayList<>();    \\n        \\n     serialize(root, map, list);\\n        \\n        return list;\\n        \\n    }\\n    \\n    \\n    public String serialize(TreeNode root, Map<String, Integer> map, List<TreeNode> list)\\n    {\\n        if(root == null)\\n            return \"x\";\\n        \\n        String left = serialize(root.left, map, list);\\n        String right = serialize(root.right, map, list);\\n        \\n        String str = root.val + \"-\"+ left +\"-\"+right;\\n        \\n        map.put(str, map.getOrDefault(str,0)+1);\\n         \\n        if(map.get(str) == 2)\\n            list.add(root);\\n        \\n        return str;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895183,
                "title": "c-clean-o-n-solution-using-postorder-traversal-map",
                "content": "```\\nvector<TreeNode*> duplicateSubtrees;\\n    unordered_map<string, int> mp;\\n    \\n    string postorder(TreeNode* root) {\\n        if(!root) return \"\";\\n        \\n        string left = postorder(root->left);\\n        string right = postorder(root->right);\\n        \\n        string current = to_string(root->val) + \"L\" + left + \"R\" + right;\\n        \\n        if(mp.find(current) == mp.end()) {\\n            mp.insert({current,1});\\n        } else {\\n            if(mp[current] == 1) duplicateSubtrees.push_back(root);\\n            mp[current]++;\\n        }\\n        return current;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        postorder(root);\\n        return duplicateSubtrees;\\n    }\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nvector<TreeNode*> duplicateSubtrees;\\n    unordered_map<string, int> mp;\\n    \\n    string postorder(TreeNode* root) {\\n        if(!root) return \"\";\\n        \\n        string left = postorder(root->left);\\n        string right = postorder(root->right);\\n        \\n        string current = to_string(root->val) + \"L\" + left + \"R\" + right;\\n        \\n        if(mp.find(current) == mp.end()) {\\n            mp.insert({current,1});\\n        } else {\\n            if(mp[current] == 1) duplicateSubtrees.push_back(root);\\n            mp[current]++;\\n        }\\n        return current;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        postorder(root);\\n        return duplicateSubtrees;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876513,
                "title": "python",
                "content": "\\n    def findDuplicateSubtrees(self, root):\\n        result, dict1 = [], defaultdict(int)\\n        \\n        def dfs(node):\\n            if not node:\\n                return \"None\"\\n            \\n            path = str(node.val)\\n            \\n            path += \".\" + dfs(node.left)\\n                \\n            path += \".\" + dfs(node.right)\\n            \\n            dict1[path] += 1\\n            \\n            if dict1[path] == 2:\\n                result.append(node)\\n                \\n            return path\\n\\t\\t\\n        dfs(root)\\n        \\n        return result",
                "solutionTags": [],
                "code": "\\n    def findDuplicateSubtrees(self, root):\\n        result, dict1 = [], defaultdict(int)\\n        \\n        def dfs(node):\\n            if not node:\\n                return \"None\"\\n            \\n            path = str(node.val)\\n            \\n            path += \".\" + dfs(node.left)\\n                \\n            path += \".\" + dfs(node.right)\\n            \\n            dict1[path] += 1\\n            \\n            if dict1[path] == 2:\\n                result.append(node)\\n                \\n            return path\\n\\t\\t\\n        dfs(root)\\n        \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 1864158,
                "title": "java-o-n-using-map-and-set",
                "content": "```java\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Set<String> subTrees= new HashSet();\\n        Map<String, TreeNode> duplicates = new HashMap();\\n      \\n        traverseTree(root, subTrees, duplicates);\\n        List<TreeNode> nodes = new ArrayList();\\n        for(String key:duplicates.keySet()){\\n            nodes.add(duplicates.get(key));\\n        }\\n        return nodes;\\n    }\\n    public String  traverseTree(TreeNode node, Set<String> subTrees, Map<String, TreeNode> duplicates){\\n        if(node==null){\\n            return \"\";\\n        }\\n        String subTree = \"\" + node.val;\\n        subTree = subTree + \",\" + traverseTree(node.left, subTrees, duplicates);\\n        subTree = subTree + \",\" + traverseTree(node.right, subTrees, duplicates);\\n        if(subTrees.contains(subTree)){\\n            duplicates.put(subTree, node);\\n        }\\n        subTrees.add(subTree);   \\n        return subTree;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Set<String> subTrees= new HashSet();\\n        Map<String, TreeNode> duplicates = new HashMap();\\n      \\n        traverseTree(root, subTrees, duplicates);\\n        List<TreeNode> nodes = new ArrayList();\\n        for(String key:duplicates.keySet()){\\n            nodes.add(duplicates.get(key));\\n        }\\n        return nodes;\\n    }\\n    public String  traverseTree(TreeNode node, Set<String> subTrees, Map<String, TreeNode> duplicates){\\n        if(node==null){\\n            return \"\";\\n        }\\n        String subTree = \"\" + node.val;\\n        subTree = subTree + \",\" + traverseTree(node.left, subTrees, duplicates);\\n        subTree = subTree + \",\" + traverseTree(node.right, subTrees, duplicates);\\n        if(subTrees.contains(subTree)){\\n            duplicates.put(subTree, node);\\n        }\\n        subTrees.add(subTree);   \\n        return subTree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800770,
                "title": "java-map-solution-easy",
                "content": "class Solution {\\n    Map<String, Integer> dupMap = new HashMap<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> resultList = new ArrayList<>();\\n        findDup(root, resultList);\\n        return resultList;\\n    }\\n\\n    public String findDup(TreeNode root, List<TreeNode> resultList) {\\n        if(root == null) {\\n            return \"null\";\\n        }\\n        String left = findDup(root.left, resultList);\\n        String right = findDup(root.right, resultList);\\n        String str = root.val + \":\" + left + \":\" + right;\\n        dupMap.merge(str, 1, Integer::sum);\\n        if(dupMap.get(str) == 2) {\\n            resultList.add(root);\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<String, Integer> dupMap = new HashMap<>();\\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> resultList = new ArrayList<>();\\n        findDup(root, resultList);\\n        return resultList;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1793291,
                "title": "python-solution-simple-code-with-explanation",
                "content": "All we have to do is traversing every node by dfs and checking whether current node\\'s structure is already seen or not.\\n\\nThen, we need to come up with a way to \\'represent\\' a tree\\'s structure. Here, we use a string to represent the tree structure. --> str(node.val) + (left tree structure) + (right tree structure)\\n\\nIf it is a new string, we add to our dictionary (self.dp).\\n\\nIf it is a already seen string, we check if it is seen for the second time with its value (self.dp[string]).\\n\\nTime complexity: O(N)\\n\\nSpace Complexity: O(N)\\n\\n```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        self.dp = {}\\n        self.ret = []\\n        self.dfs(root)\\n        return self.ret\\n        \\n    def dfs(self, node):\\n        if not node:\\n            return \"\"\\n        left, right = self.dfs(node.left), self.dfs(node.right)\\n        ret = str(node.val) + \\'(\\' + left + \\')\\' + \\'(\\' + right + \\')\\'\\n        if ret not in self.dp:\\n            self.dp[ret] = True\\n        else:\\n            if self.dp[ret]:\\n                self.ret.append(node)\\n                self.dp[ret] = False\\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n        self.dp = {}\\n        self.ret = []\\n        self.dfs(root)\\n        return self.ret\\n        \\n    def dfs(self, node):\\n        if not node:\\n            return \"\"\\n        left, right = self.dfs(node.left), self.dfs(node.right)\\n        ret = str(node.val) + \\'(\\' + left + \\')\\' + \\'(\\' + right + \\')\\'\\n        if ret not in self.dp:\\n            self.dp[ret] = True\\n        else:\\n            if self.dp[ret]:\\n                self.ret.append(node)\\n                self.dp[ret] = False\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762610,
                "title": "serializing-the-tree-o-n-solution",
                "content": "Serializing the tree and then checking if the serialized string has already been created or not.\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> res;\\n    unordered_map<string,int> us;\\n    string solve(TreeNode*root){\\n        if(!root){\\n            return \"$\";\\n        }\\n        \\n        string l=solve(root->left);\\n        string r=solve(root->right);\\n        \\n        string s=to_string(root->val)+\" \"+l+r;\\n    \\n        us[s]++;\\n        if(us[s]==2){\\n            res.push_back(root);\\n        }\\n        return s;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> res;\\n    unordered_map<string,int> us;\\n    string solve(TreeNode*root){\\n        if(!root){\\n            return \"$\";\\n        }\\n        \\n        string l=solve(root->left);\\n        string r=solve(root->right);\\n        \\n        string s=to_string(root->val)+\" \"+l+r;\\n    \\n        us[s]++;\\n        if(us[s]==2){\\n            res.push_back(root);\\n        }\\n        return s;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747150,
                "title": "tree-traversal-postorder-java-hashmap-with-comments",
                "content": "```\\nclass Solution {\\n     HashMap<String, Integer> map = null;\\n     List<TreeNode> result = null;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        // the plan is to store all the unique pattern in hashmap while we traverse the tree. Using postorder to start from smaller problem and build towards the top.\\n        map = new HashMap<>();\\n        result = new ArrayList<>();\\n        \\n        findDuplicates(root);\\n        return result;\\n    }\\n    \\n    public String findDuplicates(TreeNode root){\\n        \\n        // can return anything doesn\\'t matter.\\n        if(root == null) return \"x\";\\n        \\n        String left = findDuplicates(root.left);\\n        String right = findDuplicates(root.right);\\n        // form a string pattern to have unique hashcode pattern to store in hashmap.\\n        String temp = String.valueOf(root.val) + \"*\"+left +\"*\"+ right;\\n        // if we find a existing string with count 1 then we add as duplicate. ==1 check is to avoid adding the duplicates multiple time to result list.\\n        if(map.getOrDefault(temp, 0) == 1){\\n            result.add(root);\\n        }\\n        map.put(temp, map.getOrDefault(temp, 0)+1);\\n        // return the pattern to the parent recursion func.\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n     HashMap<String, Integer> map = null;\\n     List<TreeNode> result = null;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        // the plan is to store all the unique pattern in hashmap while we traverse the tree. Using postorder to start from smaller problem and build towards the top.\\n        map = new HashMap<>();\\n        result = new ArrayList<>();\\n        \\n        findDuplicates(root);\\n        return result;\\n    }\\n    \\n    public String findDuplicates(TreeNode root){\\n        \\n        // can return anything doesn\\'t matter.\\n        if(root == null) return \"x\";\\n        \\n        String left = findDuplicates(root.left);\\n        String right = findDuplicates(root.right);\\n        // form a string pattern to have unique hashcode pattern to store in hashmap.\\n        String temp = String.valueOf(root.val) + \"*\"+left +\"*\"+ right;\\n        // if we find a existing string with count 1 then we add as duplicate. ==1 check is to avoid adding the duplicates multiple time to result list.\\n        if(map.getOrDefault(temp, 0) == 1){\\n            result.add(root);\\n        }\\n        map.put(temp, map.getOrDefault(temp, 0)+1);\\n        // return the pattern to the parent recursion func.\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742658,
                "title": "java-easy-solution-hashmap-fast",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    \\n    \\n    HashMap<String,Integer> map=new HashMap<>();\\n    List<TreeNode> result=new ArrayList<>();\\n    String visit(TreeNode node){\\n        if (node==null) return \"\";\\n        int cur=node.val;\\n        String left=visit(node.left);\\n        String right =visit(node.right);\\n        String rep=cur+\",\"+left+\",\"+right;\\n        if (map.getOrDefault(rep,0)==1)\\n            result.add(node);\\n        map.put(rep,map.getOrDefault(rep,0)+1);\\n        return rep;\\n    }\\n    \\n    \\n    \\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        visit(root);\\n        return result;\\n    }\\n    \\n   }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    \\n    \\n    HashMap<String,Integer> map=new HashMap<>();\\n    List<TreeNode> result=new ArrayList<>();\\n    String visit(TreeNode node){\\n        if (node==null) return \"\";\\n        int cur=node.val;\\n        String left=visit(node.left);\\n        String right =visit(node.right);\\n        String rep=cur+\",\"+left+\",\"+right;\\n        if (map.getOrDefault(rep,0)==1)\\n            result.add(node);\\n        map.put(rep,map.getOrDefault(rep,0)+1);\\n        return rep;\\n    }\\n    \\n    \\n    \\n\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        visit(root);\\n        return result;\\n    }\\n    \\n   }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736958,
                "title": "keep-a-track-of-subtree-hash-not-the-subtree-serialized-string-for-efficiency",
                "content": "```\\nclass Solution {\\npublic:\\n    // From boost\\n    template <class T>\\n    inline void hash_combine(std::size_t& seed, const T& v) {\\n        std::hash<T> hasher;\\n        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        // one approach can serialize every subtree, and see if that matches\\n        \\n        typedef pair<TreeNode*,int> Pair;\\n        unordered_map<size_t,Pair> s;\\n        vector<TreeNode*> ret;        \\n        \\n        stringstream ss;\\n        \\n        function<size_t(TreeNode*)> serialize = [&](TreeNode* root) {\\n            size_t ss=5381;\\n            if(!root) { hash_combine(ss, \\'.\\'); hash_combine(ss, \\' \\'); return ss; }\\n            hash_combine(ss, to_string(root->val)); hash_combine(ss, \\' \\');\\n            hash_combine(ss, serialize(root->left));\\n            hash_combine(ss, serialize(root->right));\\n            \\n            auto it = s.find(ss);\\n            if(it != s.end()) { ++it->second.second; }\\n            else { s.emplace(ss, Pair{root, 1}); }\\n            return ss;\\n        };\\n        \\n        serialize(root);        \\n        for(auto& iter: s) { if(iter.second.second>1) ret.push_back(iter.second.first); }\\n        \\n        return move(ret);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // From boost\\n    template <class T>\\n    inline void hash_combine(std::size_t& seed, const T& v) {\\n        std::hash<T> hasher;\\n        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        // one approach can serialize every subtree, and see if that matches\\n        \\n        typedef pair<TreeNode*,int> Pair;\\n        unordered_map<size_t,Pair> s;\\n        vector<TreeNode*> ret;        \\n        \\n        stringstream ss;\\n        \\n        function<size_t(TreeNode*)> serialize = [&](TreeNode* root) {\\n            size_t ss=5381;\\n            if(!root) { hash_combine(ss, \\'.\\'); hash_combine(ss, \\' \\'); return ss; }\\n            hash_combine(ss, to_string(root->val)); hash_combine(ss, \\' \\');\\n            hash_combine(ss, serialize(root->left));\\n            hash_combine(ss, serialize(root->right));\\n            \\n            auto it = s.find(ss);\\n            if(it != s.end()) { ++it->second.second; }\\n            else { s.emplace(ss, Pair{root, 1}); }\\n            return ss;\\n        };\\n        \\n        serialize(root);        \\n        for(auto& iter: s) { if(iter.second.second>1) ret.push_back(iter.second.first); }\\n        \\n        return move(ret);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683313,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n     val map=mutableMapOf<String,Int>()\\n     val list=mutableListOf<TreeNode>()\\n    fun findDuplicateSubtrees(root: TreeNode?): List<TreeNode?> {\\n        val subPath=findPath(root)\\n        return list\\n    }\\n    \\n    fun findPath(root: TreeNode?):String{\\n        if(root==null){\\n            return \"$\"\\n        }\\n        val pathLeft=findPath(root.left)\\n        val pathRight=findPath(root.right)\\n        val rootVal=root.`val`\\n        val subPath=\"$rootVal $pathLeft $pathRight\"\\n        var count=map.getOrDefault(subPath,0)\\n        map[subPath]=++count\\n        if(map.get(subPath)==2){\\n            list.add(root)\\n        }\\n        return subPath\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     val map=mutableMapOf<String,Int>()\\n     val list=mutableListOf<TreeNode>()\\n    fun findDuplicateSubtrees(root: TreeNode?): List<TreeNode?> {\\n        val subPath=findPath(root)\\n        return list\\n    }\\n    \\n    fun findPath(root: TreeNode?):String{\\n        if(root==null){\\n            return \"$\"\\n        }\\n        val pathLeft=findPath(root.left)\\n        val pathRight=findPath(root.right)\\n        val rootVal=root.`val`\\n        val subPath=\"$rootVal $pathLeft $pathRight\"\\n        var count=map.getOrDefault(subPath,0)\\n        map[subPath]=++count\\n        if(map.get(subPath)==2){\\n            list.add(root)\\n        }\\n        return subPath\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620648,
                "title": "o-n-2-preorder-solution-using-python-3",
                "content": "```\\ndef findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n\\tdic = {}\\n\\n\\tdef preorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn \"null\"\\n\\t\\treturn str(root.val)+\"-\"+preorder(root.left)+\"-\"+preorder(root.right)\\n\\n\\tstack = [root]\\n\\tres = []\\n\\twhile stack:\\n\\t\\tnode = stack.pop()\\n\\t\\tpre = preorder(node)\\n\\n\\t\\tif node.val not in dic:\\n\\t\\t\\tdic[node.val] = {}\\n\\t\\t\\tdic[node.val][pre] = 1\\n\\t\\telse:\\n\\t\\t\\tif pre in dic[node.val]:\\n\\t\\t\\t\\tif dic[node.val][pre]==1:\\n\\t\\t\\t\\t\\tres.append(node)\\n\\t\\t\\t\\t\\tdic[node.val][pre]+=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdic[node.val][pre] = 1\\n\\n\\t\\tif node.left:\\n\\t\\t\\tstack.append(node.left)\\n\\t\\tif node.right:\\n\\t\\t\\tstack.append(node.right)\\n\\n\\treturn res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n\\tdic = {}\\n\\n\\tdef preorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn \"null\"\\n\\t\\treturn str(root.val)+\"-\"+preorder(root.left)+\"-\"+preorder(root.right)\\n\\n\\tstack = [root]\\n\\tres = []\\n\\twhile stack:\\n\\t\\tnode = stack.pop()\\n\\t\\tpre = preorder(node)\\n\\n\\t\\tif node.val not in dic:\\n\\t\\t\\tdic[node.val] = {}\\n\\t\\t\\tdic[node.val][pre] = 1\\n\\t\\telse:\\n\\t\\t\\tif pre in dic[node.val]:\\n\\t\\t\\t\\tif dic[node.val][pre]==1:\\n\\t\\t\\t\\t\\tres.append(node)\\n\\t\\t\\t\\t\\tdic[node.val][pre]+=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdic[node.val][pre] = 1\\n\\n\\t\\tif node.left:\\n\\t\\t\\tstack.append(node.left)\\n\\t\\tif node.right:\\n\\t\\t\\tstack.append(node.right)\\n\\n\\treturn res\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1515232,
                "title": "use-hash-function-and-hash-map-to-store-all-duplicates",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private Map<String, List<TreeNode>> map;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        String treeHash = getHash(root);\\n        \\n        List<TreeNode> duplicates = new ArrayList<>();\\n        for (String key: this.map.keySet()) \\n            if (this.map.get(key).size() > 1)\\n                duplicates.add(this.map.get(key).get(0));\\n        return duplicates;\\n    }\\n    \\n    private String getHash(TreeNode root) {\\n        if (root == null)\\n            return \"null\";\\n        \\n        String leftHash = getHash(root.left);\\n        String rightHash = getHash(root.right);\\n        String hash = \"|\" + leftHash + \"L\" + root.val + \"R\" + rightHash + \"|\";\\n        if (!this.map.containsKey(hash))\\n            this.map.put(hash, new ArrayList<>());\\n        this.map.get(hash).add(root);\\n        return hash;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private Map<String, List<TreeNode>> map;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        this.map = new HashMap<>();\\n        String treeHash = getHash(root);\\n        \\n        List<TreeNode> duplicates = new ArrayList<>();\\n        for (String key: this.map.keySet()) \\n            if (this.map.get(key).size() > 1)\\n                duplicates.add(this.map.get(key).get(0));\\n        return duplicates;\\n    }\\n    \\n    private String getHash(TreeNode root) {\\n        if (root == null)\\n            return \"null\";\\n        \\n        String leftHash = getHash(root.left);\\n        String rightHash = getHash(root.right);\\n        String hash = \"|\" + leftHash + \"L\" + root.val + \"R\" + rightHash + \"|\";\\n        if (!this.map.containsKey(hash))\\n            this.map.put(hash, new ArrayList<>());\\n        this.map.get(hash).add(root);\\n        return hash;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443405,
                "title": "very-simple-java-solution-using-hashmap-and-arraylist",
                "content": "### **class Solution\\n### {\\n###     HashMap<String,Integer> map = new HashMap<>();\\n###     ArrayList<TreeNode> list = new ArrayList<>();\\n###     public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n###     {\\n###         duplicate(root);\\n###         return list;\\n###     }\\n###     String duplicate(TreeNode node)\\n###     {\\n###         if(node==null)\\n###         {\\n###             return \"X\";\\n###         }\\n###         \\n###         String l = duplicate(node.left);\\n###         String r = duplicate(node.right);\\n###         \\n###         String s =Integer.toString(node.val)+\"-\"+l+\"-\"+r;\\n###         map.put(s,map.getOrDefault(s,0)+1);\\n###         \\n###         if(map.get(s)==2)\\n###         {\\n###             list.add(node);\\n###         }\\n###         return s;\\n###     }\\n### }**",
                "solutionTags": [],
                "code": "class Solution\\n### {\\n###     HashMap<String,Integer> map = new HashMap<>();\\n###     ArrayList<TreeNode> list = new ArrayList<>();\\n###     public List<TreeNode> findDuplicateSubtrees(TreeNode root) \\n###     {\\n###         duplicate(root);\\n###         return list;\\n###     }",
                "codeTag": "Java"
            },
            {
                "id": 1403208,
                "title": "java-20ms-dfs",
                "content": "```\\n\\nclass Solution {\\n    List<TreeNode> result;\\n    Map<String,Integer> map;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        map=new HashMap<>();\\n        result=new LinkedList<>();\\n        traverse(root);\\n        return result;\\n    }\\n    \\n    String traverse(TreeNode root){\\n        if(root==null){\\n            return \"N\";\\n        }\\n        String value=root.val+\",\"+traverse(root.left)+\",\"+traverse(root.right);\\n        map.put(value,map.getOrDefault(value,0)+1);\\n        if(map.get(value)==2){\\n            result.add(root);\\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    List<TreeNode> result;\\n    Map<String,Integer> map;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        map=new HashMap<>();\\n        result=new LinkedList<>();\\n        traverse(root);\\n        return result;\\n    }\\n    \\n    String traverse(TreeNode root){\\n        if(root==null){\\n            return \"N\";\\n        }\\n        String value=root.val+\",\"+traverse(root.left)+\",\"+traverse(root.right);\\n        map.put(value,map.getOrDefault(value,0)+1);\\n        if(map.get(value)==2){\\n            result.add(root);\\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381129,
                "title": "simple-code-using-recursion-map-and-string-conversion",
                "content": "```\\nclass Solution {\\npublic:\\n    string solve(TreeNode* root, unordered_map<string,vector<TreeNode*>> &mp){\\n        if(!root) return \"$\";\\n        \\n        string s = \"\";\\n        \\n        if(!root->left && !root->right){\\n            s = to_string(root->val);\\n            mp[s].push_back(root);\\n            return s;\\n        }\\n        \\n        s += to_string(root->val) + \" \" + solve(root->left, mp) + solve(root->right, mp); \\n        \\n        mp[s].push_back(root);\\n        \\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector <TreeNode*> ans;\\n        unordered_map<string,vector<TreeNode*>> mp;\\n        solve(root, mp);\\n        \\n        for(auto i:mp){\\n            if(i.second.size() > 1)\\n                ans.push_back(i.second[0]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(TreeNode* root, unordered_map<string,vector<TreeNode*>> &mp){\\n        if(!root) return \"$\";\\n        \\n        string s = \"\";\\n        \\n        if(!root->left && !root->right){\\n            s = to_string(root->val);\\n            mp[s].push_back(root);\\n            return s;\\n        }\\n        \\n        s += to_string(root->val) + \" \" + solve(root->left, mp) + solve(root->right, mp); \\n        \\n        mp[s].push_back(root);\\n        \\n        return s;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector <TreeNode*> ans;\\n        unordered_map<string,vector<TreeNode*>> mp;\\n        solve(root, mp);\\n        \\n        for(auto i:mp){\\n            if(i.second.size() > 1)\\n                ans.push_back(i.second[0]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280162,
                "title": "java-serialization",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n\\n\\nclass Solution {\\n    \\n    // Two (or more) duplicate sub trees will serialize to the same content.\\n    // We need to serialize each sub tree we pass, and count how many ocurrances of same content\\n    // we encounter\\n    // if we encounter twice - we will add the root of the sub tree to the result list (we should add only one node, so we must check that the counts equals two, and not  bigger than one\\n    \\n    Map<String, Integer> countsMap = new HashMap<>();\\n    List<TreeNode> dups = new ArrayList<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n       serialize(root);\\n        return dups;\\n    }\\n    \\n    private String serialize(TreeNode node) {\\n        StringBuilder sb = new StringBuilder();\\n        if (node == null) {\\n            return \"[]\";\\n        }\\n        sb.append(\"[\");\\n        sb.append(node.val);\\n        sb.append(\", l: \");\\n        sb.append(serialize(node.left));\\n        sb.append(\", r: \"); \\n        sb.append(serialize(node.right));\\n        sb.append(\"]\");\\n        String result = sb.toString();\\n        countsMap.put(result, countsMap.getOrDefault(result, 0) + 1);\\n        if (countsMap.get(result) == 2) {\\n            dups.add(node); \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n\\n\\nclass Solution {\\n    \\n    // Two (or more) duplicate sub trees will serialize to the same content.\\n    // We need to serialize each sub tree we pass, and count how many ocurrances of same content\\n    // we encounter\\n    // if we encounter twice - we will add the root of the sub tree to the result list (we should add only one node, so we must check that the counts equals two, and not  bigger than one\\n    \\n    Map<String, Integer> countsMap = new HashMap<>();\\n    List<TreeNode> dups = new ArrayList<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n       serialize(root);\\n        return dups;\\n    }\\n    \\n    private String serialize(TreeNode node) {\\n        StringBuilder sb = new StringBuilder();\\n        if (node == null) {\\n            return \"[]\";\\n        }\\n        sb.append(\"[\");\\n        sb.append(node.val);\\n        sb.append(\", l: \");\\n        sb.append(serialize(node.left));\\n        sb.append(\", r: \"); \\n        sb.append(serialize(node.right));\\n        sb.append(\"]\");\\n        String result = sb.toString();\\n        countsMap.put(result, countsMap.getOrDefault(result, 0) + 1);\\n        if (countsMap.get(result) == 2) {\\n            dups.add(node); \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200283,
                "title": "python-postorder-traversal-with-custom-hash-function-o-n-time-o-n-space",
                "content": "# Algorithm\\n1. Define a custom hash function that depends on the\\n\\t* Value of the node, and\\n\\t* Hash values and topology of the node\\'s children.\\n2. Use postorder traversal to compute the custom hash function.\\n3. Create a custom `HashedNode` holder class to\\n\\t* hold the `TreeNode`  and custom hash value, and\\n\\t* Implement Python\\'s `__eq__()` and `__hash__()` functions for use with the standard library data structures.\\n\\n# Complexity\\n## Time\\n`O(n)` Each node is visted exactly once.\\n## Space\\n`O(n)` We create at most one auxilary object per node.\\n\\n# Code\\n```python\\nfrom collections import Counter\\n\\n# Holder class for a node and our computed hash function.\\nclass HashedNode:\\n    def __init__(self, node: TreeNode, hashVal: int):\\n        self.node = node\\n        self.hashVal = hashVal\\n        \\n    def __hash__(self) -> int:\\n        return self.hashVal\\n    \\n    def __eq__(self, other) -> bool:\\n        return self.hashVal == other.hashVal\\n\\nclass Solution:\\n    \\n    # Use post order traversal to:\\n    # (A) Generate hash based on hash of nodes below.\\n    # (B) Create the corresponding HashedNode() and insert into self.hashNodeCounter.\\n    # (C) Return own hash for the use of nodes above.\\n    def dfs(self, node: TreeNode) -> int:\\n        # Avoid dengenerate multiplicitive hashing when node.val == 0.\\n        nodeValHash = 201 + node.val\\n        if node.left and node.right:\\n            hashVal = 97 * self.dfs(node.left) + 101 * self.dfs(node.right) + 89 * hash(nodeValHash)\\n        elif node.right:\\n            hashVal = 103 * self.dfs(node.right) + 107 * hash(nodeValHash)\\n        elif node.left:\\n            hashVal = 113 * self.dfs(node.left) + 127 * hash(nodeValHash)\\n        else:\\n            hashVal = 131 * hash(nodeValHash)\\n\\t\\t\\t\\n\\t\\t# OPTIONAL: Python uses arbitrary precision integer arithmetic, so there is no\\n\\t\\t# need to avoid overflow.  For other languages, we need to reduce the output modulo a\\n\\t\\t# prime. (Our prime is ~31 bits, so this will not stop an overflow in the above hash caclulation\\n\\t\\t# on 32 bit systems. To avoid overflow on 32 bit systems, appy modular reduction after \\n\\t\\t# each arithmetic step above)\\n\\t\\thashVal = hashVal // 1721839771\\n        \\n        hashedNode = HashedNode(node, hashVal)\\n        self.hashNodeCounter[hashedNode] += 1\\n        return hashVal\\n        \\n        \\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        self.hashNodeCounter = Counter()\\n        self.dfs(root)\\n        \\n        # Find nodes that occur more than once.\\n        out: List[ListNode] = []\\n        for entry in self.hashNodeCounter:\\n            if self.hashNodeCounter[entry] > 1:\\n                out +=[entry.node]\\n        return out\\n```\\n## Edit: Bugfix\\nUpdated to highlight potential for integer overflow when working in languages without arbitrary precision arithmetic support. Thanks @danielsoner.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\n# Holder class for a node and our computed hash function.\\nclass HashedNode:\\n    def __init__(self, node: TreeNode, hashVal: int):\\n        self.node = node\\n        self.hashVal = hashVal\\n        \\n    def __hash__(self) -> int:\\n        return self.hashVal\\n    \\n    def __eq__(self, other) -> bool:\\n        return self.hashVal == other.hashVal\\n\\nclass Solution:\\n    \\n    # Use post order traversal to:\\n    # (A) Generate hash based on hash of nodes below.\\n    # (B) Create the corresponding HashedNode() and insert into self.hashNodeCounter.\\n    # (C) Return own hash for the use of nodes above.\\n    def dfs(self, node: TreeNode) -> int:\\n        # Avoid dengenerate multiplicitive hashing when node.val == 0.\\n        nodeValHash = 201 + node.val\\n        if node.left and node.right:\\n            hashVal = 97 * self.dfs(node.left) + 101 * self.dfs(node.right) + 89 * hash(nodeValHash)\\n        elif node.right:\\n            hashVal = 103 * self.dfs(node.right) + 107 * hash(nodeValHash)\\n        elif node.left:\\n            hashVal = 113 * self.dfs(node.left) + 127 * hash(nodeValHash)\\n        else:\\n            hashVal = 131 * hash(nodeValHash)\\n\\t\\t\\t\\n\\t\\t# OPTIONAL: Python uses arbitrary precision integer arithmetic, so there is no\\n\\t\\t# need to avoid overflow.  For other languages, we need to reduce the output modulo a\\n\\t\\t# prime. (Our prime is ~31 bits, so this will not stop an overflow in the above hash caclulation\\n\\t\\t# on 32 bit systems. To avoid overflow on 32 bit systems, appy modular reduction after \\n\\t\\t# each arithmetic step above)\\n\\t\\thashVal = hashVal // 1721839771\\n        \\n        hashedNode = HashedNode(node, hashVal)\\n        self.hashNodeCounter[hashedNode] += 1\\n        return hashVal\\n        \\n        \\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        self.hashNodeCounter = Counter()\\n        self.dfs(root)\\n        \\n        # Find nodes that occur more than once.\\n        out: List[ListNode] = []\\n        for entry in self.hashNodeCounter:\\n            if self.hashNodeCounter[entry] > 1:\\n                out +=[entry.node]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193153,
                "title": "python-serialize",
                "content": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        subTreeToNodeMap = collections.defaultdict(int)\\n        result = []\\n\\n        def inorder(root):\\n            if root is None:\\n                return \"E\"\\n\\n            leftSubtree = inorder(root.left)\\n            rightSubtree = inorder(root.right)\\n            currentSubree = \\'L\\' + leftSubtree + \\'M\\' + str(root.val) + \\'R\\' + rightSubtree\\n            subTreeToNodeMap[currentSubree] += 1\\n\\n            if subTreeToNodeMap[currentSubree] == 2:\\n                result.append(root)\\n\\n            return currentSubree\\n\\n        inorder(root)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        subTreeToNodeMap = collections.defaultdict(int)\\n        result = []\\n\\n        def inorder(root):\\n            if root is None:\\n                return \"E\"\\n\\n            leftSubtree = inorder(root.left)\\n            rightSubtree = inorder(root.right)\\n            currentSubree = \\'L\\' + leftSubtree + \\'M\\' + str(root.val) + \\'R\\' + rightSubtree\\n            subTreeToNodeMap[currentSubree] += 1\\n\\n            if subTreeToNodeMap[currentSubree] == 2:\\n                result.append(root)\\n\\n            return currentSubree\\n\\n        inorder(root)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130357,
                "title": "java-o-n-using-key-compression",
                "content": "O(n)\\n\\n``` \\n\\tprivate List<TreeNode> sln3 (TreeNode root){\\n        Map<String, Integer> map = new HashMap<>();\\n        Map<String, String> map2 = new HashMap<>();\\n        List<TreeNode> res = new ArrayList<>();\\n        int[] id = new int[]{0};\\n        dfs3(root, map, map2, res, id);\\n        return res;\\n    }\\n    \\n    private String dfs3(TreeNode root, Map<String, Integer> map, Map<String, String> map2, List<TreeNode> res , int[] id){\\n        if(root == null) return \"#\";\\n        String l = dfs3(root.left, map,map2, res, id);\\n        String r = dfs3(root.right, map, map2, res, id);\\n        \\n        String rawKey = \"(\"+l+\",\"+root.val+\",\"+r+\")\";\\n        map.merge(rawKey, 1, Integer::sum);\\n        if(map.get(rawKey)==2) res.add(root);\\n        else if(map.get(rawKey)==1) map2.put(rawKey, \"K\"+(id[0]++)); //compress the key in to O(1) space key\\n        return map2.get(rawKey);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "O(n)\\n\\n``` \\n\\tprivate List<TreeNode> sln3 (TreeNode root){\\n        Map<String, Integer> map = new HashMap<>();\\n        Map<String, String> map2 = new HashMap<>();\\n        List<TreeNode> res = new ArrayList<>();\\n        int[] id = new int[]{0};\\n        dfs3(root, map, map2, res, id);\\n        return res;\\n    }\\n    \\n    private String dfs3(TreeNode root, Map<String, Integer> map, Map<String, String> map2, List<TreeNode> res , int[] id){\\n        if(root == null) return \"#\";\\n        String l = dfs3(root.left, map,map2, res, id);\\n        String r = dfs3(root.right, map, map2, res, id);\\n        \\n        String rawKey = \"(\"+l+\",\"+root.val+\",\"+r+\")\";\\n        map.merge(rawKey, 1, Integer::sum);\\n        if(map.get(rawKey)==2) res.add(root);\\n        else if(map.get(rawKey)==1) map2.put(rawKey, \"K\"+(id[0]++)); //compress the key in to O(1) space key\\n        return map2.get(rawKey);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1130346,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        unordered_map<string, int> map;\\n        helper(root, res, map);\\n        return res;\\n    }\\n    \\n    string helper(TreeNode* root, vector<TreeNode*>& res, unordered_map<string, int>& map){\\n        if(!root) return \"\";\\n        string s = to_string(root->val) + \",\" + helper(root->left, res, map) + \",\" + helper(root->right, res, map);\\n        map[s]++;\\n        if(map[s] == 2){\\n            res.push_back(root);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        unordered_map<string, int> map;\\n        helper(root, res, map);\\n        return res;\\n    }\\n    \\n    string helper(TreeNode* root, vector<TreeNode*>& res, unordered_map<string, int>& map){\\n        if(!root) return \"\";\\n        string s = to_string(root->val) + \",\" + helper(root->left, res, map) + \",\" + helper(root->right, res, map);\\n        map[s]++;\\n        if(map[s] == 2){\\n            res.push_back(root);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105437,
                "title": "java-solution-with-post-order-traversal",
                "content": "\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        if (root == null) return null;\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    Map<String, Integer> map = new HashMap<>();\\n    List<TreeNode> res = new ArrayList<>();\\n    public String traverse (TreeNode root) {\\n        if (root == null) {\\n            return \"#\";\\n        }\\n        \\n        String left = traverse(root.left);\\n        String right = traverse(root.right);\\n\\n        String rootStr = root.val + \",\" + left + \",\" + right;\\n        \\n        int freq = map.getOrDefault(rootStr, 0);\\n        if (freq == 1) {\\n            res.add(root);\\n        }\\n        map.put(rootStr, freq+1);\\n        return rootStr;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        if (root == null) return null;\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    Map<String, Integer> map = new HashMap<>();\\n    List<TreeNode> res = new ArrayList<>();\\n    public String traverse (TreeNode root) {\\n        if (root == null) {\\n            return \"#\";\\n        }\\n        \\n        String left = traverse(root.left);\\n        String right = traverse(root.right);\\n\\n        String rootStr = root.val + \",\" + left + \",\" + right;\\n        \\n        int freq = map.getOrDefault(rootStr, 0);\\n        if (freq == 1) {\\n            res.add(root);\\n        }\\n        map.put(rootStr, freq+1);\\n        return rootStr;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1090567,
                "title": "javascript-using-serialization-o-n-time",
                "content": "```javascript\\nvar findDuplicateSubtrees = function(root) {\\n    const map = new Map();\\n    const output = []\\n    \\n    function serialize(node) {\\n        if(!node) return \\'x\\';\\n        const id = node.val + \\',\\' + serialize(node.left) + \\',\\' + serialize(node.right)\\n        map.set(id, (map.get(id) || 0) + 1);\\n        if(map.get(id) === 2) output.push(node)\\n        return id;\\n    }\\n    \\n    serialize(root)\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar findDuplicateSubtrees = function(root) {\\n    const map = new Map();\\n    const output = []\\n    \\n    function serialize(node) {\\n        if(!node) return \\'x\\';\\n        const id = node.val + \\',\\' + serialize(node.left) + \\',\\' + serialize(node.right)\\n        map.set(id, (map.get(id) || 0) + 1);\\n        if(map.get(id) === 2) output.push(node)\\n        return id;\\n    }\\n    \\n    serialize(root)\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023871,
                "title": "c-easy-to-understand-solution",
                "content": "\\t1.We can encode the subtrees into a string;\\n\\t\\tin the following form - or any form. \\n\\t\\t(Root # (Left)#(Right))\\n\\n\\t2.Store each of the encoded strings into map while encoding. \\n\\t    Key->string; Value->vector of root Nodes. \\n\\n\\t3.Parse through map, and get the values with value vector size greater than 1. (duplicate subtrees)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<TreeNode*>> mp;\\n    \\n    string serialize(TreeNode* root){\\n        string res = \"\";\\n        if(root == NULL){\\n            return res;\\n        }\\n        res+= to_string(root->val)+\"#\";\\n        res+= serialize(root->left)+\"#\";\\n        res+= serialize(root->right);\\n        \\n        mp[res].push_back(root);\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        \\n        vector<TreeNode*> result;\\n        \\n        serialize(root);\\n        \\n        for(auto pr: mp){\\n            if(pr.second.size() > 1){\\n                result.push_back(pr.second[0]);\\n            }\\n        }\\n        return result;\\n     \\n    }\\n};\\n\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<TreeNode*>> mp;\\n    \\n    string serialize(TreeNode* root){\\n        string res = \"\";\\n        if(root == NULL){\\n            return res;\\n        }\\n        res+= to_string(root->val)+\"#\";\\n        res+= serialize(root->left)+\"#\";\\n        res+= serialize(root->right);\\n        \\n        mp[res].push_back(root);\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        \\n        vector<TreeNode*> result;\\n        \\n        serialize(root);\\n        \\n        for(auto pr: mp){\\n            if(pr.second.size() > 1){\\n                result.push_back(pr.second[0]);\\n            }\\n        }\\n        return result;\\n     \\n    }\\n};\\n\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 849136,
                "title": "c-faster-than-99-01-less-than-99-15-memory-usage",
                "content": "28 ms, 26.5MB.\\nUse the **height of subtree** to be the key of map (to find another subtree).\\nsametree : check if these two trees are the same or not.\\ngo : it traverse the tree, and build the map to find whether a identical subtree exists.\\n\\n```\\nclass Solution {\\n    unordered_map<int, vector<TreeNode*> > visit;\\n    unordered_set<TreeNode*> ans;\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        if(root == NULL) return {};\\n        go(root);\\n        vector<TreeNode*> ret;\\n        for(auto node : ans)\\n            ret.push_back(node);\\n        return ret;\\n    }\\n    bool sametree(TreeNode* r1, TreeNode* r2) {\\n        if(!r1 && !r2) return true;\\n        else if(!r1 || !r2) return false;\\n        if(r1->val != r2->val) return false;\\n        bool tmp = sametree(r1->left, r2->left);\\n        if(!tmp) return false;\\n        tmp = sametree(r1->right, r2->right);\\n        return tmp;\\n    }\\n    int go(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int ld = go(root->left);\\n        int rd = go(root->right);\\n        int dep = max(ld, rd) + 1;\\n        auto it = visit.find(dep);\\n        if(it == visit.end()){\\n            visit[dep].push_back(root);\\n            return dep;\\n        }\\n        for(auto node : it->second) {\\n            bool same = sametree(node, root);\\n            if(same) {\\n                ans.insert(node);\\n                return dep;\\n            }\\n        }\\n        it->second.push_back(root);\\n        return dep;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<TreeNode*> > visit;\\n    unordered_set<TreeNode*> ans;\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        if(root == NULL) return {};\\n        go(root);\\n        vector<TreeNode*> ret;\\n        for(auto node : ans)\\n            ret.push_back(node);\\n        return ret;\\n    }\\n    bool sametree(TreeNode* r1, TreeNode* r2) {\\n        if(!r1 && !r2) return true;\\n        else if(!r1 || !r2) return false;\\n        if(r1->val != r2->val) return false;\\n        bool tmp = sametree(r1->left, r2->left);\\n        if(!tmp) return false;\\n        tmp = sametree(r1->right, r2->right);\\n        return tmp;\\n    }\\n    int go(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int ld = go(root->left);\\n        int rd = go(root->right);\\n        int dep = max(ld, rd) + 1;\\n        auto it = visit.find(dep);\\n        if(it == visit.end()){\\n            visit[dep].push_back(root);\\n            return dep;\\n        }\\n        for(auto node : it->second) {\\n            bool same = sametree(node, root);\\n            if(same) {\\n                ans.insert(node);\\n                return dep;\\n            }\\n        }\\n        it->second.push_back(root);\\n        return dep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760802,
                "title": "c-solution-with-dfs",
                "content": "```\\n        private List<TreeNode> _res = new List<TreeNode>();\\n        private Dictionary<string, TreeNode> _schema = new Dictionary<string, TreeNode>();\\n\\n        public IList<TreeNode> FindDuplicateSubtrees(TreeNode root)\\n        {\\n            if (root == null) return new List<TreeNode>();\\n\\n            Dfs(root);\\n\\n            return _res.Distinct().ToList();\\n        }\\n\\n        private string Dfs(TreeNode node)\\n        {\\n            if (node == null) return \"null\";\\n\\n            var l = Dfs(node.left);\\n            var r = Dfs(node.right);\\n\\n            var schema = $\"{node.val} {l} {r}\";\\n\\n            if (_schema.ContainsKey(schema)) _res.Add(_schema[schema]);\\n            else _schema.Add(schema, node);\\n\\n            return schema;\\n        }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n        private List<TreeNode> _res = new List<TreeNode>();\\n        private Dictionary<string, TreeNode> _schema = new Dictionary<string, TreeNode>();\\n\\n        public IList<TreeNode> FindDuplicateSubtrees(TreeNode root)\\n        {\\n            if (root == null) return new List<TreeNode>();\\n\\n            Dfs(root);\\n\\n            return _res.Distinct().ToList();\\n        }\\n\\n        private string Dfs(TreeNode node)\\n        {\\n            if (node == null) return \"null\";\\n\\n            var l = Dfs(node.left);\\n            var r = Dfs(node.right);\\n\\n            var schema = $\"{node.val} {l} {r}\";\\n\\n            if (_schema.ContainsKey(schema)) _res.Add(_schema[schema]);\\n            else _schema.Add(schema, node);\\n\\n            return schema;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697891,
                "title": "simplest-c-sol-using-map",
                "content": "```\\nclass Solution {\\n    unordered_map<string, unordered_set<TreeNode*>> _map;\\n    string serialize(TreeNode* root) {\\n        if (root == NULL) return \"#\";\\n        string str = to_string(root->val)+\".\";\\n        str+=serialize(root->left);\\n        str+=serialize(root->right);\\n        _map[str].insert(root);\\n        return str;\\n    }\\n    void print(unordered_map<string, unordered_set<TreeNode*>>& _map) {\\n        for (auto elem : _map) {\\n            cout<<\"str:\"<<elem.first<<\"  nodes: {\";\\n            for (auto node : elem.second) {\\n                cout<<node->val<<\" \";\\n            }\\n            cout<<\"}\\\\n\";\\n        }\\n        cout<<endl;\\n    }\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        if (root == NULL) return res;\\n        \\n        serialize(root);\\n        for (auto elem : _map) {\\n            unordered_set<TreeNode*> _set = elem.second;\\n            if (_set.size() > 1) {\\n                res.push_back(*_set.begin());\\n            }\\n        }\\n        // print(_map);\\n        return res;\\n    }\\n};\\n\\n//map -- serialization of subtrees with the nodes\\n//two subrees having same structure and same values should have same serialization for than :\\n//1. put \\'#\\' or any other delimiting char in place of null node\\n//2. values should have some ending symbol for that i have used \\'.\\'\\n//[1,2,3] will look like : 1.2.##3.##\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, unordered_set<TreeNode*>> _map;\\n    string serialize(TreeNode* root) {\\n        if (root == NULL) return \"#\";\\n        string str = to_string(root->val)+\".\";\\n        str+=serialize(root->left);\\n        str+=serialize(root->right);\\n        _map[str].insert(root);\\n        return str;\\n    }\\n    void print(unordered_map<string, unordered_set<TreeNode*>>& _map) {\\n        for (auto elem : _map) {\\n            cout<<\"str:\"<<elem.first<<\"  nodes: {\";\\n            for (auto node : elem.second) {\\n                cout<<node->val<<\" \";\\n            }\\n            cout<<\"}\\\\n\";\\n        }\\n        cout<<endl;\\n    }\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> res;\\n        if (root == NULL) return res;\\n        \\n        serialize(root);\\n        for (auto elem : _map) {\\n            unordered_set<TreeNode*> _set = elem.second;\\n            if (_set.size() > 1) {\\n                res.push_back(*_set.begin());\\n            }\\n        }\\n        // print(_map);\\n        return res;\\n    }\\n};\\n\\n//map -- serialization of subtrees with the nodes\\n//two subrees having same structure and same values should have same serialization for than :\\n//1. put \\'#\\' or any other delimiting char in place of null node\\n//2. values should have some ending symbol for that i have used \\'.\\'\\n//[1,2,3] will look like : 1.2.##3.##\\n```",
                "codeTag": "C++"
            },
            {
                "id": 561415,
                "title": "simple-o-n-java-solution-using-post-order-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> dupes = new ArrayList<>();\\n        build(root, new HashMap<>(), dupes);\\n        return dupes;\\n    }\\n    \\n    private String build(TreeNode root, Map<String, Integer> treeByCount, List<TreeNode> dupes) {\\n        if (root == null)\\n            return \"\";\\n        \\n        String serialized = String.valueOf(root.val) \\n            + \"(\" + build(root.left, treeByCount, dupes) + \")\" \\n            + \"(\" + build(root.right, treeByCount, dupes) + \")\";\\n        int count = treeByCount.getOrDefault(serialized, 0).intValue();\\n        \\n        if (count == 1)\\n            dupes.add(root);\\n        treeByCount.put(serialized, count + 1);\\n        \\n        return serialized;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> dupes = new ArrayList<>();\\n        build(root, new HashMap<>(), dupes);\\n        return dupes;\\n    }\\n    \\n    private String build(TreeNode root, Map<String, Integer> treeByCount, List<TreeNode> dupes) {\\n        if (root == null)\\n            return \"\";\\n        \\n        String serialized = String.valueOf(root.val) \\n            + \"(\" + build(root.left, treeByCount, dupes) + \")\" \\n            + \"(\" + build(root.right, treeByCount, dupes) + \")\";\\n        int count = treeByCount.getOrDefault(serialized, 0).intValue();\\n        \\n        if (count == 1)\\n            dupes.add(root);\\n        treeByCount.put(serialized, count + 1);\\n        \\n        return serialized;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554067,
                "title": "java-one-hashmap-and-stringbuilder-to-store-intermediate-results",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list, new StringBuilder(), new HashMap<>());\\n        return list;\\n    }\\n    \\n    private StringBuilder helper(TreeNode node, List<TreeNode> list, StringBuilder sb, Map<String, Integer> map) {\\n        if (node == null) {\\n            sb.append(\\'n\\');\\n            sb.append(\\'-\\');\\n            return sb;\\n        }\\n        sb.append(node.val);\\n        sb.append(\\'-\\');\\n        StringBuilder leftSubtreeSerialized = helper(node.left, list, new StringBuilder(), map);\\n        StringBuilder rightSubtreeSerialized = helper(node.right, list, new StringBuilder(), map);\\n        sb.append(leftSubtreeSerialized);\\n        sb.append(rightSubtreeSerialized);\\n        String serialized = sb.toString();\\n        if (map.getOrDefault(serialized, 0) == 1)\\n            list.add(node);\\n        map.put(serialized, map.getOrDefault(serialized, 0) + 1);\\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list, new StringBuilder(), new HashMap<>());\\n        return list;\\n    }\\n    \\n    private StringBuilder helper(TreeNode node, List<TreeNode> list, StringBuilder sb, Map<String, Integer> map) {\\n        if (node == null) {\\n            sb.append(\\'n\\');\\n            sb.append(\\'-\\');\\n            return sb;\\n        }\\n        sb.append(node.val);\\n        sb.append(\\'-\\');\\n        StringBuilder leftSubtreeSerialized = helper(node.left, list, new StringBuilder(), map);\\n        StringBuilder rightSubtreeSerialized = helper(node.right, list, new StringBuilder(), map);\\n        sb.append(leftSubtreeSerialized);\\n        sb.append(rightSubtreeSerialized);\\n        String serialized = sb.toString();\\n        if (map.getOrDefault(serialized, 0) == 1)\\n            list.add(node);\\n        map.put(serialized, map.getOrDefault(serialized, 0) + 1);\\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517458,
                "title": "python-serialization-easy-understanding",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        # from leaf to root algorithm\\n        \"\"\"\\nAn Efficient solution based on tree serialization and hashing. The idea is to serialize subtrees as strings and store the strings in hash table. Once we find a serialized tree (which is not a leaf) already existing in hash-table, we return true.\\nBelow The implementation of above idea.\\n        \"\"\"\\n        self.pathCount=defaultdict(int)\\n        self.res=[]\\n        self.serialization(root)\\n        return self.res\\n        \\n    def serialization(self, node):\\n        if not node:\\n            return \\'*\\'\\n        path = str(node.val) + self.serialization(node.left) + self.serialization(node.right)\\n        if self.pathCount[path] == 1:\\n            self.res.append(node)\\n        self.pathCount[path] += 1\\n        \\n        return path\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        \\n        # from leaf to root algorithm\\n        \"\"\"\\nAn Efficient solution based on tree serialization and hashing. The idea is to serialize subtrees as strings and store the strings in hash table. Once we find a serialized tree (which is not a leaf) already existing in hash-table, we return true.\\nBelow The implementation of above idea.\\n        \"\"\"\\n        self.pathCount=defaultdict(int)\\n        self.res=[]\\n        self.serialization(root)\\n        return self.res\\n        \\n    def serialization(self, node):\\n        if not node:\\n            return \\'*\\'\\n        path = str(node.val) + self.serialization(node.left) + self.serialization(node.right)\\n        if self.pathCount[path] == 1:\\n            self.res.append(node)\\n        self.pathCount[path] += 1\\n        \\n        return path\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371302,
                "title": "go-hashmap-preorder-traversal-solution",
                "content": "```\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n\\tcache := make(map[string]int)\\n\\tresult := make([]*TreeNode, 0)\\n\\thelper(root, cache, &result)\\n\\treturn result\\n}\\n\\nfunc helper(root *TreeNode, cache map[string]int, result *[]*TreeNode) string {\\n\\tif root == nil {\\n\\t\\treturn \"|\"\\n\\t}\\n\\tleft, right := helper(root.Left, cache, result), helper(root.Right, cache, result)\\n\\tkey := strconv.Itoa(root.Val) + \"|\" + left + \"|\" + right\\n\\tif cache[key] == 1 {\\n\\t\\t*result = append(*result, root)\\n\\t}\\n\\tcache[key]++\\n\\treturn key\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode {\\n\\tcache := make(map[string]int)\\n\\tresult := make([]*TreeNode, 0)\\n\\thelper(root, cache, &result)\\n\\treturn result\\n}\\n\\nfunc helper(root *TreeNode, cache map[string]int, result *[]*TreeNode) string {\\n\\tif root == nil {\\n\\t\\treturn \"|\"\\n\\t}\\n\\tleft, right := helper(root.Left, cache, result), helper(root.Right, cache, result)\\n\\tkey := strconv.Itoa(root.Val) + \"|\" + left + \"|\" + right\\n\\tif cache[key] == 1 {\\n\\t\\t*result = append(*result, root)\\n\\t}\\n\\tcache[key]++\\n\\treturn key\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292100,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    map<string, TreeNode*> m;  \\n    set<TreeNode*> res; \\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        DFS(root);\\n        return vector<TreeNode*>(res.begin(), res.end()); \\n    }\\n    \\n    string DFS(TreeNode* root){\\n        if(root == NULL) return \"#\"; \\n        string v = DFS(root->left) + DFS(root->right) + to_string(root->val);\\n        if(m.count(v))\\n            res.insert(m[v]); \\n        else\\n            m[v] = root;\\n        return v; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<string, TreeNode*> m;  \\n    set<TreeNode*> res; \\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        DFS(root);\\n        return vector<TreeNode*>(res.begin(), res.end()); \\n    }\\n    \\n    string DFS(TreeNode* root){\\n        if(root == NULL) return \"#\"; \\n        string v = DFS(root->left) + DFS(root->right) + to_string(root->val);\\n        if(m.count(v))\\n            res.insert(m[v]); \\n        else\\n            m[v] = root;\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270853,
                "title": "java-clean-post-order-with-state-memoization",
                "content": "Idea similar to recursive traversal (post order due to approach of making the key - node, left_child, right_child). However we store the keys generated for very node so we don\\'t do O(N^2), but O(N) - every node visited only once, after that values are taken from cache.\\n\\nUPD: Caching keys is not neccessary cause we\\'ll be visiting every node only once. Thanks to Joik for pointing this out. \\n\\n```\\n    List<TreeNode> res;\\n\\t//count how many times we met sub-tree with exact values\\n    Map<String, Integer> count;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        res = new ArrayList();\\n        count = new HashMap();\\n        helper(root);\\n        return res;\\n    }\\n    \\n    String helper(TreeNode n) {\\n        if (n == null)\\n            return \"-\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n.val).\\n            append(helper(n.left)).\\n            append(helper(n.right));\\n        String key = sb.toString();      \\n        \\n        if (!count.containsKey(key))\\n            count.put(key, 1);\\n        else if (count.get(key) == 1) {\\n            res.add(n);\\n            count.put(key, 2);\\n        }\\n        return key;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\n    List<TreeNode> res;\\n\\t//count how many times we met sub-tree with exact values\\n    Map<String, Integer> count;\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        res = new ArrayList();\\n        count = new HashMap();\\n        helper(root);\\n        return res;\\n    }\\n    \\n    String helper(TreeNode n) {\\n        if (n == null)\\n            return \"-\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(n.val).\\n            append(helper(n.left)).\\n            append(helper(n.right));\\n        String key = sb.toString();      \\n        \\n        if (!count.containsKey(key))\\n            count.put(key, 1);\\n        else if (count.get(key) == 1) {\\n            res.add(n);\\n            count.put(key, 2);\\n        }\\n        return key;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253703,
                "title": "python-dfs-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        self.cur_id = 0\\n        self.trees = collections.defaultdict(int)\\n        self.count_id = collections.Counter()\\n        self.ans = []\\n        self.dfs(root)\\n        return self.ans\\n        \\n    def dfs(self, node: TreeNode) -> int:\\n        if node:\\n            left = self.dfs(node.left)\\n            right = self.dfs(node.right)\\n            \\n            if (node.val, left, right) not in self.trees:\\n                self.trees[(node.val, left, right)] = self.cur_id\\n                self.cur_id += 1\\n            tree_id = self.trees[(node.val, left, right)]\\n            self.count_id[tree_id] += 1\\n            if self.count_id[tree_id] == 2:\\n                self.ans.append(node)\\n            return tree_id\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\\n        self.cur_id = 0\\n        self.trees = collections.defaultdict(int)\\n        self.count_id = collections.Counter()\\n        self.ans = []\\n        self.dfs(root)\\n        return self.ans\\n        \\n    def dfs(self, node: TreeNode) -> int:\\n        if node:\\n            left = self.dfs(node.left)\\n            right = self.dfs(node.right)\\n            \\n            if (node.val, left, right) not in self.trees:\\n                self.trees[(node.val, left, right)] = self.cur_id\\n                self.cur_id += 1\\n            tree_id = self.trees[(node.val, left, right)]\\n            self.count_id[tree_id] += 1\\n            if self.count_id[tree_id] == 2:\\n                self.ans.append(node)\\n            return tree_id\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242564,
                "title": "java-beats-100-8ms",
                "content": "```\\nclass Solution {\\n    \\n    private HashMap<Long, TreeNode> cache;\\n    private HashMap<Long, TreeNode> result;\\n    \\n    private long findSubTree(TreeNode node) {\\n        if(node == null) return 31;\\n        \\n        long left = findSubTree(node.left);\\n        long right = findSubTree(node.right);\\n        long val = node.val + 5381;\\n        long hash = val + val * left + val * left * right;\\n        if(cache.containsKey(hash)) {\\n            if(!result.containsKey(hash)) {\\n                result.put(hash, node);\\n            }\\n        } else {\\n            cache.put(hash, node);\\n            //System.out.println(hash + \" \" + node);\\n        }\\n        \\n        return hash; \\n    }\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> output = new ArrayList<TreeNode>();\\n        if(root == null) return output;\\n        \\n        cache = new HashMap<Long, TreeNode>();\\n        result = new HashMap<Long, TreeNode>();\\n        \\n        findSubTree(root);\\n        \\n        for(long n : result.keySet()) {\\n            output.add(result.get(n));\\n        }\\n        \\n        cache.clear();\\n        result.clear();\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private HashMap<Long, TreeNode> cache;\\n    private HashMap<Long, TreeNode> result;\\n    \\n    private long findSubTree(TreeNode node) {\\n        if(node == null) return 31;\\n        \\n        long left = findSubTree(node.left);\\n        long right = findSubTree(node.right);\\n        long val = node.val + 5381;\\n        long hash = val + val * left + val * left * right;\\n        if(cache.containsKey(hash)) {\\n            if(!result.containsKey(hash)) {\\n                result.put(hash, node);\\n            }\\n        } else {\\n            cache.put(hash, node);\\n            //System.out.println(hash + \" \" + node);\\n        }\\n        \\n        return hash; \\n    }\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> output = new ArrayList<TreeNode>();\\n        if(root == null) return output;\\n        \\n        cache = new HashMap<Long, TreeNode>();\\n        result = new HashMap<Long, TreeNode>();\\n        \\n        findSubTree(root);\\n        \\n        for(long n : result.keySet()) {\\n            output.add(result.get(n));\\n        }\\n        \\n        cache.clear();\\n        result.clear();\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566517,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816806,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816823,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816827,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1775583,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1565982,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1817128,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816729,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1817242,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1569588,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1566517,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816806,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816823,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816827,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1775583,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1565982,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1817128,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1816729,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1817242,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1569588,
                "content": [
                    {
                        "username": "atchn",
                        "content": "The question asks to return the root of duplicate sub-trees. But, there is no clear info on whether to return both the roots in case of duplicate trees. There is also no info about when there are 3 duplicate subtrees. Needs improvement"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "> For each kind of duplicate subtrees, you only need to return the root node of any one of them. \n\nI think this part needs improving. What they _really_ mean is that we **must** return exactly one tree node per every set of duplicate sub-trees. The way it's written it leaves room to think that they would accept solutions with the nodes of multiple of the duplicate trees included. Which is not the case (I just confirmed :)). So do make sure to `unique` your results before returning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@arghyadas](/arghyadas)  His comment is from 2017, maybe there was an issue in the problem statement and they fixed it by now."
                    },
                    {
                        "username": "arghyadas",
                        "content": "even if there are n number of duplicate sub-tree, return any one root node among them"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I am so confused what I need to return for this problem. The description is very unclear."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You\\'re to return the root of duplicate subtrees. The description is slighty confusing because for every testcase it outputs a list of level order traversal of the tree.\\nBut nevertheless, you should just return the root of the subtrees and you will be fine."
                    },
                    {
                        "username": "seandeme",
                        "content": "my first badge : )"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend!"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Hints: Think of **string representation** of a tree. \\n\\nThen use a `dfs(node)` to return string reprt of the node\\'s subtree, and a hash table to check duplicated subtree along the way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Thanks, I went to do the string representation problem first. And than just slightly adjusted that code to fit for this problem as well :) "
                    },
                    {
                        "username": "timmypass99",
                        "content": "Testcase: \\nroot = [0,0,0,0,null,null,0,null,null,null,0]\\nOutput = [[0], [0,0]]\\nExpected = [[0]]\\n\\nHow come there is only 1 duplicate? I found 2 sub tree duplicates which are 0 and 0 -> 0. The leaf node and the subtree with 2 nodes."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@liu35937266](/liu35937266) Good eye. Thank you for the help. "
                    },
                    {
                        "username": "zvezdalion",
                        "content": "You might have a bug (like I did) where the order of traversal of the child nodes was not quite what you intended to write :)) The order is crucial so as to get a unique subtree representation (that distinguishes between trees with same values but different structure)."
                    },
                    {
                        "username": "liu35937266",
                        "content": "I came up with the same question, finally realized that one is [0,0,null] while the other one is[0,0,0],so they are not duplicate"
                    },
                    {
                        "username": "batsy01",
                        "content": "You have to go with tree structure, \\nhere in case of 00 -> one is 0L0 and other one is 0R0"
                    },
                    {
                        "username": "w7089",
                        "content": "The description states:\\nFor each kind of duplicate subtrees, you only need to return **the root node** of any one of them.\\n\\nHowever, when a solution is run on the test case [1,2,3,4,null,2,4,null,null,4] the expected result is \\n[[2,4],[4]] while it should be \\n[2,4]"
                    },
                    {
                        "username": "sb2302",
                        "content": "the tree [2,4] appears twice, and the subtree of that, [4], also appears three times, so both are answers to the prompt."
                    },
                    {
                        "username": "yhan310",
                        "content": "Given the output and expected output, it seems that leetcode messed up the print statement in the test lol"
                    },
                    {
                        "username": "PranavBansal",
                        "content": "Could not understand the output format at all\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "+1 badge"
                    },
                    {
                        "username": "Movsar",
                        "content": "Congratulations my friend! :)"
                    },
                    {
                        "username": "user8228j",
                        "content": "yeah 0+1 is 1 good job"
                    },
                    {
                        "username": "Subh001",
                        "content": "my first BADGE,\\n i had started coding from Jan 2023, regularly doing 3-4 code while doing job, \\nfrom total noob to atleast now able to code to code easy and medium ones which is having high acceptance.\\nFor earning this badge i had taken help from youtube/discussion/solution for few medium and hard ones, i know i have done a bit cheating but i will learn and improve my efficiency day by day.\\n\\nSuggestion are welcome to improve my logic and coding skills.....thanks "
                    },
                    {
                        "username": "blaustin10",
                        "content": "Can you explain this test case? [0,0,0,0,null,null,0,0,0,0,0]\\n\\nIt seems like the answer should involve 3 roots, not the 2 that it expects. I say 3 becausee we have the mirrored subtrees on the 1st level (with 3 children), the mirrored subtrees on the 2nd level (with 2 children), then the mirrored subtrees on the 3rd level (with 0 childrens...the leafs)."
                    },
                    {
                        "username": "user5336hR",
                        "content": "The 2 subtrees from the first level are mirrored but not the same. Both have only one subtree as immediate child but one has it in the left and the other in the right. "
                    }
                ]
            },
            {
                "id": 1824419,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1817084,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1572333,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1569146,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1817512,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1817434,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1816745,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1572858,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1565848,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1817323,
                "content": [
                    {
                        "username": "MishaChernov",
                        "content": "I found this task in the expole card \"Hash tables\", are you sure it should be there if even Binary Trees would be far away of this? "
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "So confusing examples, can anybody explain it better way ?? "
                    },
                    {
                        "username": "roylee",
                        "content": "TestCase [1,2,2,4,5,4,5], left-tree is the same as right-tree. Should we return all the nodes?\\n\\nthe problem says: ***you only need to return the root node of any one of them.***\\n\\nWhat does it really mean?\\n\\n*edit: the example testcase is really confusing, I thought the answer [4] means rightmost node..."
                    },
                    {
                        "username": "jerryouyang",
                        "content": "![0_1503065178698_Screenshot.jpg](/assets/uploads/files/1503065179970-screenshot.jpg) \\n\\nShould the answer be [[0], [0]] ? One for the leaf node, another for the non-leaf node."
                    },
                    {
                        "username": "user7237lF",
                        "content": "Two identical nodes may have the same children, but still not be identical subtrees. When the question is asking for identical subtrees, it means a node and all the nodes below it are identical to another one in the tree, including the children of the children and so on. The tree you show only has identical subtrees that are leaf nodes [[0]]."
                    },
                    {
                        "username": "Diamantis",
                        "content": "The tree you're showing is:\n[0,0,0,0,null,null,0,null,null,0,0]\n\nThe answer should be [[0]], because that's the only sub-tree that appears multiple times. You should return any TreeNode* of the 3 duplicates.\n\nThere are no non-leaf duplicates in this tree, look carefully."
                    },
                    {
                        "username": "Aditya_reddy",
                        "content": "The description not clear I think it needs some improvement..."
                    },
                    {
                        "username": "asander1995",
                        "content": "In example 1 input is [1,2,3,4,null,2,4,null,null,4]\\nShouldn\\'t it be [1,2,3,4,null,2,4,null,null,null,null,4]?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "The input is given by a level-order traversal of the nodes. First the level of the root, then the level of any nodes just under the root, then the level of their children, etc. If you want to check what tree your input is you can do it by going to the console, select Testcase, click the \"+\" while \"Case 1\" is selected. This will clone Case 1, and you can modify it to be your input. You will see your input \"moves\" the location of the last node with value 4 to be a left child of the rightmost node of level 2. Hope this helps. Cheers :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "be aware of trees like that\n[0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0... etc]\ncould end up with TLE :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I get a memory on that one (test case 128), error: std::bad_alloc. I think the solution is to not generate a new string for every node. But to use DFS and use the string from the children to generate the new string. Seems much faster, but I am a bit surprised this approach fails. I thought O(N^2)  would be fast enough with 5000 nodes."
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "got it anyway thank u"
                    },
                    {
                        "username": "Harshavardhan_10",
                        "content": "how to handle this"
                    },
                    {
                        "username": "user_s1996",
                        "content": "[[0,0],[0]] have 2 zero in a list how can node have two values"
                    },
                    {
                        "username": "David2008",
                        "content": "For this test case, [0,0,0,0,null,0,null,0,0,0,0]\\nmy output is [[0],[0,0,0],[0,0,null,0,0]]\\nthe expected is [[0,0,null,0,0],[0],[0,0,0]]\\n\\nthe only difference is order, my answer was considered incorrect. This does not make sense. I did not see any place in the problem description that says order matters.\\nHow to get the expected order?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1.Perform a depth-first search (DFS) traversal of the binary tree.\\n2.For each node visited during the traversal, generate a unique string representation of the subtree rooted at that node using a subtree serialization technique.\\n3.Store the string representation in a hash map along with the node that is the root of the subtree.\\n4.If a string representation already exists in the hash map, it means we have found a duplicate subtree. Add its root node to a list of duplicate subtree roots.\\n5.Return the list of duplicate subtree roots.\\n\\nSubtree serialization is a process of generating a unique string representation of a subtree in a binary tree.\\n\\nFor Example:-\\n\\n       1\\n     /   \\\\\\n    2     3\\n\\nString Representation: 12##3##\\n\\nWe generate string representations for all subtrees in the binary tree using this technique."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\n\\nhttps://leetcode.com/problems/find-duplicate-subtrees/solutions/3239945/o-n-solution-very-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 2038773,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1979773,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1863070,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1819014,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1818150,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817775,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817773,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817634,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817619,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817562,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Output description should be modified to: Return all duplicate subtrees (Subtree defined below). For e.g. for the input below, we have two sets of duplicate subtrees: [2,4] and [4].\n\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\n\nWhat is a subtree? In the diagram linked below, everything in a dashed enclosure is a subtree. (Root - Left - Right)\n\n![Diagram](https://assets.leetcode.com/users/images/0d4c98a5-59a2-4180-a887-7b02e5bfe07c_1693532137.083587.png)\n\nYour goal is to collect and count them all and see if there are duplicates.\n\nSee more [intuition](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3986288/observations-for-prepostin-order-traversals-for-collecting-subtrees/) here."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\n```\\n[2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 1, 3, 1, 3, 3, 1]\\n[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1]\\n[2, null, 2, 1, null, 2, 2, 2, 2, 2, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, 2, null, 2, 1, null, 1, 2, 1, null, 2]\\n```\\n\\n```\\n[3, 2, 3, 2, 3, 1, 3, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 3, 3, 2, 1, 1, 3, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 2, 2, 3, 3, 2, 1, 2, 1, 1, 3, 1, 2, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 3, 2, 3, 1, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 2, 1, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 1, 1, 1, 2, 3, 1, 2, 2, 1, 2, 3, 1, 3, 2, 1, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 3, 1, 2, 1, 1, 2, 1, 3, 3, 3, 3, 2, 1, 3, 3, 1, 2, 3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 1, 3, 1, 1, 3, 3, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 2, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 2, 3, 1, 3, 3, 2, 1, 3, 1, 1, 2, 3, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 2, 1, 1, 3, 2, 1, 3, 1, 3, 2, 1, 3, 1, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 1, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 1, 1, 2, 2, 2, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 2, 1, 3, 3, 1, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 3, 3, 2, 2, 1, 2, 1, 2, 3, 2, 3, 3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 3, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 3, 1, 3, 2, 3, 1, 2, 1, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 1, 2, 1, 1, 3, 2, 1, 2, 3, 2, 3, 2, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 2, 3, 2, 3, 1, 2, 1, 1, 2, 2, 2, 1, 1, 3, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3, 3, 2, 3, 1, 3, 3, 1, 2, 2, 3, 3, 1, 3, 1, 2, 1, 3, 3, 1, 3, 3, 3, 1, 1, 3, 3, 1, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 3, 2, 1, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 3, 1, 2, 1, 1, 2, 2, 3, 1, 1, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 2, 1, 2, 3, 3, 3, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 3, 3, 2, 1, 3, 1, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 3, 1, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 3, 3, 1, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 2, 3, 1, 3, 2, 3, 2, 1, 1, 2, 2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 2, 3, 3, 1, 2, 1, 2, 3, 1, 3, 2, 1, 1, 3, 1, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 1, 3, 1, 3, 3, 2, 3, 3, 2, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 3, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 2, 3, 1, 3, 1, 1, 3, 1, 3, 3, 2, 2, 2, 2, 1, 2, 2, 3, 3, 3, 1, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 3, 2, 2, 1, 2, 2, 3, 2, 1, 3, 1, 3, 2, 1, 1, 3, 3, 1, 3, 3, 1, 2, 2, 3, 2, 2, 2, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 2, 1, 1, 1, 3, 3, 2, 3, 3, 1, 2, 2, 1, 3, 3, 2, 1, 3, 2, 3, 3, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 2, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 1, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 3, 3, 1, 1, 3, 1, 3, 2, 2, 3, 1, 3, 1, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 2, 2, 1, 2, 1, 3, 3, 2, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 3, 3, 2, 3, 2, 3, 2, 2, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 3, 1, 2, 1, 2, 3, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 3, 2, 1, 1, 1, 2, 3, 2, 2, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 3, 1, 3, 3, 2, 3, 2, 3, 2, 1, 1, 3, 3, 1, 1, 1, 1, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 2, 3, 1, 1, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 1, 1, 2, 2, 1, 1, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 1, 1, 3, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 3, 2, 1, 2, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3, 3, 2, 3, 1, 3, 3, 2, 1, 2, 2, 2, 2, 3, 3, 2, 1, 3, 1, 2, 1, 1, 2, 3, 3, 2, 1, 2, 2, 1, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 2, 2, 2, 1, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 1, 3, 3, 1, 3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 2, 3, 3, 3, 3, 3, 1, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 3, 2, 1, 3, 3, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 3, 3, 1, 3, 1, 1, 2, 3, 1, 1, 1, 3, 1, 2, 2, 1, 3, 3, 3, 1, 1, 1, 2, 2, 3, 1, 2, 1, 2, 2, 3, 1, 3, 2, 2, 3, 1, 3, 1, 1, 3, 2, 2, 1, 3, 2, 3, 1, 3, 1, 3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 2, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 1, 3, 1, 2, 3, 3, 1, 3, 3, 3, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 2, 3, 3, 1, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 1, 2, 1, 3, 1, 2, 2, 2, 1, 2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 3, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1, 3, 1, 2, 3, 1, 3, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 1, 3, 1, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 1, 3, 1, 1, 3, 1, 2, 1, 2, 3, 1, 2, 2, 3, 1, 1, 3, 2, 3, 2, 1, 2, 3, 3, 1, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 2, 1, 3, 1, 2, 3, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 2, 3, 3, 3, 1, 3, 3, 2, 3, 1, 3, 1, 3, 2, 1, 2, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 3, 1, 2, 2, 1, 3, 2, 1, 3, 3, 1, 1, 3, 3, 3, 2, 1, 2, 3, 2, 3, 3, 3, 1, 2, 1, 1, 3, 1, 3, 1, 3, 2, 3, 3, 3, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 1, 1, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 3, 2, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 3, 2, 1, 1, 3, 3, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 3, 3, 2, 3, 2, 3, 1, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 3, 3, 2, 1, 3, 1, 2, 2, 1, 1, 1, 3, 3, 1, 1, 3, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 2, 1, 3, 1, 1, 2, 2, 1, 2, 1, 3, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 1, 2, 1, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 3, 1, 2, 3, 1, 1, 2, 2, 2, 3, 2, 1, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 2, 2, 1, 2, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 3, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 2, 1, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2, 1, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 3, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 2, 3, 1, 1, 1, 2, 1, 3, 2, 3, 3, 1, 1, 2, 2, 2, 2, 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 1, 3, 3, 1, 2, 1, 1, 3, 1, 2, 3, 1, 1, 3, 1, 2, 3, 1, 2, 2, 3, 1, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 1, 2, 1, 1, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 3, 1, 3, 3, 3, 3, 2, 3, 2, 3, 2, 1, 1, 1, 2, 1, 2, 2, 3, 3, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 2, 3, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 3, 1, 2, 2, 2, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 2, 3, 1, 3, 2, 1, 2, 2, 3, 2, 2, 3, 3, 2, 1, 1, 2, 2, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 2, 2, 3, 2, 3, 1, 1, 1, 1, 3, 2, 3, 3, 2, 2, 3, 1, 2, 1, 1, 2, 3, 3, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 3, 2, 1, 3, 3, 3, 3, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 1, 1, 1, 2, 3, 1, 3, 2, 2, 1, 3, 1, 2, 1, 3, 3, 1, 3, 2, 2, 1, 3, 1, 1, 1, 2, 3, 3, 2, 1, 2, 2, 3, 2, 2, 3, 1, 3, 3, 2, 1, 2, 1, 2, 1, 3, 1, 2, 2, 3, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 2, 2, 3, 2, 3, 1, 2, 1, 3, 3, 2, 2, 2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 1, 1, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 3, 3, 3, 3, 1, 2, 1, 2, 3, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 1, 3, 2, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 3, 3, 3, 3, 2, 3, 1, 1, 2, 1, 2, 1, 2, 3, 3, 2, 3, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 3, 3, 3, 2, 2, 1, 3, 1, 2, 2, 3, 1, 2, 1, 3, 2, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 2, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1, 3, 2, 3, 1, 3, 3, 2, 3, 1, 2, 3, 3, 3, 1, 1, 2, 3, 1, 1, 3, 1, 2, 2, 3, 1, 1, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 2, 1, 3, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 1, 1, 3, 1, 3, 2, 3, 2, 2, 1, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 1, 3, 2, 3, 3, 1, 2, 3, 1, 1, 2, 2, 3, 1, 1, 1, 2, 3, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2, 2, 1, 3, 2, 2, 3, 1, 1, 3, 3, 3, 3, 1, 2, 2, 1, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 3, 2, 3, 3, 2, 2, 2, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 1, 3, 3, 1, 3, 1, 3, 2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 2, 1, 1, 3, 1, 2, 2, 1, 1, 2, 3, 2, 1, 3, 1, 2, 1, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 1, 3, 2, 1, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 1, 1, 3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 1, 2, 2, 2, 3, 1, 3, 3, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 2, 3, 3, 1, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 1, 3, 1, 2, 2, 1, 3, 3, 1, 2, 1, 3, 1, 1, 3, 2, 3, 2, 3, 2, 2, 1, 2, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 2, 1, 1, 2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 1, 2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 1, 1, 3, 1, 2, 3, 2, 3, 2, 1, 2, 3, 2, 2, 2, 1, 3, 2, 2, 1, 3, 1, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 1, 2, 1, 2, 1, 2, 3, 1, 1, 3, 1, 3, 2, 3, 2, 3, 3, 1, 3, 1, 2, 3, 1, 1, 1, 1, 2, 2, 1, 2, 3, 1, 2, 3, 2, 1, 1, 3, 2, 2, 1, 1, 1, 3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2, 1, 1, 1, 3, 2, 3, 1, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1, 2, 3, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 2, 1, 2, 3, 1, 2, 2, 1, 3, 3, 3, 3, 1, 2, 1, 2, 3, 1, 1, 3, 2, 3, 2, 2, 1, 3, 2, 3, 3, 2, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 1, 1, 2, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 1, 3, 2, 1, 2, 2, 1, 2, 1, 3, 2, 1, 3, 1, 3, 1, 3, 2, 2, 1, 2, 2, 1, 3, 2, 2, 1, 3, 3, 3, 1, 3, 2, 2, 1, 2, 3, 3, 1, 3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 2, 1, 3, 2, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2, 1, 3, 2, 1, 2, 2, 1, 2, 3, 2, 3, 1, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 3, 2, 3, 3, 3, 2, 3, 1, 3, 3, 1, 1, 2, 2, 1, 2, 3, 2, 2, 2, 2, 3, 3, 1, 1, 1, 2, 1, 1, 2, 2, 3, 1, 2, 2, 1, 2, 3, 2, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 2, 1, 3, 3, 1, 1, 2, 3, 2, 1, 3, 1, 1, 2, 2, 1, 1, 3, 2, 2, 1, 1, 2, 3, 3, 2, 3, 1, 1, 3, 2, 1, 1, 3, 3, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 3, 2, 3, 3, 1, 3, 2, 3, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 3, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 1, 3, 2, 3, 2, 1, 3, 3, 2, 2, 3, 2, 1, 2, 3, 1, 2, 1, 2, 3, 1, 2, 3, 3, 3, 2, 2, 3, 1, 1, 3, 2, 2, 3, 3, 2, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 1, 2, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 3, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 3, 2, 3, 2, 1, 3, 3, 3, 3, 2, 1, 3, 1, 2, 1, 1, 3, 1, 1, 2, 3, 3, 2, 3, 1, 2, 3, 3, 2, 1, 1, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 3, 1, 3, 3, 1, 1, 1, 1, 2, 1, 2, 2, 3, 1, 2, 1, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 3, 1, 1, 1, 1]\\n```"
                    },
                    {
                        "username": "toravipatel",
                        "content": "I dont understand why we are checking the frequency as 2 only after putting in map. We are increasing the frequency count everytime when we get same string . We should check as \">1\" to check the duplicate. When I tried with >1 then it is not giving the correct output."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ohhh.. thought i lost this section, but here u r \\uD83D\\uDE44"
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "I tried doing this problem using inorder traversal of the tree and it did not work. I do not understand why the preorder and postorder traversals work while the inorder traversal doesnt work. If anybody understands this, please help me too :,"
                    },
                    {
                        "username": "changyou1009",
                        "content": "The problem statement \"you only need to return the root node of any one of them\" can be improved by removing the word \"root\" because each subtree has only one root. A better phrasing could be: \"you only need to return the nodes of any one of the subtrees.\" This clarifies that the requirement is to return the nodes from a single subtree who has duplications, not just the root node of that subtree."
                    },
                    {
                        "username": "roshitkhare",
                        "content": "Hint: This is a string question!"
                    },
                    {
                        "username": "jems1123",
                        "content": "I\\'m really not getting the output formate,\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Just an array/vector of TreeNodes/pointers where each TreeNode represents the root of a subtree that is duplicated elsewhere in the input tree. Each element of the output should be unique as well."
                    },
                    {
                        "username": "user5336hR",
                        "content": "Is the input an array / list representation of the binary tree of the form: for each node on index k (starting with 1) its left node is at index `2*k` and its right at `2*k+1`?\\nAs an example a 3 nodes tree, all to the right is represented as [1, null,2, null,null, null,3] or as [1, null,2, null,3]?"
                    },
                    {
                        "username": "roshatron",
                        "content": "Is the O(n ^ 2) solution giving TLE for anyone?"
                    }
                ]
            },
            {
                "id": 1817422,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817386,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817360,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817286,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817284,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817178,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817137,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817125,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817082,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            },
            {
                "id": 1817058,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "why postorder please can anybody explain??"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Because you are trying to serialize the tree. That is, describe it with a string or integer. Each node will be described _somehow_ in terms of itself and its two children. In order to make that happen, you have to first traverse the two children. We typically traverse first the left, then the right child (but it doesn't matter at all here, we could as easily traverse first right child, then left child). This traversal is called postorder (the node itself is \"traversed\", i.e., processed **after** its children). Hope it's clearer now!"
                    },
                    {
                        "username": "the_curious_1",
                        "content": "Can you please tell why my solution doesn\\'t work if I include these checks `if(root->left) & if(root->right)`\\nTC Passed-174/175\\nI can\\'t seem to understand what is the problem if I include these checks. Can you tell me the exact test case where this might fail.\\nclass Solution {\\npublic:\\n    string pre(TreeNode* root,unordered_map<string,vector<TreeNode*>> &mpp)\\n    {\\n        if(root==NULL)\\n            return \"\";\\n        string s1;\\n        s1=to_string(root->val);\\n        if(root->left)\\n        s1+=\"l\"+pre(root->left,mpp);\\n        if(root->right)\\n        s1+=\"r\"+pre(root->right,mpp);\\n        mpp[s1].push_back(root);\\n        return s1;\\n    }\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string,vector<TreeNode*>> mpp;\\n        pre(root,mpp);\\n        vector<TreeNode*> ans;\\n        for(auto i:mpp)\\n        {\\n            if(i.second.size()>=2)\\n                ans.push_back(i.second[0]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "Here I made you one example that your code will fail because of what I explained in the previous message. Just hang both of these trees \"under\" a root with value 9:\\nInput 3: [9,1,1,2,null,2,3,null,3]\\nYour output is [[1,2,null,null,3],[3]]  -- Because you identify the two subtrees with 1,2,3 values as duplicates, which they aren\\'t.\\nExpected is [[3]]\\nYou can fix your code by putting parenthesis around the subtrees in the representation, or always printing the \"null\" nodes as \"nulls\" in your strings (or \"#\" or some other symbol). Best of luck, nice attempt!"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I got curious and tried a few examples. Basically your representation does not properly distinguish between some trees with different structure (but same values). To better understand the examples, do a `cout << s1 << endl;` before you \\n`return s1;`. Try adding these two sample Testcases, and you will see you present these two trees in the same way. \\nInput 1: [1,2,null,null,3]\\nIt\\'s a tree \"heavy\" on the left side. You serialize it as \"1l2r3\".\\nInput 2: [1,2,3]\\nIt\\'s a perfect binary tree (full). You serialize it the same way.\\n"
                    },
                    {
                        "username": "Rishabh_ku2022",
                        "content": "what is the 175th test case do any one know?\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "first badge \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Example 1:\n  4 (null + null + 4), 4 _ 2(4 + null + 2),\n    4, 4 _ 2, \n    4, \n  4 _ 2 4 3(4 _ 2 + 4 + 3),\n4 _ 2 4 _ 2 4 2 1 (4 _ 2 + 4 _ 2 4 3 + 1)\nExample 2:\n  1,\n  1,\n1 1 2\nExample 3:\n  3, 3 _ 2,\n  3, 3 _ 2,\n3 _ 2 3 _ 2 2\n\nYou can use a different separator other than space."
                    },
                    {
                        "username": "KhacLong",
                        "content": "it\\'s quite tricky but when i think it\\'s a hash table problem, everything seems ez"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I can see this to be used as a part of some sort of tree compression algorithm. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"if (root==NULL)\" should be added something to the strings.\\nI was wrong with the Testcase:\\nroot =\\n[0,0,0,0,null,null,0,null,null,null,0]"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 5 failed attempts it clicked in my mind that I could generate hash for a subtree and then check if its same\\uD83D\\uDE2D "
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "My code is failing for 171 test case, the test case is so huge that i can\\'t even debug it manually. Please help me to find the error in my code. It took me more than 1.5 hours to come with code for the solution, even though i got thought process"
                    }
                ]
            }
        ]
    }
]