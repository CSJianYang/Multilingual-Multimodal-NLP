[
    {
        "title": "Create Maximum Number",
        "question_content": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\nReturn an array of the k digits representing the answer.\n&nbsp;\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\n\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\n\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n\n&nbsp;\nConstraints:\n\n\tm == nums1.length\n\tn == nums2.length\n\t1 <= m, n <= 500\n\t0 <= nums1[i], nums2[i] <= 9\n\t1 <= k <= m + n",
        "solutions": [
            {
                "id": 77285,
                "title": "share-my-greedy-solution",
                "content": "Many of the posts have the same algorithm. In short we can first solve 2 simpler problem\\n\\n1. Create the maximum number of one array \\n2. Create the maximum number of two array using all of their digits.\\n\\nFor an long and detailed explanation see my blog [here][1].\\n\\nThe algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.\\n\\n**Java**\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[] ans = new int[k];\\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\\n        }\\n        return ans;\\n    }\\n    private int[] merge(int[] nums1, int[] nums2, int k) {\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\\n    }\\n    public int[] maxArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\\n            if (j < k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n\\n\\n  [1]: http://algobox.org/create-maximum-number/",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "Many of the posts have the same algorithm. In short we can first solve 2 simpler problem\\n\\n1. Create the maximum number of one array \\n2. Create the maximum number of two array using all of their digits.\\n\\nFor an long and detailed explanation see my blog [here][1].\\n\\nThe algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.\\n\\n**Java**\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[] ans = new int[k];\\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\\n        }\\n        return ans;\\n    }\\n    private int[] merge(int[] nums1, int[] nums2, int k) {\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\\n    }\\n    public int[] maxArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\\n            if (j < k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n\\n\\n  [1]: http://algobox.org/create-maximum-number/",
                "codeTag": "Unknown"
            },
            {
                "id": 77287,
                "title": "c-16ms-fastest-beats-97",
                "content": "The basic idea:\\n\\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\\n\\nOptimization: \\n\\n1. Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result. \\n\\n2. Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8]. \\n\\n3. In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9].\\n\\n#\\n\\n    class Solution {\\n    public:\\n        #define MIN(a,b) (a<b?a:b)\\n        #define MAX(a,b) (a>b?a:b)\\n        // create max number of length t from single non-empty vector\\n        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n        {\\n        \\tint n, top = 0;\\n        \\tresult[0] = num[0];\\n        \\tconst int need2drop = len - t;\\n        \\tfor (int i = 1; i < len; ++i){\\n        \\t\\tn = num[i];\\n        \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\\n        \\t\\tif (i - top > need2drop){\\n        \\t\\t\\tsortedLen = MAX(1,top);\\n        \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n        \\t\\t\\treturn;\\n        \\t\\t}\\n        \\t\\tif (++top < t) result[top] = n;\\n        \\t\\telse top = t - 1;\\n        \\t}\\n        }\\n        // create max number of different length from single vector\\n        void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n        \\tint  j, *head, *prevhead = res;\\n        \\tconst int soi = sizeof(int);\\n        \\tgetMax(num, len, res, maxL,sortedLen);\\n        \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n        \\t\\thead = prevhead + k;\\n        \\t\\tmemcpy(head, prevhead, l*soi);\\n        \\t\\tfor (j = sortedLen; j < l; ++j){\\n        \\t\\t\\tif (head[j] > head[j - 1]){\\n        \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n        \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n        \\t\\t\\t\\tbreak;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\tif (j == l) sortedLen = l;\\n        \\t\\tprevhead = head;\\n        \\t}\\n        }\\n        // merge max number created from single vector\\n        void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n        \\tint i = 0, j = 0, k = 0;\\n        \\twhile (i < resSize){\\n        \\t\\tif (j < len1 && k < len2){\\n        \\t\\t\\tif (num1[j] > num2[k])\\n        \\t\\t\\t\\tresult[i++] = num1[j++];\\n        \\t\\t\\telse if (num1[j] < num2[k])\\n        \\t\\t\\t\\tresult[i++] = num2[k++];\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n        \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n        \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n        \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n        \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n        \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n        \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse if (j < len1) result[i++] = num1[j++];\\n        \\t\\telse result[i++] = num2[k++];\\n        \\t}\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n        \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n        \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n        \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n        \\tmemset(res, 0, step);\\n        \\tint sortedLen1 = 1, sortedLen2 = 1;\\n        \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 > 0){\\n        \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n        \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n        \\t\\tif (sortedLen1 + sortedLen2 > k){\\n        \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n        \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n        \\t\\t\\tdelete[] res;\\n        \\t\\t\\treturn resv;\\n        \\t\\t}\\n        \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n        \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n        \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n        \\t\\t}\\n        \\t}\\n        \\tvector<int> resv(res, res + k);\\n        \\tdelete[] res;\\n        \\treturn resv;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        #define MIN(a,b) (a<b?a:b)\\n        #define MAX(a,b) (a>b?a:b)\\n        // create max number of length t from single non-empty vector\\n        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n        {\\n        \\tint n, top = 0;\\n        \\tresult[0] = num[0];\\n        \\tconst int need2drop = len - t;\\n        \\tfor (int i = 1; i < len; ++i){\\n        \\t\\tn = num[i];\\n        \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\\n        \\t\\tif (i - top > need2drop){\\n        \\t\\t\\tsortedLen = MAX(1,top);\\n        \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n        \\t\\t\\treturn;\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 77286,
                "title": "short-python-ruby-c",
                "content": "**Python**\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        def prep(nums, k):\\n            drop = len(nums) - k\\n            out = []\\n            for num in nums:\\n                while drop and out and out[-1] < num:\\n                    out.pop()\\n                    drop -= 1\\n                out.append(num)\\n            return out[:k]\\n\\n        def merge(a, b):\\n            return [max(a, b).pop(0) for _ in a+b]\\n\\n        return max(merge(prep(nums1, i), prep(nums2, k-i))\\n                   for i in range(k+1)\\n                   if i <= len(nums1) and k-i <= len(nums2))\\n\\nSolved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.\\n\\nThe last two lines can be combined, but I find it rather ugly and not worth it:  \\n`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`\\n\\n---\\n\\n**Ruby**\\n\\n    def prep(nums, k)\\n      drop = nums.size - k\\n      out = [9]\\n      nums.each do |num|\\n        while drop > 0 && out[-1] < num\\n          out.pop\\n          drop -= 1\\n        end\\n        out << num\\n      end\\n      out[1..k]\\n    end\\n    \\n    def max_number(nums1, nums2, k)\\n      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|\\n        parts = [prep(nums1, k1), prep(nums2, k-k1)]\\n        (1..k).map { parts.max.shift }\\n      }.max\\n    end\\n\\n---\\n\\n**C++**\\n\\nTranslated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)\\n            best = max(best, maxNumber(maxNumber(nums1, k1),\\n                                       maxNumber(nums2, k-k1)));\\n        return best;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size() - k;\\n        vector<int> out;\\n        for (int num : nums) {\\n            while (drop && out.size() && out.back() < num) {\\n                out.pop_back();\\n                drop--;\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k);\\n        return out;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        while (nums1.size() + nums2.size()) {\\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\\n            out.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return out;\\n    }\\n\\nAn alternative for `maxNumber(nums1, nums2)`:\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        auto i1 = nums1.begin(), end1 = nums1.end();\\n        auto i2 = nums2.begin(), end2 = nums2.end();\\n        while (i1 != end1 || i2 != end2)\\n            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);\\n        return out;\\n    }",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "**Python**\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        def prep(nums, k):\\n            drop = len(nums) - k\\n            out = []\\n            for num in nums:\\n                while drop and out and out[-1] < num:\\n                    out.pop()\\n                    drop -= 1\\n                out.append(num)\\n            return out[:k]\\n\\n        def merge(a, b):\\n            return [max(a, b).pop(0) for _ in a+b]\\n\\n        return max(merge(prep(nums1, i), prep(nums2, k-i))\\n                   for i in range(k+1)\\n                   if i <= len(nums1) and k-i <= len(nums2))\\n\\nSolved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.\\n\\nThe last two lines can be combined, but I find it rather ugly and not worth it:  \\n`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`\\n\\n---\\n\\n**Ruby**\\n\\n    def prep(nums, k)\\n      drop = nums.size - k\\n      out = [9]\\n      nums.each do |num|\\n        while drop > 0 && out[-1] < num\\n          out.pop\\n          drop -= 1\\n        end\\n        out << num\\n      end\\n      out[1..k]\\n    end\\n    \\n    def max_number(nums1, nums2, k)\\n      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|\\n        parts = [prep(nums1, k1), prep(nums2, k-k1)]\\n        (1..k).map { parts.max.shift }\\n      }.max\\n    end\\n\\n---\\n\\n**C++**\\n\\nTranslated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)\\n            best = max(best, maxNumber(maxNumber(nums1, k1),\\n                                       maxNumber(nums2, k-k1)));\\n        return best;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size() - k;\\n        vector<int> out;\\n        for (int num : nums) {\\n            while (drop && out.size() && out.back() < num) {\\n                out.pop_back();\\n                drop--;\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k);\\n        return out;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        while (nums1.size() + nums2.size()) {\\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\\n            out.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return out;\\n    }\\n\\nAn alternative for `maxNumber(nums1, nums2)`:\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        auto i1 = nums1.begin(), end1 = nums1.end();\\n        auto i2 = nums2.begin(), end2 = nums2.end();\\n        while (i1 != end1 || i2 != end2)\\n            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);\\n        return out;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 77291,
                "title": "share-my-python-solution-with-explanation",
                "content": "To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.\\n\\nObviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. \\n\\nThe final result is the maximum possible merge of all left and right. \\n\\nSo there're 3 steps:\\n\\n 1. **iterate i from 0 to k.**\\n 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**\\n 3. **find max merge of left, right**\\n\\nfunction **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.\\n1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.\\n2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.\\n3rd digits: only one left [2], we select it. and function output [7,4,2]\\n\\nfunction **mergeMax**  find the maximum combination of left, and right. \\n\\n\\n    class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m= len(nums1),len(nums2)\\n        ret = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: continue\\n            left = self.maxSingleNumber(nums1, i)\\n            right = self.maxSingleNumber(nums2, j)\\n            num = self.mergeMax(left, right)\\n            ret = max(num, ret)\\n        return ret\\n\\n\\n    def mergeMax(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxSingleNumber(self, nums, selects):\\n        n = len(nums)\\n        ret = [-1]\\n        if selects > n : return ret\\n        while selects > 0:\\n            start = ret[-1] + 1 #search start\\n            end = n-selects + 1 #search end\\n            ret.append( max(range(start, end), key = nums.__getitem__))\\n            selects -= 1\\n        ret = [nums[item] for item in ret[1:]]\\n        return ret",
                "solutionTags": [],
                "code": "To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.\\n\\nObviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. \\n\\nThe final result is the maximum possible merge of all left and right. \\n\\nSo there're 3 steps:\\n\\n 1. **iterate i from 0 to k.**\\n 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**\\n 3. **find max merge of left, right**\\n\\nfunction **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.\\n1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.\\n2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.\\n3rd digits: only one left [2], we select it. and function output [7,4,2]\\n\\nfunction **mergeMax**  find the maximum combination of left, and right. \\n\\n\\n    class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m= len(nums1),len(nums2)\\n        ret = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: continue\\n            left = self.maxSingleNumber(nums1, i)\\n            right = self.maxSingleNumber(nums2, j)\\n            num = self.mergeMax(left, right)\\n            ret = max(num, ret)\\n        return ret\\n\\n\\n    def mergeMax(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxSingleNumber(self, nums, selects):\\n        n = len(nums)\\n        ret = [-1]\\n        if selects > n : return ret\\n        while selects > 0:\\n            start = ret[-1] + 1 #search start\\n            end = n-selects + 1 #search end\\n            ret.append( max(range(start, end), key = nums.__getitem__))\\n            selects -= 1\\n        ret = [nums[item] for item in ret[1:]]\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 77299,
                "title": "divide-to-three-subproblem-solution-beat-98",
                "content": "subproblem1: \\nget the largest k numbers when keeping the relative order\\n\\nsubproblem2: \\nmerge two arrays which are from subproblem1.\\n\\nsubproblem3: \\ncompare two arrays.\\n\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int[] result = new int[k];\\n        if(len1+len2 < k) {\\n            return result;//bad case\\n        }else if(len1+len2 == k){\\n            result = mergeTwoArrays(nums1, nums2, k);//edge case\\n        }else{\\n            for (int i = 0; i <= k; i++) {\\n                if(i<=len1 && (k-i)<=len2){\\n                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);\\n                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);\\n                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);\\n                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        int idx1 = 0, idx2 = 0;\\n        int idx = 0;\\n        while(idx < k){\\n            //check the two remain arrays to see which one is larger.\\n            if(compareTwoArrays(nums1, idx1, nums2, idx2)){\\n                result[idx] = nums1[idx1++];\\n            }else{\\n                result[idx] = nums2[idx2++];\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n    \\n    //get the largest k numbers when keeping the relative order\\n    private int[] maxNumberOfSingleArray(int[] nums, int k){\\n        int[] result = new int[k];\\n        if(k == 0) return result;\\n\\n        int len = nums.length;\\n        int idx = 0;\\n        for(int i = 0; i < len; i++){\\n            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;\\n            if(idx < k) result[idx++] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    //compare two arrays at the \"start\" index\\n    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {\\n        int len1 = nums1.length - startIdx1;\\n        if(len1 <= 0) return false;\\n        int len2 = nums2.length - startIdx2;\\n        if(len2 <= 0) return true;\\n        int len = Math.max(len1, len2);\\n        for (int i = 0; i< len; i++) {\\n        \\tint digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;\\n        \\tint digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;\\n        \\tif(digit1 != digit2){\\n        \\t    return digit1 > digit2;\\n        \\t}\\n        }\\n        return true;//equal, choose either one is ok\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int[] result = new int[k];\\n        if(len1+len2 < k) {\\n            return result;//bad case\\n        }else if(len1+len2 == k){\\n            result = mergeTwoArrays(nums1, nums2, k);//edge case\\n        }else{\\n            for (int i = 0; i <= k; i++) {\\n                if(i<=len1 && (k-i)<=len2){\\n                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);\\n                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);\\n                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);\\n                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        int idx1 = 0, idx2 = 0;\\n        int idx = 0;\\n        while(idx < k){\\n            //check the two remain arrays to see which one is larger.\\n            if(compareTwoArrays(nums1, idx1, nums2, idx2)){\\n                result[idx] = nums1[idx1++];\\n            }else{\\n                result[idx] = nums2[idx2++];\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n    \\n    //get the largest k numbers when keeping the relative order\\n    private int[] maxNumberOfSingleArray(int[] nums, int k){\\n        int[] result = new int[k];\\n        if(k == 0) return result;\\n\\n        int len = nums.length;\\n        int idx = 0;\\n        for(int i = 0; i < len; i++){\\n            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;\\n            if(idx < k) result[idx++] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    //compare two arrays at the \"start\" index\\n    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {\\n        int len1 = nums1.length - startIdx1;\\n        if(len1 <= 0) return false;\\n        int len2 = nums2.length - startIdx2;\\n        if(len2 <= 0) return true;\\n        int len = Math.max(len1, len2);\\n        for (int i = 0; i< len; i++) {\\n        \\tint digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;\\n        \\tint digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;\\n        \\tif(digit1 != digit2){\\n        \\t    return digit1 > digit2;\\n        \\t}\\n        }\\n        return true;//equal, choose either one is ok\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77283,
                "title": "share-my-21ms-java-solution-with-comments",
                "content": "To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i.\\n\\nSo ,  the digits from nums2 is K - i.\\n\\nAnd we can use a stack to get the get maximum number(x digits) from one array.\\n\\nOK, Once we choose two maximum subarray , we should combine it to the answer.\\n\\nIt is just like merger sort, but we should pay attention to the case: the two digital are equal.\\n\\nwe should find the digits behind it to judge which digital we should choose now.\\n\\nIn other words,we should judge which subarry is bigger than the other.\\n\\nThat's all.\\n\\nIf you have any question or suggest, I am happy you can comment on my blog : [Create Maximum Number][1].\\n\\nThanks, merry christmas :)\\n\\n *update:use stack to find max sub array and it runs 21ms now.( thanks to @dietpepsi )*\\n\\n   \\n\\n     /**  * Created by hrwhisper on 2015/11/23.  * http://www.hrwhisper.me/leetcode-create-maximum-number/  */\\n    \\n    \\n    public class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }\\n                while (pos1 < res1.length)\\n                    res[tpos++] = res1[pos1++];\\n                while (pos2 < res2.length)\\n                    res[tpos++] = res2[pos2++];\\n    \\n                if (!compare(ans, 0, res, 0))\\n                    ans = res;\\n            }\\n    \\n            return ans;\\n        }\\n    \\n        public boolean compare(int[] nums1, int start1, int[] nums2, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n    \\n        public int[] solve(int[] nums, int k) {\\n            int[] res = new int[k];\\n            int len = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                while (len > 0 && len + nums.length - i > k && res[len - 1] < nums[i]) {\\n                    len--;\\n                }\\n                if (len < k)\\n                    res[len++] = nums[i];\\n            }\\n            return res;\\n        } }\\n\\n\\n  [1]: http://www.hrwhisper.me/leetcode-create-maximum-number/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77325,
                "title": "clean-and-easy-to-understand-c-solution",
                "content": "    vector<int> maxVector(vector<int> nums, int k) {\\n        while (nums.size() > k) {\\n            int i = 0, n = nums.size();\\n            for (; i < n - 1; ++i) {\\n                if (nums[i] < nums[i + 1]) {\\n                    nums.erase(nums.begin() + i);\\n                    break;\\n                }\\n            }\\n            if (i == n - 1) nums.erase(nums.begin() + i);\\n        }\\n    \\n        return nums;\\n    }\\n    \\n    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {\\n        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\\n            ++i;\\n            ++j;\\n        }\\n        if (j == nums2.size()) return true;\\n        if (i < nums1.size() && nums1[i] > nums2[j]) return true;\\n        return false;\\n    }\\n    \\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {\\n        vector<int> res(k, 0);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r) {\\n            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        }\\n    \\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<int> res(k, 0);\\n    \\n        for (int i = max(0, k - n); i <= min(k, m); ++i) {\\n            auto v1 = maxVector(nums1, i);\\n            auto v2 = maxVector(nums2, k - i);\\n            auto tmp = merge(v1, v2, k);\\n            if (compare(tmp, 0, res, 0)) res = tmp;\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> maxVector(vector<int> nums, int k) {\\n        while (nums.size() > k) {\\n            int i = 0, n = nums.size();\\n            for (; i < n - 1; ++i) {\\n                if (nums[i] < nums[i + 1]) {\\n                    nums.erase(nums.begin() + i);\\n                    break;\\n                }\\n            }\\n            if (i == n - 1) nums.erase(nums.begin() + i);\\n        }\\n    \\n        return nums;\\n    }\\n    \\n    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {\\n        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\\n            ++i;\\n            ++j;\\n        }\\n        if (j == nums2.size()) return true;\\n        if (i < nums1.size() && nums1[i] > nums2[j]) return true;\\n        return false;\\n    }\\n    \\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {\\n        vector<int> res(k, 0);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r) {\\n            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        }\\n    \\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<int> res(k, 0);\\n    \\n        for (int i = max(0, k - n); i <= min(k, m); ++i) {\\n            auto v1 = maxVector(nums1, i);\\n            auto v2 = maxVector(nums2, k - i);\\n            auto tmp = merge(v1, v2, k);\\n            if (compare(tmp, 0, res, 0)) res = tmp;\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529919,
                "title": "greedy-intuitive-detailed-explanation",
                "content": "# Intuition\\n\\nThis question is basically a combo of monotonic stack and merging two arrays.\\n\\nSo, to create a maximum number of k size array, we will iterate over the first array to take the size of largest possible number and correspondingly we will take the (k-i) size of largest possible number from the second array.\\nAfter storing the largest arrays in n1 and n2 we are merging them using merge function and then taking maximum of all.\\n\\n```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n```\\n\\nThis is the code to calculate the largest possible number of kth size from array nums. This is based on monotonic stack.\\n\\nSimilar question(Same logic): https://leetcode.com/submissions/detail/950762503/\\n\\n```\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n\\n``` \\n\\nSo, here we are merging both the arrays.\\nIf element of n2 is greater then we will simply take its value in the ans array and vice versa (similar to merging of merge sort).\\n\\n**Most Important**\\nWhen we will encounter equal values in n1 and n2 then we will simply increment both the indices.\\n\\n`nums1 = [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3],\\nnums2 = [7,6,7,1,0,1,0,5,6,0,5,0],\\nk = 31`\\n\\nYou can dry run on this test case.\\n\\n```\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n```\\n\\n\\n\\n# Complete Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n```\n```\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n\\n```\n```\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxnum(vector<int> nums, int k){\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i] && n - i + st.size() > k) st.pop();\\n            if(st.size() < k) st.push(i);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()) ans.push_back(nums[st.top()]), st.pop();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    string merge(vector<int>& n1, vector<int>& n2, int k){\\n        vector<int> ans(k, 0);\\n         int i = 0, j = 0, x = 0;\\n            while(i < n1.size() && j < n2.size()){\\n                if(n2[j] > n1[i]) ans[x++] = n2[j], j++;\\n                else if(n2[j] == n1[i]){\\n                    int indi=i, indj=j;\\n                    while(indi < n1.size() && indj < n2.size() && n1[indi] == n2[indj]) indi++, indj++;\\n                    if(indj == n2.size()) ans[x++] = n1[i], i++;\\n                    else{\\n                        if(indi < n1.size() && n1[indi] > n2[indj]) ans[x++] = n1[i], i++;\\n                        else ans[x++] = n2[j], j++;\\n                    }\\n                }\\n\\n                else ans[x++] = n1[i], i++; \\n            }\\n            while(i < n1.size()) ans[x++] = n1[i], i++;\\n            while(j < n2.size()) ans[x++] = n2[j], j++;\\n            string s = \"\";\\n            for(auto it: ans) s += to_string(it);\\n            return s;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size(), m = nums2.size();\\n        string mx = \"\";\\n        for(int i = 0; i <= k && i <= n; i++){\\n            if((k-i) > m) continue; //If we are taking i size of largest array from nums1 then are we capable of building k-i size of largest array from num2 .\\n            vector<int> n1 = maxnum(nums1, i);\\n            vector<int> n2 = maxnum(nums2, k-i);\\n            string s = merge(n1, n2, k);\\n            mx = max(mx, s);\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < mx.size(); i++) res.push_back(mx[i] - \\'0\\');\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917528,
                "title": "c-intuition-w-reference-question-stack-and-merge-sort-concept",
                "content": "\\nThis question is a combination of multiple topics and also one of the best question i have encountered so far. \\nBefore solving this question, you need have knowledge about merge sort technique and also you need to solve its prerequisite question ([1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/))\\n\\nFirst, Try that question and if you dont get any intuition, don\\'t feel bad. Even i took some help. You can read its editorial from [here](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/1903056/C%2B%2B-Stack-Solution-intuition-or-Monotonic-Stack)\\n\\n***Basic Idea*** of this problem is that we have two arrays, so we find the largest \\'i\\' digit number from nums1 and largest \\'k-i\\' digit number from nums2. After having these two, we merge them using merge sort algorithm. We use merge sort because it can be proved that largest number will always be sorted in descending order. The only thing to keep in mind while merging is the case where array elements are equal. In that case, we have to loop untill we find a greater element in one of the two arrays and then act accordingly.\\n            So after finding a i digit number from nums1 and k-i digit number from nums2, we merge them to form the maximum k digit number from these two arrays.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector <int>res;\\n\\n        for(int i = 0; i<=k; i++){\\n            vector <int> a = fun(nums1, i);\\n            vector <int> b = fun(nums2, k-i);\\n\\n            vector <int> m;\\n            merge(a, b, m);\\n\\n            if(m.size()==k) res = max(res,m);\\n        }\\n        return res;\\n    }\\nprotected:\\n    // This function is the code of \"Find most consecutive subsequence\" problem, which finds the k digit maximum number possible\\n    vector <int> fun(vector <int>&nums, int k){\\n        if(k>nums.size()) return {};\\n        vector <int> res;\\n        stack <int> st;\\n        int rem = k, n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]), rem--;\\n            else{\\n                int avail = n-i;\\n                while(!st.empty() and st.top()<nums[i] and rem<k and avail>rem) st.pop(), rem++;\\n                st.push(nums[i]), rem--;\\n            }\\n        }\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()) res.push_back(st.top()), st.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    void merge(vector <int>&a, vector <int>&b, vector <int>&res){\\n        int i = 0, j = 0, k = 0;\\n        // This is the only case which we need to take care of. Here, we loop until we find a number greater than another number\\n        // in other array. When we do that, we push the element in result array accordingly. Note that i am not using the pointer\\n        // i and j to loop, instead i have creater a temporary pointers which finds the position where elements are different.\\n        while(i<a.size() and j<b.size()){\\n            if(a[i]==b[j]){\\n                int ti = i, tj = j;\\n                while(ti<a.size() and tj<b.size() and a[ti]==b[tj]) ti++, tj++;\\n\\n                if(tj==b.size()) res.push_back(a[i]), i++;\\n                else\\n                if(ti<a.size() and a[ti]>b[tj]) res.push_back(a[i]), i++;\\n                else res.push_back(b[j]), j++;\\n            }\\n            else\\n            if(a[i]>b[j]) res.push_back(a[i]), i++;\\n            else res.push_back(b[j]), j++;\\n        }\\n        while(i<a.size()) res.push_back(a[i]), i++;\\n        while(j<b.size()) res.push_back(b[j]), j++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector <int>res;\\n\\n        for(int i = 0; i<=k; i++){\\n            vector <int> a = fun(nums1, i);\\n            vector <int> b = fun(nums2, k-i);\\n\\n            vector <int> m;\\n            merge(a, b, m);\\n\\n            if(m.size()==k) res = max(res,m);\\n        }\\n        return res;\\n    }\\nprotected:\\n    // This function is the code of \"Find most consecutive subsequence\" problem, which finds the k digit maximum number possible\\n    vector <int> fun(vector <int>&nums, int k){\\n        if(k>nums.size()) return {};\\n        vector <int> res;\\n        stack <int> st;\\n        int rem = k, n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]), rem--;\\n            else{\\n                int avail = n-i;\\n                while(!st.empty() and st.top()<nums[i] and rem<k and avail>rem) st.pop(), rem++;\\n                st.push(nums[i]), rem--;\\n            }\\n        }\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()) res.push_back(st.top()), st.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    void merge(vector <int>&a, vector <int>&b, vector <int>&res){\\n        int i = 0, j = 0, k = 0;\\n        // This is the only case which we need to take care of. Here, we loop until we find a number greater than another number\\n        // in other array. When we do that, we push the element in result array accordingly. Note that i am not using the pointer\\n        // i and j to loop, instead i have creater a temporary pointers which finds the position where elements are different.\\n        while(i<a.size() and j<b.size()){\\n            if(a[i]==b[j]){\\n                int ti = i, tj = j;\\n                while(ti<a.size() and tj<b.size() and a[ti]==b[tj]) ti++, tj++;\\n\\n                if(tj==b.size()) res.push_back(a[i]), i++;\\n                else\\n                if(ti<a.size() and a[ti]>b[tj]) res.push_back(a[i]), i++;\\n                else res.push_back(b[j]), j++;\\n            }\\n            else\\n            if(a[i]>b[j]) res.push_back(a[i]), i++;\\n            else res.push_back(b[j]), j++;\\n        }\\n        while(i<a.size()) res.push_back(a[i]), i++;\\n        while(j<b.size()) res.push_back(b[j]), j++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77294,
                "title": "an-accepted-python-solution",
                "content": "This problem could be divided into 2 sub-problems:\\n\\n1. **function getMax(nums, t):**\\n\\n  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved\\n\\n2. **function merge(nums1, nums2):**\\n\\n  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved\\n\\nThe final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            \"\"\"\\n            :type nums1: List[int]\\n            :type nums2: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            def getMax(nums, t):\\n                ans = []\\n                size = len(nums)\\n                for x in range(size):\\n                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\\n                        ans.pop()\\n                    if len(ans) < t:\\n                        ans += nums[x],\\n                return ans\\n    \\n            def merge(nums1, nums2):\\n                ans = []\\n                while nums1 or nums2:\\n                    if nums1 > nums2:\\n                        ans += nums1[0],\\n                        nums1 = nums1[1:]\\n                    else:\\n                        ans += nums2[0],\\n                        nums2 = nums2[1:]\\n                return ans\\n            \\n            len1, len2 = len(nums1), len(nums2)\\n            res = []\\n            for x in range(max(0, k - len2), min(k, len1) + 1):\\n                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))\\n                res = max(tmp, res)\\n            return res\\n\\nRef: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/",
                "solutionTags": [
                    "Python"
                ],
                "code": "This problem could be divided into 2 sub-problems:\\n\\n1. **function getMax(nums, t):**\\n\\n  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved\\n\\n2. **function merge(nums1, nums2):**\\n\\n  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved\\n\\nThe final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            \"\"\"\\n            :type nums1: List[int]\\n            :type nums2: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            def getMax(nums, t):\\n                ans = []\\n                size = len(nums)\\n                for x in range(size):\\n                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\\n                        ans.pop()\\n                    if len(ans) < t:\\n                        ans += nums[x],\\n                return ans\\n    \\n            def merge(nums1, nums2):\\n                ans = []\\n                while nums1 or nums2:\\n                    if nums1 > nums2:\\n                        ans += nums1[0],\\n                        nums1 = nums1[1:]\\n                    else:\\n                        ans += nums2[0],\\n                        nums2 = nums2[1:]\\n                return ans\\n            \\n            len1, len2 = len(nums1), len(nums2)\\n            res = []\\n            for x in range(max(0, k - len2), min(k, len1) + 1):\\n                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))\\n                res = max(tmp, res)\\n            return res\\n\\nRef: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/",
                "codeTag": "Java"
            },
            {
                "id": 77310,
                "title": "strictly-o-nk-c-solution-with-detailed-explanation",
                "content": "\\n\\tclass list1\\n    {\\n        vector<int> a;\\n        vector<vector<int>> f;\\n    public:\\n        list1() = delete;\\n        inline int size() {return a.size();}\\n        inline int next(int x,int d) {return f[x][d];}\\n        list1(vector<int>& a0)\\n        {\\n            a = a0;\\n            f = vector<vector<int>>(a0.size() + 1,vector<int>(10,INT_MAX));\\n            for (int i = 0;i<a0.size();i++)\\n            {\\n                f[i][a[i]] = i;\\n                for (int j = i-1;j>=0;j--)\\n                {\\n                    if (a[j] == a[i]) break;\\n                    f[j][a[i]] = i;\\n                }\\n            }\\n        }\\n    };\\n    \\n    //dmd for detect_max_digit\\n    // dmd(a,x,rem) -> (max_digit, pos) , where a[pos-1] == max_digit\\n    // list a , from x, need rem numbers, x not included.\\n        \\n    pair<int,int> dmd(list1& a,int x,int rem)\\n    {\\n        for (int d = 9;d >= 0;d--)\\n        {\\n            int pos = a.next(x,d);\\n            if (pos == INT_MAX) continue;\\n            if (a.size() - (pos + 1) >= rem)\\n            return make_pair(d,pos + 1);\\n        }\\n    }\\n    \\n    \\n    class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            list1 a1 = list1(nums1);\\n            int N1 = nums1.size();\\n            list1 a2 = list1(nums2);\\n            int N2 = nums2.size();\\n            \\n            auto ret = vector<int>(k,0);\\n            auto f = vector<int>(N1 + 1,0); \\n            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k\\n            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] \\n            for (int d = 1;d <= k;d++)\\n            {\\n                int maxDigit = -1;\\n                auto tmpf = vector<int>(N1 + 1,INT_MAX);\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y)); \\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    maxDigit = max(maxDigit,m1.first);\\n                    maxDigit = max(maxDigit,m2.first);\\n                }\\n                ret[d-1] = maxDigit;\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y));\\n                    if (m1.first == maxDigit)\\n                    tmpf[m1.second] = min(tmpf[m1.second],y);\\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    if (m2.first == maxDigit)\\n                    tmpf[x] = min(tmpf[x],m2.second);\\n                }\\n                f = tmpf;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nAny Question is welcome and will be answered as soon as possible.\\nDetailed explanation is coming soon!\\nYou may firstly read my code, it\\'s quite easy to understand.\\n\\n## Detailed Solution ##\\nLet a1,a2 be the two list from where we construct the maximal number.\\nLet N1,N2 denote the size of a1,a2.\\nWe construct the maximal number digit by digit.\\n\\nSuppose we are constructing the d-th digit(ret[0..d-1] is done)  and we have a set of states S = {(a1,b1),(a2,b2),...(a_N,b_N)},For each state (x,y) in S, it means we use a1[0..(x-1)] and a2[0..(y-1)] to construct ret[0..d-1] and a1[x..N1] and a2[y..N2] are avaliabe to construct the remaining digits.\\n\\nIn the iteration, we need to construct the d-th digit as well as the set S\\', that is from where we can construct the d+1-th digit.\\n\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the biggest d-th digit we can get from it. \\nLet maxdigit = {max(dmd(x,y)[1])|(x,y) in S}, it is the d-th digit.\\n\\nAs we now the d-th digit,\\nWe scan S again,\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the (x\\',y) and (x,y\\') it extands to, \\nif a1[x\\'-1] == maxdigit, we add (x\\',y) to S\\'.\\nif a2[y\\'-1] == maxdigit, we add (x,y\\') to S\\'.\\n\\nNow we can construct the d+1-th digit from S\\', note that the size of S\\' is at most N1, for(x,y1) and (x,y2), y1 < y2, (x,y2) is needless to be recorded.\\n\\nFinally I\\'d like to use an typical example to illustrate the process.\\n\\n> a1 = [8,1] a2 = [8,9] k = 4\\n> \\n> S = {(0,0)}\\n\\nthe first digit is 8,\\n\\n> S\\' = {(0,1),(1,0)}\\n\\nthe second digit is 9, we construct it from (0,1)\\n\\n>S\\'\\' = {(0,2)}\\n\\nthe remain digits are 8 and 1,\\nwe finally reach 8981.\\n\\nNow I use python and write a piece of much shorter and more readable code as follows:\\n\\n ```\\nclass Solution:\\n    \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def calcnext(a):\\n            ret = [[-1] * 10 for i in range(len(a) + 1)]\\n            for i in reversed(range(len(a))):\\n                for d in range(0, 10):\\n                    ret[i][d] = i if a[i] == d else ret[i + 1][d]\\n            return ret\\n        \\n        M, N = len(nums1), len(nums2)\\n        next1 = calcnext(nums1)\\n        next2 = calcnext(nums2)\\n        ret = []\\n        S = [(0, 0)]\\n        \\n        for i in range(k):\\n            rem = k - i - 1\\n            found, best = False, [N + 1] * (M + 1)\\n            for d in reversed(range(0, 10)):\\n                for (d1, d2) in S:\\n                    n1 = next1[d1][d] + 1\\n                    if n1 and M - n1 + N - d2 >= rem:\\n                        found, best[n1] = True, min(best[n1], d2)\\n                    n2 = next2[d2][d] + 1\\n                    if n2 and M - d1 + N - n2 >= rem:\\n                        found, best[d1] = True, min(best[d1], n2)\\n                if found:\\n                    ret += [d]\\n                    break\\n            S = [(i, best[i]) for i, x in enumerate(best) if best[i] <= N]\\n\\n        return ret\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            list1 a1 = list1(nums1);\\n            int N1 = nums1.size();\\n            list1 a2 = list1(nums2);\\n            int N2 = nums2.size();\\n            \\n            auto ret = vector<int>(k,0);\\n            auto f = vector<int>(N1 + 1,0); \\n            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k\\n            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] \\n            for (int d = 1;d <= k;d++)\\n            {\\n                int maxDigit = -1;\\n                auto tmpf = vector<int>(N1 + 1,INT_MAX);\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y)); \\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    maxDigit = max(maxDigit,m1.first);\\n                    maxDigit = max(maxDigit,m2.first);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 128242,
                "title": "java-self-explanatory-neat-code",
                "content": "The final result res[] would be merged from res1[] and res2[], such that res1[] is max subsequence of nums1 of length ki, then res2[] is max subsequence of nums2 with length k - ki.\\nTo get max subsequence of length cnt, we use stack.\\nTo do with merging and update final result, we use util method greater().\\n```\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        \\n        for (int ki = Math.max(0, k - nums2.length); ki <= Math.min(k, nums1.length); ki++) {\\n            int[] res1 = getMaxSubsequence(nums1, ki); // ki < nums1.length\\n            int[] res2 = getMaxSubsequence(nums2, k - ki); // k - ki < nums2.length\\n            int[] resTmp = new int[k];\\n            int p1 = 0, p2 = 0, pt = 0;\\n            while (p1 < res1.length || p2 < res2.length) {\\n                resTmp[pt++] = isGreater(res1, p1, res2, p2) ? res1[p1++] : res2[p2++];\\n            }\\n            if (!isGreater(result, 0, resTmp, 0)) {\\n                result = resTmp;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] getMaxSubsequence(int[] nums, int cnt){\\n        Stack<Integer> stack = new Stack<>();\\n        int remain = cnt;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i] && nums.length - 1 - i >= remain) {\\n                stack.pop();\\n                remain++;\\n            }\\n            if (remain > 0) {\\n                stack.push(nums[i]);\\n                remain--;\\n            }\\n        }\\n        int[] maxSub = new int[cnt];\\n        int mi = maxSub.length - 1;\\n        while (!stack.isEmpty()) {\\n            maxSub[mi--] = stack.pop();\\n        }\\n        return maxSub;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2) {\\n        for (; p1 < nums1.length && p2 < nums2.length; p1++, p2++) {\\n            if (nums1[p1] > nums2[p2]) {\\n                return true;\\n            }\\n            if (nums1[p1] < nums2[p2]) {\\n                return false;\\n            }\\n        }\\n        return p1 != nums1.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        \\n        for (int ki = Math.max(0, k - nums2.length); ki <= Math.min(k, nums1.length); ki++) {\\n            int[] res1 = getMaxSubsequence(nums1, ki); // ki < nums1.length\\n            int[] res2 = getMaxSubsequence(nums2, k - ki); // k - ki < nums2.length\\n            int[] resTmp = new int[k];\\n            int p1 = 0, p2 = 0, pt = 0;\\n            while (p1 < res1.length || p2 < res2.length) {\\n                resTmp[pt++] = isGreater(res1, p1, res2, p2) ? res1[p1++] : res2[p2++];\\n            }\\n            if (!isGreater(result, 0, resTmp, 0)) {\\n                result = resTmp;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] getMaxSubsequence(int[] nums, int cnt){\\n        Stack<Integer> stack = new Stack<>();\\n        int remain = cnt;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i] && nums.length - 1 - i >= remain) {\\n                stack.pop();\\n                remain++;\\n            }\\n            if (remain > 0) {\\n                stack.push(nums[i]);\\n                remain--;\\n            }\\n        }\\n        int[] maxSub = new int[cnt];\\n        int mi = maxSub.length - 1;\\n        while (!stack.isEmpty()) {\\n            maxSub[mi--] = stack.pop();\\n        }\\n        return maxSub;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2) {\\n        for (; p1 < nums1.length && p2 < nums2.length; p1++, p2++) {\\n            if (nums1[p1] > nums2[p2]) {\\n                return true;\\n            }\\n            if (nums1[p1] < nums2[p2]) {\\n                return false;\\n            }\\n        }\\n        return p1 != nums1.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611691,
                "title": "java-easy-to-understand-monotonic-stack-3-subproblems-same-as-leetcode-16737",
                "content": "# 1673. Find the Most Competitive Subsequence\\n```\\n// TC-o(n)- Monotonously increasing stack\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n        Stack<Integer> st=new Stack<>();\\n        int[] res=new int[k];\\n        int rem=n-k;\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && st.peek()>nums[i] && rem>0){\\n                st.pop();\\n                rem--;\\n            }\\n            st.push(nums[i]);\\n            \\n        }\\n        while(rem>0){\\n            st.pop();\\n            rem--;\\n        }\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# 321. Create Maximum Number\\n**3 Subproblems-**\\n1. Find greatest numbers from nums1 and nums2 using the concept from leetcode 1673(monotonously decreasing stack here, that is the only change)\\n2. Merge the two numbers(here they are in the form of arrays) such that it forms the greatest number\\n3. Find the greatest among all the formed numbers.\\nHere greatest means the number which is lexicographically greater.\\n\\n```\\n// using the concept of 1673. Find the Most Competitive Subsequence\\n// prob is we dn t know how many elements we will take from nums1 and nums2\\n// so we will try for all combinations of k and find the max out of them\\n\\nclass Solution {\\n    \\n    // monotonic decreasing stack same as leetcode 1673 , only > changed to < \\n\\tpublic int[] findLexMax(int[] nums, int k) {\\n\\t\\tint n = nums.length;\\n\\t\\tStack<Integer> st = new Stack<>();\\n\\t\\tint[] res = new int[k];\\n        \\n        /* we have to form a k digit number which is lexicographically greatest\\n         that gives some hint that we need to maintain a monotonic decreasing stack\\n         and rem=n-k means we will remove n-k smaller digits from stack\\n         lets say nums=[6,7,4,8,9] and k=3, we have to remove 5-3=2 digits from the stack,\\n         while we try to form monotonic decreasing satck\\n         o our max number will be [8,9]\\n         */\\n\\t\\tint rem = n - k;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!st.isEmpty() && st.peek() < nums[i] && rem > 0) {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\trem--;\\n\\t\\t\\t}\\n\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t}\\n        \\n        /* if still some elements can be removed, the best option would be to remove the\\n        elements from the top of the stack, as we are mainting a monotonic decreasing satck\\n        so elemets at the top would be smaller\\n        take this example arr-[6,4,2] k=2 ans would be [6,4]\\n        */\\n\\t\\twhile (rem > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\trem--;\\n\\t\\t}\\n\\t\\tfor (int i = k - 1; i >= 0; i--) {\\n\\t\\t\\tres[i] = st.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\n\\tprivate static boolean findMax(int[] arr1, int[] arr2, int p1,int p2) {\\n\\t\\twhile (p1 < arr1.length && p2 < arr2.length) {\\n\\t\\t\\tif (arr1[p1] < arr2[p2]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if (arr1[p1] > arr2[p2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t}\\n        // when p1 is empty returns true, so that in merge function it picks up values of arr2\\n        // when p1==arr1.length, then returns false,so that we keep pn picking arr2 elements\\n\\t\\treturn p1!=arr1.length; // tricky\\n\\t}\\n\\n    \\n\\t// think of the case [6,0,4] and [6,7], can t do simple logic like merge two sorted arrays\\n    // we need to decide which pointer to move forward based on the rest of the array,\\n    // if both elements are same compare the next element, and then decide\\n\\tprivate int[] merge(int[] nums1, int[] nums2, int k) {\\n\\t\\tint[] res = new int[k];\\n\\t\\tint resIndex = 0;\\n\\t\\tint p1 = 0;\\n\\t\\tint p2 = 0;\\n        \\n\\t\\twhile (resIndex<res.length) {\\n\\t\\t\\tres[resIndex++]=findMax(nums1,nums2,p1,p2)?nums1[p1++]:nums2[p2++];// tricky\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tint len1 = nums1.length;\\n\\t\\tint len2 = nums2.length;\\n\\t\\tint[] maxRes = new int[k];\\n\\t\\tfor (int i = 0; i <= k; i++) { \\n\\t\\t\\tint j = k - i;\\n\\t\\t\\tif (i <= len1 && (k - i) <= len2) { // skip invalid cases, imp step!\\n\\t\\t\\t\\tint[] maxLex1 = findLexMax(nums1, i);\\n\\t\\t\\t\\tint[] maxLex2 = findLexMax(nums2, j);\\n\\t\\t\\t\\tint[] res = merge(maxLex1, maxLex2, k);\\n\\t\\t\\t\\tboolean compareRes = findMax(res, maxRes,0,0);\\n\\t\\t\\t\\tif (compareRes) {\\n\\t\\t\\t\\t\\tmaxRes = res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxRes;\\n\\t}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\n// TC-o(n)- Monotonously increasing stack\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n        Stack<Integer> st=new Stack<>();\\n        int[] res=new int[k];\\n        int rem=n-k;\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && st.peek()>nums[i] && rem>0){\\n                st.pop();\\n                rem--;\\n            }\\n            st.push(nums[i]);\\n            \\n        }\\n        while(rem>0){\\n            st.pop();\\n            rem--;\\n        }\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n// using the concept of 1673. Find the Most Competitive Subsequence\\n// prob is we dn t know how many elements we will take from nums1 and nums2\\n// so we will try for all combinations of k and find the max out of them\\n\\nclass Solution {\\n    \\n    // monotonic decreasing stack same as leetcode 1673 , only > changed to < \\n\\tpublic int[] findLexMax(int[] nums, int k) {\\n\\t\\tint n = nums.length;\\n\\t\\tStack<Integer> st = new Stack<>();\\n\\t\\tint[] res = new int[k];\\n        \\n        /* we have to form a k digit number which is lexicographically greatest\\n         that gives some hint that we need to maintain a monotonic decreasing stack\\n         and rem=n-k means we will remove n-k smaller digits from stack\\n         lets say nums=[6,7,4,8,9] and k=3, we have to remove 5-3=2 digits from the stack,\\n         while we try to form monotonic decreasing satck\\n         o our max number will be [8,9]\\n         */\\n\\t\\tint rem = n - k;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!st.isEmpty() && st.peek() < nums[i] && rem > 0) {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\trem--;\\n\\t\\t\\t}\\n\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t}\\n        \\n        /* if still some elements can be removed, the best option would be to remove the\\n        elements from the top of the stack, as we are mainting a monotonic decreasing satck\\n        so elemets at the top would be smaller\\n        take this example arr-[6,4,2] k=2 ans would be [6,4]\\n        */\\n\\t\\twhile (rem > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\trem--;\\n\\t\\t}\\n\\t\\tfor (int i = k - 1; i >= 0; i--) {\\n\\t\\t\\tres[i] = st.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\n\\tprivate static boolean findMax(int[] arr1, int[] arr2, int p1,int p2) {\\n\\t\\twhile (p1 < arr1.length && p2 < arr2.length) {\\n\\t\\t\\tif (arr1[p1] < arr2[p2]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if (arr1[p1] > arr2[p2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t}\\n        // when p1 is empty returns true, so that in merge function it picks up values of arr2\\n        // when p1==arr1.length, then returns false,so that we keep pn picking arr2 elements\\n\\t\\treturn p1!=arr1.length; // tricky\\n\\t}\\n\\n    \\n\\t// think of the case [6,0,4] and [6,7], can t do simple logic like merge two sorted arrays\\n    // we need to decide which pointer to move forward based on the rest of the array,\\n    // if both elements are same compare the next element, and then decide\\n\\tprivate int[] merge(int[] nums1, int[] nums2, int k) {\\n\\t\\tint[] res = new int[k];\\n\\t\\tint resIndex = 0;\\n\\t\\tint p1 = 0;\\n\\t\\tint p2 = 0;\\n        \\n\\t\\twhile (resIndex<res.length) {\\n\\t\\t\\tres[resIndex++]=findMax(nums1,nums2,p1,p2)?nums1[p1++]:nums2[p2++];// tricky\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tint len1 = nums1.length;\\n\\t\\tint len2 = nums2.length;\\n\\t\\tint[] maxRes = new int[k];\\n\\t\\tfor (int i = 0; i <= k; i++) { \\n\\t\\t\\tint j = k - i;\\n\\t\\t\\tif (i <= len1 && (k - i) <= len2) { // skip invalid cases, imp step!\\n\\t\\t\\t\\tint[] maxLex1 = findLexMax(nums1, i);\\n\\t\\t\\t\\tint[] maxLex2 = findLexMax(nums2, j);\\n\\t\\t\\t\\tint[] res = merge(maxLex1, maxLex2, k);\\n\\t\\t\\t\\tboolean compareRes = findMax(res, maxRes,0,0);\\n\\t\\t\\t\\tif (compareRes) {\\n\\t\\t\\t\\t\\tmaxRes = res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxRes;\\n\\t}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592042,
                "title": "easy-understanding-and-readable-code-monotonic-stack-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will find lexographically greatest subsequence from both array and then merge them.\\nBut constraint is length=k must be satisfied. So have to find lexographically greater subsequence such that both combinedly have length k.\\n\\nBut how to decide how much length have to take from first array and how much from second array? --> This time go by bruteforce. So for possible {i, k-i} pair of length , we will find our answer.\\n\\nlet\\'s divide the problem into subparts:\\nsubpart-1: find out lexographically greatest subsequence from both array.\\nsubpart-2: Merge them and keep taking maximum.\\n\\nImplemented stack logic through array. You can go through stack .\\n# Complexity\\n- Time complexity:O(K*N + K*N)= O(K*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(K) => for this loop: for(int i=0;i<=k;i++) in maxNumber function.\\nO(N) => for getGrtrSubseq function.\\nO(K*N) => merge Function.\\n- Space complexity: O(N) as all are linear vectors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```\\n.![download (2).jpg](https://assets.leetcode.com/users/images/8eac6c0a-55fa-4b53-abd4-45a92c342e39_1685777059.4901643.jpeg)\\n\\nCorrect me if i am wrong.\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027086,
                "title": "python-solution-greedy-search-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:        \\n        def merge(n1, n2):\\n            res = []\\n            while (n1 or n2) :\\n                if n1>n2:\\n                    res.append(n1[0])\\n                    n1 = n1[1:]\\n                else:\\n                    res.append(n2[0])\\n                    n2 = n2[1:]\\n            return res\\n        \\n        def findmax(nums, length):\\n            l = []\\n            maxpop = len(nums)-length\\n            for i in range(len(nums)):\\n                while maxpop>0 and len(l) and nums[i]>l[-1]:\\n                    l.pop()\\n                    maxpop -= 1\\n                l.append(nums[i])\\n            return l[:length]\\n        \\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        res = [0]*k\\n        for i in range(k+1):\\n            j = k-i\\n            if i>n1 or j>n2:    continue\\n            l1 = findmax(nums1, i)\\n            l2 = findmax(nums2, j)\\n            res = max(res, merge(l1,l2))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:        \\n        def merge(n1, n2):\\n            res = []\\n            while (n1 or n2) :\\n                if n1>n2:\\n                    res.append(n1[0])\\n                    n1 = n1[1:]\\n                else:\\n                    res.append(n2[0])\\n                    n2 = n2[1:]\\n            return res\\n        \\n        def findmax(nums, length):\\n            l = []\\n            maxpop = len(nums)-length\\n            for i in range(len(nums)):\\n                while maxpop>0 and len(l) and nums[i]>l[-1]:\\n                    l.pop()\\n                    maxpop -= 1\\n                l.append(nums[i])\\n            return l[:length]\\n        \\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        res = [0]*k\\n        for i in range(k+1):\\n            j = k-i\\n            if i>n1 or j>n2:    continue\\n            l1 = findmax(nums1, i)\\n            l2 = findmax(nums2, j)\\n            res = max(res, merge(l1,l2))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 620783,
                "title": "java-simple-code-dp",
                "content": "`dp[i][j][k]` is denoted as the maximum string that takes `a` numbers from first `i` numbers from `A`, and `b` numbers from first `j` numbers from `B` to create `a+b = k` numbers.\\n\\nedge case:\\nif `(i+j < k)` then `dp[i][j][k] = empty`\\nif `i = 0` or `j = 0`, the issue turns into `1 array`\\nif `k = 0` then `dp[i][j][0] = empty`\\n\\n```\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        int m = A.length, n = B.length;\\n        if (m+n < k) return new int[0];\\n\\n        String[][][] dp = new String[m+1][n+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    if (i+j < l) dp[i][j][l] = \"\";\\n                    else {\\n                        String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i-1][j][l-1] + A[i-1];\\n                        String chooseBj = (j == 0 || l == 0) ? \"\" : dp[i][j-1][l-1] + B[j-1];\\n                        String maxChoose = max(chooseAi, chooseBj);\\n\\n                        String ignoreAi = (i == 0) ? \"\" : dp[i-1][j][l];\\n                        String ignoreBj = (j == 0) ? \"\" : dp[i][j-1][l];\\n                        String ignoreBoth = (i == 0 || j == 0) ? \"\" : dp[i-1][j-1][l];\\n                        String maxIgnore = max(max(ignoreAi, ignoreBj), ignoreBoth);\\n\\n                        dp[i][j][l] = max(maxChoose, maxIgnore);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return convert(dp[m][n][k]);\\n    }\\n\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n\\n    private int[] convert(String s)  {\\n        int n = s.length(), res[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = s.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n```\\n\\nTime complexity `O(mnk)`, Space complexity `O(mnk)`.\\nthough `MLE`, but space complexity can be improved to `O(mn)` (good practice).",
                "solutionTags": [],
                "code": "```\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        int m = A.length, n = B.length;\\n        if (m+n < k) return new int[0];\\n\\n        String[][][] dp = new String[m+1][n+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    if (i+j < l) dp[i][j][l] = \"\";\\n                    else {\\n                        String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i-1][j][l-1] + A[i-1];\\n                        String chooseBj = (j == 0 || l == 0) ? \"\" : dp[i][j-1][l-1] + B[j-1];\\n                        String maxChoose = max(chooseAi, chooseBj);\\n\\n                        String ignoreAi = (i == 0) ? \"\" : dp[i-1][j][l];\\n                        String ignoreBj = (j == 0) ? \"\" : dp[i][j-1][l];\\n                        String ignoreBoth = (i == 0 || j == 0) ? \"\" : dp[i-1][j-1][l];\\n                        String maxIgnore = max(max(ignoreAi, ignoreBj), ignoreBoth);\\n\\n                        dp[i][j][l] = max(maxChoose, maxIgnore);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return convert(dp[m][n][k]);\\n    }\\n\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n\\n    private int[] convert(String s)  {\\n        int n = s.length(), res[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = s.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330015,
                "title": "greedy-solution-time-complexity-o-n-2-space-complexity-o-n-with-comments",
                "content": "Basic idea is to find best answer from nums1 with size `i`  and from `nums2` with size `k-i`. Then we merge the two arrays, the merge function has been optimized to be `O(N)` . Overall Complexity is `O(N^2)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> answer(k);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        for(int i = 0; i <= k; i++) {\\n            int j = k - i;\\n            if (i <= n1 && j <= n2) {\\n                vector<int> ans1 = maxSingleNumber(nums1, i); // best of size i - O(n)\\n                vector<int> ans2 = maxSingleNumber(nums2, j); // best of size k - i - O(n)\\n                vector<int> ans = merge(ans1, ans2); // merging both - O(n)\\n               \\n                answer = max(ans, answer); // maximize answer - O(n)\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; \\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = 0; \\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // Eventhough there are two nested loops, I believe this is linear as the second loop can only run once per element\\n        while(i<n1 && j<n2) {\\n            if (nums1[i] > nums2[j])\\n                ans.push_back(nums1[i++]);\\n            else if (nums1[i] < nums2[j])\\n                ans.push_back(nums2[j++]);\\n            else { // Both are equal, we need to pick the one that is better in the future\\n                int i1 = i + 1;\\n                int j1 = j + 1;\\n                int larger = 0; \\n                \\n                while(i1<n1 && j1 < n2 && !larger) {\\n                    if(nums1[i1] == nums2[j1]) {\\n                        if (nums1[i1] < nums1[i]) // This number is less than the current stopping position, so we would pick that instead \\n                            break;\\n                        i1++;\\n                        j1++;\\n                    }\\n                    else if (nums1[i1] > nums2[j1]) // nums1 is better to pick \\n                        larger = -1;\\n                    else\\n                        larger = 1;  // nums2 is better to pick \\n                }\\n                \\n                if (i1 == n1)\\n                    larger = 1;\\n                if (j1 == n2)\\n                    larger = -1;\\n                \\n                if (larger == -1)\\n                    ans.push_back(nums1[i++]);\\n                else \\n                    ans.push_back(nums2[j++]);\\n            }\\n        }\\n            \\n        // Push Remaining elements\\n        while(i<n1)\\n            ans.push_back(nums1[i++]);\\n        \\n        while(j<n2)\\n            ans.push_back(nums2[j++]);\\n        \\n        return ans;\\n            \\n                \\n    }\\n    \\n    vector<int> maxSingleNumber(vector<int>& nums1, int k) {\\n        \\n        vector<int> stack; \\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            // Pop elements from the stack if current element is greater than head of the stack\\n            // We can pop only if remaining elements in nums1 + remaining elements in stack \\n            // after popping is greater than or equal to k\\n            while(!stack.empty() && (stack.back() < nums1[i] && (stack.size() -1) + (n-i) >=k ))\\n                stack.pop_back();\\n            \\n            // Push if less than k elements\\n            if (stack.size() < k)\\n                stack.push_back(nums1[i]);\\n        }\\n        return stack;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> answer(k);\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        for(int i = 0; i <= k; i++) {\\n            int j = k - i;\\n            if (i <= n1 && j <= n2) {\\n                vector<int> ans1 = maxSingleNumber(nums1, i); // best of size i - O(n)\\n                vector<int> ans2 = maxSingleNumber(nums2, j); // best of size k - i - O(n)\\n                vector<int> ans = merge(ans1, ans2); // merging both - O(n)\\n               \\n                answer = max(ans, answer); // maximize answer - O(n)\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; \\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = 0; \\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        // Eventhough there are two nested loops, I believe this is linear as the second loop can only run once per element\\n        while(i<n1 && j<n2) {\\n            if (nums1[i] > nums2[j])\\n                ans.push_back(nums1[i++]);\\n            else if (nums1[i] < nums2[j])\\n                ans.push_back(nums2[j++]);\\n            else { // Both are equal, we need to pick the one that is better in the future\\n                int i1 = i + 1;\\n                int j1 = j + 1;\\n                int larger = 0; \\n                \\n                while(i1<n1 && j1 < n2 && !larger) {\\n                    if(nums1[i1] == nums2[j1]) {\\n                        if (nums1[i1] < nums1[i]) // This number is less than the current stopping position, so we would pick that instead \\n                            break;\\n                        i1++;\\n                        j1++;\\n                    }\\n                    else if (nums1[i1] > nums2[j1]) // nums1 is better to pick \\n                        larger = -1;\\n                    else\\n                        larger = 1;  // nums2 is better to pick \\n                }\\n                \\n                if (i1 == n1)\\n                    larger = 1;\\n                if (j1 == n2)\\n                    larger = -1;\\n                \\n                if (larger == -1)\\n                    ans.push_back(nums1[i++]);\\n                else \\n                    ans.push_back(nums2[j++]);\\n            }\\n        }\\n            \\n        // Push Remaining elements\\n        while(i<n1)\\n            ans.push_back(nums1[i++]);\\n        \\n        while(j<n2)\\n            ans.push_back(nums2[j++]);\\n        \\n        return ans;\\n            \\n                \\n    }\\n    \\n    vector<int> maxSingleNumber(vector<int>& nums1, int k) {\\n        \\n        vector<int> stack; \\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            // Pop elements from the stack if current element is greater than head of the stack\\n            // We can pop only if remaining elements in nums1 + remaining elements in stack \\n            // after popping is greater than or equal to k\\n            while(!stack.empty() && (stack.back() < nums1[i] && (stack.size() -1) + (n-i) >=k ))\\n                stack.pop_back();\\n            \\n            // Push if less than k elements\\n            if (stack.size() < k)\\n                stack.push_back(nums1[i]);\\n        }\\n        return stack;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210773,
                "title": "c-fast-and-elegant-new-idea-12ms-100-time-o-k-m-n-space-o-m-n",
                "content": "Iteratively (greedily) find the maximal number of x digits that could potentially be extended to k digits (i.e. there are at least k digits left). To determine whether the number can be extended, it suffices to record the index of the last used digit in both numbers (there can be multiple such pairs of indices leading to the same maximal number), and check that there are at least a total of k-x digits left in both numbers. In the following implementation, the indices following the last used digits are recorded in `list_indices`. (Using set instead of vector or list because it can has at most max(m,n) elements, but with repetition it can blow up to 2^x and TLE.)\\nTo go from step x to x+1, for each pair of indices in `list_indices`, extend the maximum number by one digit chosen from the ranges starting from those indices. Depending on whether the added digit is from the first or the second number, we get two new pairs of indices (stored in `next_list_indices`). We can throw out those pairs whose corresponding added digits are not maximal.\\nIf we index the elements in `list_indices` as (m1,n1), (m2, n2), ... then they can be shown to satisfy m1 > m2 > m3 > ... and n1 < n2 < n3 < ... which shows the size of `list_indices` can be at most max(m,n), so the space complexity is clearly O(m+n). (It helps to plot the indices in a 2D grid.) Further analysis shows that for set insertion we just need to check that the inserted element is not the same as the last inserted element, so we can get rid of a log(m+n) factor for insertion. There are k steps and for each step the total number of indices checked in `getBestIndex` doesn\\'t exceed m+n (e.g. if you extend (m1,n1) by one digit from the first number, you get some (m1\\',n1) with m1\\' <= m2), so the time complexity is O(k(m+n)). With more reasoning you can avoid some of the `getBestIndex` calls under certain conditions, but that doesn\\'t lead to improvement on the asymptotic complexity.\\n\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> getBestIndex(vector<int>& nums, int start, int span) {\\n\\t// get index and maximum\\n        int max_idx = 0;\\n        int max_ = nums[start];\\n        int i = 1;\\n        while (i < span) {\\n            auto val = nums[start+i];\\n            if (val > max_) {\\n                max_idx = i;\\n                max_ = val;\\n                if (max_ == 9) break;\\n            }\\n            i++;\\n        }\\n        return pair<int,int>(max_idx, max_);\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> best_seq;\\n        set<pair<int,int>> list_indices = {{0,0}};\\n        while (k-- > 0) {\\n            set<pair<int,int>> next_list_indices;\\n            int max_ = -1;\\n            for (auto indices : list_indices) {\\n                auto n1 = indices.first;\\n                auto n2 = indices.second;\\n                auto remaining = nums1.size() + nums2.size() - n1 - n2 - k;\\n                int idx1, max1 = -1, idx2, max2 = -1;\\n                auto remaining1 = min(remaining, nums1.size() - n1);\\n                auto remaining2 = min(remaining, nums2.size() - n2);\\n                if (remaining1)\\n                    tie(idx1, max1) = getBestIndex(nums1, n1, remaining1);\\n                if (remaining2)\\n                    tie(idx2, max2) = getBestIndex(nums2, n2, remaining2);\\n                auto max12 = max(max1, max2);\\n                if (max12 < max_) continue;\\n                if (max12 > max_) { max_ = max12; next_list_indices.clear(); }\\n                if (max1 >= max2) next_list_indices.insert({n1+idx1+1, n2});\\n                if (max1 <= max2) next_list_indices.insert({n1, n2+idx2+1});\\n            }\\n            best_seq.emplace_back(max_);\\n            list_indices = move(next_list_indices);\\n        }\\n        return best_seq;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> getBestIndex(vector<int>& nums, int start, int span) {\\n\\t// get index and maximum\\n        int max_idx = 0;\\n        int max_ = nums[start];\\n        int i = 1;\\n        while (i < span) {\\n            auto val = nums[start+i];\\n            if (val > max_) {\\n                max_idx = i;\\n                max_ = val;\\n                if (max_ == 9) break;\\n            }\\n            i++;\\n        }\\n        return pair<int,int>(max_idx, max_);\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> best_seq;\\n        set<pair<int,int>> list_indices = {{0,0}};\\n        while (k-- > 0) {\\n            set<pair<int,int>> next_list_indices;\\n            int max_ = -1;\\n            for (auto indices : list_indices) {\\n                auto n1 = indices.first;\\n                auto n2 = indices.second;\\n                auto remaining = nums1.size() + nums2.size() - n1 - n2 - k;\\n                int idx1, max1 = -1, idx2, max2 = -1;\\n                auto remaining1 = min(remaining, nums1.size() - n1);\\n                auto remaining2 = min(remaining, nums2.size() - n2);\\n                if (remaining1)\\n                    tie(idx1, max1) = getBestIndex(nums1, n1, remaining1);\\n                if (remaining2)\\n                    tie(idx2, max2) = getBestIndex(nums2, n2, remaining2);\\n                auto max12 = max(max1, max2);\\n                if (max12 < max_) continue;\\n                if (max12 > max_) { max_ = max12; next_list_indices.clear(); }\\n                if (max1 >= max2) next_list_indices.insert({n1+idx1+1, n2});\\n                if (max1 <= max2) next_list_indices.insert({n1, n2+idx2+1});\\n            }\\n            best_seq.emplace_back(max_);\\n            list_indices = move(next_list_indices);\\n        }\\n        return best_seq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77300,
                "title": "c-dp-greedy-solution-should-be-easy-to-understand",
                "content": "Here is the idea:\\n                       \\nLet's consider a similar but simple version of this problem: if there is only one array arr of which length is m, how to find the k digits of it to create maximum number preserving the order?\\nSo here comes to my DP solution: DP[ i ][ j ] means that the maximum number that has i digits we can get  when the jth digits is the last one of this number. Thus the formula is as follows:\\n\\n           dp[ i ] [ j ] = max(dp[ i ][ j ], max(dp[ i - 1 ][ 0 ... j - 1 ]))\\n\\nOk. We apply this formula to the two given arrays and then get two DP arrays DP1 and DP2 where DP[ i ] means the largest number with i digits.    \\n\\nBack to our problem: Choose k digits of these two arrays/strings to create the maximum number. Now here is the greedy solution:\\n\\nFor every pair of i and j where i + j == k and i is the number of digits used from array1 and j is the number of digits used from array2, we have to combine to create a new number so that it is the largest of all combinations. Remember a similar greedy problem? The trick here is that we use two pointers for each array and in each iteration, pick up pointers pointing to the larger digit or the larger substring. Then the number created is the largest from the given two arrays/strings.\\n                    \\nStill confused? Plsz read the code below:\\n      \\n    \\n              \\n    class Solution {\\n        public:\\n            vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n                vector<int> ans;\\n                if(!nums1.size() && !nums2.size() || !k)\\n                    return ans;\\n                ans.resize(k);\\n                int n = nums1.size(), m = nums2.size();\\n                vector<string> dp1(min(k, n)), dp2(min(k, m));\\n                vector<string> dpprev1(n), dpcur1(n), dpprev2(m), dpcur2(m);\\n        \\n                for(int i = 0; i < dp1.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp1[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < n; ++ j){\\n                            dpprev1[j] = \"\";\\n                            dpprev1[j] += (char)(nums1[j] + '0');\\n                            dp1[i] = max(dp1[i], dpprev1[j]);\\n                            if(j)\\n                                dpprev1[j] = max(dpprev1[j], dpprev1[j - 1]);\\n        \\n                        }\\n                    }else{\\n                        for(int j = i; j < n; ++ j){\\n                            dpcur1[j] = tmpval;\\n        \\n                            dpcur1[j] = max(dpcur1[j], dpprev1[j - 1] + (char)(nums1[j] + '0'));\\n        \\n                            dp1[i] = max(dp1[i], dpcur1[j]);\\n                            if(j >= i)\\n                                dpcur1[j] = max(dpcur1[j], dpcur1[j - 1]);\\n                        }\\n                        dpprev1 = dpcur1;\\n                    }\\n        \\n                }\\n        \\n        \\n        \\n                for(int i = 0; i < dp2.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp2[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < m; ++ j){\\n                            dpprev2[j] = \"\";\\n                            dpprev2[j] += (char)(nums2[j] + '0');\\n                            dp2[i] = max(dp2[i], dpprev2[j]);\\n                            if(j)\\n                                dpprev2[j] = max(dpprev2[j], dpprev2[j - 1]);\\n                        }\\n                    }else{\\n                        for(int j = i; j < m; ++ j){\\n                            dpcur2[j] = tmpval;\\n        \\n                            dpcur2[j] = max(dpcur2[j], dpprev2[j - 1] + (char)(nums2[j] + '0'));\\n        \\n                            dp2[i] = max(dp2[i], dpcur2[j]);\\n                            if(j >= i)\\n                                dpcur2[j] = max(dpcur2[j], dpcur2[j - 1]);\\n                        }\\n                        dpprev2 = dpcur2;\\n                    }\\n        \\n                }\\n        \\n        \\n                string tmpans(k, 0), v = \"\";\\n        \\n                if(!dp1.size()){\\n                    getAns(v, dp2[k - 1], ans, tmpans);\\n                }else{\\n                    for(int i = 0; i <= min(k, (int)dp1.size()); ++ i){\\n                        if(i == 0){\\n                            if(dp2.size() >= k)\\n                                getAns(v, dp2[k - 1], ans, tmpans);\\n                        }else if(i < k){\\n                            if(dp2.size() >= k - i)\\n                                getAns(dp1[i - 1], dp2[k - i - 1], ans, tmpans);\\n                        }else{\\n                            if(dp1.size() >= k)\\n                                getAns(dp1[k - 1], v, ans, tmpans);\\n                        }\\n                    }\\n        \\n                }\\n        \\n                return ans;\\n            }\\n        \\n        private:\\n            void getAns(string &s1, string &s2, vector<int> &ans, string &tmpans){\\n                string res;\\n                if(!s1.size())\\n                    res = s2;\\n                else if(!s2.size())\\n                    res = s1;\\n                else{\\n                    int id1 = 0, id2 = 0;\\n        \\n                    while(id1 < s1.size() && id2 < s2.size()){\\n                        if(s1[id1] > s2[id2]){\\n                            res += s1[id1 ++];\\n                        }else if(s1[id1] < s2[id2]){\\n                            res += s2[id2 ++];\\n                        }else{\\n                            if(s1.substr(id1) >= s2.substr(id2))\\n                                res += s1[id1 ++];\\n                            else\\n                                res += s2[id2 ++];\\n                        }\\n                    }\\n                    while(id1 < s1.size())\\n                        res += s1[id1 ++];\\n                    while(id2 < s2.size())\\n                        res += s2[id2 ++];\\n                }\\n        \\n                if(res > tmpans){\\n                    tmpans = res;\\n                    for(int i = 0; i < res.size(); ++ i)\\n                        ans[i] = (res[i] - '0');\\n                }\\n            }\\n        };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\n        public:\\n            vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n                vector<int> ans;\\n                if(!nums1.size() && !nums2.size() || !k)\\n                    return ans;\\n                ans.resize(k);\\n                int n = nums1.size(), m = nums2.size();\\n                vector<string> dp1(min(k, n)), dp2(min(k, m));\\n                vector<string> dpprev1(n), dpcur1(n), dpprev2(m), dpcur2(m);\\n        \\n                for(int i = 0; i < dp1.size(); ++ i){\\n                    string tmpval(i + 1, 0);\\n                    dp1[i] = tmpval;\\n                    if(!i){\\n                        for(int j = 0; j < n; ++ j){\\n                            dpprev1[j] = \"\";\\n                            dpprev1[j] += (char)(nums1[j] + '0');\\n                            dp1[i] = max(dp1[i], dpprev1[j]);\\n                            if(j)\\n                                dpprev1[j] = max(dpprev1[j], dpprev1[j - 1]);\\n        \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3043133,
                "title": "c-best-and-easiest-solution-monotonic-stack-vector-merging",
                "content": "# Approach\\nTake ans = 0;\\nfor every i from 0 to n-1, do the following : \\n1. Take max number of i digits from nums1 and max number of k-i digits from nums2.\\n2. Merge the above generated numbers to get the maximum number temp of k digits.\\n3. update our ans as ans = max(ans , temp);\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // function to generate maximum number of k digits in the form of vector obtained using elements of array nums.\\n    vector<int> solve(int k , vector<int> &nums){\\n        int n = nums.size();\\n        if(k>n) return {};\\n        vector<int> ans;\\n        int rem = n-k;\\n        ans.push_back(nums[0]);\\n        // monotonic stack\\n        for(int i=1 ; i<n ; i++){\\n            while(!ans.empty() && nums[i]>ans.back() && rem>0){\\n                ans.pop_back();\\n                rem--;\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        while(rem--){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n\\n    // function to merge two numbers in the form of vectors (v1 and v2) to get the maximum possible number and store it in another vector temp\\n    void merge(vector<int> &ans , vector<int> &v1 , vector<int> &v2){\\n        int m = v1.size();\\n        int n = v2.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n){\\n            // Case1:\\n            // ....5 5 5 5 5 7....     .... 5 5 5 5 5 5...\\n            //     i                        j\\n            //               tempi                     tempj\\n            if(v1[i] == v2[j]){\\n                int tempi= i;\\n                int tempj= j;\\n                while(tempi<m && tempj<n && v1[tempi]==v2[tempj]){\\n                    tempi++;\\n                    tempj++;\\n                }\\n                if(tempj == n){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else if(tempi == m){\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }else if(v1[tempi]>v2[tempj]){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else{\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }                \\n            }\\n            // Case2 : ....5 6 7 3 4.....     .....2 3 9 8 7....\\n            //             i                       j\\n            else if(v1[i] > v2[j]){\\n                ans.push_back(v1[i]);\\n                i++;\\n            }\\n            // Case2 : ....2 6 7 3 4.....     .....9 3 9 8 7....\\n            //             i                       j\\n            else{\\n                ans.push_back(v2[j]);\\n                j++;\\n            }\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //          i                j\\n        while(i<m){\\n            ans.push_back(v1[i]);\\n            i++;\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //              i      j\\n        while(j<n){\\n            ans.push_back(v2[j]);\\n            j++;\\n        }\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // We consider every possible case:\\n        // eg.1 Take maximum number of 0 digits from nums1 and maximum number of k digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg2. Take maximum number of 1 digits from nums1 and maximum number of k-1 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg3. Take maximum number of 2 digits from nums1 and maximum number of k-2 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg4. Take maximum number of 3 digits from nums1 and maximum number of k-3 digits from nums2 and merge them to get a maximum number of k digits.\\n        // and so on.................\\n        // Then take the maximum among all the above generated numbers as our answer.\\n\\n        vector<int> ans;\\n        for(int i=0 ; i<=k ; i++){\\n            vector<int> temp1 = solve(i , nums1);\\n            vector<int> temp2 = solve(k-i , nums2);\\n            vector<int> temp;\\n            merge(temp , temp1 , temp2);\\n            if(temp.size() == k) ans = max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if you understood the approach and the code!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // function to generate maximum number of k digits in the form of vector obtained using elements of array nums.\\n    vector<int> solve(int k , vector<int> &nums){\\n        int n = nums.size();\\n        if(k>n) return {};\\n        vector<int> ans;\\n        int rem = n-k;\\n        ans.push_back(nums[0]);\\n        // monotonic stack\\n        for(int i=1 ; i<n ; i++){\\n            while(!ans.empty() && nums[i]>ans.back() && rem>0){\\n                ans.pop_back();\\n                rem--;\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        while(rem--){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n\\n    // function to merge two numbers in the form of vectors (v1 and v2) to get the maximum possible number and store it in another vector temp\\n    void merge(vector<int> &ans , vector<int> &v1 , vector<int> &v2){\\n        int m = v1.size();\\n        int n = v2.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n){\\n            // Case1:\\n            // ....5 5 5 5 5 7....     .... 5 5 5 5 5 5...\\n            //     i                        j\\n            //               tempi                     tempj\\n            if(v1[i] == v2[j]){\\n                int tempi= i;\\n                int tempj= j;\\n                while(tempi<m && tempj<n && v1[tempi]==v2[tempj]){\\n                    tempi++;\\n                    tempj++;\\n                }\\n                if(tempj == n){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else if(tempi == m){\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }else if(v1[tempi]>v2[tempj]){\\n                    ans.push_back(v1[i]);\\n                    i++;\\n                }else{\\n                    ans.push_back(v2[j]);\\n                    j++;\\n                }                \\n            }\\n            // Case2 : ....5 6 7 3 4.....     .....2 3 9 8 7....\\n            //             i                       j\\n            else if(v1[i] > v2[j]){\\n                ans.push_back(v1[i]);\\n                i++;\\n            }\\n            // Case2 : ....2 6 7 3 4.....     .....9 3 9 8 7....\\n            //             i                       j\\n            else{\\n                ans.push_back(v2[j]);\\n                j++;\\n            }\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //          i                j\\n        while(i<m){\\n            ans.push_back(v1[i]);\\n            i++;\\n        }\\n        // if ......8 9 7   ...3 5 2 8\\n        //              i      j\\n        while(j<n){\\n            ans.push_back(v2[j]);\\n            j++;\\n        }\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // We consider every possible case:\\n        // eg.1 Take maximum number of 0 digits from nums1 and maximum number of k digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg2. Take maximum number of 1 digits from nums1 and maximum number of k-1 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg3. Take maximum number of 2 digits from nums1 and maximum number of k-2 digits from nums2 and merge them to get a maximum number of k digits.\\n        // eg4. Take maximum number of 3 digits from nums1 and maximum number of k-3 digits from nums2 and merge them to get a maximum number of k digits.\\n        // and so on.................\\n        // Then take the maximum among all the above generated numbers as our answer.\\n\\n        vector<int> ans;\\n        for(int i=0 ; i<=k ; i++){\\n            vector<int> temp1 = solve(i , nums1);\\n            vector<int> temp2 = solve(k-i , nums2);\\n            vector<int> temp;\\n            merge(temp , temp1 , temp2);\\n            if(temp.size() == k) ans = max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415185,
                "title": "short-python-code-with-explanation-100-faster",
                "content": "Step1: Create maximum numbers individually from nums1 and nums2. Store \\'j\\' digit max numbers in dictionary. (say dp1 and dp2)  \\nStep2: Combine dp1[i] + dp2[k-i]  to create maximum \\'k\\' digit number\\n\\n```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        def maximize(nums,length):\\n            dp,i = {length:nums},0\\n            while (length):\\n                while (i+1<length and nums[i]>=nums[i+1]): i+=1\\n                nums,length = nums[:i]+nums[i+1:],length-1\\n                dp[length] = nums\\n                if i>0: i-=1\\n            return dp\\n        m,n,result = len(nums1),len(nums2),[]\\n        dp1,dp2 = maximize(nums1,m),maximize(nums2,n)\\n        for i in range(min(m+1,k+1)):\\n            if k-i not in dp2: continue\\n\\t\\t\\tresult = max(result,[max(dp1[i],dp2[k-i]).pop(0) for _ in range(k)])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        def maximize(nums,length):\\n            dp,i = {length:nums},0\\n            while (length):\\n                while (i+1<length and nums[i]>=nums[i+1]): i+=1\\n                nums,length = nums[:i]+nums[i+1:],length-1\\n                dp[length] = nums\\n                if i>0: i-=1\\n            return dp\\n        m,n,result = len(nums1),len(nums2),[]\\n        dp1,dp2 = maximize(nums1,m),maximize(nums2,n)\\n        for i in range(min(m+1,k+1)):\\n            if k-i not in dp2: continue\\n\\t\\t\\tresult = max(result,[max(dp1[i],dp2[k-i]).pop(0) for _ in range(k)])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77353,
                "title": "share-c-72ms-with-simple-comments",
                "content": "    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        const int size1 = nums1.size();\\n        const int size2 = nums2.size();\\n        if (size1 + size2 < k) return vector<int>();\\n        vector<int> res(k, 0);\\n        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());\\n        getDp(nums1, k, dp1);\\n        getDp(nums2, k, dp2);\\n        for (int i = 0; i <= min(k, size1); i++) {\\n            int j = k - i;\\n            vector<int> temp_res(k, 0);\\n            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());\\n            if (j <= size2 && compareVector(temp_res, res)) {\\n                res = temp_res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    template <class container>\\n    bool compareVector ( container vec1, container vec2)\\n        {\\n          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();\\n          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();\\n          while (first1 != last1 && first2 != last2) {\\n            if (*first1 > *first2)\\n              return true;\\n            else if (*first1 < *first2) return false;\\n            ++first1; ++first2;\\n          }\\n          if (first1 == last1) return false;\\n          else return true;\\n        }\\n        \\n    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {\\n          while (nums.size() > k) {\\n                int j = 0;\\n                for (; j < nums.size() - 1; ++j) {\\n                    if (nums[j] < nums[j + 1]) {\\n                        nums.erase(nums.begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == nums.size() - 1) nums.erase(nums.begin() + j); \\n           }\\n           dp[nums.size()] = nums;\\n           const int size1 = nums.size();\\n           for (int i = k; i > 0; i--) {\\n            if (i >= size1) continue; \\n            else {\\n                dp[i] = dp[i+1];\\n                int j = 0;\\n                const int size_dp = dp[i].size();\\n                for (; j < size_dp - 1; ++j) {\\n                    if (dp[i][j] < dp[i][j + 1]) {\\n                        dp[i].erase(dp[i].begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); \\n            }\\n            \\n        }\\n    }\\n    template <class InputIterator1, class InputIterator2, class OutputIterator>\\n    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,\\n                        InputIterator2 first2, InputIterator2 last2,\\n                        OutputIterator result)\\n    {\\n      while (true) {\\n        if (first1==last1) return std::copy(first2,last2,result);\\n        if (first2==last2) return std::copy(first1,last1,result);\\n        if (*first2 > *first1) *result++ = *first2++;\\n        else if (*first2 < *first1) *result++ = *first1++;\\n        else { // *first1 == *first2\\n            auto pos1 = first1, pos2 = first2;\\n            while (true) {\\n                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;\\n                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;\\n                if (f1 > f2) { *result++ = *first1++; break;}\\n                else if (f1 < f2) {*result++ = *first2++; break;}\\n            }\\n        }\\n      }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        const int size1 = nums1.size();\\n        const int size2 = nums2.size();\\n        if (size1 + size2 < k) return vector<int>();\\n        vector<int> res(k, 0);\\n        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());\\n        getDp(nums1, k, dp1);\\n        getDp(nums2, k, dp2);\\n        for (int i = 0; i <= min(k, size1); i++) {\\n            int j = k - i;\\n            vector<int> temp_res(k, 0);\\n            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());\\n            if (j <= size2 && compareVector(temp_res, res)) {\\n                res = temp_res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    template <class container>\\n    bool compareVector ( container vec1, container vec2)\\n        {\\n          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();\\n          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();\\n          while (first1 != last1 && first2 != last2) {\\n            if (*first1 > *first2)\\n              return true;\\n            else if (*first1 < *first2) return false;\\n            ++first1; ++first2;\\n          }\\n          if (first1 == last1) return false;\\n          else return true;\\n        }\\n        \\n    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {\\n          while (nums.size() > k) {\\n                int j = 0;\\n                for (; j < nums.size() - 1; ++j) {\\n                    if (nums[j] < nums[j + 1]) {\\n                        nums.erase(nums.begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == nums.size() - 1) nums.erase(nums.begin() + j); \\n           }\\n           dp[nums.size()] = nums;\\n           const int size1 = nums.size();\\n           for (int i = k; i > 0; i--) {\\n            if (i >= size1) continue; \\n            else {\\n                dp[i] = dp[i+1];\\n                int j = 0;\\n                const int size_dp = dp[i].size();\\n                for (; j < size_dp - 1; ++j) {\\n                    if (dp[i][j] < dp[i][j + 1]) {\\n                        dp[i].erase(dp[i].begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); \\n            }\\n            \\n        }\\n    }\\n    template <class InputIterator1, class InputIterator2, class OutputIterator>\\n    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,\\n                        InputIterator2 first2, InputIterator2 last2,\\n                        OutputIterator result)\\n    {\\n      while (true) {\\n        if (first1==last1) return std::copy(first2,last2,result);\\n        if (first2==last2) return std::copy(first1,last1,result);\\n        if (*first2 > *first1) *result++ = *first2++;\\n        else if (*first2 < *first1) *result++ = *first1++;\\n        else { // *first1 == *first2\\n            auto pos1 = first1, pos2 = first2;\\n            while (true) {\\n                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;\\n                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;\\n                if (f1 > f2) { *result++ = *first1++; break;}\\n                else if (f1 < f2) {*result++ = *first2++; break;}\\n            }\\n        }\\n      }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2167532,
                "title": "o-k-m-n-python-solution-with-monotonically-decreasing-stack-commented-for-clarity",
                "content": "This solution is pretty efficient and intuitive.\\nTime complexity is **O(k(n+m))** where n and m is length of each list. \\n\\n\\nTo understand this solution you must also do other problems concerning monotonic stack like LC-402 which are pre-requisites for this problem.\\n\\nDo give me a thumbs up if u like it.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:\\n            # monotonically decreasing stack\\n            s = []\\n            m = len(nums) - k_i\\n            for n in nums:\\n                while s and s[-1] < n and m > 0:\\n                    s.pop()\\n                    m -= 1\\n                s.append(n)\\n            s = s[:len(s)-m] # very important\\n            return s\\n        def greater(a, b, i , j): # get the number which is lexiographically greater\\n            while i< len(a) or j < len(b): \\n                if i == len(a): return False\\n                if j == len(b): return True\\n                if a[i] > b[j]: return True\\n                if a[i] < b[j]: return False\\n                i += 1 # we increment until each of their elements are same\\n                j += 1\\n        \\n        def merge(x_num, y_num):\\n            n = len(x_num)\\n            m = len(y_num)\\n            i = 0\\n            j = 0\\n            s = []\\n            while i < n or j < m:\\n                a = x_num[i] if i < n else float(\"-inf\") \\n                b = y_num[j] if j < m else float(\"-inf\") \\n\\n                if a > b or greater(x_num, y_num, i , j):\\n# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.\\n                    chosen = a\\n                    i += 1\\n                else:\\n                    chosen = b\\n                    j += 1\\n                s.append(chosen)\\n            return s\\n\\n        max_num_arr = []\\n        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution\\n            first = maximum_num_each_list(nums1, i)\\n            second = maximum_num_each_list(nums2, k-i)\\n            merged = merge(first, second)\\n            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.\\n\\t\\t\\t# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.\\n            if len(merged) == len(max_num_arr) and  merged > max_num_arr:\\n                max_num_arr = merged\\n            elif len(merged) > len(max_num_arr):\\n                max_num_arr = merged\\n        return max_num_arr\\n\\n```\\nFeel free to ask any questions in the comments.\\nDo suggest improvements if any.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:\\n            # monotonically decreasing stack\\n            s = []\\n            m = len(nums) - k_i\\n            for n in nums:\\n                while s and s[-1] < n and m > 0:\\n                    s.pop()\\n                    m -= 1\\n                s.append(n)\\n            s = s[:len(s)-m] # very important\\n            return s\\n        def greater(a, b, i , j): # get the number which is lexiographically greater\\n            while i< len(a) or j < len(b): \\n                if i == len(a): return False\\n                if j == len(b): return True\\n                if a[i] > b[j]: return True\\n                if a[i] < b[j]: return False\\n                i += 1 # we increment until each of their elements are same\\n                j += 1\\n        \\n        def merge(x_num, y_num):\\n            n = len(x_num)\\n            m = len(y_num)\\n            i = 0\\n            j = 0\\n            s = []\\n            while i < n or j < m:\\n                a = x_num[i] if i < n else float(\"-inf\") \\n                b = y_num[j] if j < m else float(\"-inf\") \\n\\n                if a > b or greater(x_num, y_num, i , j):\\n# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.\\n                    chosen = a\\n                    i += 1\\n                else:\\n                    chosen = b\\n                    j += 1\\n                s.append(chosen)\\n            return s\\n\\n        max_num_arr = []\\n        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution\\n            first = maximum_num_each_list(nums1, i)\\n            second = maximum_num_each_list(nums2, k-i)\\n            merged = merge(first, second)\\n            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.\\n\\t\\t\\t# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.\\n            if len(merged) == len(max_num_arr) and  merged > max_num_arr:\\n                max_num_arr = merged\\n            elif len(merged) > len(max_num_arr):\\n                max_num_arr = merged\\n        return max_num_arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538203,
                "title": "java-segment-tree-3ms-unprecented-100-o-klogn-o-n-for-best-case",
                "content": "Basic idea is pick the maximum from `nums1` and `nums2`, in a way that will ensure enough numbers for later picks. Two points `cur1` and `cur2` is maintained to ensure relative orders of picks.\\n\\nTo make picking a maximum *O(logn)*, segment tree is used, which stores indices and the query function, `reducer`, is max function.\\n\\n```java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        SegmentTreeMax st1 = new SegmentTreeMax(nums1), st2 = new SegmentTreeMax(nums2);\\n        int[] maxN = new int[k];\\n        int cur1 = 0, cur2 = 0, remained = nums1.length + nums2.length - k;\\n        for (int i = 0; i != k; ++i) {\\n            int to1 = remained - cur2 + i,\\n                to2 = remained - cur1 + i;\\n            int picked1 = st1.reduceClosedGuarded(cur1, to1);\\n            int picked2 = st2.reduceClosedGuarded(cur2, to2);\\n            int comparePicked = compareIdx(nums1, picked1, nums2, picked2);\\n            if (comparePicked == 0) {\\n                int p1 = picked1, p2 = picked2;\\n                for (int j = 1; comparePicked == 0; ++j) {\\n                    p1 = st1.reduceClosedGuarded(p1 + 1, to1 + j);\\n                    p2 = st2.reduceClosedGuarded(p2 + 1, to2 + j);\\n                    comparePicked = compareIdx(nums1, p1, nums2, p2);\\n                }\\n                if (p1 == -1 && p2 == -1) {\\n                    comparePicked = 0;\\n                    p1 = picked1; p2 = picked2;\\n                    while (comparePicked == 0) {\\n                        p1 = st1.reduceClosedGuarded(cur1, p1 - 1);\\n                        p2 = st2.reduceClosedGuarded(cur2, p2 - 1);\\n                        comparePicked = -compareIdx(nums1, p1, nums2, p2);\\n                    }\\n                }\\n            }\\n            if (comparePicked == 1) {\\n                maxN[i] = nums1[picked1];\\n                cur1 = picked1 + 1;\\n            }\\n            else {\\n                assert comparePicked == -1;\\n                maxN[i] = nums2[picked2];\\n                cur2 = picked2 + 1;\\n            }\\n        }\\n        return maxN;\\n    }\\n    private int compareIdx(int[] nums1, int i, int[] nums2, int j) {\\n        if (i == -1) return -1;\\n        if (j == -1) return 1;\\n        return Integer.compare(nums1[i], nums2[j]);\\n    }\\n}\\n\\nclass SegmentTreeMax {\\n    private final int[] data;\\n    private final int[] origin;\\n    public SegmentTreeMax(int[] origin) {\\n        data = new int[origin.length << 1];\\n        this.origin = origin;\\n        for (int i = origin.length; i != data.length; ++i) data[i] = i - origin.length;\\n        for (int i = origin.length - 1; i > 0; --i) data[i] = reducer4Build(data[i << 1], data[(i << 1) | 1]);\\n    }\\n    private int reducer4Build(int a, int b) {\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    private int reducer(int a, int b) {\\n        if (a > b) {\\n            a = a ^ b;\\n            b = a ^ b;\\n            a = a ^ b;\\n        }\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    public int reduceClosedGuarded(int from, int to) {\\n        to = Math.min(to, origin.length - 1);\\n        if (from > to) return -1;\\n        int maxima = from;\\n        for (int i = from + origin.length, j = to + origin.length; i <= j; i >>= 1, j >>= 1) {\\n            if ((i & 1) == 1) maxima = reducer(maxima, data[i++]);\\n            if ((j & 1) == 0) maxima = reducer(maxima, data[j--]);\\n        }\\n        return maxima;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        SegmentTreeMax st1 = new SegmentTreeMax(nums1), st2 = new SegmentTreeMax(nums2);\\n        int[] maxN = new int[k];\\n        int cur1 = 0, cur2 = 0, remained = nums1.length + nums2.length - k;\\n        for (int i = 0; i != k; ++i) {\\n            int to1 = remained - cur2 + i,\\n                to2 = remained - cur1 + i;\\n            int picked1 = st1.reduceClosedGuarded(cur1, to1);\\n            int picked2 = st2.reduceClosedGuarded(cur2, to2);\\n            int comparePicked = compareIdx(nums1, picked1, nums2, picked2);\\n            if (comparePicked == 0) {\\n                int p1 = picked1, p2 = picked2;\\n                for (int j = 1; comparePicked == 0; ++j) {\\n                    p1 = st1.reduceClosedGuarded(p1 + 1, to1 + j);\\n                    p2 = st2.reduceClosedGuarded(p2 + 1, to2 + j);\\n                    comparePicked = compareIdx(nums1, p1, nums2, p2);\\n                }\\n                if (p1 == -1 && p2 == -1) {\\n                    comparePicked = 0;\\n                    p1 = picked1; p2 = picked2;\\n                    while (comparePicked == 0) {\\n                        p1 = st1.reduceClosedGuarded(cur1, p1 - 1);\\n                        p2 = st2.reduceClosedGuarded(cur2, p2 - 1);\\n                        comparePicked = -compareIdx(nums1, p1, nums2, p2);\\n                    }\\n                }\\n            }\\n            if (comparePicked == 1) {\\n                maxN[i] = nums1[picked1];\\n                cur1 = picked1 + 1;\\n            }\\n            else {\\n                assert comparePicked == -1;\\n                maxN[i] = nums2[picked2];\\n                cur2 = picked2 + 1;\\n            }\\n        }\\n        return maxN;\\n    }\\n    private int compareIdx(int[] nums1, int i, int[] nums2, int j) {\\n        if (i == -1) return -1;\\n        if (j == -1) return 1;\\n        return Integer.compare(nums1[i], nums2[j]);\\n    }\\n}\\n\\nclass SegmentTreeMax {\\n    private final int[] data;\\n    private final int[] origin;\\n    public SegmentTreeMax(int[] origin) {\\n        data = new int[origin.length << 1];\\n        this.origin = origin;\\n        for (int i = origin.length; i != data.length; ++i) data[i] = i - origin.length;\\n        for (int i = origin.length - 1; i > 0; --i) data[i] = reducer4Build(data[i << 1], data[(i << 1) | 1]);\\n    }\\n    private int reducer4Build(int a, int b) {\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    private int reducer(int a, int b) {\\n        if (a > b) {\\n            a = a ^ b;\\n            b = a ^ b;\\n            a = a ^ b;\\n        }\\n        return (origin[a] < origin[b]) ? b : a;\\n    }\\n    public int reduceClosedGuarded(int from, int to) {\\n        to = Math.min(to, origin.length - 1);\\n        if (from > to) return -1;\\n        int maxima = from;\\n        for (int i = from + origin.length, j = to + origin.length; i <= j; i >>= 1, j >>= 1) {\\n            if ((i & 1) == 1) maxima = reducer(maxima, data[i++]);\\n            if ((j & 1) == 0) maxima = reducer(maxima, data[j--]);\\n        }\\n        return maxima;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384801,
                "title": "java-100-4ms",
                "content": "```\\nclass Solution {\\n    //\\u6838\\u5FC3\\u5C31\\u662F\\u4E24\\u4E2A\\u6307\\u9488\\uFF0C\\u4F9D\\u6B21\\u5BF9\\u6BD4\\uFF0C\\u5728\\u6EE1\\u8DB3canSkip\\u60C5\\u51B5\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u7684\\u503C\\u3002\\u96BE\\u70B9\\u662F\\u5982\\u679C\\u6700\\u5927\\u503C\\u76F8\\u540C\\uFF0C\\u5219\\u9700\\u8981\\u8FED\\u4EE3\\u5904\\u7406\\u3002\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        //canSkip : \\u6700\\u591A\\u53EF\\u4EE5\\u8DF3\\u8FC7\\u591A\\u5C11\\u4E2A\\n        int canSkip = nums1.length - 0 + nums2.length - 0 - k;\\n        return helper(nums1, 0, nums2, 0, k, canSkip, 1).result;\\n    }\\n    //\\u6700\\u540E\\u4E00\\u4E2A\\u53C2\\u6570ifSameThenWhich\\u8868\\u793A\\u4E24\\u8005\\u7686\\u53EF\\u9009\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u9009\\u62E9\\u54EA\\u4E2A1\\u8868\\u793A\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C2\\u8868\\u793A\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u3002\\n    public ResultInfo helper(int[] nums1, int start1, int[] nums2, int start2, int k, int canSkip, int ifSameThenWhich) {\\n        int[] result = new int[k];\\n        for (int index = 0; index < k; index++) {\\n            int max1Index = maxWithSkip(nums1, start1, canSkip);\\n            int max2Index = maxWithSkip(nums2, start2, canSkip);\\n            if (max1Index != -1 && max2Index != -1 && nums1[max1Index] > nums2[max2Index] || max1Index != -1 && max2Index == -1) {//\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums1[max1Index];\\n                canSkip = canSkip - (max1Index - start1);\\n                start1 = max1Index + 1;\\n            } else if (max1Index != -1 && max2Index != -1 && nums2[max2Index] > nums1[max1Index] || max2Index != -1 && max1Index == -1) {//\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums2[max2Index];\\n                canSkip = canSkip - (max2Index - start2);\\n                start2 = max2Index + 1;\\n            } else {//\\u4E24\\u503C\\u76F8\\u7B49\\uFF0C\\u5219\\u5047\\u8BBE\\u90091\\u6216\\u90092\\u540E\\u7EED\\u503C\\u6BD4\\u8F83\\n                boolean done = false;\\n                int newK = k - index - 1;//\\u8FD8\\u5269\\u591A\\u5C11\\u4E2A\\u6CA1\\u9009\\n                int newStart1 = max1Index + 1;//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684start1\\u4E3AnewStart1\\n                int canSkip1 = canSkip - (max1Index - start1);//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684canSkip\\u4E3AcanSkip1\\n                int newStart2 = max2Index + 1;//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684start2\\u4E3AnewStart2\\n                int canSkip2 = canSkip - (max2Index - start2);//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684canSkip\\u4E3AcanSkip2\\n                ResultInfo resultInfo1 = new ResultInfo(null, newStart1, start2, canSkip1);\\n                ResultInfo resultInfo2 = new ResultInfo(null, start1, newStart2, canSkip2);\\n                for (int tmpK = 1; tmpK <= newK; tmpK++) {//\\u6CE8\\u610F\\u4F18\\u5316\\uFF1A\\u6BCF\\u6B21\\u53EA\\u8BA1\\u7B97\\u957F\\u5EA6\\u4E3A1\\u7684\\u6570\\u7EC4\\uFF0C\\u5982\\u679C\\u76F8\\u540C\\uFF0C\\u518D\\u8BA1\\u7B97\\u540E\\u9762\\u7684\\n                    //\\u5047\\u8BBE\\u90091\\n                    resultInfo1 = helper(nums1, resultInfo1.start1, nums2, resultInfo1.start2, 1, resultInfo1.canSkip, 1);\\n                    int result1 = resultInfo1.result[0];\\n                    //\\u5047\\u8BBE\\u90092\\n                    resultInfo2 = helper(nums1, resultInfo2.start1, nums2, resultInfo2.start2, 1, resultInfo2.canSkip, 2);\\n                    int result2 = resultInfo2.result[0];\\n                    if (result1 > result2) {\\n                        //\\u90091\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                        done = true;\\n                        break;\\n                    } else if (result1 < result2) {\\n                        //\\u90092\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                        done = true;\\n                        break;\\n                    }\\n                }\\n                if (!done) {//\\u90FD\\u884C\\uFF0C\\u6839\\u636EifSameThenWhich\\u9009\\n                    if (ifSameThenWhich == 1) {\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                    } else {\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return new ResultInfo(result, start1, start2, canSkip);\\n    }\\n    //\\u5728\\u6EE1\\u8DB3canSkip\\u6761\\u4EF6\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u503C\\u3002\\n    public int maxWithSkip(int[] nums, int start, int canSkip) {//\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\u4E0B\\u6807\\n        if (start == nums.length) {\\n            return -1;\\n        }\\n        int index = start;\\n        for (int i = 1; i <= canSkip; i++) {\\n            if (start + i < nums.length && nums[start + i] > nums[index]) {\\n                index = start + i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\nclass ResultInfo {//\\u7ED3\\u679C\\u548C\\u7ED3\\u675F\\u65F6\\u7684\\u72B6\\u6001\\u503C\\uFF0C\\u5176\\u4E2D\\u72B6\\u6001\\u503C\\u7528\\u4E8E\\u8FED\\u4EE3\\u4F18\\u5316\\n    int[] result;\\n    int start1;\\n    int start2;\\n    int canSkip;\\n\\n    public ResultInfo(int[] result, int start1, int start2, int canSkip) {\\n        this.result = result;\\n        this.start1 = start1;\\n        this.start2 = start2;\\n        this.canSkip = canSkip;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //\\u6838\\u5FC3\\u5C31\\u662F\\u4E24\\u4E2A\\u6307\\u9488\\uFF0C\\u4F9D\\u6B21\\u5BF9\\u6BD4\\uFF0C\\u5728\\u6EE1\\u8DB3canSkip\\u60C5\\u51B5\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u7684\\u503C\\u3002\\u96BE\\u70B9\\u662F\\u5982\\u679C\\u6700\\u5927\\u503C\\u76F8\\u540C\\uFF0C\\u5219\\u9700\\u8981\\u8FED\\u4EE3\\u5904\\u7406\\u3002\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        //canSkip : \\u6700\\u591A\\u53EF\\u4EE5\\u8DF3\\u8FC7\\u591A\\u5C11\\u4E2A\\n        int canSkip = nums1.length - 0 + nums2.length - 0 - k;\\n        return helper(nums1, 0, nums2, 0, k, canSkip, 1).result;\\n    }\\n    //\\u6700\\u540E\\u4E00\\u4E2A\\u53C2\\u6570ifSameThenWhich\\u8868\\u793A\\u4E24\\u8005\\u7686\\u53EF\\u9009\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u9009\\u62E9\\u54EA\\u4E2A1\\u8868\\u793A\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C2\\u8868\\u793A\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u3002\\n    public ResultInfo helper(int[] nums1, int start1, int[] nums2, int start2, int k, int canSkip, int ifSameThenWhich) {\\n        int[] result = new int[k];\\n        for (int index = 0; index < k; index++) {\\n            int max1Index = maxWithSkip(nums1, start1, canSkip);\\n            int max2Index = maxWithSkip(nums2, start2, canSkip);\\n            if (max1Index != -1 && max2Index != -1 && nums1[max1Index] > nums2[max2Index] || max1Index != -1 && max2Index == -1) {//\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E00\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums1[max1Index];\\n                canSkip = canSkip - (max1Index - start1);\\n                start1 = max1Index + 1;\\n            } else if (max1Index != -1 && max2Index != -1 && nums2[max2Index] > nums1[max1Index] || max2Index != -1 && max1Index == -1) {//\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\u7684\\u5927\\uFF0C\\u9009\\u7B2C\\u4E8C\\u4E2A\\u6570\\u7EC4\\n                result[index] = nums2[max2Index];\\n                canSkip = canSkip - (max2Index - start2);\\n                start2 = max2Index + 1;\\n            } else {//\\u4E24\\u503C\\u76F8\\u7B49\\uFF0C\\u5219\\u5047\\u8BBE\\u90091\\u6216\\u90092\\u540E\\u7EED\\u503C\\u6BD4\\u8F83\\n                boolean done = false;\\n                int newK = k - index - 1;//\\u8FD8\\u5269\\u591A\\u5C11\\u4E2A\\u6CA1\\u9009\\n                int newStart1 = max1Index + 1;//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684start1\\u4E3AnewStart1\\n                int canSkip1 = canSkip - (max1Index - start1);//\\u5047\\u8BBE\\u90091\\u52191\\u65B0\\u7684canSkip\\u4E3AcanSkip1\\n                int newStart2 = max2Index + 1;//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684start2\\u4E3AnewStart2\\n                int canSkip2 = canSkip - (max2Index - start2);//\\u5047\\u8BBE\\u90092\\u52192\\u65B0\\u7684canSkip\\u4E3AcanSkip2\\n                ResultInfo resultInfo1 = new ResultInfo(null, newStart1, start2, canSkip1);\\n                ResultInfo resultInfo2 = new ResultInfo(null, start1, newStart2, canSkip2);\\n                for (int tmpK = 1; tmpK <= newK; tmpK++) {//\\u6CE8\\u610F\\u4F18\\u5316\\uFF1A\\u6BCF\\u6B21\\u53EA\\u8BA1\\u7B97\\u957F\\u5EA6\\u4E3A1\\u7684\\u6570\\u7EC4\\uFF0C\\u5982\\u679C\\u76F8\\u540C\\uFF0C\\u518D\\u8BA1\\u7B97\\u540E\\u9762\\u7684\\n                    //\\u5047\\u8BBE\\u90091\\n                    resultInfo1 = helper(nums1, resultInfo1.start1, nums2, resultInfo1.start2, 1, resultInfo1.canSkip, 1);\\n                    int result1 = resultInfo1.result[0];\\n                    //\\u5047\\u8BBE\\u90092\\n                    resultInfo2 = helper(nums1, resultInfo2.start1, nums2, resultInfo2.start2, 1, resultInfo2.canSkip, 2);\\n                    int result2 = resultInfo2.result[0];\\n                    if (result1 > result2) {\\n                        //\\u90091\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                        done = true;\\n                        break;\\n                    } else if (result1 < result2) {\\n                        //\\u90092\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                        done = true;\\n                        break;\\n                    }\\n                }\\n                if (!done) {//\\u90FD\\u884C\\uFF0C\\u6839\\u636EifSameThenWhich\\u9009\\n                    if (ifSameThenWhich == 1) {\\n                        result[index] = nums1[max1Index];\\n                        canSkip = canSkip - (max1Index - start1);\\n                        start1 = max1Index + 1;\\n                    } else {\\n                        result[index] = nums2[max2Index];\\n                        canSkip = canSkip - (max2Index - start2);\\n                        start2 = max2Index + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return new ResultInfo(result, start1, start2, canSkip);\\n    }\\n    //\\u5728\\u6EE1\\u8DB3canSkip\\u6761\\u4EF6\\u4E0B\\uFF0C\\u627E\\u6700\\u5927\\u503C\\u3002\\n    public int maxWithSkip(int[] nums, int start, int canSkip) {//\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\u4E0B\\u6807\\n        if (start == nums.length) {\\n            return -1;\\n        }\\n        int index = start;\\n        for (int i = 1; i <= canSkip; i++) {\\n            if (start + i < nums.length && nums[start + i] > nums[index]) {\\n                index = start + i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\nclass ResultInfo {//\\u7ED3\\u679C\\u548C\\u7ED3\\u675F\\u65F6\\u7684\\u72B6\\u6001\\u503C\\uFF0C\\u5176\\u4E2D\\u72B6\\u6001\\u503C\\u7528\\u4E8E\\u8FED\\u4EE3\\u4F18\\u5316\\n    int[] result;\\n    int start1;\\n    int start2;\\n    int canSkip;\\n\\n    public ResultInfo(int[] result, int start1, int start2, int canSkip) {\\n        this.result = result;\\n        this.start1 = start1;\\n        this.start2 = start2;\\n        this.canSkip = canSkip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77321,
                "title": "a-very-efficient-solution-accepted-as-best-beating-98-16ms-in-c-well-commented",
                "content": "    class Solution {\\n    public:\\n        // create max number of length t from single non-empty vector\\n        // @nums is the array of length @len \\n        // @result will be used to store the max number of length @t \\n        // @sortedLen indicates the prefix length which is in descending order;\\n        void getMax(int* nums, int& len, int* result, int& t, int& sortedLen)\\n        {\\n            int n, top = 0;\\n            result[0] = nums[0];\\n            const int need2drop = len - t;\\n            for (int i = 1; i < len; ++i){\\n                n = nums[i];\\n                while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numsbers\\n                if (i - top > need2drop){\\n                    sortedLen = max(1,top);\\n                    while (++top < t) result[top] = nums[i++];\\n                    return;\\n                }\\n                if (++top < t) result[top] = n;\\n                else top = t - 1;\\n            }\\n        }\\n        // create max number of different length from single vector\\n        // @nums is the original array of length @len\\n        // @sortedLen is the longest length of the descending prefix of the max number;\\n        // @minL and @maxL is the min and max length of the result max number\\n        // @res is a pointer which will record the max numbers of length ranging from minL to maxL\\n        // @k is the length of the final max number;\\n        void dp(int *nums, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k)\\n        {\\n            int  j, *head, *preHead = res;\\n            const int soi = sizeof(int);\\n            getMax(nums, len, res, maxL, sortedLen);\\n            for(int l = maxL; l > max(minL,1); --l) //according to the max number of length maxL to generate all the max numbers ranging from minL to maxL (exclusive) and append them;\\n            {\\n                head = preHead + k; //jump to the next max-number pointer;\\n                memcpy(head, preHead, l*soi); \\n                for(j = sortedLen; j < l; ++j)\\n                {\\n                    if(head[j] > head[j - 1]) //remove the previous element encountering the first ascending pair;\\n                    {\\n                        sortedLen = max(1, j - 1); //update the sortedLen;\\n                        memcpy(head + j - 1, preHead + j, soi*(l - j));\\n                        break;\\n                    }\\n                }\\n                if(j == l) sortedLen = l; //it's already descending, remove the last element updating sortedLen to l;\\n                preHead = head; //update preHead;\\n            }\\n        }\\n        // merge max number created from single vector\\n        // @nums1 is the first array of length @len1\\n        // @nums2 is the second array of length @len2\\n        // @result is the array of length @resSize which will contain the max number generated\\n        // by the both two arrays without changing the order in each array;\\n        void merge(int* nums1,int len1,int* nums2,int len2,int* result,int& resSize)\\n        {\\n            int i = 0, j = 0, k = 0; //i -> result, j -> nums1, k -> nums2;\\n            while (i < resSize)\\n            {\\n                if (j < len1 && k < len2) //normal case;\\n                {\\n                    if (nums1[j] > nums2[k]) //collect the bigger element first;\\n                        result[i++] = nums1[j++];\\n                    else if (nums1[j] < nums2[k])\\n                        result[i++] = nums2[k++];\\n                    else //when they are equal, collect the one with bigger lexical order;\\n                    {\\n                        int remaining1 = len1-j, remaining2 = len2-k, tmp = nums1[j];\\n                        int flag = memcmp(nums1+j, nums2+k, sizeof(int)*min(remaining1, remaining2));\\n                        flag = (flag==0 ? (remaining1>remaining2 ? 1 : -1) : flag); //determine which is bigger in lexical order -> when the lexical order are the same the longer one will be bigger in order;\\n                        int * nums = flag > 0 ? nums1 : nums2;\\n                        int & cnt = flag > 0 ? j : k; //using reference to modify j or k;\\n                        int len = flag > 0 ? len1 : len2;\\n                        while (nums[cnt]==tmp && cnt < len && i<resSize) result[i++] = nums[cnt++];\\n                    }\\n                }\\n                else if (j < len1) result[i++] = nums1[j++];\\n                else result[i++] = nums2[k++];\\n            }\\n        }\\n    \\n        //AC - 16ms - the most efficient solution;\\n        // Reference: https://leetcode.com/discuss/85603/c-16ms-fastest-beats-97%25\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n            int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size();\\n            int step = k*soi; //the space the final max number might take in memory;\\n            int minL1 = max(0, k-len2), maxL1 = min(k, len1), minL2 = k-maxL1, maxL2 = k-minL1, range = maxL1-minL1+1;\\n            int * res = new int[range*k*2 + 2*k], *dp1 = res+k, *dp2 = res+range*k+k, *tmp=res+range*2*k+k; //using one-dimension array to handle different arrays -> only using the necessary space without any waste;\\n            memset(res, 0, step);\\n            int sortedLen1=1, sortedLen2=1;\\n            if (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2); //handle corner cases;\\n            else if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen1);\\n            else if (len1 > 0 && len2 > 0) //the normal case;\\n            {\\n                dp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n                dp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n                if (sortedLen1+sortedLen2 > k) //special cases - needless to check each combination accelerating the process from 20ms to 16ms;\\n                    merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, res, k);\\n                else for(int i = minL1; i <= maxL1; ++i)\\n                {\\n                    merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n                    if(memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n                }\\n            }\\n            vector<int> resv(res, res + k);\\n            delete[] res;\\n            return resv;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        // create max number of length t from single non-empty vector\\n        // @nums is the array of length @len \\n        // @result will be used to store the max number of length @t \\n        // @sortedLen indicates the prefix length which is in descending order;\\n        void getMax(int* nums, int& len, int* result, int& t, int& sortedLen)\\n        {\\n            int n, top = 0;\\n            result[0] = nums[0];\\n            const int need2drop = len - t;\\n            for (int i = 1; i < len; ++i){\\n                n = nums[i];\\n                while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numsbers\\n                if (i - top > need2drop){\\n                    sortedLen = max(1,top);\\n                    while (++top < t) result[top] = nums[i++];\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77314,
                "title": "o-m-n-k-dp-solution-tle",
                "content": "Now I find there are O(max(m, n) * k) greedy solution from the posts. My first idea is DP. Let f(i,j,k) represent maximum number of length k generated from nums1[1:i] and nums2[1:j]. the formula is: f(i,j,k) = max{f(i-1,j,k), f(i,j-1,k), f(i-1,j,k-1) + [nums1[i]], f(i,j-1,k-1) + [nums2[j]] } The implementation is as follows,\\n\\n        def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(nums1)\\n        n = len(nums2)\\n        if k > m + n or k <= 0:\\n            return []\\n        #kk = 0\\n        pre_dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n        \\n        for kk in xrange(1, k + 1):\\n            #kk\\n            dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n            #i >= kk, j = 0\\n            for i in xrange(kk, m + 1):\\n                dp[i][0] = max(pre_dp[i-1][0] + [nums1[i-1]], dp[i-1][0])\\n                \\n            #i = 0, j >= kk\\n            for j in xrange(kk, n + 1):\\n                dp[0][j] = max(pre_dp[0][j-1] + [nums2[j-1]], dp[0][j-1])\\n            \\n            #i > 0, j > 0\\n            for i in xrange(1, m + 1):\\n                for j in xrange(1, n + 1):\\n                    if i + j < kk:\\n                        continue\\n                    dp[i][j] = max(dp[i-1][j], \\\\\\n                                    dp[i][j-1], \\\\\\n                                    pre_dp[i-1][j] + [nums1[i-1]], \\\\\\n                                    pre_dp[i][j-1] + [nums2[j-1]])\\n            pre_dp, dp = dp, pre_dp\\n        return pre_dp[m][n]",
                "solutionTags": [],
                "code": "Now I find there are O(max(m, n) * k) greedy solution from the posts. My first idea is DP. Let f(i,j,k) represent maximum number of length k generated from nums1[1:i] and nums2[1:j]. the formula is: f(i,j,k) = max{f(i-1,j,k), f(i,j-1,k), f(i-1,j,k-1) + [nums1[i]], f(i,j-1,k-1) + [nums2[j]] } The implementation is as follows,\\n\\n        def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(nums1)\\n        n = len(nums2)\\n        if k > m + n or k <= 0:\\n            return []\\n        #kk = 0\\n        pre_dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n        \\n        for kk in xrange(1, k + 1):\\n            #kk\\n            dp = [[[] for _ in xrange(n + 1)] for __ in xrange(m + 1)]\\n            #i >= kk, j = 0\\n            for i in xrange(kk, m + 1):\\n                dp[i][0] = max(pre_dp[i-1][0] + [nums1[i-1]], dp[i-1][0])\\n                \\n            #i = 0, j >= kk\\n            for j in xrange(kk, n + 1):\\n                dp[0][j] = max(pre_dp[0][j-1] + [nums2[j-1]], dp[0][j-1])\\n            \\n            #i > 0, j > 0\\n            for i in xrange(1, m + 1):\\n                for j in xrange(1, n + 1):\\n                    if i + j < kk:\\n                        continue\\n                    dp[i][j] = max(dp[i-1][j], \\\\\\n                                    dp[i][j-1], \\\\\\n                                    pre_dp[i-1][j] + [nums1[i-1]], \\\\\\n                                    pre_dp[i][j-1] + [nums2[j-1]])\\n            pre_dp, dp = dp, pre_dp\\n        return pre_dp[m][n]",
                "codeTag": "Python3"
            },
            {
                "id": 3242314,
                "title": "321-space-98-63-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function called \"get_max_subseq\" that takes two inputs: a list of integers called \"nums\" and an integer \"k\" representing the length of the subsequence we want to extract from the list.\\n2. Initialize an empty stack to hold the maximum subsequence and iterate through the input list \"nums\" using a for loop and the enumerate() function.\\n3. For each element \"num\" in \"nums\", do the following:\\na. While the stack is not empty AND the length of the remaining part of \"nums\" (i.e., len(nums) - i) plus the length of the stack is greater than \"k\" AND the last element in the stack is less than \"num\", pop the last element from the stack.\\nb. If the length of the stack is less than \"k\", append \"num\" to the stack.\\n4. Return the resulting stack, which contains the maximum subsequence of \"nums\" of length \"k\".\\n5. Define a function called \"merge\" that takes two inputs: two lists of integers called \"nums1\" and \"nums2\".\\n6. Initialize an empty list called \"merged\" to hold the merged list.\\n7. Initialize two counters i and j to 0 to track the current index of \"nums1\" and \"nums2\", respectively.\\n8. While i is less than the length of \"nums1\" OR j is less than the length of \"nums2\", do the following:\\na. If i is greater than or equal to the length of \"nums1\", append the jth element of \"nums2\" to \"merged\" and increment j by 1.\\nb. Else if j is greater than or equal to the length of \"nums2\", append the ith element of \"nums1\" to \"merged\" and increment i by 1.\\nc. Else if the remaining part of \"nums1\" starting from the ith index is lexicographically greater than the remaining part of \"nums2\" starting from the jth index, append the ith element of \"nums1\" to \"merged\" and increment i by 1.\\nd. Otherwise, append the jth element of \"nums2\" to \"merged\" and increment j by 1.\\n9. Return the resulting merged list.\\n10. Initialize an empty list called \"ans\" to hold the maximum subsequence of length \"k\" from \"nums1\" and \"nums2\".\\n11. Loop through all possible lengths \"i\" of the subsequence from \"nums1\" ranging from max(0, k - len(nums2)) to min(len(nums1), k) + 1.\\n12. Calculate the corresponding subsequence of \"nums2\" of length \"j\" by subtracting \"i\" from \"k\".\\n13. Call the \"get_max_subseq\" function on \"nums1\" with \"i\" as the input \"k\" and store the result in \"subseq1\".\\n14. Call the \"get_max_subseq\" function on \"nums2\" with \"j\" as the input \"k\" and store the result in \"subseq2\".\\n15. Call the \"merge\" function on \"subseq1\" and \"subseq2\" and store the result in \"merged\".\\n16. Update \"ans\" to be the maximum value between the current value of \"ans\" and \"merged\" using the max() function.\\n17. Return the resulting maximum subsequence of length \"k\" from \"nums1\" and \"nums2\", which is stored in \"ans\".\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def get_max_subseq(nums, k):\\n            stack = []\\n            for i, num in enumerate(nums):\\n                while stack and len(nums) - i + len(stack) > k and stack[-1] < num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            return stack\\n        \\n        def merge(nums1, nums2):\\n            merged = []\\n            i, j = 0, 0\\n            while i < len(nums1) or j < len(nums2):\\n                if i >= len(nums1):\\n                    merged.append(nums2[j])\\n                    j += 1\\n                elif j >= len(nums2):\\n                    merged.append(nums1[i])\\n                    i += 1\\n                elif nums1[i:] > nums2[j:]:\\n                    merged.append(nums1[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums2[j])\\n                    j += 1\\n            return merged\\n        \\n        ans = []\\n        for i in range(max(0, k - len(nums2)), min(len(nums1), k) + 1):\\n            j = k - i\\n            subseq1 = get_max_subseq(nums1, i)\\n            subseq2 = get_max_subseq(nums2, j)\\n            merged = merge(subseq1, subseq2)\\n            ans = max(ans, merged)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def get_max_subseq(nums, k):\\n            stack = []\\n            for i, num in enumerate(nums):\\n                while stack and len(nums) - i + len(stack) > k and stack[-1] < num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            return stack\\n        \\n        def merge(nums1, nums2):\\n            merged = []\\n            i, j = 0, 0\\n            while i < len(nums1) or j < len(nums2):\\n                if i >= len(nums1):\\n                    merged.append(nums2[j])\\n                    j += 1\\n                elif j >= len(nums2):\\n                    merged.append(nums1[i])\\n                    i += 1\\n                elif nums1[i:] > nums2[j:]:\\n                    merged.append(nums1[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums2[j])\\n                    j += 1\\n            return merged\\n        \\n        ans = []\\n        for i in range(max(0, k - len(nums2)), min(len(nums1), k) + 1):\\n            j = k - i\\n            subseq1 = get_max_subseq(nums1, i)\\n            subseq2 = get_max_subseq(nums2, j)\\n            merged = merge(subseq1, subseq2)\\n            ans = max(ans, merged)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429774,
                "title": "java-monotonic-stack",
                "content": "Please upvote if you find it useful! Thank you so much!!\\n\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length, len2 = nums2.length;\\n        int[] res = new int[k];\\n        int[] tempRes = null;\\n        \\n        // enumerate all the possible ways to construct an array with len k from two arrays\\n        // the length of the res is k \\n        // we assume that we pick k1 numbers from nums1, therefore we pick (k - k1) numbers\\n        // from nums2. The possible range of k1 is from Math.max(0, k-len2)\\n        // to Math.min(len1, k);\\n        for(int k1 = Math.max(0, k-len2); k1 <= Math.min(len1, k); k1++){\\n            int[] num1Max = findMaxSubsequence(nums1, k1);\\n            int[] num2Max = findMaxSubsequence(nums2, k - k1);\\n            tempRes = merge(num1Max, num2Max);\\n            if(isGreater(tempRes, 0, res, 0)){\\n                res = tempRes;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // find the largest number that can be constructed from two arrays\\n    private int[] merge(int[] nums1, int[] nums2){\\n        int[] res = new int[nums1.length + nums2.length];\\n        int p1 = 0, p2 = 0, p3 = 0;\\n        \\n        while(p3 < res.length){\\n            res[p3++] = isGreater(nums1, p1, nums2, p2) ? nums1[p1++] : nums2[p2++];     \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2){\\n        while(p1 < nums1.length && p2 < nums2.length){\\n            if(nums1[p1] > nums2[p2]){\\n                return true;\\n            }else if(nums1[p1] < nums2[p2]){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return p1 != nums1.length;\\n    }\\n    \\n    // this subroutine is similar to leetcode 1673\\n    private int[] findMaxSubsequence(int[] num, int len){\\n        if(num.length == len){return num;}\\n        \\n        int[] stack = new int[len];\\n        int top = -1;\\n        int canRemoveCnt = num.length - len;\\n        \\n        for(int i = 0; i < num.length; i++){\\n            int curNum = num[i];\\n            \\n            while(top >= 0 && canRemoveCnt > 0 && curNum > stack[top]){\\n                top--;\\n                canRemoveCnt--;\\n            }\\n            \\n            if(top + 1 < stack.length){\\n                stack[++top] = curNum;     \\n            }else{\\n                canRemoveCnt--;\\n            }\\n        }\\n        \\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length, len2 = nums2.length;\\n        int[] res = new int[k];\\n        int[] tempRes = null;\\n        \\n        // enumerate all the possible ways to construct an array with len k from two arrays\\n        // the length of the res is k \\n        // we assume that we pick k1 numbers from nums1, therefore we pick (k - k1) numbers\\n        // from nums2. The possible range of k1 is from Math.max(0, k-len2)\\n        // to Math.min(len1, k);\\n        for(int k1 = Math.max(0, k-len2); k1 <= Math.min(len1, k); k1++){\\n            int[] num1Max = findMaxSubsequence(nums1, k1);\\n            int[] num2Max = findMaxSubsequence(nums2, k - k1);\\n            tempRes = merge(num1Max, num2Max);\\n            if(isGreater(tempRes, 0, res, 0)){\\n                res = tempRes;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // find the largest number that can be constructed from two arrays\\n    private int[] merge(int[] nums1, int[] nums2){\\n        int[] res = new int[nums1.length + nums2.length];\\n        int p1 = 0, p2 = 0, p3 = 0;\\n        \\n        while(p3 < res.length){\\n            res[p3++] = isGreater(nums1, p1, nums2, p2) ? nums1[p1++] : nums2[p2++];     \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isGreater(int[] nums1, int p1, int[] nums2, int p2){\\n        while(p1 < nums1.length && p2 < nums2.length){\\n            if(nums1[p1] > nums2[p2]){\\n                return true;\\n            }else if(nums1[p1] < nums2[p2]){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return p1 != nums1.length;\\n    }\\n    \\n    // this subroutine is similar to leetcode 1673\\n    private int[] findMaxSubsequence(int[] num, int len){\\n        if(num.length == len){return num;}\\n        \\n        int[] stack = new int[len];\\n        int top = -1;\\n        int canRemoveCnt = num.length - len;\\n        \\n        for(int i = 0; i < num.length; i++){\\n            int curNum = num[i];\\n            \\n            while(top >= 0 && canRemoveCnt > 0 && curNum > stack[top]){\\n                top--;\\n                canRemoveCnt--;\\n            }\\n            \\n            if(top + 1 < stack.length){\\n                stack[++top] = curNum;     \\n            }else{\\n                canRemoveCnt--;\\n            }\\n        }\\n        \\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353982,
                "title": "c-solution-greedy-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    // pick k numbers from vector num\\n    vector<int> select(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> res(k, INT_MIN);\\n        for(int i = 0, j = 0;i<nums.size();i++){\\n            int x = nums[i];\\n            // monotonic stack\\n            while(j>0&&x > res[j-1]&&i+k-j<n) j--;\\n            if(j<k) res[j++] = x;\\n        }\\n        return res;\\n    }\\n    vector<int> merge(vector<int>& a, vector<int> &b){\\n        vector<int> c;\\n        while(a.size()&&b.size()){\\n            // The time complexity of compare operation for two vector is order of n.\\n            // Greedy Algorithm:\\n            // If we meet two elements which have the same value, choose the vector which has the higher dictionary order first.\\n            // 1: ...xxxb , 2: ...xxxa, if a > b, then merge sequence 2 first. \\n            if(a > b)\\n                c.push_back(a[0]), a.erase(a.begin());\\n            else\\n                c.push_back(b[0]), b.erase(b.begin());\\n        }\\n        while(a.size())\\n            c.push_back(a[0]), a.erase(a.begin());\\n        while(b.size())\\n            c.push_back(b[0]), b.erase(b.begin());\\n        return c;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> res(k, INT_MIN);\\n        int n = nums1.size(), m = nums2.size();\\n        // s1  => nums1.size(), s2 => nums2.size()\\n        // {0<=i<=k, i<=s1, 0<=k-i<=s2} => i>=max(0, k-s2), i<=min(k, n)\\n        for(int i = max(0, k-m);i<=min(k, n);i++){\\n            vector<int> a = select(nums1, i);\\n            vector<int> b = select(nums2, k - i);\\n            res = max(res, merge(a, b));\\n        }\\n        return res;\\n    }\\n};\\n```\\n// yxc nb!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // pick k numbers from vector num\\n    vector<int> select(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> res(k, INT_MIN);\\n        for(int i = 0, j = 0;i<nums.size();i++){\\n            int x = nums[i];\\n            // monotonic stack\\n            while(j>0&&x > res[j-1]&&i+k-j<n) j--;\\n            if(j<k) res[j++] = x;\\n        }\\n        return res;\\n    }\\n    vector<int> merge(vector<int>& a, vector<int> &b){\\n        vector<int> c;\\n        while(a.size()&&b.size()){\\n            // The time complexity of compare operation for two vector is order of n.\\n            // Greedy Algorithm:\\n            // If we meet two elements which have the same value, choose the vector which has the higher dictionary order first.\\n            // 1: ...xxxb , 2: ...xxxa, if a > b, then merge sequence 2 first. \\n            if(a > b)\\n                c.push_back(a[0]), a.erase(a.begin());\\n            else\\n                c.push_back(b[0]), b.erase(b.begin());\\n        }\\n        while(a.size())\\n            c.push_back(a[0]), a.erase(a.begin());\\n        while(b.size())\\n            c.push_back(b[0]), b.erase(b.begin());\\n        return c;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> res(k, INT_MIN);\\n        int n = nums1.size(), m = nums2.size();\\n        // s1  => nums1.size(), s2 => nums2.size()\\n        // {0<=i<=k, i<=s1, 0<=k-i<=s2} => i>=max(0, k-s2), i<=min(k, n)\\n        for(int i = max(0, k-m);i<=min(k, n);i++){\\n            vector<int> a = select(nums1, i);\\n            vector<int> b = select(nums2, k - i);\\n            res = max(res, merge(a, b));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112284,
                "title": "cpp-simple-greedy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> calc(vector<int> &v,int k,int n) {\\n        vector<int> v1;\\n        // IF I replace the current top or not.\\n        int i=-1,j,ind=-1,ans=-1;\\n        while(k) {\\n            j=i+1;ind=-1;ans=-1;\\n            while(j<n&&n-j>=k) {\\n                if(v[j]>ans) {\\n                    ans=v[j];\\n                    ind=j;\\n                }\\n                j++;\\n            }\\n            i=ind;\\n            v1.push_back(ans);\\n            k--;\\n        }\\n        return v1;\\n    }\\n    vector<int> merge(vector<int> &v1,vector<int> &v2,int n,int m) {\\n        vector<int> v;\\n        if(n>m) {\\n            swap(v1,v2);\\n            swap(n,m);\\n        }\\n        int i=0,j=0;\\n        while(i<n && j<m) {\\n            if(v1[i]>v2[j]) {\\n                v.push_back(v1[i]);\\n                i++;\\n            }\\n            else if(v1[i]<v2[j]) {\\n                v.push_back(v2[j]);\\n                j++;\\n            }\\n            else {\\n                int k=i+1,l=j+1,f=1;\\n                while(k<n && l<m) {\\n                    if(v1[k]>v2[l]) { f=0;break; }\\n                    else if(v1[k]<v2[l]) { f=1;break;}\\n                    k++;\\n                    l++;\\n                }\\n                \\n                if(f==0||l==m) { v.push_back(v1[i++]); }\\n                else     { v.push_back(v2[j++]); }\\n            }\\n        }\\n        while(i<n) { v.push_back(v1[i]);i++; }\\n        while(j<m) { v.push_back(v2[j]);j++; }\\n        return v;\\n    }\\n    int comp(vector<int> v1,vector<int> v2,int k) {\\n        for(int i=0;i<k;i++) { \\n            if(v1[i]!=v2[i]) return v1[i]>v2[i];\\n        }\\n        return 0;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        // If I have to chose k greatest elements.\\n        // from a vector. how you are going to pick up.\\n        // this task is awesome.\\n        vector<int> ans(k,-1);\\n        for(int i=0;i<=min(n,k);i++) {\\n            int r=k-i;\\n            if(r<=m) { \\n                vector<int> v1=calc(nums1,i,n),v2=calc(nums2,r,m);\\n                vector<int> x=merge(v1,v2,i,r);\\n                if(comp(x,ans,k)>0) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> calc(vector<int> &v,int k,int n) {\\n        vector<int> v1;\\n        // IF I replace the current top or not.\\n        int i=-1,j,ind=-1,ans=-1;\\n        while(k) {\\n            j=i+1;ind=-1;ans=-1;\\n            while(j<n&&n-j>=k) {\\n                if(v[j]>ans) {\\n                    ans=v[j];\\n                    ind=j;\\n                }\\n                j++;\\n            }\\n            i=ind;\\n            v1.push_back(ans);\\n            k--;\\n        }\\n        return v1;\\n    }\\n    vector<int> merge(vector<int> &v1,vector<int> &v2,int n,int m) {\\n        vector<int> v;\\n        if(n>m) {\\n            swap(v1,v2);\\n            swap(n,m);\\n        }\\n        int i=0,j=0;\\n        while(i<n && j<m) {\\n            if(v1[i]>v2[j]) {\\n                v.push_back(v1[i]);\\n                i++;\\n            }\\n            else if(v1[i]<v2[j]) {\\n                v.push_back(v2[j]);\\n                j++;\\n            }\\n            else {\\n                int k=i+1,l=j+1,f=1;\\n                while(k<n && l<m) {\\n                    if(v1[k]>v2[l]) { f=0;break; }\\n                    else if(v1[k]<v2[l]) { f=1;break;}\\n                    k++;\\n                    l++;\\n                }\\n                \\n                if(f==0||l==m) { v.push_back(v1[i++]); }\\n                else     { v.push_back(v2[j++]); }\\n            }\\n        }\\n        while(i<n) { v.push_back(v1[i]);i++; }\\n        while(j<m) { v.push_back(v2[j]);j++; }\\n        return v;\\n    }\\n    int comp(vector<int> v1,vector<int> v2,int k) {\\n        for(int i=0;i<k;i++) { \\n            if(v1[i]!=v2[i]) return v1[i]>v2[i];\\n        }\\n        return 0;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        // If I have to chose k greatest elements.\\n        // from a vector. how you are going to pick up.\\n        // this task is awesome.\\n        vector<int> ans(k,-1);\\n        for(int i=0;i<=min(n,k);i++) {\\n            int r=k-i;\\n            if(r<=m) { \\n                vector<int> v1=calc(nums1,i,n),v2=calc(nums2,r,m);\\n                vector<int> x=merge(v1,v2,i,r);\\n                if(comp(x,ans,k)>0) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865712,
                "title": "360-ms-python-solution-with-detailed-explanation",
                "content": "The main idea: \\n\\n1 . get the maximum array with length of s1 from list nums1 called p1 and then get the maximum array with length of k-s1 from list nums2 called p2\\n2 . arrange p1 and p2 to make maximum rs \\n\\nTo get the maximum array with length of c_len and also reserve the relative order in that array:\\n    We use a helper function to get the maximum array with length of c_len\\nas long as ans[-1]< current value and the remaining elements in list nums is enough to form ans with length c_len then we pop the last element in ans\\n```\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \\n        l1,l2 = len(nums1),len(nums2)\\n        rs = []\\n        \\n        \\n        def helper(nums,c_len):\\n            ans = []\\n            ln = len(nums)\\n            for idx,val in enumerate(nums):\\n                while ans and ans[-1]<val and ln-idx> c_len-len(ans):\\n                    ans.pop(-1)\\n                if len(ans)<c_len:\\n                    ans.append(val)\\n            return ans\\n        \\n        for s1 in range(max(0,k-l2),min(k,l1)+1):\\n            p1,p2 = helper(nums1,s1),helper(nums2,k-s1)\\n            rs = max(rs,[max(p1,p2).pop(0) for _ in range(k)])\\n        return rs\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \\n        l1,l2 = len(nums1),len(nums2)\\n        rs = []\\n        \\n        \\n        def helper(nums,c_len):\\n            ans = []\\n            ln = len(nums)\\n            for idx,val in enumerate(nums):\\n                while ans and ans[-1]<val and ln-idx> c_len-len(ans):\\n                    ans.pop(-1)\\n                if len(ans)<c_len:\\n                    ans.append(val)\\n            return ans\\n        \\n        for s1 in range(max(0,k-l2),min(k,l1)+1):\\n            p1,p2 = helper(nums1,s1),helper(nums2,k-s1)\\n            rs = max(rs,[max(p1,p2).pop(0) for _ in range(k)])\\n        return rs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539266,
                "title": "help-me-understand-the-question",
                "content": "I have a hard time understanding the question. \\nFor the input:\\n[5,5,4,1,1,6,2], [8,8], 4\\nI think the expected output is [8,8,5,6], which still preserves the order of 2 arrays. \\nHowever, the correct output is [8,8,6,2]\\nAny comments will be helpful.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 155478,
                "title": "c-solution-based-on-stefanpochmann-s-approach-with-very-detailed-explanation",
                "content": "@StefanPochmann solution is great but lacks detailed comments. Here is the solution that explains the process step by step. \\n    Idea - \\n*   K elements can be picked as i elements from nums1 and k-i elements from nums2. \\n*   We slice two lists nums1 and nums2 by choosing series of values for i\\n*   We create biggest number possible from each list for given value of i or k-i\\n*   We combine the two lists to get the biggest number for given slice.\\n*   We choose maximum number for all slices.\\n\\nCode below - \\n```\\nclass Solution {\\n\\nprivate:\\n    //Compare function for two generic collections.\\n    //if collection contains non primitive types then it must overload\\n    //operator \\'<\\'\\n    \\n    //returns true if second list is greater in value than first one\\n    //if all elements are equal then it returns true if second list is\\n    //larger in size\\n    \\n    template <class InputIterator1, class InputIterator2>\\n      bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,\\n                                    InputIterator2 first2, InputIterator2 last2)\\n    {\\n      while (first1!=last1)\\n      {\\n        if (first2==last2 || *first2<*first1) return false;\\n        else if (*first1<*first2) return true;\\n        ++first1; ++first2;\\n      }\\n      return (first2!=last2);\\n    }\\npublic:\\n    \\n    //subproblem 1 = create the greatest number with K digits from a single list\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size()-k; //number of digits to be dropped\\n        vector<int> out;\\n        for(int num : nums) {\\n            //if there are digits left to be dropped and if we find\\n            //a digit that is greater than the digit we have in our \\n            //output array we drop the digits and add that digit\\n            while(drop > 0 && out.size() != 0 && out.back() < num) {\\n                drop--;\\n                out.pop_back();\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k); // this is necessary if there are more than K digits in out\\n        return out;\\n    }\\n    \\n    /*\\n      subproblem 2 = create largest number from the two lists, containing\\n      digits [0-9]. The size of output number is sum of size of two\\n      lists\\n    */\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        auto start1 = nums1.begin(), end1 = nums1.end(),\\n             start2 = nums2.begin(), end2 = nums2.end();\\n        vector<int> out;\\n        while(start1 != end1 || start2 != end2) {\\n            if(lexicographical_compare(start1,end1,start2,end2)) {\\n                out.push_back(*start2++);\\n            }\\n            else {\\n                out.push_back(*start1++);\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        /* \\n           The start and end range of for the \"for loop\" is computed based on\\n           number of min elements we need to pick from nums1 and number of maximum\\n           elements we can pick from nums1. if k > n2 then we must at least pick up\\n           k-n2 elements from n1\\n           \\n           \\n           Example 1\\n           consider n1 = 4 and n2 = 6 and k = 5\\n           Result can be constructed in following ways \\n           (i:0, k-i:5), (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1)\\n           where i is number of elements picked from nums1 and k-i is number of elements\\n           picked from nums2. Please note\\n           --> (i:5, k-i:0) is not valid since n1=4\\n           \\n           Example 2\\n           Now consider n1 = 6 and n2 = 4 and k = 5\\n           (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1), (i:5, k-i:0)\\n           \\n           hence starting index for i that is associated with nums1 is \\n           max(0, k-n2) (in first example k-n2 = -1, in second example k-n2 = 1)\\n           \\n           end index for i associated with nums1 is \\n           min(k,n1) (in first example i can only go up to 4 since n1 = 4, in second example\\n                      i can only go up to 5 since k = 5)\\n                      \\n          Example 3\\n          n1 = 3, n2 = 4, k = 5\\n          we must pick at least 1 element from nums1 (k-n2 = 1) also i can only go up to 3 since\\n          n1 is capped at 3\\n          \\n          Example 4\\n          \\n          n1 = 5, n2=3, k = 4\\n          we must pick up at least 1 element from nums1 (k-n2 = 1) and i can go up to 4\\n           \\n        */\\n          for(int i = max(0,k-n2); i <= min(k,n1); i++) {\\n            \\n            if(best.size() == 0) {\\n                best = maxNumber(maxNumber(nums1,i),\\n                                 maxNumber(nums2,k-i));\\n            }\\n            else {\\n                vector<int> temp = maxNumber(maxNumber(nums1,i),\\n                                             maxNumber(nums2,k-i));\\n                if(lexicographical_compare(best.begin(), best.end(),\\n                                           temp.begin(),temp.end())) {\\n                    best = temp;\\n                }\\n            }\\n            //vector class overloads \"<\" operator hence you could simply use the \\n            //statement below, above code is only to make things simple.\\n            //best = max(best,maxNumber(maxNumber(nums1,i),maxNumber(nums2,k-i)));\\n        }\\n        return best;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    //Compare function for two generic collections.\\n    //if collection contains non primitive types then it must overload\\n    //operator \\'<\\'\\n    \\n    //returns true if second list is greater in value than first one\\n    //if all elements are equal then it returns true if second list is\\n    //larger in size\\n    \\n    template <class InputIterator1, class InputIterator2>\\n      bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,\\n                                    InputIterator2 first2, InputIterator2 last2)\\n    {\\n      while (first1!=last1)\\n      {\\n        if (first2==last2 || *first2<*first1) return false;\\n        else if (*first1<*first2) return true;\\n        ++first1; ++first2;\\n      }\\n      return (first2!=last2);\\n    }\\npublic:\\n    \\n    //subproblem 1 = create the greatest number with K digits from a single list\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size()-k; //number of digits to be dropped\\n        vector<int> out;\\n        for(int num : nums) {\\n            //if there are digits left to be dropped and if we find\\n            //a digit that is greater than the digit we have in our \\n            //output array we drop the digits and add that digit\\n            while(drop > 0 && out.size() != 0 && out.back() < num) {\\n                drop--;\\n                out.pop_back();\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k); // this is necessary if there are more than K digits in out\\n        return out;\\n    }\\n    \\n    /*\\n      subproblem 2 = create largest number from the two lists, containing\\n      digits [0-9]. The size of output number is sum of size of two\\n      lists\\n    */\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        auto start1 = nums1.begin(), end1 = nums1.end(),\\n             start2 = nums2.begin(), end2 = nums2.end();\\n        vector<int> out;\\n        while(start1 != end1 || start2 != end2) {\\n            if(lexicographical_compare(start1,end1,start2,end2)) {\\n                out.push_back(*start2++);\\n            }\\n            else {\\n                out.push_back(*start1++);\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        /* \\n           The start and end range of for the \"for loop\" is computed based on\\n           number of min elements we need to pick from nums1 and number of maximum\\n           elements we can pick from nums1. if k > n2 then we must at least pick up\\n           k-n2 elements from n1\\n           \\n           \\n           Example 1\\n           consider n1 = 4 and n2 = 6 and k = 5\\n           Result can be constructed in following ways \\n           (i:0, k-i:5), (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1)\\n           where i is number of elements picked from nums1 and k-i is number of elements\\n           picked from nums2. Please note\\n           --> (i:5, k-i:0) is not valid since n1=4\\n           \\n           Example 2\\n           Now consider n1 = 6 and n2 = 4 and k = 5\\n           (i:1, k-i:4), (i:2, k-i:3), (i:3, k-i:2), (i:4, k-i:1), (i:5, k-i:0)\\n           \\n           hence starting index for i that is associated with nums1 is \\n           max(0, k-n2) (in first example k-n2 = -1, in second example k-n2 = 1)\\n           \\n           end index for i associated with nums1 is \\n           min(k,n1) (in first example i can only go up to 4 since n1 = 4, in second example\\n                      i can only go up to 5 since k = 5)\\n                      \\n          Example 3\\n          n1 = 3, n2 = 4, k = 5\\n          we must pick at least 1 element from nums1 (k-n2 = 1) also i can only go up to 3 since\\n          n1 is capped at 3\\n          \\n          Example 4\\n          \\n          n1 = 5, n2=3, k = 4\\n          we must pick up at least 1 element from nums1 (k-n2 = 1) and i can go up to 4\\n           \\n        */\\n          for(int i = max(0,k-n2); i <= min(k,n1); i++) {\\n            \\n            if(best.size() == 0) {\\n                best = maxNumber(maxNumber(nums1,i),\\n                                 maxNumber(nums2,k-i));\\n            }\\n            else {\\n                vector<int> temp = maxNumber(maxNumber(nums1,i),\\n                                             maxNumber(nums2,k-i));\\n                if(lexicographical_compare(best.begin(), best.end(),\\n                                           temp.begin(),temp.end())) {\\n                    best = temp;\\n                }\\n            }\\n            //vector class overloads \"<\" operator hence you could simply use the \\n            //statement below, above code is only to make things simple.\\n            //best = max(best,maxNumber(maxNumber(nums1,i),maxNumber(nums2,k-i)));\\n        }\\n        return best;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77284,
                "title": "easy-to-understand-greedy-c-solution-o-nmk",
                "content": "We pick optimal digit one by one. At each phase, let dp[sa] be the minimum number of elements we need to use\\nin array b, if we use sa elements in array a, in order to obtain the optimal solution so far. We look ahead to find the next optimal digit then update dp accordingly.\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int na = a.size(), nb =b.size();\\n        vector<int> dp(na+1);\\n        vector<int> ans;\\n        while (k) {\\n            int x = 0;\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) x = max(x,a[i]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) x = max(x,b[j]);\\n            }\\n            vector<int> dp2(na+1,INT_MAX);\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) if (a[i] == x) dp2[i+1] = min(dp2[i+1], dp[sa]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) if (b[j] == x) dp2[sa] = min(dp2[sa], j+1);\\n            }\\n            dp.swap(dp2);\\n            ans.push_back(x);\\n            --k;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int na = a.size(), nb =b.size();\\n        vector<int> dp(na+1);\\n        vector<int> ans;\\n        while (k) {\\n            int x = 0;\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) x = max(x,a[i]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) x = max(x,b[j]);\\n            }\\n            vector<int> dp2(na+1,INT_MAX);\\n            for (int sa = 0; sa <= na; ++sa) if (dp[sa] <= nb && nb- dp[sa] + na - sa >=k) {\\n                for (int i = sa; i < na; ++i) if (na - i + nb- dp[sa] >= k) if (a[i] == x) dp2[i+1] = min(dp2[i+1], dp[sa]);\\n                for (int j = dp[sa]; j < nb; ++j) if (na - sa + nb - j >= k) if (b[j] == x) dp2[sa] = min(dp2[sa], j+1);\\n            }\\n            dp.swap(dp2);\\n            ans.push_back(x);\\n            --k;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77317,
                "title": "very-straight-forward-solution-yet-still-efficient-in-c",
                "content": "If you prefer performance than anything else then check this [post](https://leetcode.com/discuss/101043/efficient-solution-accepted-best-beating-16ms-well-commented). The following solution is simplified for simplicity and readability, so the performance is reduced.\\n\\n    class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }\\n                }\\n                if (i == n - 1) nums.erase(nums.begin() + i);\\n            }\\n            return nums;\\n        }\\n    \\n        //compare two vectors from certain index adopting lexical order;\\n        //if the first vector is bigger return true otherwise return false;\\n        bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) \\n        {\\n            while (i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j]) ++i, ++j;\\n            if (i<nums1.size() && j<nums2.size()) return nums1[i]>nums2[j];\\n            else if(j == nums2.size()) return true;\\n            else return false;\\n        }\\n    \\n        //get the first k numbers which form the largest lexical sequence;\\n        vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) \\n        {\\n            vector<int> res(k, 0);\\n            for (int i=0, j=0, r=0; r < k; ++r) \\n                res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n            return res;\\n        }\\n    \\n        //AC - 386ms - the most intuitive solution;\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            int len1=nums1.size(), len2=nums2.size();\\n            vector<int> v(k, 0);\\n            for (int l1 = max(0, k-len2); l1 <= min(k, len1); ++l1) \\n            {\\n                auto v1 = maxVector(nums1, l1);\\n                auto v2 = maxVector(nums2, k-l1);\\n                auto tmp = merge(v1, v2, k);\\n                if (compare(tmp, 0, v, 0)) v = tmp;\\n            }\\n            return v;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77345,
                "title": "c-implementation-of-the-top-voted-answer-without-the-compare-function",
                "content": "    class Solution {\\n    private:\\n        //get the max k-length number of array nums ...\\n        vector<int> helper(vector<int>& nums, int k){\\n            int n=nums.size();\\n            int j=0; // the count of the stacked array \\n            vector<int> result(k,0);\\n            for(int i=0; i<n; i++){\\n                //result[j-1] stores the top of the stack \\n                while(j>0 && n-i+j>k && nums[i]>result[j-1])  j--;\\n                if(j<k) result[j++]=nums[i];\\n            }\\n            return result;\\n        }\\n        \\n        vector<int> merge(vector<int>& nums1, vector<int>& nums2, int k){\\n            vector<int> result(k, 0);\\n            ostringstream num_str1, num_str2;\\n            string str1, str2;\\n            for(auto num:nums1)  num_str1 << num;\\n            for(auto num:nums2)  num_str2 << num;\\n            str1=num_str1.str();\\n            str2=num_str2.str();\\n            for(int i=0, j=0, r=0; r<k; r++){\\n                result[r] = str1.substr(i).compare(str2.substr(j)) > 0 ? nums1[i++] : nums2[j++];\\n            }\\n            return result;\\n        }\\n        \\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            int n=nums1.size(), m=nums2.size();\\n            vector<int> result(k, 0);\\n            string result_str;\\n            for(int i=max(0, k-m); i<=k && i<=n; i++){\\n                vector<int> sub_1 = helper(nums1, i);\\n                vector<int> sub_2 = helper(nums2, k-i);\\n                vector<int> candidate = merge(sub_1, sub_2, k);\\n                ostringstream str_c;\\n                for(auto number:candidate)  str_c << number;\\n                if(result_str==\"\" || str_c.str().compare(result_str) > 0 ){\\n                    result_str=str_c.str();\\n                    result=candidate;\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        //get the max k-length number of array nums ...\\n        vector<int> helper(vector<int>& nums, int k){\\n            int n=nums.size();\\n            int j=0; // the count of the stacked array \\n            vector<int> result(k,0);\\n            for(int i=0; i<n; i++){\\n                //result[j-1] stores the top of the stack \\n                while(j>0 && n-i+j>k && nums[i]>result[j-1])  j--;\\n                if(j<k) result[j++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2856490,
                "title": "c-greedy-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //function to find the maximum lexicographic sequence using monotonic stack implemented\\n    //via vector. It will give us maximum lexicographic sequence of length k.\\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            //condition to pop\\n            //the last condition ensures length k is returned\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    //function to return true if vector starting at a is lexicographically greater than nums2 starting at b\\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        //we are trying to generate all possible max lexicographic sequences from the two vextors\\n        //of different lengths and then we merge them and compare for maximum result\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            //using merge sort technique\\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                //if we have the case where we have got the same value then we have to consider \\n                //which of the two vectors have max lexicographic sequence beginning from a and b pointers\\n                //as a max sequence will affect the answer positively and we would be pushing the result\\n                //from the vector which has a max sequence\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                    //if max1 is greater then we enter\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //function to find the maximum lexicographic sequence using monotonic stack implemented\\n    //via vector. It will give us maximum lexicographic sequence of length k.\\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            //condition to pop\\n            //the last condition ensures length k is returned\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    //function to return true if vector starting at a is lexicographically greater than nums2 starting at b\\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        //we are trying to generate all possible max lexicographic sequences from the two vextors\\n        //of different lengths and then we merge them and compare for maximum result\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            //using merge sort technique\\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                //if we have the case where we have got the same value then we have to consider \\n                //which of the two vectors have max lexicographic sequence beginning from a and b pointers\\n                //as a max sequence will affect the answer positively and we would be pushing the result\\n                //from the vector which has a max sequence\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                    //if max1 is greater then we enter\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713556,
                "title": "c-94-faster-stack-solution-merge-sort-variation",
                "content": "[**321. Create Maximum Number**](https://leetcode.com/problems/create-maximum-number/)\\n\\n**`Time Complexity : O(n2)`**\\n**`Space Complexity : O(n)`**\\n\\n```\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(), n=nums2.size();\\n        vector<int>res(k);\\n        for(int i=0; i<=k; i++){\\n            if(i<=m and k-i<=n){\\n                vector<int>v1=maxArray(nums1, i), v2=maxArray(nums2, k-i);\\n                vector<int>v=merge(v1,v2 , k);\\n                res=max(res, v);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    vector<int>merge(vector<int>&nums1 , vector<int>&nums2, int k){\\n        vector<int>v(k);\\n        for(int i=0, j=0, t=0;t<k; t++){\\n            v[t]=cmp(nums1,i, nums2, j)?nums1[i++]:nums2[j++];\\n        }\\n        return v;\\n    }\\n\\t\\n    bool cmp(vector<int>&nums1, int i, vector<int>&nums2,int j){\\n        while(i<nums1.size() and j<nums2.size() and nums1[i]==nums2[j]){\\n            i++, j++;\\n        }\\n        return j==nums2.size() or (i<nums1.size() and nums1[i]>nums2[j]);\\n    }\\n\\t\\n    vector<int>maxArray(vector<int>&nums, int k){\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0; i<n; i++){\\n            while(v.size()+n-i>k and !v.empty() and v.back()<nums[i])v.pop_back();\\n            if(v.size()<k)v.push_back(nums[i]);\\n        }\\n        return v;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n![image](https://assets.leetcode.com/users/images/77d4616f-979f-4fd2-acdf-6cf04532de46_1665998757.740748.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Merge Sort"
                ],
                "code": "```\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(), n=nums2.size();\\n        vector<int>res(k);\\n        for(int i=0; i<=k; i++){\\n            if(i<=m and k-i<=n){\\n                vector<int>v1=maxArray(nums1, i), v2=maxArray(nums2, k-i);\\n                vector<int>v=merge(v1,v2 , k);\\n                res=max(res, v);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    vector<int>merge(vector<int>&nums1 , vector<int>&nums2, int k){\\n        vector<int>v(k);\\n        for(int i=0, j=0, t=0;t<k; t++){\\n            v[t]=cmp(nums1,i, nums2, j)?nums1[i++]:nums2[j++];\\n        }\\n        return v;\\n    }\\n\\t\\n    bool cmp(vector<int>&nums1, int i, vector<int>&nums2,int j){\\n        while(i<nums1.size() and j<nums2.size() and nums1[i]==nums2[j]){\\n            i++, j++;\\n        }\\n        return j==nums2.size() or (i<nums1.size() and nums1[i]>nums2[j]);\\n    }\\n\\t\\n    vector<int>maxArray(vector<int>&nums, int k){\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0; i<n; i++){\\n            while(v.size()+n-i>k and !v.empty() and v.back()<nums[i])v.pop_back();\\n            if(v.size()<k)v.push_back(nums[i]);\\n        }\\n        return v;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2333992,
                "title": "easy-c-solution-with-full-explanation-two-stacks-with-i-k-i-sequences",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n          for(int i=0; i<=k; i++) {\\n                vector<int> s1 , s2;\\n                if(i>0) s1 = getBest(a,i);  // make i length lexographically biggest sequence possible from stack 1 \\n                if(k-i>0) s2 = getBest(b,k-i); // make k-i length lexographically biggest sequence from stack 2\\n                vector<int> s3;\\n                int m = 0 , n = 0;\\n                \\n                // take the element from corresponding stack is is lexographically bigger!\\n                while(m<s1.size() && n<s2.size()) s3.push_back((cmp(s1,s2,m,n) ? s1[m++] : s2[n++]));\\n                \\n                while(m<s1.size()) s3.push_back(s1[m++]);\\n                while(n<s2.size()) s3.push_back(s2[n++]);\\n                \\n                if(s3.size()==k) ans=max(ans,s3);\\n          }\\n         return ans;\\n    }\\n    bool cmp(vector<int>&a,vector<int>&b,int i,int j) {\\n         while(i<a.size() && j<b.size() && a[i]==b[j]) i++,j++;\\n         return (j==b.size() || ((i<(int)a.size()) && (a[i] > b[j])));\\n    }\\n    vector<int> getBest(vector<int> &a,int k) {\\n        vector<int> stk;\\n        int n = a.size();\\n        for(int i=0; i<a.size(); i++) {\\n             // a bigger element is present than current maximum & you can make a sequence >= k !\\n             while(!stk.empty() && stk.back() < a[i] && (((int)stk.size() - 1) + (n - i)) >=k) stk.pop_back();\\n             stk.push_back(a[i]);\\n        }\\n        while(stk.size() > k) stk.pop_back();\\n        return stk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n          for(int i=0; i<=k; i++) {\\n                vector<int> s1 , s2;\\n                if(i>0) s1 = getBest(a,i);  // make i length lexographically biggest sequence possible from stack 1 \\n                if(k-i>0) s2 = getBest(b,k-i); // make k-i length lexographically biggest sequence from stack 2\\n                vector<int> s3;\\n                int m = 0 , n = 0;\\n                \\n                // take the element from corresponding stack is is lexographically bigger!\\n                while(m<s1.size() && n<s2.size()) s3.push_back((cmp(s1,s2,m,n) ? s1[m++] : s2[n++]));\\n                \\n                while(m<s1.size()) s3.push_back(s1[m++]);\\n                while(n<s2.size()) s3.push_back(s2[n++]);\\n                \\n                if(s3.size()==k) ans=max(ans,s3);\\n          }\\n         return ans;\\n    }\\n    bool cmp(vector<int>&a,vector<int>&b,int i,int j) {\\n         while(i<a.size() && j<b.size() && a[i]==b[j]) i++,j++;\\n         return (j==b.size() || ((i<(int)a.size()) && (a[i] > b[j])));\\n    }\\n    vector<int> getBest(vector<int> &a,int k) {\\n        vector<int> stk;\\n        int n = a.size();\\n        for(int i=0; i<a.size(); i++) {\\n             // a bigger element is present than current maximum & you can make a sequence >= k !\\n             while(!stk.empty() && stk.back() < a[i] && (((int)stk.size() - 1) + (n - i)) >=k) stk.pop_back();\\n             stk.push_back(a[i]);\\n        }\\n        while(stk.size() > k) stk.pop_back();\\n        return stk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243230,
                "title": "c-not-so-simple-warning-just-run-away-don-t-try-this-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> func(vector<int> &nums, int k)\\n    {\\n        vector<int> ret(k, 0);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(ret.empty() || ret.back()>=nums[i])\\n            {\\n                if(ret.size()<k)\\n                    ret.push_back(nums[i]);\\n            }\\n            else{\\n                while(!ret.empty() && n-i>k-ret.size() && ret.back()<nums[i])\\n                    ret.pop_back();\\n                ret.push_back(nums[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n    bool isGreater(vector<int> &a, vector<int> &b)\\n    {\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(b[i]>a[i])\\n                return false;\\n            else if(b[i]<a[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v1, v2;\\n        vector<int> ret(k, 0);\\n        for(int i=0; i<=k; i++)\\n        {\\n            if(i>nums1.size() || k-i>nums2.size())\\n                continue;\\n            vector<int> x, y;\\n            if(i)\\n                x=func(nums1, i);\\n            if(k-i)\\n                y=func(nums2, k-i);\\n            vector<int> res;\\n            int p=0, q=0, m=x.size(), n=y.size();\\n            x.push_back(0);\\n            y.push_back(0);\\n            while(p<m && q<n)\\n            {\\n                if(x[p]>y[q])\\n                    res.push_back(x[p++]);\\n                else if(x[p]<y[q])\\n                    res.push_back(y[q++]);\\n                else\\n                {\\n                    bool flag=true;\\n                    int t=1;\\n                    while(p+t<m && q+t<n && x[p+t]==y[q+t])\\n                        t++;\\n                    if(p+t>=m || (q+t<n && x[p+t]<y[q+t]))\\n                        flag=false;\\n                    if(flag)\\n                        res.push_back(x[p++]);\\n                    else\\n                        res.push_back(y[q++]);\\n                }\\n            }\\n            while(p<m)\\n                res.push_back(x[p++]);\\n            while(q<n)\\n                res.push_back(y[q++]);\\n            if(isGreater(res, ret))\\n                ret=res;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> func(vector<int> &nums, int k)\\n    {\\n        vector<int> ret(k, 0);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(ret.empty() || ret.back()>=nums[i])\\n            {\\n                if(ret.size()<k)\\n                    ret.push_back(nums[i]);\\n            }\\n            else{\\n                while(!ret.empty() && n-i>k-ret.size() && ret.back()<nums[i])\\n                    ret.pop_back();\\n                ret.push_back(nums[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n    bool isGreater(vector<int> &a, vector<int> &b)\\n    {\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(b[i]>a[i])\\n                return false;\\n            else if(b[i]<a[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v1, v2;\\n        vector<int> ret(k, 0);\\n        for(int i=0; i<=k; i++)\\n        {\\n            if(i>nums1.size() || k-i>nums2.size())\\n                continue;\\n            vector<int> x, y;\\n            if(i)\\n                x=func(nums1, i);\\n            if(k-i)\\n                y=func(nums2, k-i);\\n            vector<int> res;\\n            int p=0, q=0, m=x.size(), n=y.size();\\n            x.push_back(0);\\n            y.push_back(0);\\n            while(p<m && q<n)\\n            {\\n                if(x[p]>y[q])\\n                    res.push_back(x[p++]);\\n                else if(x[p]<y[q])\\n                    res.push_back(y[q++]);\\n                else\\n                {\\n                    bool flag=true;\\n                    int t=1;\\n                    while(p+t<m && q+t<n && x[p+t]==y[q+t])\\n                        t++;\\n                    if(p+t>=m || (q+t<n && x[p+t]<y[q+t]))\\n                        flag=false;\\n                    if(flag)\\n                        res.push_back(x[p++]);\\n                    else\\n                        res.push_back(y[q++]);\\n                }\\n            }\\n            while(p<m)\\n                res.push_back(x[p++]);\\n            while(q<n)\\n                res.push_back(y[q++]);\\n            if(isGreater(res, ret))\\n                ret=res;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467230,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def fn(arr, k):\\n            \"\"\"Return largest sub-sequence of arr of size k.\"\"\"\\n            ans = []\\n            for i, x in enumerate(arr): \\n                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()\\n                if len(ans) < k: ans.append(x)\\n            return ans\\n            \\n        ans = [0] * k\\n        for i in range(k+1): \\n            if k - len(nums2) <= i <= len(nums1): \\n                val1 = fn(nums1, i)\\n                val2 = fn(nums2, k-i)\\n                cand = []\\n                i1 = i2 = 0\\n                while i1 < len(val1) or i2 < len(val2): \\n                    if val1[i1:] >= val2[i2:]: \\n                        cand.append(val1[i1])\\n                        i1 += 1\\n                    else: \\n                        cand.append(val2[i2])\\n                        i2 += 1\\n                ans = max(ans, cand)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def fn(arr, k):\\n            \"\"\"Return largest sub-sequence of arr of size k.\"\"\"\\n            ans = []\\n            for i, x in enumerate(arr): \\n                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()\\n                if len(ans) < k: ans.append(x)\\n            return ans\\n            \\n        ans = [0] * k\\n        for i in range(k+1): \\n            if k - len(nums2) <= i <= len(nums1): \\n                val1 = fn(nums1, i)\\n                val2 = fn(nums2, k-i)\\n                cand = []\\n                i1 = i2 = 0\\n                while i1 < len(val1) or i2 < len(val2): \\n                    if val1[i1:] >= val2[i2:]: \\n                        cand.append(val1[i1])\\n                        i1 += 1\\n                    else: \\n                        cand.append(val2[i2])\\n                        i2 += 1\\n                ans = max(ans, cand)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134816,
                "title": "beginner-friendly-logic-implementation-in-java-easy-to-understand",
                "content": "Algorithm:\\nLet the arrays be arr1 and arr2\\n1. Find the maximum length of arr1 which is less than or equal to k. i.e. n <= k. Create a maximum array for this size using arr1.\\n2.  Now left length is k - n. Lets call it m, which will be the length for arr2. Create maximum array of this size using arr2.\\n\\nNow comes the main logic\\n\\n3. Start a loop \\n4. At every step decrease the size of arr1 by one and increment the size of arr2 by one, so that the sum of both sizes of array is equal to k   i.e.  n-- and m++\\n\\nSo the loop condition will become (m <= k && n>=0 && m <= arr2.length)\\n\\n5. Generate the array and merge both the arrays and store in the form of String for easy lexicographical comparison \\n\\n```\\nclass Solution {\\n\\n    String str_ans;\\n\\n    int[] build(int org[], int size) {\\n\\n        // This function is for generating maximum array\\n\\n        int res[] = new int[size];\\n        ArrayList<Integer> al = new ArrayList<>();\\n\\n        for (int i = 0; i < org.length; i++) {\\n            al.add(i);\\n        }\\n\\n        Collections.sort(al, (Integer a, Integer b) -> {\\n            return org[b] - org[a];\\n        });\\n\\n        int index = 0;\\n        int count = 0;\\n\\n        Arrays.fill(res, -1);\\n\\n        while (count < size) {\\n\\n            int cur_ind = al.get(index++);\\n            int smaller = org.length - cur_ind - 1;\\n\\n            for (int i = Math.max(0, size - smaller - 1); i < size; i++) {\\n                if (res[i] == -1) {\\n                    res[i] = cur_ind;\\n                    count++;\\n                    break;\\n                }\\n                if (res[i] > cur_ind) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < size; i++) {\\n            res[i] = org[res[i]];\\n        }\\n\\n        return res;\\n    }\\n\\n    int[] merge(int arr1[], int arr2[]) {\\n        int n = arr1.length;\\n        int m = arr2.length;\\n\\n        int res[] = new int[n + m];\\n\\n        int ind1 = 0;\\n        int ind2 = 0;\\n\\n        for (int i = 0; i < n + m; i++) {\\n            int val1 = (ind1 >= n ? -1 : arr1[ind1]);\\n            int val2 = (ind2 >= m ? -1 : arr2[ind2]);\\n\\n            if (val1 > val2) {\\n                res[i] = val1;\\n                ind1++;\\n            } else if (val2 > val1) {\\n                res[i] = val2;\\n                ind2++;\\n            } else {\\n\\n                // As both the values are equal find the first unequal element\\n\\n                int next_ind1 = ind1 + 1;\\n                int next_ind2 = ind2 + 1;\\n                while (next_ind1 < n && next_ind2 < m && arr1[next_ind1] == arr2[next_ind2]) {\\n                    next_ind1++;\\n                    next_ind2++;\\n                }\\n                if (next_ind1 == n) {\\n                    res[i] = val2;\\n                    ind2++;\\n                } else if (next_ind2 == m) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else if (arr1[next_ind1] > arr2[next_ind2]) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else {\\n                    res[i] = val2;\\n                    ind2++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    String toString(int arr[]) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int[] maxNumber(int[] arr1, int[] arr2, int k) {\\n        int ans[] = new int[k];\\n\\n        int n = Math.min(arr1.length, k);\\n        int m = k - n;\\n\\n        str_ans = \"\";\\n\\n        while (m <= k && n >= 0 && m <= arr2.length) {\\n\\n            int cur_arr1[] = build(arr1, n);\\n            int cur_arr2[] = build(arr2, m);\\n\\n            int res[] = merge(cur_arr1, cur_arr2);\\n            String str_res = toString(res);\\n\\n            if (str_res.compareTo(str_ans) > 0) {\\n                str_ans = str_res;\\n            }\\n\\n            n--;\\n            m++;\\n        }\\n\\n        char c[] = str_ans.toCharArray();\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = c[i] - \\'0\\';\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\nThe solution can be improved by using better logic for removing and adding of element from both the arrays in the loop avoiding the complexity to build maximum array",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    String str_ans;\\n\\n    int[] build(int org[], int size) {\\n\\n        // This function is for generating maximum array\\n\\n        int res[] = new int[size];\\n        ArrayList<Integer> al = new ArrayList<>();\\n\\n        for (int i = 0; i < org.length; i++) {\\n            al.add(i);\\n        }\\n\\n        Collections.sort(al, (Integer a, Integer b) -> {\\n            return org[b] - org[a];\\n        });\\n\\n        int index = 0;\\n        int count = 0;\\n\\n        Arrays.fill(res, -1);\\n\\n        while (count < size) {\\n\\n            int cur_ind = al.get(index++);\\n            int smaller = org.length - cur_ind - 1;\\n\\n            for (int i = Math.max(0, size - smaller - 1); i < size; i++) {\\n                if (res[i] == -1) {\\n                    res[i] = cur_ind;\\n                    count++;\\n                    break;\\n                }\\n                if (res[i] > cur_ind) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < size; i++) {\\n            res[i] = org[res[i]];\\n        }\\n\\n        return res;\\n    }\\n\\n    int[] merge(int arr1[], int arr2[]) {\\n        int n = arr1.length;\\n        int m = arr2.length;\\n\\n        int res[] = new int[n + m];\\n\\n        int ind1 = 0;\\n        int ind2 = 0;\\n\\n        for (int i = 0; i < n + m; i++) {\\n            int val1 = (ind1 >= n ? -1 : arr1[ind1]);\\n            int val2 = (ind2 >= m ? -1 : arr2[ind2]);\\n\\n            if (val1 > val2) {\\n                res[i] = val1;\\n                ind1++;\\n            } else if (val2 > val1) {\\n                res[i] = val2;\\n                ind2++;\\n            } else {\\n\\n                // As both the values are equal find the first unequal element\\n\\n                int next_ind1 = ind1 + 1;\\n                int next_ind2 = ind2 + 1;\\n                while (next_ind1 < n && next_ind2 < m && arr1[next_ind1] == arr2[next_ind2]) {\\n                    next_ind1++;\\n                    next_ind2++;\\n                }\\n                if (next_ind1 == n) {\\n                    res[i] = val2;\\n                    ind2++;\\n                } else if (next_ind2 == m) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else if (arr1[next_ind1] > arr2[next_ind2]) {\\n                    res[i] = val1;\\n                    ind1++;\\n                } else {\\n                    res[i] = val2;\\n                    ind2++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    String toString(int arr[]) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int[] maxNumber(int[] arr1, int[] arr2, int k) {\\n        int ans[] = new int[k];\\n\\n        int n = Math.min(arr1.length, k);\\n        int m = k - n;\\n\\n        str_ans = \"\";\\n\\n        while (m <= k && n >= 0 && m <= arr2.length) {\\n\\n            int cur_arr1[] = build(arr1, n);\\n            int cur_arr2[] = build(arr2, m);\\n\\n            int res[] = merge(cur_arr1, cur_arr2);\\n            String str_res = toString(res);\\n\\n            if (str_res.compareTo(str_ans) > 0) {\\n                str_ans = str_res;\\n            }\\n\\n            n--;\\n            m++;\\n        }\\n\\n        char c[] = str_ans.toCharArray();\\n\\n        for (int i = 0; i < k; i++) {\\n            ans[i] = c[i] - \\'0\\';\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127814,
                "title": "dp-greedy-faster-than-80-c-36ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        const int m = nums1.size(), n = nums2.size();\\n        \\n        for (int i = 0; i <= k; i++) {\\n            int j = k - i;  \\n            if (i > m || j > n) continue;\\n            ans = max(ans, maxNumber(maxNumber(nums1,i),maxNumber(nums2,j)));\\n        }\\n        \\n        return ans;\\n    }\\nprivate:\\n    \\n    vector<int> maxNumber(const vector<int>& nums, int k) {\\n        if (k == 0) return {};\\n        int to_pop = nums.size() - k;\\n        vector<int> ans;\\n        for (auto &num : nums) {\\n            while (!ans.empty() && ans.back() < num && 0 < to_pop--)\\n                 ans.pop_back();\\n            ans.push_back(num);\\n        }\\n        ans.resize(k);\\n        return ans;\\n    }\\n    \\n     vector<int> maxNumber(const vector<int>& nums1,const vector<int>& nums2) {\\n        vector<int> ans;\\n        auto s1 = nums1.begin();\\n        auto e1 = nums1.end();\\n        auto s2 = nums2.begin();\\n        auto e2 = nums2.end();\\n        while (s1 != e1 || s2 != e2) {\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        }\\n         return ans;\\n     }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        const int m = nums1.size(), n = nums2.size();\\n        \\n        for (int i = 0; i <= k; i++) {\\n            int j = k - i;  \\n            if (i > m || j > n) continue;\\n            ans = max(ans, maxNumber(maxNumber(nums1,i),maxNumber(nums2,j)));\\n        }\\n        \\n        return ans;\\n    }\\nprivate:\\n    \\n    vector<int> maxNumber(const vector<int>& nums, int k) {\\n        if (k == 0) return {};\\n        int to_pop = nums.size() - k;\\n        vector<int> ans;\\n        for (auto &num : nums) {\\n            while (!ans.empty() && ans.back() < num && 0 < to_pop--)\\n                 ans.pop_back();\\n            ans.push_back(num);\\n        }\\n        ans.resize(k);\\n        return ans;\\n    }\\n    \\n     vector<int> maxNumber(const vector<int>& nums1,const vector<int>& nums2) {\\n        vector<int> ans;\\n        auto s1 = nums1.begin();\\n        auto e1 = nums1.end();\\n        auto s2 = nums2.begin();\\n        auto e2 = nums2.end();\\n        while (s1 != e1 || s2 != e2) {\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        }\\n         return ans;\\n     }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953917,
                "title": "c-find-all-lenth-combination-of-two-then-merge-them",
                "content": "The idea is to \\n1) find max number of each single array of lenght l1, l2 first.  \\n2) Then combine them to form the final largest one.   \\n3) Then select the largest combined one. \\n\\nStep 1 and 2 are both quite tricky to get right.\\n\\n```\\nclass Solution {  \\n    \\n \\n    // 54321  // find first bottom item:  3   \\n    // nums2 = [9, 1, 2, 5, 8, 3], k=3, remain 3    \\n    vector<int> maxNumber (vector<int>& nums1, int k)\\n    {\\n        int sz= nums1.size(), remove = sz-k;\\n        vector<int> res ;\\n        // best code structure: for + while\\n        // goal: generate an all decreasing sequence: remove bottom  < next\\n        for (int i=0; i< nums1.size(); i++)\\n        {\\n            // when to pop the stack:  back< current\\n            while (res.size()>0 && res.back()< nums1[i] && remove)\\n            {\\n                res.pop_back(); remove--;             \\n            }                              \\n              res.push_back(nums1[i]);                    \\n        }                \\n\\n        // finished : res may be too many, we only need k element        \\n        // the case of all decreasing, just remove from back\\n        while (remove)\\n        {\\n            res.pop_back(); remove--; \\n        }        \\n        \\n        return res; \\n    }\\n    \\n    // merge linked list problem: but tricker to handle equal case\\n    // max len 2 : 6,5 \\n   //  max len 3 : 9 8 3\\n    vector<int> combine (vector<int>& v1, vector<int>& v2)\\n    {\\n        vector<int> res; \\n        int p1=0, p2=0;\\n        \\n        while (p1<v1.size() && p2<v2.size())\\n        {\\n        // equal? look after until not equal, pick larger one next non equal one\\n       //nums1: {6, 7}\\n      // nums2: {6, 0, 4} : mistake: naive pick larger one won\\'t work!!\\n       // look after until not equal            \\n            if (v1[p1]==v2[p2])\\n            {\\n                int p1n=p1+1, p2n=p2+1;\\n                while (p1n<v1.size() && p2n<v2.size() && v1[p1n]==v2[p2n])\\n                {\\n                    p1n++; p2n++; \\n                }\\n                // several conditions:  p1n reach the end\\n                // either one reach the end, pick any of they, No! pick the one with remains!!\\n                if (p1n==v1.size() ) \\n                {\\n                    res.push_back(v2[p2++]);    \\n                }\\n                else if  ( p2n==v2.size())\\n                    res.push_back(v1[p1++]);    \\n                else if (v1[p1n]>v2[p2n]) // first non equal element\\n                    res.push_back(v1[p1++]);    \\n                else\\n                    res.push_back(v2[p2++]);                        \\n            }\\n            else if (v1[p1]>v2[p2])\\n                res.push_back(v1[p1++]);\\n            else\\n                res.push_back(v2[p2++]);\\n        }\\n        \\n        while (p1<v1.size())\\n            res.push_back(v1[p1++]);\\n        \\n        while (p2<v2.size())\\n            res.push_back(v2[p2++]);    \\n        \\n        assert (res.size()== v1.size()+v2.size());\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {       \\n      \\n          vector<int> max_res (k, 0); //min value     \\n        for (int l1=0; l1<= nums1.size(); l1++) //select 0 to max from nums1\\n        {     \\n            if (k-l1<0 ) break;    // l1 too large, we stop       \\n            if (k-l1> nums2.size()) continue;  // l1 too small, we continue\\t\\t\\t\\n            vector<int> m1= maxNumber (nums1, l1); \\n            vector<int> m2= maxNumber (nums2, k-l1);            \\n            vector<int> merge1= combine (m1, m2);          \\n\\n           if (merge1>max_res)\\n                max_res= merge1;                        \\n        }          \\n        return max_res; \\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    \\n \\n    // 54321  // find first bottom item:  3   \\n    // nums2 = [9, 1, 2, 5, 8, 3], k=3, remain 3    \\n    vector<int> maxNumber (vector<int>& nums1, int k)\\n    {\\n        int sz= nums1.size(), remove = sz-k;\\n        vector<int> res ;\\n        // best code structure: for + while\\n        // goal: generate an all decreasing sequence: remove bottom  < next\\n        for (int i=0; i< nums1.size(); i++)\\n        {\\n            // when to pop the stack:  back< current\\n            while (res.size()>0 && res.back()< nums1[i] && remove)\\n            {\\n                res.pop_back(); remove--;             \\n            }                              \\n              res.push_back(nums1[i]);                    \\n        }                \\n\\n        // finished : res may be too many, we only need k element        \\n        // the case of all decreasing, just remove from back\\n        while (remove)\\n        {\\n            res.pop_back(); remove--; \\n        }        \\n        \\n        return res; \\n    }\\n    \\n    // merge linked list problem: but tricker to handle equal case\\n    // max len 2 : 6,5 \\n   //  max len 3 : 9 8 3\\n    vector<int> combine (vector<int>& v1, vector<int>& v2)\\n    {\\n        vector<int> res; \\n        int p1=0, p2=0;\\n        \\n        while (p1<v1.size() && p2<v2.size())\\n        {\\n        // equal? look after until not equal, pick larger one next non equal one\\n       //nums1: {6, 7}\\n      // nums2: {6, 0, 4} : mistake: naive pick larger one won\\'t work!!\\n       // look after until not equal            \\n            if (v1[p1]==v2[p2])\\n            {\\n                int p1n=p1+1, p2n=p2+1;\\n                while (p1n<v1.size() && p2n<v2.size() && v1[p1n]==v2[p2n])\\n                {\\n                    p1n++; p2n++; \\n                }\\n                // several conditions:  p1n reach the end\\n                // either one reach the end, pick any of they, No! pick the one with remains!!\\n                if (p1n==v1.size() ) \\n                {\\n                    res.push_back(v2[p2++]);    \\n                }\\n                else if  ( p2n==v2.size())\\n                    res.push_back(v1[p1++]);    \\n                else if (v1[p1n]>v2[p2n]) // first non equal element\\n                    res.push_back(v1[p1++]);    \\n                else\\n                    res.push_back(v2[p2++]);                        \\n            }\\n            else if (v1[p1]>v2[p2])\\n                res.push_back(v1[p1++]);\\n            else\\n                res.push_back(v2[p2++]);\\n        }\\n        \\n        while (p1<v1.size())\\n            res.push_back(v1[p1++]);\\n        \\n        while (p2<v2.size())\\n            res.push_back(v2[p2++]);    \\n        \\n        assert (res.size()== v1.size()+v2.size());\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {       \\n      \\n          vector<int> max_res (k, 0); //min value     \\n        for (int l1=0; l1<= nums1.size(); l1++) //select 0 to max from nums1\\n        {     \\n            if (k-l1<0 ) break;    // l1 too large, we stop       \\n            if (k-l1> nums2.size()) continue;  // l1 too small, we continue\\t\\t\\t\\n            vector<int> m1= maxNumber (nums1, l1); \\n            vector<int> m2= maxNumber (nums2, k-l1);            \\n            vector<int> merge1= combine (m1, m2);          \\n\\n           if (merge1>max_res)\\n                max_res= merge1;                        \\n        }          \\n        return max_res; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749965,
                "title": "c-faster-than-75-less-then-100-mem",
                "content": "Runtime: 316 ms\\nMemory Usage: 32.1 MB\\n\\nWhat helped me was thinking in therms of elements that needed to be removed.\\nSay you have 4 elements to remove to get to a total size of k.\\nYou can remove 0 from nums1 and 4 to nums2 or 1-3, 2-2, 3-1 or 4-0.\\nThen at each stage just merge the trimmed arrays taking care of the equal case (see code). Compare the resulting arrays to find the biggest number.\\n\\n```\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) \\n    {\\n        nums1 = Trim(nums1, k);\\n        nums2 = Trim(nums2, k);        \\n        \\n        int dif = (nums1.Length + nums2.Length) - k;\\n\\n        if (dif == 0)\\n        {\\n            return Merge(nums1, nums2, k);\\n        }\\n       \\n        int[] new1;\\n        int[] new2;\\n        int[] crnt;\\n        int[] biggest = null;\\n\\n        for (int i = dif, j = 0; i >= 0; i--, j++)\\n        {\\n            if (nums1.Length < i || nums2.Length < j) { continue; }\\n\\n            new1 = Trim(nums1, nums1.Length - i);\\n            new2 = Trim(nums2, nums2.Length - j);\\n\\n            crnt = Merge(new1, new2, k);\\n\\n            if (biggest == null) \\n            { \\n                biggest = crnt; \\n            }\\n            else\\n            {\\n                for (int s = 0; s < k; s++)\\n                {\\n                    if (biggest[s] < crnt[s]) { biggest = crnt; break; }\\n                    else if (biggest[s] > crnt[s]) { break; }\\n                }\\n            }\\n        }\\n\\n        return biggest;\\n    }\\n    \\n    private int[] Merge(int[] nums1, int[] nums2, int k)\\n    {\\n        int[] result = new int[k];\\n\\n        int i = 0;\\n        int j = 0;\\n        int p = 0;\\n\\n        int h;\\n        int g;\\n\\n        while (i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] > nums2[j])\\n            {\\n                result[p++] = nums1[i++];\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                result[p++] = nums2[j++];\\n            }\\n            else\\n            {\\n                //find next non equal pair.\\n                h = i + 1;\\n                g = j + 1;\\n                while (h < nums1.Length && g < nums2.Length && nums1[h] == nums2[g])\\n                {\\n                    h++; g++;\\n                }\\n\\n                if (h == nums1.Length) { result[p++] = nums2[j++]; }\\n                else if (g == nums2.Length) { result[p++] = nums1[i++]; }\\n                else if (nums1[h] > nums2[g]) { result[p++] = nums1[i++]; }\\n                else { result[p++] = nums2[j++]; }\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            result[p++] = nums1[i++];\\n        }\\n\\n        while (j < nums2.Length)\\n        {\\n            result[p++] = nums2[j++];\\n        }\\n\\n        return result;\\n    }\\n         \\n    private int[] Trim(int[] nums, int k)\\n    {\\n        if (nums.Length <= k) { return nums; }\\n        \\n        int rem = nums.Length-k;\\n       \\n        Stack<int> stack = new Stack<int>();\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (stack.Count == 0 || rem == 0) { stack.Push(nums[i]); }\\n            else\\n            {\\n                while(stack.Count > 0 && stack.Peek() < nums[i] && rem > 0)\\n                {\\n                    stack.Pop();\\n                    rem--;\\n                }\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        while (rem > 0) {  stack.Pop(); rem--;  }\\n        \\n        int[] result = new int[k];\\n        int j = k-1;\\n        while(stack.Count > 0)\\n        {\\n            result[j] = stack.Pop();\\n            j--;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 316 ms\\nMemory Usage: 32.1 MB\\n\\nWhat helped me was thinking in therms of elements that needed to be removed.\\nSay you have 4 elements to remove to get to a total size of k.\\nYou can remove 0 from nums1 and 4 to nums2 or 1-3, 2-2, 3-1 or 4-0.\\nThen at each stage just merge the trimmed arrays taking care of the equal case (see code). Compare the resulting arrays to find the biggest number.\\n\\n```\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) \\n    {\\n        nums1 = Trim(nums1, k);\\n        nums2 = Trim(nums2, k);        \\n        \\n        int dif = (nums1.Length + nums2.Length) - k;\\n\\n        if (dif == 0)\\n        {\\n            return Merge(nums1, nums2, k);\\n        }\\n       \\n        int[] new1;\\n        int[] new2;\\n        int[] crnt;\\n        int[] biggest = null;\\n\\n        for (int i = dif, j = 0; i >= 0; i--, j++)\\n        {\\n            if (nums1.Length < i || nums2.Length < j) { continue; }\\n\\n            new1 = Trim(nums1, nums1.Length - i);\\n            new2 = Trim(nums2, nums2.Length - j);\\n\\n            crnt = Merge(new1, new2, k);\\n\\n            if (biggest == null) \\n            { \\n                biggest = crnt; \\n            }\\n            else\\n            {\\n                for (int s = 0; s < k; s++)\\n                {\\n                    if (biggest[s] < crnt[s]) { biggest = crnt; break; }\\n                    else if (biggest[s] > crnt[s]) { break; }\\n                }\\n            }\\n        }\\n\\n        return biggest;\\n    }\\n    \\n    private int[] Merge(int[] nums1, int[] nums2, int k)\\n    {\\n        int[] result = new int[k];\\n\\n        int i = 0;\\n        int j = 0;\\n        int p = 0;\\n\\n        int h;\\n        int g;\\n\\n        while (i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] > nums2[j])\\n            {\\n                result[p++] = nums1[i++];\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                result[p++] = nums2[j++];\\n            }\\n            else\\n            {\\n                //find next non equal pair.\\n                h = i + 1;\\n                g = j + 1;\\n                while (h < nums1.Length && g < nums2.Length && nums1[h] == nums2[g])\\n                {\\n                    h++; g++;\\n                }\\n\\n                if (h == nums1.Length) { result[p++] = nums2[j++]; }\\n                else if (g == nums2.Length) { result[p++] = nums1[i++]; }\\n                else if (nums1[h] > nums2[g]) { result[p++] = nums1[i++]; }\\n                else { result[p++] = nums2[j++]; }\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            result[p++] = nums1[i++];\\n        }\\n\\n        while (j < nums2.Length)\\n        {\\n            result[p++] = nums2[j++];\\n        }\\n\\n        return result;\\n    }\\n         \\n    private int[] Trim(int[] nums, int k)\\n    {\\n        if (nums.Length <= k) { return nums; }\\n        \\n        int rem = nums.Length-k;\\n       \\n        Stack<int> stack = new Stack<int>();\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (stack.Count == 0 || rem == 0) { stack.Push(nums[i]); }\\n            else\\n            {\\n                while(stack.Count > 0 && stack.Peek() < nums[i] && rem > 0)\\n                {\\n                    stack.Pop();\\n                    rem--;\\n                }\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        while (rem > 0) {  stack.Pop(); rem--;  }\\n        \\n        int[] result = new int[k];\\n        int j = k-1;\\n        while(stack.Count > 0)\\n        {\\n            result[j] = stack.Pop();\\n            j--;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77290,
                "title": "my-easy-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>greatest(vector<int>nums, int k)\\n    {\\n        int leave=nums.size()-k;\\n        vector<int>great;\\n        for(auto i : nums)\\n        {\\n           while(leave && great.size() && great.back()<i)\\n           {\\n              great.pop_back();\\n               leave--;\\n           }\\n           great.push_back(i); \\n        }\\n        great.resize(k);\\n        return great;\\n    }\\n    bool check(vector<int>nums1, int i, vector<int>nums2, int j)\\n    {\\n        while(i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        if(j==nums2.size()) return true;\\n        if(i<nums1.size() && nums1[i]>nums2[j]) return true;\\n        return false;\\n    }\\n    // merge the 2 big numbers we have got in 2 vectors into 1 big possible number of size k \\n    vector<int> merge(vector<int>nums1 , vector<int>nums2,int k)\\n    {\\n        int i=0,j=0;\\n        vector<int>great(k,0);\\n        for(int l=0;l<k;l++)\\n        {\\n            great[l]=check(nums1,i,nums2,j)?nums1[i++]:nums2[j++];\\n        }\\n        return great;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n=nums1.size();\\n        m=nums2.size();\\n        vector<int>res;\\n        for(int i=max(0,k-m);i<=min(k,n);i++)\\n        {\\n            //v1 = greatest possible number stored in vector of length i\\n            //v2 = greatest possible number stored in vector of length k-i;\\n            auto v1 =greatest(nums1,i);\\n            auto v2=greatest(nums2,k-i);\\n            auto candidate=merge(v1,v2,k);\\n            if(check(candidate,0,res,0))\\n                res=candidate;\\n        }\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>greatest(vector<int>nums, int k)\\n    {\\n        int leave=nums.size()-k;\\n        vector<int>great;\\n        for(auto i : nums)\\n        {\\n           while(leave && great.size() && great.back()<i)\\n           {\\n              great.pop_back();\\n               leave--;\\n           }\\n           great.push_back(i); \\n        }\\n        great.resize(k);\\n        return great;\\n    }\\n    bool check(vector<int>nums1, int i, vector<int>nums2, int j)\\n    {\\n        while(i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        if(j==nums2.size()) return true;\\n        if(i<nums1.size() && nums1[i]>nums2[j]) return true;\\n        return false;\\n    }\\n    // merge the 2 big numbers we have got in 2 vectors into 1 big possible number of size k \\n    vector<int> merge(vector<int>nums1 , vector<int>nums2,int k)\\n    {\\n        int i=0,j=0;\\n        vector<int>great(k,0);\\n        for(int l=0;l<k;l++)\\n        {\\n            great[l]=check(nums1,i,nums2,j)?nums1[i++]:nums2[j++];\\n        }\\n        return great;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n=nums1.size();\\n        m=nums2.size();\\n        vector<int>res;\\n        for(int i=max(0,k-m);i<=min(k,n);i++)\\n        {\\n            //v1 = greatest possible number stored in vector of length i\\n            //v2 = greatest possible number stored in vector of length k-i;\\n            auto v1 =greatest(nums1,i);\\n            auto v2=greatest(nums2,k-i);\\n            auto candidate=merge(v1,v2,k);\\n            if(check(candidate,0,res,0))\\n                res=candidate;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77297,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Create Maximum Number** https://leetcode.com/problems/create-maximum-number/\\n\\n**Dynamic Programming/Recursive Solution**\\n* Sketch the recursion and throw in a cache. The complexity will be O(i * j * k). \\n* The recursion is interesting in terms of the number of cases. When you have i,j, you need to think in how many different ways you can advance i and j with and without choosing nums1[i] and nums2[j]. Refer to the code, especially:\\n```\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n```\\n\\n```\\nclass Solution(object):\\n    def max_number(self, i, j, k, nums1, nums2, so_far):\\n        if len(so_far) == k:\\n            int_number = int(\"\".join(map(str, so_far)))\\n            if int_number > self.maximum_number:\\n                self.maximum_number = int_number\\n                self.max_list = [x for x in so_far]\\n        elif 0<=i<len(nums1) and 0<=j<len(nums2):\\n            if nums1[i] > nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] < nums2[j]:\\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] == nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()                \\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            # Ignore nums[i]    \\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            # ignore nums[i]\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            # Ignore both\\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n        elif i == len(nums1) and 0<=j<len(nums2):\\n            so_far.append(nums2[j])\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n        elif j == len(nums2) and 0<=i<len(nums1):\\n            so_far.append(nums1[i])\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n        return\\n    \\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.maximum_number, self.max_list = -2**31, None\\n        self.max_number(0, 0, k, nums1, nums2, [])\\n        return self.max_list\\n```\\n\\n**Optimized Solution using Stacks**\\n* There is a smarter solution to this problem which is a combination of 2 smaller problems. \\n* The solution to this problem will comprise of k digits, i from nums1 and k-i from nums2. \\n* Assume i were 2, then what would be the best candidate? Clearly, the answer is \"maximum number of size 2 from nums1 while keeping the relative order of the digits\". \\n* So lets call that problem as P0: \"Given an array nums and an integer n, return the maximum number of size n that can be formed from nums while keeping the relative order of digits\". Now for i=2, we will have 2 lists from nums1 and nums2 of size i and K-1. \\n* We can merge them to compute a candidate solution of size k. This will be problem P1\\n* What can be all the possible candidate solutions? Clearly when i will range from 0 to K for nums1 we will have a corresponding pair from nums2 ranging in size K to 0. Merging each of these pairs will give us the K+1 candidates. We then choose the largest from this pool and we are done!\\nhttps://discuss.leetcode.com/topic/32281/share-my-python-solution-with-explanation\\n\\nP1: Merge 2 arrays with size i and K-1 formed from nums1 and nums2 to return the maximum possible number array of size K.\\n* This is just like merge-sort merging, except when the elements are same. In that case we need to look beyond the current element (skipping all equal elements) to find the first unequal element and then pick the one which has the higher unequal element. Notice that when nums1[i] (or nums2[j]) is the last element and the value is equal to nums2[j] (or nums1[i]), we always pick the from the sublist which has elements remaining since there is a possibility of finding a greater solution.\\n```\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n```\\n* Notice that in Python we can compare 2 lists l1 > l2 (merge_solution function) which does the above.\\n```\\n if nums1 > nums2:\\n                ans += nums1[0],\\n```\\n\\nP0: Given an array nums and an integer n, return the maximum number of size n that can be formed from nums while keeping the relative order of digits.\\n\\n**Method 1**\\n* We can maintain a stack. As long as we get input in descending order, just keep pushing on the stack. if you get a number larger than top of stack, then pop till you find a smaller number.While doing this, make sure you do not pop so much that you cannot meet the constraint of K digits. Refer to the code in max_number_list.\\n\\n**Method 2**\\n* Say the size of array is N = 10. Say K = 6. What is the maximum number that can be formed of size N = 10? Answer is the original array. What about K = 6?\\n* This problem can be stated as: \"Remove k1 (4) digits from the array to form the largest number\". This is the opposite of https://leetcode.com/problems/remove-k-digits/ where we remove K digits to form the smallest number\\n* The solution to the smallest number problem was to scan from left to right and remove the first peak element and then the next peak from the solution of previous.\\n* The solution to this problem is opposite - remove the first trough element, i.e. element which is smaller than both its left and right side!\\n\\n```\\nclass Solution(object):\\n    def max_number_list(self, nums, n):\\n        st, required_to_remove = [], len(nums)-n\\n        for idx, x in enumerate(nums):\\n            while required_to_remove and st and st[-1] < x:\\n                st.pop()\\n                required_to_remove = required_to_remove - 1\\n            st.append(x)\\n        while len(st) > n:\\n            st.pop()\\n        return st\\n    \\n    def merge(self, left, right):\\n        i, j = 0, 0\\n        N, M = len(left), len(right)\\n        result = []\\n        while i < N or j < M:\\n            if i == N:\\n                result.append(right[j])\\n                j += 1\\n            elif j == M:\\n                result.append(left[i])\\n                i += 1\\n            elif left[i] < right[j]:\\n                result.append(right[j])\\n                j += 1\\n            elif left[i] > right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n        return result\\n\\n    def merge_solution(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.max_list = [0]*k\\n        for i in range(k+1):\\n            if i <= N and k-i <= M:\\n                left, right = self.max_number_list(nums1, i), self.max_number_list(nums2, k-i)\\n                merged = self.merge(left, right)\\n                for i in range(k):\\n                    if self.max_list[i] != merged[i]:\\n                        if self.max_list[i] > merged[i]:\\n                            break\\n                        elif merged[i] > self.max_list[i]:\\n                            self.max_list = merged\\n                            break\\n        return self.max_list\\n```",
                "solutionTags": [],
                "code": "```\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j, k, nums1, nums2, so_far)            \\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n```\n```\\nclass Solution(object):\\n    def max_number(self, i, j, k, nums1, nums2, so_far):\\n        if len(so_far) == k:\\n            int_number = int(\"\".join(map(str, so_far)))\\n            if int_number > self.maximum_number:\\n                self.maximum_number = int_number\\n                self.max_list = [x for x in so_far]\\n        elif 0<=i<len(nums1) and 0<=j<len(nums2):\\n            if nums1[i] > nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] < nums2[j]:\\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            elif nums1[i] == nums2[j]:\\n                so_far.append(nums1[i])\\n                self.max_number(i+1, j, k, nums1, nums2, so_far)\\n                so_far.pop()                \\n                so_far.append(nums2[j])\\n                self.max_number(i, j+1, k, nums1, nums2, so_far)\\n                so_far.pop()\\n            # Ignore nums[i]    \\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            # ignore nums[i]\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            # Ignore both\\n            self.max_number(i+1, j+1, k, nums1, nums2, so_far)\\n        elif i == len(nums1) and 0<=j<len(nums2):\\n            so_far.append(nums2[j])\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i, j+1, k, nums1, nums2, so_far)\\n        elif j == len(nums2) and 0<=i<len(nums1):\\n            so_far.append(nums1[i])\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n            so_far.pop()\\n            self.max_number(i+1, j, k, nums1, nums2, so_far)\\n        return\\n    \\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.maximum_number, self.max_list = -2**31, None\\n        self.max_number(0, 0, k, nums1, nums2, [])\\n        return self.max_list\\n```\n```\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n```\n```\\n if nums1 > nums2:\\n                ans += nums1[0],\\n```\n```\\nclass Solution(object):\\n    def max_number_list(self, nums, n):\\n        st, required_to_remove = [], len(nums)-n\\n        for idx, x in enumerate(nums):\\n            while required_to_remove and st and st[-1] < x:\\n                st.pop()\\n                required_to_remove = required_to_remove - 1\\n            st.append(x)\\n        while len(st) > n:\\n            st.pop()\\n        return st\\n    \\n    def merge(self, left, right):\\n        i, j = 0, 0\\n        N, M = len(left), len(right)\\n        result = []\\n        while i < N or j < M:\\n            if i == N:\\n                result.append(right[j])\\n                j += 1\\n            elif j == M:\\n                result.append(left[i])\\n                i += 1\\n            elif left[i] < right[j]:\\n                result.append(right[j])\\n                j += 1\\n            elif left[i] > right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                x,y = i, j\\n                while x < N and y < M and left[x] == right[y]:\\n                    x,y = x+1, y+1\\n                if x != N and y != M and left[x] > right[y]:\\n                    result.append(left[i])\\n                    i += 1\\n                elif x != N and y != M and left[x] < right[y]:\\n                    result.append(right[j])\\n                    j += 1\\n                elif x == N:\\n                    result.append(right[j])\\n                    j += 1\\n                elif y == M:\\n                    result.append(left[i])\\n                    i += 1\\n        return result\\n\\n    def merge_solution(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        N, M = len(nums1), len(nums2)\\n        self.max_list = [0]*k\\n        for i in range(k+1):\\n            if i <= N and k-i <= M:\\n                left, right = self.max_number_list(nums1, i), self.max_number_list(nums2, k-i)\\n                merged = self.merge(left, right)\\n                for i in range(k):\\n                    if self.max_list[i] != merged[i]:\\n                        if self.max_list[i] > merged[i]:\\n                            break\\n                        elif merged[i] > self.max_list[i]:\\n                            self.max_list = merged\\n                            break\\n        return self.max_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77312,
                "title": "java-solution-with-comments-inspired-by-dietpepsi",
                "content": "It's almost the same with the solution by @dietpepsi. I changed some code and added comments to make it easier to understand.\\n\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k];\\n        for (int i = 0; i <= k; i++) {\\n            if (nums1.length >= i && nums2.length >= k-i) {\\n                int[] merged = maxMerge(maxNumberSingleArray(nums1, i), maxNumberSingleArray(nums2, k-i));\\n                if (isGreater(merged, 0, maxNum, 0)) {\\n                    maxNum = merged;\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n    \\n    // compute max number of a single array, given available numbers 'nums[]'' and length 'len'\\n    // assume len <= nums.length\\n    private int[] maxNumberSingleArray(int[] nums, int len) {\\n        int[] result = new int[len];\\n        int filledDigits = 0;   // number of digits already filled\\n        for (int i = 0; i < nums.length; i++) {\\n            int j = filledDigits; // default position for current digit = index of last filled digit\\n            while (j > 0 && result[j-1] < nums[i] && nums.length-i >= len-(j-1)) {\\n                // want to place larger numbers to as high digit as possible\\n                j--;\\n            }\\n            if (j < len) {\\n                result[j] = nums[i];\\n                filledDigits = j+1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // merge two number arrays to create a maximum number array\\n    // want to use digits from the array with the higher lexicographical order\\n    private int[] maxMerge(int[] arr1, int[] arr2) {\\n        int len = arr1.length + arr2.length;\\n        int[] result = new int[len];\\n        int i = 0, j = 0, k = 0;\\n        while (k < len) {\\n            result[k++] = isGreater(arr1, i, arr2, j) ? arr1[i++] : arr2[j++];\\n        }\\n        return result;\\n    }\\n    \\n    // compare which array contains a larger number, returns < 0 if arr1 < arr2, == 0 if equal, > 0 if arr1 > arr2\\n    private boolean isGreater(int[] arr1, int i, int[] arr2, int j) {\\n        while (i < arr1.length && j < arr2.length && arr1[i] == arr2[j]) {\\n            i++;\\n            j++;\\n        }\\n        // arr1 is lexicographically greater if it has a longer length, or  has a digit greater than the digit as same place in arr2\\n        return i < arr1.length && j == arr2.length || (i < arr1.length && j < arr2.length && arr1[i] > arr2[j]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k];\\n        for (int i = 0; i <= k; i++) {\\n            if (nums1.length >= i && nums2.length >= k-i) {\\n                int[] merged = maxMerge(maxNumberSingleArray(nums1, i), maxNumberSingleArray(nums2, k-i));\\n                if (isGreater(merged, 0, maxNum, 0)) {\\n                    maxNum = merged;\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n    \\n    // compute max number of a single array, given available numbers 'nums[]'' and length 'len'\\n    // assume len <= nums.length\\n    private int[] maxNumberSingleArray(int[] nums, int len) {\\n        int[] result = new int[len];\\n        int filledDigits = 0;   // number of digits already filled\\n        for (int i = 0; i < nums.length; i++) {\\n            int j = filledDigits; // default position for current digit = index of last filled digit\\n            while (j > 0 && result[j-1] < nums[i] && nums.length-i >= len-(j-1)) {\\n                // want to place larger numbers to as high digit as possible\\n                j--;\\n            }\\n            if (j < len) {\\n                result[j] = nums[i];\\n                filledDigits = j+1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // merge two number arrays to create a maximum number array\\n    // want to use digits from the array with the higher lexicographical order\\n    private int[] maxMerge(int[] arr1, int[] arr2) {\\n        int len = arr1.length + arr2.length;\\n        int[] result = new int[len];\\n        int i = 0, j = 0, k = 0;\\n        while (k < len) {\\n            result[k++] = isGreater(arr1, i, arr2, j) ? arr1[i++] : arr2[j++];\\n        }\\n        return result;\\n    }\\n    \\n    // compare which array contains a larger number, returns < 0 if arr1 < arr2, == 0 if equal, > 0 if arr1 > arr2\\n    private boolean isGreater(int[] arr1, int i, int[] arr2, int j) {\\n        while (i < arr1.length && j < arr2.length && arr1[i] == arr2[j]) {\\n            i++;\\n            j++;\\n        }\\n        // arr1 is lexicographically greater if it has a longer length, or  has a digit greater than the digit as same place in arr2\\n        return i < arr1.length && j == arr2.length || (i < arr1.length && j < arr2.length && arr1[i] > arr2[j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77319,
                "title": "beats-100-00-of-python-submissions-surprisingly",
                "content": "It's a tough way to solve this problem.\\n\\nMy solution is trying to construct the answer.\\n\\n1. At first, using dp[i][j][k] as a set to record the state, which means the k-length result from arr1[i:] and arr[j:]. But got TLE.\\n2. After that, trying to pre-process loc[i][x] to locate the digit x in arr[i:]. But still TLE.\\n3. Finally, handling the case when l1+l2 == k. Got AC.\\n\\nI think the complexity maybe O((m+n+k)*10), since the number of answer is k*10.\\n\\nHere is my code. 128ms in py.\\n\\n    ### 321. Create Maximum Number ###\\n    # @param {integer[]} nums1\\n    # @param {integer[]} nums2\\n    # @param {integer} k\\n    # @return {integer[]}\\n    def maxNumber(self, nums1, nums2, k):\\n        if not k or len(nums1)+len(nums2)<k: return []\\n    \\n        loc1 = [[-1]*10 for _ in range(len(nums1)+1)]\\n        loc2 = [[-1]*10 for _ in range(len(nums2)+1)]\\n        l12 = len(nums1)+len(nums2)\\n        vis, res = set(), [-1]*k\\n    \\n        def make(nums, loc):\\n            pos = [-1]*10\\n            for i in xrange(len(nums)-1,-1,-1):\\n                pos[nums[i]] = i\\n                for j in range(10):\\n                    loc[i][j] = pos[j]\\n    \\n        make(nums1, loc1)\\n        make(nums2, loc2)\\n    \\n        def compare(p1, p2):\\n            if p2 == len(nums2): return 1\\n            if p1 == len(nums1): return 2\\n            if nums1[p1] > nums2[p2]: return 1\\n            if nums1[p1] < nums2[p2]: return 2\\n            return compare(p1+1, p2+1)\\n    \\n        def dfs(p1, p2, k):\\n            if k == 0 or (p1, p2, k) in vis: return\\n    \\n            if l12 == p1+p2+k:\\n                flag, update = True, False\\n                while flag and k>0:\\n                    if compare(p1, p2) == 1:\\n                        if res[-k] <= nums1[p1] or update:\\n                            if res[-k] < nums1[p1]: update = True\\n                            res[-k] = nums1[p1]\\n                            p1 += 1\\n                        else: flag = False\\n                    else:\\n                        if res[-k] <= nums2[p2] or update:\\n                            if res[-k] < nums2[p2]: update = True\\n                            res[-k] = nums2[p2]\\n                            p2 += 1\\n                        else: flag = False\\n                    k -= 1\\n            else:\\n                flag = False\\n                for i in range(9,-1,-1):\\n                    if loc1[p1][i] != -1:\\n                        if l12-loc1[p1][i]-p2 >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(loc1[p1][i]+1, p2, k-1)\\n                            flag = True\\n                    if loc2[p2][i] != -1:\\n                        if l12-p1-loc2[p2][i] >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(p1, loc2[p2][i]+1, k-1)\\n                            flag = True\\n                    if flag: break\\n            vis.add((p1, p2, k))\\n    \\n        dfs(0, 0, k)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's a tough way to solve this problem.\\n\\nMy solution is trying to construct the answer.\\n\\n1. At first, using dp[i][j][k] as a set to record the state, which means the k-length result from arr1[i:] and arr[j:]. But got TLE.\\n2. After that, trying to pre-process loc[i][x] to locate the digit x in arr[i:]. But still TLE.\\n3. Finally, handling the case when l1+l2 == k. Got AC.\\n\\nI think the complexity maybe O((m+n+k)*10), since the number of answer is k*10.\\n\\nHere is my code. 128ms in py.\\n\\n    ### 321. Create Maximum Number ###\\n    # @param {integer[]} nums1\\n    # @param {integer[]} nums2\\n    # @param {integer} k\\n    # @return {integer[]}\\n    def maxNumber(self, nums1, nums2, k):\\n        if not k or len(nums1)+len(nums2)<k: return []\\n    \\n        loc1 = [[-1]*10 for _ in range(len(nums1)+1)]\\n        loc2 = [[-1]*10 for _ in range(len(nums2)+1)]\\n        l12 = len(nums1)+len(nums2)\\n        vis, res = set(), [-1]*k\\n    \\n        def make(nums, loc):\\n            pos = [-1]*10\\n            for i in xrange(len(nums)-1,-1,-1):\\n                pos[nums[i]] = i\\n                for j in range(10):\\n                    loc[i][j] = pos[j]\\n    \\n        make(nums1, loc1)\\n        make(nums2, loc2)\\n    \\n        def compare(p1, p2):\\n            if p2 == len(nums2): return 1\\n            if p1 == len(nums1): return 2\\n            if nums1[p1] > nums2[p2]: return 1\\n            if nums1[p1] < nums2[p2]: return 2\\n            return compare(p1+1, p2+1)\\n    \\n        def dfs(p1, p2, k):\\n            if k == 0 or (p1, p2, k) in vis: return\\n    \\n            if l12 == p1+p2+k:\\n                flag, update = True, False\\n                while flag and k>0:\\n                    if compare(p1, p2) == 1:\\n                        if res[-k] <= nums1[p1] or update:\\n                            if res[-k] < nums1[p1]: update = True\\n                            res[-k] = nums1[p1]\\n                            p1 += 1\\n                        else: flag = False\\n                    else:\\n                        if res[-k] <= nums2[p2] or update:\\n                            if res[-k] < nums2[p2]: update = True\\n                            res[-k] = nums2[p2]\\n                            p2 += 1\\n                        else: flag = False\\n                    k -= 1\\n            else:\\n                flag = False\\n                for i in range(9,-1,-1):\\n                    if loc1[p1][i] != -1:\\n                        if l12-loc1[p1][i]-p2 >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(loc1[p1][i]+1, p2, k-1)\\n                            flag = True\\n                    if loc2[p2][i] != -1:\\n                        if l12-p1-loc2[p2][i] >= k and res[-k] <= i:\\n                            if res[-k] < i: res[-k:] = [-1]*k\\n                            res[-k] = i\\n                            dfs(p1, loc2[p2][i]+1, k-1)\\n                            flag = True\\n                    if flag: break\\n            vis.add((p1, p2, k))\\n    \\n        dfs(0, 0, k)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 77341,
                "title": "java-17-ms-o-n-m-k-2-or-3-worst-case-merge-with-lazy-computation",
                "content": "I must admit I found this problem the most difficult so far, and I've solved more than 80 already.\\n\\nAt first my idea was very similar to [this solution][1], which I think is the most awesome so far, but I wasn't able to get it right.\\n\\nSo in the end I had to look up solutions, and I usually don't do that. But once I saw the most common type of solutions so far, I was able to use some of my earlier ideas and came up with this:\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, final int k) {\\n        if (k > nums1.length + nums2.length)\\n            throw new IllegalArgumentException(\"k=\" + k + \" n=\" + nums1.length + \" m=\" + nums2.length);\\n        int[][] digitPositions1 = findDigitPositions(nums1);\\n        int[][] digitPositions2 = findDigitPositions(nums2);\\n        Merger best = null;\\n        final int l1start = nums2.length >= k ? 0 : k - nums2.length;\\n        final int l1end = Math.min(k, nums1.length);\\n        // Will now try to get the largest sequences of digits from nums1, nums2 of lengths l1, (k - l1)\\n        // and merge them. The largest merge result will be the answer.\\n        for (int l1 = l1start; l1 <= l1end; ++l1) {\\n            MaxFinder res1 = new MaxFinder(nums1, l1, k, digitPositions1);\\n            MaxFinder res2 = new MaxFinder(nums2, k - l1, k, digitPositions2);\\n            Merger merger = new Merger(res1, res2, k);\\n            if (best == null || merger.compareTo(best) > 0) {\\n                best = merger;\\n            }\\n        }\\n        assert best != null;\\n        return best.toIntArray();\\n    }\\n\\n    private static int[][] findDigitPositions(int[] nums) {\\n        int[][] digitPositions = new int[nums.length][];\\n        int[] pos = new int[10];\\n        Arrays.fill(pos, -1);\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            pos[nums[i]] = i;\\n            digitPositions[i] = Arrays.copyOf(pos, pos.length);\\n        }\\n        return digitPositions;\\n    }\\n    \\n    private static class Merger implements Comparable<Merger> {\\n        private final MaxFinder seq1;\\n        private final MaxFinder seq2;\\n        private final int k; // total length\\n        private final int[] output;\\n        private int outPos = 0, inPos1 = 0, inPos2 = 0;\\n\\n        Merger(MaxFinder seq1, MaxFinder seq2, int k) {\\n            this.seq1 = seq1;\\n            this.seq2 = seq2;\\n            this.k = k;\\n            this.output = new int[k];\\n        }\\n        \\n        int get(int i) {\\n            while (outPos <= i) {\\n                if (seq1.compareTo(seq2) >= 0) {\\n                    output[outPos++] = seq1.get(inPos1++);\\n                } else {\\n                    output[outPos++] = seq2.get(inPos2++);\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(Merger that) {\\n            for (int i = 0; i < k; ++i) {\\n                int v1 = this.get(i), v2 = that.get(i);\\n                if (v1 > v2) {\\n                    return +1;\\n                } else if (v1 < v2) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        int[] toIntArray() {\\n            get(k - 1); // complete generation\\n            return output;\\n        }\\n    }\\n    \\n    private static class MaxFinder implements Comparable<MaxFinder> {\\n        private final int[] input;\\n        private final int k; // total length of two sequences, needed for comparison caching\\n        private final int[][] digitPositions; // computed by findDigitPositions\\n        private final int[] output;\\n        private final int[] lastDiffPos;\\n        private int inPos = 0, outPos = 0;\\n        private int nextIndex = 0;\\n        \\n        MaxFinder(int[] nums, int length, int k, int[][] digitPositions) {\\n            this.input = nums;\\n            this.k = k;\\n            this.digitPositions = digitPositions;\\n            this.output = new int[length];\\n            this.lastDiffPos = new int[2 * k + 1];\\n        }\\n        \\n        int get(int i) {\\n            this.nextIndex = i + 1; // If we need to compare with the other sequence, here is where we should start.\\n            return compute(i);\\n        }\\n        \\n        // helper for get and compareTo\\n        private int compute(int i) {\\n            while (outPos <= i) {\\n                // Look for the next best digit.\\n                for (int d = 9; d >= 0; --d) {\\n                    final int nextDigitPos = digitPositions[inPos][d];\\n                    // The digit must satisfy two conditions:\\n                    // 1. It must be out there somewhere (obviously).\\n                    // 2. There must be enough digits after it, or we may end up running out of digits too soon.\\n                    if (nextDigitPos != -1 && input.length - (nextDigitPos + 1) >= output.length - outPos - 1) {\\n                        output[outPos++] = d;\\n                        inPos = digitPositions[inPos][d] + 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(MaxFinder that) {\\n            final int cacheIndex = k + (this.nextIndex - that.nextIndex);\\n            // We can use the cached position if there is one, but only if we haven't advanced past the last found\\n            // difference position (which is stored in the cache).\\n            if (lastDiffPos[cacheIndex] != 0 && lastDiffPos[cacheIndex] >= this.nextIndex) {\\n                int lastDiffPos1 = lastDiffPos[cacheIndex];\\n                int lastDiffPos2 = lastDiffPos1 + (that.nextIndex - this.nextIndex);\\n                if (lastDiffPos1 < this.output.length && lastDiffPos2 < that.output.length) {\\n                    return Integer.compare(this.output[lastDiffPos1], that.output[lastDiffPos2]);\\n                } else {\\n                    return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n                }\\n            }\\n            // No luck in the cache.\\n            final int end = Math.min(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            int result = 0;\\n            for (int i = 0; i < end; ++i) {\\n                result = this.compute(this.nextIndex + i) - that.compute(that.nextIndex + i);\\n                if (result != 0) {\\n                    lastDiffPos[cacheIndex] = this.nextIndex + i;\\n                    break;\\n                }\\n            }\\n            if (result == 0) {\\n                lastDiffPos[cacheIndex] = this.nextIndex + end;\\n                return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            } else {\\n                return result;\\n            }\\n        }\\n    }\\n\\nThe code is quite verbose, but the ideas are pretty simple:\\n\\n1. Precompute the table of digit positions so we don't have to search for the next best digit (only have to try from 9 to 0).\\n2. Compute everything lazily. We don't know in advance how many digits we need to compare two sequences, so why generate them fully? The same thing for merging.\\n3. Cache comparison results. When we've already compared two sequences, we don't want to compare them again if we advance both positions by the same amount. Although some suffix tables would probably be better (maybe compute them lazily too).\\n\\nThe resulting code runs in 17 ms. The code without improvements 2\\u20133 ran for 26 ms, but then I introduced classes and it was 37 ms (because local variables moved to heap?). So these improvements turned 37 to 17, actually. Moving back to local variables will probably improve a lot, but the code would be a real mess.\\n\\nP. S. I'm not exactly sure: doesn't this comparison caching technique essentially replaces the suffix array and reduces the complexity to O(n + m + k^2). On the 500/500/500 case `MaxFinder::get` is called 575356 times which is of order (500^2) * 2.\\n\\n  [1]: https://leetcode.com/discuss/75655/strictly-o-nk-c-solution-with-detailed-explanation",
                "solutionTags": [
                    "Java"
                ],
                "code": "I must admit I found this problem the most difficult so far, and I've solved more than 80 already.\\n\\nAt first my idea was very similar to [this solution][1], which I think is the most awesome so far, but I wasn't able to get it right.\\n\\nSo in the end I had to look up solutions, and I usually don't do that. But once I saw the most common type of solutions so far, I was able to use some of my earlier ideas and came up with this:\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, final int k) {\\n        if (k > nums1.length + nums2.length)\\n            throw new IllegalArgumentException(\"k=\" + k + \" n=\" + nums1.length + \" m=\" + nums2.length);\\n        int[][] digitPositions1 = findDigitPositions(nums1);\\n        int[][] digitPositions2 = findDigitPositions(nums2);\\n        Merger best = null;\\n        final int l1start = nums2.length >= k ? 0 : k - nums2.length;\\n        final int l1end = Math.min(k, nums1.length);\\n        // Will now try to get the largest sequences of digits from nums1, nums2 of lengths l1, (k - l1)\\n        // and merge them. The largest merge result will be the answer.\\n        for (int l1 = l1start; l1 <= l1end; ++l1) {\\n            MaxFinder res1 = new MaxFinder(nums1, l1, k, digitPositions1);\\n            MaxFinder res2 = new MaxFinder(nums2, k - l1, k, digitPositions2);\\n            Merger merger = new Merger(res1, res2, k);\\n            if (best == null || merger.compareTo(best) > 0) {\\n                best = merger;\\n            }\\n        }\\n        assert best != null;\\n        return best.toIntArray();\\n    }\\n\\n    private static int[][] findDigitPositions(int[] nums) {\\n        int[][] digitPositions = new int[nums.length][];\\n        int[] pos = new int[10];\\n        Arrays.fill(pos, -1);\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            pos[nums[i]] = i;\\n            digitPositions[i] = Arrays.copyOf(pos, pos.length);\\n        }\\n        return digitPositions;\\n    }\\n    \\n    private static class Merger implements Comparable<Merger> {\\n        private final MaxFinder seq1;\\n        private final MaxFinder seq2;\\n        private final int k; // total length\\n        private final int[] output;\\n        private int outPos = 0, inPos1 = 0, inPos2 = 0;\\n\\n        Merger(MaxFinder seq1, MaxFinder seq2, int k) {\\n            this.seq1 = seq1;\\n            this.seq2 = seq2;\\n            this.k = k;\\n            this.output = new int[k];\\n        }\\n        \\n        int get(int i) {\\n            while (outPos <= i) {\\n                if (seq1.compareTo(seq2) >= 0) {\\n                    output[outPos++] = seq1.get(inPos1++);\\n                } else {\\n                    output[outPos++] = seq2.get(inPos2++);\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(Merger that) {\\n            for (int i = 0; i < k; ++i) {\\n                int v1 = this.get(i), v2 = that.get(i);\\n                if (v1 > v2) {\\n                    return +1;\\n                } else if (v1 < v2) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        int[] toIntArray() {\\n            get(k - 1); // complete generation\\n            return output;\\n        }\\n    }\\n    \\n    private static class MaxFinder implements Comparable<MaxFinder> {\\n        private final int[] input;\\n        private final int k; // total length of two sequences, needed for comparison caching\\n        private final int[][] digitPositions; // computed by findDigitPositions\\n        private final int[] output;\\n        private final int[] lastDiffPos;\\n        private int inPos = 0, outPos = 0;\\n        private int nextIndex = 0;\\n        \\n        MaxFinder(int[] nums, int length, int k, int[][] digitPositions) {\\n            this.input = nums;\\n            this.k = k;\\n            this.digitPositions = digitPositions;\\n            this.output = new int[length];\\n            this.lastDiffPos = new int[2 * k + 1];\\n        }\\n        \\n        int get(int i) {\\n            this.nextIndex = i + 1; // If we need to compare with the other sequence, here is where we should start.\\n            return compute(i);\\n        }\\n        \\n        // helper for get and compareTo\\n        private int compute(int i) {\\n            while (outPos <= i) {\\n                // Look for the next best digit.\\n                for (int d = 9; d >= 0; --d) {\\n                    final int nextDigitPos = digitPositions[inPos][d];\\n                    // The digit must satisfy two conditions:\\n                    // 1. It must be out there somewhere (obviously).\\n                    // 2. There must be enough digits after it, or we may end up running out of digits too soon.\\n                    if (nextDigitPos != -1 && input.length - (nextDigitPos + 1) >= output.length - outPos - 1) {\\n                        output[outPos++] = d;\\n                        inPos = digitPositions[inPos][d] + 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            return output[i];\\n        }\\n        \\n        @Override\\n        public int compareTo(MaxFinder that) {\\n            final int cacheIndex = k + (this.nextIndex - that.nextIndex);\\n            // We can use the cached position if there is one, but only if we haven't advanced past the last found\\n            // difference position (which is stored in the cache).\\n            if (lastDiffPos[cacheIndex] != 0 && lastDiffPos[cacheIndex] >= this.nextIndex) {\\n                int lastDiffPos1 = lastDiffPos[cacheIndex];\\n                int lastDiffPos2 = lastDiffPos1 + (that.nextIndex - this.nextIndex);\\n                if (lastDiffPos1 < this.output.length && lastDiffPos2 < that.output.length) {\\n                    return Integer.compare(this.output[lastDiffPos1], that.output[lastDiffPos2]);\\n                } else {\\n                    return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n                }\\n            }\\n            // No luck in the cache.\\n            final int end = Math.min(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            int result = 0;\\n            for (int i = 0; i < end; ++i) {\\n                result = this.compute(this.nextIndex + i) - that.compute(that.nextIndex + i);\\n                if (result != 0) {\\n                    lastDiffPos[cacheIndex] = this.nextIndex + i;\\n                    break;\\n                }\\n            }\\n            if (result == 0) {\\n                lastDiffPos[cacheIndex] = this.nextIndex + end;\\n                return Integer.compare(this.output.length - this.nextIndex, that.output.length - that.nextIndex);\\n            } else {\\n                return result;\\n            }\\n        }\\n    }\\n\\nThe code is quite verbose, but the ideas are pretty simple:\\n\\n1. Precompute the table of digit positions so we don't have to search for the next best digit (only have to try from 9 to 0).\\n2. Compute everything lazily. We don't know in advance how many digits we need to compare two sequences, so why generate them fully? The same thing for merging.\\n3. Cache comparison results. When we've already compared two sequences, we don't want to compare them again if we advance both positions by the same amount. Although some suffix tables would probably be better (maybe compute them lazily too).\\n\\nThe resulting code runs in 17 ms. The code without improvements 2\\u20133 ran for 26 ms, but then I introduced classes and it was 37 ms (because local variables moved to heap?). So these improvements turned 37 to 17, actually. Moving back to local variables will probably improve a lot, but the code would be a real mess.\\n\\nP. S. I'm not exactly sure: doesn't this comparison caching technique essentially replaces the suffix array and reduces the complexity to O(n + m + k^2). On the 500/500/500 case `MaxFinder::get` is called 575356 times which is of order (500^2) * 2.\\n\\n  [1]: https://leetcode.com/discuss/75655/strictly-o-nk-c-solution-with-detailed-explanation",
                "codeTag": "Java"
            },
            {
                "id": 77352,
                "title": "92ms-cpp-try-first-biggest-num-with-index-pre-process",
                "content": "The basic idea is to find the largest number in answer array's first position: try number from 9 to 0, firstly in nums1: if a number can be found, check if the left numbers (minus numbers before the found number) are sufficient for k.\\n\\nIf we can find a largest number in both nums1 and nums2, we should compare the two answers, and keep the bigger one.\\n\\nA fast pre-process for above solution: for i-th element in array nums1, lowPos1[i][num] is the smallest index of num in range [i, nums1.size()-1]. Since we have this helper, we can use O(1) time to find if num exists in nums1 or nums2 from a given position.\\n\\nAn important special case: when nums1.size() + nums2.size() = k, which means we have to use all elements in both arrays to produce the k-length answer. In such case, set two pointers pointing to the beginning of two arrays. Move the pointer with bigger number. Tricky part is when two pointers point to a same value, in this case we detect the values in two arrays behind the two pointers; we move the two pointers together until we find the values are different or one array is ended. The pointer with bigger value should go first, and if one pointer gets to end of array, the other pointer should go first.\\n\\n\\n    class Solution {\\n    public:\\n        unordered_map<string, vector<int>> store;\\n        deque<vector<int>> lowPos1, lowPos2;\\n        int len1, len2;\\n        \\n        vector<int> get(int p1, int p2, int k, vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> ans;\\n            if (k==0)\\n                return ans;\\n            \\n            char buf[50];\\n            sprintf(buf, \"%d.%d.%d\", p1, p2, k);\\n            string key = buf;\\n            if (store.find(key) != store.end())\\n                return store[key];\\n            \\n            int rest = nums1.size()-p1 + nums2.size()-p2;\\n            if (k==rest) {\\n                while (p1<len1 || p2<len2)\\n                {\\n                    if (p1==len1 || (p2<len2 && nums1[p1] < nums2[p2]))\\n                        ans.push_back(nums2[p2++]);\\n                    else if (p2==len2 || (p1<len1 && nums1[p1] > nums2[p2]))\\n                        ans.push_back(nums1[p1++]);\\n                    else {\\n                        int i=0;\\n                        while (p1+i<len1 && p2+i<len2) {\\n                            if (nums1[p1+i] != nums2[p2+i])\\n                                break;\\n                            i++;\\n                        }\\n                        if (p1+i==len1 || (p2+i<len2 && nums2[p2+i]>nums1[p1+i]))\\n                            ans.push_back(nums2[p2++]);\\n                        else\\n                            ans.push_back(nums1[p1++]);\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int i=9; i>=0; i--) \\n                {\\n                    vector<int> ans1, ans2;\\n                    int j = p1==len1 ? -1 : lowPos1[p1][i];\\n                    if (j!=-1 && rest-(j-p1)-1 >= k-1)\\n                    {\\n                        ans1.push_back(i);\\n                        vector<int> temp = get(j+1, p2, k-1, nums1, nums2);\\n                        ans1.insert(ans1.end(), temp.begin(), temp.end());\\n                    }\\n                    \\n                    j = p2==len2 ? -1 : lowPos2[p2][i];\\n                    if (j!=-1 && rest-(j-p2)-1 >= k-1)\\n                    {\\n                        ans2.push_back(i);\\n                        vector<int> temp = get(p1, j+1, k-1, nums1, nums2);\\n                        ans2.insert(ans2.end(), temp.begin(), temp.end());\\n                    }\\n        \\n                    if (ans1.size() + ans2.size())\\n                    {\\n                        if (ans1.size() < ans2.size())\\n                            std::swap(ans1, ans2);\\n                        bool use1=true;\\n                        for (int i=0; i<min(ans1.size(), ans2.size()); i++)\\n                            if (ans2[i] != ans1[i]) {\\n                                use1 = ans1[i]>ans2[i];\\n                                break;\\n                            }\\n                        ans = use1 ? ans1 : ans2;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            store[key] = ans;\\n            return ans;\\n        }\\n        \\n        void preProcess(deque<vector<int>>& lowPos, const vector<int>& nums) {\\n            lowPos.push_back(vector<int> (10, -1));\\n            for (int i=(int)nums.size()-1; i>=0; i--) {\\n                lowPos.push_front(lowPos.front());\\n                lowPos.front()[nums[i]] = i;\\n            }\\n            lowPos.pop_back();\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            len1=nums1.size(), len2=nums2.size();\\n            preProcess(lowPos1, nums1);\\n            preProcess(lowPos2, nums2);\\n            \\n            return get(0, 0, k, nums1, nums2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        unordered_map<string, vector<int>> store;\\n        deque<vector<int>> lowPos1, lowPos2;\\n        int len1, len2;\\n        \\n        vector<int> get(int p1, int p2, int k, vector<int>& nums1, vector<int>& nums2) {\\n            vector<int> ans;\\n            if (k==0)\\n                return ans;\\n            \\n            char buf[50];\\n            sprintf(buf, \"%d.%d.%d\", p1, p2, k);\\n            string key = buf;\\n            if (store.find(key) != store.end())\\n                return store[key];\\n            \\n            int rest = nums1.size()-p1 + nums2.size()-p2;\\n            if (k==rest) {\\n                while (p1<len1 || p2<len2)\\n                {\\n                    if (p1==len1 || (p2<len2 && nums1[p1] < nums2[p2]))\\n                        ans.push_back(nums2[p2++]);\\n                    else if (p2==len2 || (p1<len1 && nums1[p1] > nums2[p2]))\\n                        ans.push_back(nums1[p1++]);\\n                    else {\\n                        int i=0;\\n                        while (p1+i<len1 && p2+i<len2) {\\n                            if (nums1[p1+i] != nums2[p2+i])\\n                                break;\\n                            i++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3592041,
                "title": "easy-understanding-and-readable-code-monotonic-stack-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will find lexographically greatest subsequence from both array and then merge them.\\nBut constraint is length=k must be satisfied. So have to find lexographically greater subsequence such that both combinedly have length k.\\n\\nBut how to decide how much length have to take from first array and how much from second array? --> This time go by bruteforce. So for possible {i, k-i} pair of length , we will find our answer.\\n\\nlet\\'s divide the problem into subparts:\\nsubpart-1: find out lexographically greatest subsequence from both array.\\nsubpart-2: Merge them and keep taking maximum.\\n\\nImplemented stack logic through array. You can go through stack .\\n# Complexity\\n- Time complexity:O(K*N + K*N)= O(K*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(K) => for this loop: for(int i=0;i<=k;i++) in maxNumber function.\\nO(N) => for getGrtrSubseq function.\\nO(K*N) => merge Function.\\n- Space complexity: O(N) as all are linear vectors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```\\n.![download (2).jpg](https://assets.leetcode.com/users/images/8eac6c0a-55fa-4b53-abd4-45a92c342e39_1685777059.4901643.jpeg)\\n\\nCorrect me if i am wrong.\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate maximum number from nums of  requiredLength.\\n    vector<int> getGrtrSubseq(vector<int> nums, int requiredLength)\\n    {\\n        vector<int> ans; // Store the resultant maximum\\n        int n = nums.size();\\n        // i will try to maximize initial digit as much as i can. If falling for shorter length, then i am forced to take last requiredLength-ans.size()\\n        //elements left. So, before popping any element check ((requiredLength-ans.size())<(n-i)) to ensure you have requiredLength of digits.\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size()>0 && ans.back()<nums[i] && ((requiredLength-ans.size())<(n-i))) // If true, then pop out the last element\\n            ans.pop_back();\\n            if(ans.size()<requiredLength)ans.push_back(nums[i]); \\n        }\\n        return ans;\\n    }\\n    void pop_front(std::vector<int> &v)\\n    {\\n        if (v.size() > 0)v.erase(v.begin());\\n    }\\n    vector<int> merge(vector<int> p1, vector<int>p2, int k)\\n    {\\n        vector<int> temp;\\n        for(int j=0;j<k;j++)\\n        { \\n            vector<int> temp2 = max(p1,p2);\\n            int fr = temp2.front();\\n            if(p1>p2)\\n            pop_front(p1);\\n            else\\n            pop_front(p2);\\n            temp.push_back(fr);\\n        }\\n      return temp;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1=nums1.size(), n2=nums2.size();\\n        vector<int>res;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n1 || k-i>n2) continue;\\n            vector<int>grtrSubseq1=getGrtrSubseq(nums1,i);; \\n            vector<int>grtrSubseq2=getGrtrSubseq(nums2,k-i); \\n            vector<int>temp=merge(grtrSubseq1,grtrSubseq2,k);      \\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319525,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    #define MIN(a,b) (a<b?a:b)\\n    #define MAX(a,b) (a>b?a:b)\\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n    {\\n    \\tint n, top = 0;\\n    \\tresult[0] = num[0];\\n    \\tconst int need2drop = len - t;\\n    \\tfor (int i = 1; i < len; ++i){\\n    \\t\\tn = num[i];\\n    \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top;\\n    \\t\\tif (i - top > need2drop){\\n    \\t\\t\\tsortedLen = MAX(1,top);\\n    \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (++top < t) result[top] = n;\\n    \\t\\telse top = t - 1;\\n    \\t}\\n    }\\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n    \\tint  j, *head, *prevhead = res;\\n    \\tconst int soi = sizeof(int);\\n    \\tgetMax(num, len, res, maxL,sortedLen);\\n    \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n    \\t\\thead = prevhead + k;\\n    \\t\\tmemcpy(head, prevhead, l*soi);\\n    \\t\\tfor (j = sortedLen; j < l; ++j){\\n    \\t\\t\\tif (head[j] > head[j - 1]){\\n    \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n    \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (j == l) sortedLen = l;\\n    \\t\\tprevhead = head;\\n    \\t}\\n    }\\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n    \\tint i = 0, j = 0, k = 0;\\n    \\twhile (i < resSize){\\n    \\t\\tif (j < len1 && k < len2){\\n    \\t\\t\\tif (num1[j] > num2[k])\\n    \\t\\t\\t\\tresult[i++] = num1[j++];\\n    \\t\\t\\telse if (num1[j] < num2[k])\\n    \\t\\t\\t\\tresult[i++] = num2[k++];\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n    \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n    \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n    \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n    \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n    \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n    \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse if (j < len1) result[i++] = num1[j++];\\n    \\t\\telse result[i++] = num2[k++];\\n    \\t}\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n    \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n    \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n    \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n    \\tmemset(res, 0, step);\\n    \\tint sortedLen1 = 1, sortedLen2 = 1;\\n    \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 > 0){\\n    \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n    \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n    \\t\\tif (sortedLen1 + sortedLen2 > k){\\n    \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n    \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n    \\t\\t\\tdelete[] res;\\n    \\t\\t\\treturn resv;\\n    \\t\\t}\\n    \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n    \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n    \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n    \\t\\t}\\n    \\t}\\n    \\tvector<int> resv(res, res + k);\\n    \\tdelete[] res;\\n    \\treturn resv;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n            \\n        def get_max_subarray(nums, k):\\n            stack = []\\n            drop = len(nums) - k\\n            for num in nums:\\n                while drop and stack and stack[-1] < num:\\n                    stack.pop()\\n                    drop -= 1\\n                stack.append(num)\\n            return stack[:k]\\n\\n        max_num = []\\n\\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\\n            max_subarray1 = get_max_subarray(nums1, i)\\n            max_subarray2 = get_max_subarray(nums2, k - i)\\n\\n            candidate = []\\n            while max_subarray1 or max_subarray2:\\n                if max_subarray1 > max_subarray2:\\n                    candidate.append(max_subarray1.pop(0))\\n                else:\\n                    candidate.append(max_subarray2.pop(0))\\n\\n            if candidate > max_num:\\n                max_num = candidate\\n\\n        return max_num\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n    int m = nums1.length, n = nums2.length;\\n    int[] ans = new int[k];\\n    \\n    for (int i = Math.max(0, k-n); i <= Math.min(k, m); i++) {\\n        int j = k - i;\\n        int[] maxNum1 = getMax(nums1, i);\\n        int[] maxNum2 = getMax(nums2, j);\\n        int[] merged = merge(maxNum1, maxNum2);\\n        if (compare(merged, 0, ans, 0) > 0) {\\n            ans = merged;\\n        }\\n    }\\n    return ans;\\n}\\nprivate int[] getMax(int[] nums, int k) {\\n    int n = nums.length;\\n    int[] stack = new int[k];\\n    int top = -1, remaining = n - k;\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = nums[i];\\n        while (top >= 0 && stack[top] < num && remaining > 0) {\\n            top--;\\n            remaining--;\\n        }\\n        if (top < k - 1) {\\n            stack[++top] = num;\\n        } else {\\n            remaining--;\\n        }\\n    }\\n    return stack;\\n}\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n    int m = nums1.length, n = nums2.length;\\n    int[] merged = new int[m + n];\\n    int i = 0, j = 0, k = 0;\\n    \\n    while (i < m && j < n) {\\n        if (compare(nums1, i, nums2, j) > 0) {\\n            merged[k++] = nums1[i++];\\n        } else {\\n            merged[k++] = nums2[j++];\\n        }\\n    }\\n    while (i < m) {\\n        merged[k++] = nums1[i++];\\n    }\\n    while (j < n) {\\n        merged[k++] = nums2[j++];\\n    }\\n    return merged;\\n}\\nprivate int compare(int[] nums1, int i, int[] nums2, int j) {\\n    int m = nums1.length, n = nums2.length;\\n    while (i < m && j < n) {\\n        int diff = nums1[i] - nums2[j];\\n        if (diff != 0) {\\n            return diff;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return (m - i) - (n - j);\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    #define MIN(a,b) (a<b?a:b)\\n    #define MAX(a,b) (a>b?a:b)\\n    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n    {\\n    \\tint n, top = 0;\\n    \\tresult[0] = num[0];\\n    \\tconst int need2drop = len - t;\\n    \\tfor (int i = 1; i < len; ++i){\\n    \\t\\tn = num[i];\\n    \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top;\\n    \\t\\tif (i - top > need2drop){\\n    \\t\\t\\tsortedLen = MAX(1,top);\\n    \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (++top < t) result[top] = n;\\n    \\t\\telse top = t - 1;\\n    \\t}\\n    }\\n    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n    \\tint  j, *head, *prevhead = res;\\n    \\tconst int soi = sizeof(int);\\n    \\tgetMax(num, len, res, maxL,sortedLen);\\n    \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n    \\t\\thead = prevhead + k;\\n    \\t\\tmemcpy(head, prevhead, l*soi);\\n    \\t\\tfor (j = sortedLen; j < l; ++j){\\n    \\t\\t\\tif (head[j] > head[j - 1]){\\n    \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n    \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (j == l) sortedLen = l;\\n    \\t\\tprevhead = head;\\n    \\t}\\n    }\\n    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n    \\tint i = 0, j = 0, k = 0;\\n    \\twhile (i < resSize){\\n    \\t\\tif (j < len1 && k < len2){\\n    \\t\\t\\tif (num1[j] > num2[k])\\n    \\t\\t\\t\\tresult[i++] = num1[j++];\\n    \\t\\t\\telse if (num1[j] < num2[k])\\n    \\t\\t\\t\\tresult[i++] = num2[k++];\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n    \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n    \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n    \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n    \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n    \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n    \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse if (j < len1) result[i++] = num1[j++];\\n    \\t\\telse result[i++] = num2[k++];\\n    \\t}\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n    \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n    \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n    \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n    \\tmemset(res, 0, step);\\n    \\tint sortedLen1 = 1, sortedLen2 = 1;\\n    \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n    \\telse if (len1 > 0 && len2 > 0){\\n    \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n    \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n    \\t\\tif (sortedLen1 + sortedLen2 > k){\\n    \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n    \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n    \\t\\t\\tdelete[] res;\\n    \\t\\t\\treturn resv;\\n    \\t\\t}\\n    \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n    \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n    \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n    \\t\\t}\\n    \\t}\\n    \\tvector<int> resv(res, res + k);\\n    \\tdelete[] res;\\n    \\treturn resv;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n            \\n        def get_max_subarray(nums, k):\\n            stack = []\\n            drop = len(nums) - k\\n            for num in nums:\\n                while drop and stack and stack[-1] < num:\\n                    stack.pop()\\n                    drop -= 1\\n                stack.append(num)\\n            return stack[:k]\\n\\n        max_num = []\\n\\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\\n            max_subarray1 = get_max_subarray(nums1, i)\\n            max_subarray2 = get_max_subarray(nums2, k - i)\\n\\n            candidate = []\\n            while max_subarray1 or max_subarray2:\\n                if max_subarray1 > max_subarray2:\\n                    candidate.append(max_subarray1.pop(0))\\n                else:\\n                    candidate.append(max_subarray2.pop(0))\\n\\n            if candidate > max_num:\\n                max_num = candidate\\n\\n        return max_num\\n```\n```Java []\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n    int m = nums1.length, n = nums2.length;\\n    int[] ans = new int[k];\\n    \\n    for (int i = Math.max(0, k-n); i <= Math.min(k, m); i++) {\\n        int j = k - i;\\n        int[] maxNum1 = getMax(nums1, i);\\n        int[] maxNum2 = getMax(nums2, j);\\n        int[] merged = merge(maxNum1, maxNum2);\\n        if (compare(merged, 0, ans, 0) > 0) {\\n            ans = merged;\\n        }\\n    }\\n    return ans;\\n}\\nprivate int[] getMax(int[] nums, int k) {\\n    int n = nums.length;\\n    int[] stack = new int[k];\\n    int top = -1, remaining = n - k;\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = nums[i];\\n        while (top >= 0 && stack[top] < num && remaining > 0) {\\n            top--;\\n            remaining--;\\n        }\\n        if (top < k - 1) {\\n            stack[++top] = num;\\n        } else {\\n            remaining--;\\n        }\\n    }\\n    return stack;\\n}\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n    int m = nums1.length, n = nums2.length;\\n    int[] merged = new int[m + n];\\n    int i = 0, j = 0, k = 0;\\n    \\n    while (i < m && j < n) {\\n        if (compare(nums1, i, nums2, j) > 0) {\\n            merged[k++] = nums1[i++];\\n        } else {\\n            merged[k++] = nums2[j++];\\n        }\\n    }\\n    while (i < m) {\\n        merged[k++] = nums1[i++];\\n    }\\n    while (j < n) {\\n        merged[k++] = nums2[j++];\\n    }\\n    return merged;\\n}\\nprivate int compare(int[] nums1, int i, int[] nums2, int j) {\\n    int m = nums1.length, n = nums2.length;\\n    while (i < m && j < n) {\\n        int diff = nums1[i] - nums2[j];\\n        if (diff != 0) {\\n            return diff;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return (m - i) - (n - j);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948100,
                "title": "c-dynamic-programming-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findMaxNum(vector<int>& nums1, vector<int>& nums2, int k, int x, int y, vector<vector<string>>& dp) {\\n        if (k == 0) return \"\";\\n        if (!dp[x][y].empty()) return dp[x][y];\\n        string res = \"\";\\n        int idx1 = x, idx2 = y, upperBound1 = nums2.size() + nums1.size() - y - k, upperBound2 = nums2.size() + nums1.size() - x - k;\\n        if (upperBound1 > nums1.size() - 1) upperBound1 = nums1.size() - 1;\\n        if (upperBound2 > nums2.size() - 1) upperBound2 = nums2.size() - 1;\\n        for (int i = x; i <= upperBound1; ++ i) if (nums1[i] > nums1[idx1]) idx1 = i;\\n        for (int i = y; i <= upperBound2; ++ i) if (nums2[i] > nums2[idx2]) idx2 = i;\\n        if (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1] >= nums2[idx2]) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n            if (nums1[idx1] <= nums2[idx2]) res = max(res, to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp));\\n        } \\n        else if (idx1 < nums1.size()) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n        else if (idx2 < nums2.size()) res = to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp);\\n        dp[x][y] = res;\\n        return res;\\n\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<string>> dp(nums1.size() + 1, vector<string>(nums2.size() + 1));\\n        string maxNum = findMaxNum(nums1, nums2, k, 0, 0, dp);\\n        vector<int> res;\\n        for (char c : maxNum) res.push_back(c - \\'0\\');\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findMaxNum(vector<int>& nums1, vector<int>& nums2, int k, int x, int y, vector<vector<string>>& dp) {\\n        if (k == 0) return \"\";\\n        if (!dp[x][y].empty()) return dp[x][y];\\n        string res = \"\";\\n        int idx1 = x, idx2 = y, upperBound1 = nums2.size() + nums1.size() - y - k, upperBound2 = nums2.size() + nums1.size() - x - k;\\n        if (upperBound1 > nums1.size() - 1) upperBound1 = nums1.size() - 1;\\n        if (upperBound2 > nums2.size() - 1) upperBound2 = nums2.size() - 1;\\n        for (int i = x; i <= upperBound1; ++ i) if (nums1[i] > nums1[idx1]) idx1 = i;\\n        for (int i = y; i <= upperBound2; ++ i) if (nums2[i] > nums2[idx2]) idx2 = i;\\n        if (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1] >= nums2[idx2]) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n            if (nums1[idx1] <= nums2[idx2]) res = max(res, to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp));\\n        } \\n        else if (idx1 < nums1.size()) res = to_string(nums1[idx1]) + findMaxNum(nums1, nums2, k - 1, idx1 + 1, y, dp);\\n        else if (idx2 < nums2.size()) res = to_string(nums2[idx2]) + findMaxNum(nums1, nums2, k - 1, x, idx2 + 1, dp);\\n        dp[x][y] = res;\\n        return res;\\n\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<string>> dp(nums1.size() + 1, vector<string>(nums2.size() + 1));\\n        string maxNum = findMaxNum(nums1, nums2, k, 0, 0, dp);\\n        vector<int> res;\\n        for (char c : maxNum) res.push_back(c - \\'0\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862803,
                "title": "python-1-hard-2-easy-1-medium-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is only one array, how to solve it, use monotonic stack.\\nIf we can find subarray in nums1 and nums2, then merge them.\\nThe ans is all combinations of the merge\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmonotonic stack is a medium problem\\nmerge is an easy one\\nfind combination should be an easy problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nk* O(n^2)\\n\\nmonotonic stack is O(n)\\nmerge is O(n)\\nk loops\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def getMaxOrder(nums, n, total, res): # monotonic stack\\n            for i, v in enumerate(nums):\\n                while res and len(res) + total - i > n and res[-1] < v:\\n                    res.pop()\\n                if len(res) < n:\\n                    res.append(nums[i])\\n            return res\\n\\n        def merge(nums1, nums2, ans): # check lexicographically greater\\n            while nums1 or nums2:\\n                if nums1 > nums2:\\n                    ans.append(nums1[0])\\n                    nums1 = nums1[1:]\\n                else:\\n                    ans.append(nums2[0])\\n                    nums2 = nums2[1:]\\n            return ans\\n\\n        n1, n2 = len(nums1), len(nums2)\\n        res = []\\n        for i in range(max(0, k - n2), min(k, n1) + 1): # find all combinations of nums1 and nums2\\n            ans = merge(getMaxOrder(nums1, i, n1, []), getMaxOrder(nums2, k - i, n2, []), [])\\n            res = max(ans, res)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def getMaxOrder(nums, n, total, res): # monotonic stack\\n            for i, v in enumerate(nums):\\n                while res and len(res) + total - i > n and res[-1] < v:\\n                    res.pop()\\n                if len(res) < n:\\n                    res.append(nums[i])\\n            return res\\n\\n        def merge(nums1, nums2, ans): # check lexicographically greater\\n            while nums1 or nums2:\\n                if nums1 > nums2:\\n                    ans.append(nums1[0])\\n                    nums1 = nums1[1:]\\n                else:\\n                    ans.append(nums2[0])\\n                    nums2 = nums2[1:]\\n            return ans\\n\\n        n1, n2 = len(nums1), len(nums2)\\n        res = []\\n        for i in range(max(0, k - n2), min(k, n1) + 1): # find all combinations of nums1 and nums2\\n            ans = merge(getMaxOrder(nums1, i, n1, []), getMaxOrder(nums2, k - i, n2, []), [])\\n            res = max(ans, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346274,
                "title": "runtime-216-ms-memory-usage-14-2-mb",
                "content": "![image](https://assets.leetcode.com/users/images/4243db7e-d5e7-4b56-bfb0-03ae0972896b_1659018972.6834903.png)\\n\\n```\\nclass Solution:\\n    def maxNumber(self, n_1: List[int], n_2: List[int], k: int) -> List[int]:\\n        def f1(maxum,s1,s2):\\n            n1, n2 = -1, -1\\n            if M - s1 > maxum: n1 = max(n_1[s1:s1+maxum])\\n            elif s1 < M: n1 = max(n_1[s1:])\\n                \\n            if N - s2 > maxum: n2 = max(n_2[s2:s2+maxum])\\n            elif s2 < N: n2 = max(n_2[s2:])\\n            return n1,n2\\n\\n        M, N = len(n_1), len(n_2)\\n        r, l = [], [[0,0]]\\n        for x in range(k):\\n            n_l, n_r = [], []\\n            for st in l:\\n                n1, n2 = f1(M + N - st[0] - st[1] - k + 1 + x , st[0], st[1])\\n                if n1 > n2:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                elif n1 < n2:\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n2)+1])\\n                elif n1 == n2 and n1 != -1:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n1)+1])\\n            nr = -1\\n            for i in range(len(n_r)):\\n                if n_r[i] > nr: n_n_l = set(); n_n_l.add((n_l[i][0],n_l[i][1])); nr = n_r[i]\\n                elif n_r[i] == nr: n_n_l.add((n_l[i][0],n_l[i][1]))\\n            r.append(nr)\\n            l = n_n_l\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, n_1: List[int], n_2: List[int], k: int) -> List[int]:\\n        def f1(maxum,s1,s2):\\n            n1, n2 = -1, -1\\n            if M - s1 > maxum: n1 = max(n_1[s1:s1+maxum])\\n            elif s1 < M: n1 = max(n_1[s1:])\\n                \\n            if N - s2 > maxum: n2 = max(n_2[s2:s2+maxum])\\n            elif s2 < N: n2 = max(n_2[s2:])\\n            return n1,n2\\n\\n        M, N = len(n_1), len(n_2)\\n        r, l = [], [[0,0]]\\n        for x in range(k):\\n            n_l, n_r = [], []\\n            for st in l:\\n                n1, n2 = f1(M + N - st[0] - st[1] - k + 1 + x , st[0], st[1])\\n                if n1 > n2:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                elif n1 < n2:\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n2)+1])\\n                elif n1 == n2 and n1 != -1:\\n                    n_r.append(n1)\\n                    n_l.append([st[0]+n_1[st[0]:].index(n1)+1,st[1]])\\n                    n_r.append(n2)\\n                    n_l.append([st[0],st[1]+n_2[st[1]:].index(n1)+1])\\n            nr = -1\\n            for i in range(len(n_r)):\\n                if n_r[i] > nr: n_n_l = set(); n_n_l.add((n_l[i][0],n_l[i][1])); nr = n_r[i]\\n                elif n_r[i] == nr: n_n_l.add((n_l[i][0],n_l[i][1]))\\n            r.append(nr)\\n            l = n_n_l\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205941,
                "title": "c-bfs-hash-t-s-o-n1-n2-k-98-67-fast-89-12-space-notes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ind1(n1+1);  // direct pointer for each digit for every ix\\n        vector<vector<int>> ind2(n2+1);  // direct pointer for each digit for every ix\\n        vector<int> il(10,n1);\\n        ind1[n1] = il;\\n        int i;\\n        for(i=n1-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            il[nums1[i]]=i;\\n            ind1[i] = il;\\n        }\\n        vector<int> ik(10,n2);\\n        ind2[n2] = ik;\\n        for(i=n2-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            ik[nums2[i]]=i;\\n            ind2[i]=ik;\\n        }\\n        int ix = 0;\\n        queue<pair<int,int>> q1;  // Double queues system to implement BFS\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;        // Current queue\\n        queue<pair<int,int>> &q_next = q2;   // Next queue\\n        q.push({0,0});\\n\\t\\tunordered_map<int,int> hash;         // Hash to avoid duplication\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind1[ix1][d];\\n                    if (i<n1 && n1+n2-ix2-i>=k-ix)    \\n                    {\\n                        // cout << d << \", \" << i << endl;\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({i+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind2[ix2][d];    // Update the ix for next d (n2 means no next available)\\n                    \\n                    if (i<n2 && n1+n2-ix1-i>=k-ix)  // Check if this ix allow leave enough digit to get to length k\\n                    {  // Yes - \\n                        // cout << d << \",,\" << i << endl;\\n                        if (ans[ix] < d)  // Check if new max for this ix. \\n                        {   // If new max arase acumulated combination of the old max\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;  // Save new max\\n                        }\\n                        q_next.push({ix1,i+1});  //\\xA0Push current combination\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue  (next become current)\\n            ix++;\\n        }\\n        return  ans;   \\n    }\\n};\\n\\n```\\n// Simple\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> d1(10);\\n        vector<vector<int>> d2(10);\\n        for(int i=0; i<n1; i++) d1[nums1[i]].push_back(i);\\n        for(int i=0; i<n2; i++) d2[nums2[i]].push_back(i);\\n        int ix1[10]={0};\\n        int ix2[10]={0};\\n        int ix = 0;\\n        queue<pair<int,int>> q1;\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;\\n        queue<pair<int,int>> &q_next = q2;\\n        q.push({0,0});\\n        unordered_map<int,int> hash;\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {\\n                    int i;\\n                    for (i=0; i<d1[d].size(); i++) \\n                    {\\n                        if (d1[d][i] < ix1) continue;\\n                        if (n1+n2-ix2-d1[d][i]>=k-ix) break;  // find largest available\\n                    }\\n                    if (i<d1[d].size())    \\n                    {\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({d1[d][i]+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {\\n                    int i;\\n                    for (i=0; i<d2[d].size(); i++) \\n                    {\\n                        if (d2[d][i] < ix2)continue;\\n                        if (n1+n2-ix1-d2[d][i]>=k-ix) break;\\n                    }\\n                    if (i<d2[d].size())    \\n                    {  \\n                        if (ans[ix] < d) \\n                        {\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({ix1,d2[d][i]+1});\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue\\n            ix++;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n/*\\n[3,4,6,5]\\n[9,1,2,5,8,3]\\n5\\n\\n[6,7]\\n[6,0,4]\\n5\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ind1(n1+1);  // direct pointer for each digit for every ix\\n        vector<vector<int>> ind2(n2+1);  // direct pointer for each digit for every ix\\n        vector<int> il(10,n1);\\n        ind1[n1] = il;\\n        int i;\\n        for(i=n1-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            il[nums1[i]]=i;\\n            ind1[i] = il;\\n        }\\n        vector<int> ik(10,n2);\\n        ind2[n2] = ik;\\n        for(i=n2-1; i>=0; i--) \\n        {  // Starting from the end, update the index for the next for each digit\\n            ik[nums2[i]]=i;\\n            ind2[i]=ik;\\n        }\\n        int ix = 0;\\n        queue<pair<int,int>> q1;  // Double queues system to implement BFS\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;        // Current queue\\n        queue<pair<int,int>> &q_next = q2;   // Next queue\\n        q.push({0,0});\\n\\t\\tunordered_map<int,int> hash;         // Hash to avoid duplication\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind1[ix1][d];\\n                    if (i<n1 && n1+n2-ix2-i>=k-ix)    \\n                    {\\n                        // cout << d << \", \" << i << endl;\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({i+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {   // Checking the availebility from high to low (the current highest for this ix)\\n                    int i =ind2[ix2][d];    // Update the ix for next d (n2 means no next available)\\n                    \\n                    if (i<n2 && n1+n2-ix1-i>=k-ix)  // Check if this ix allow leave enough digit to get to length k\\n                    {  // Yes - \\n                        // cout << d << \",,\" << i << endl;\\n                        if (ans[ix] < d)  // Check if new max for this ix. \\n                        {   // If new max arase acumulated combination of the old max\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;  // Save new max\\n                        }\\n                        q_next.push({ix1,i+1});  //\\xA0Push current combination\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue  (next become current)\\n            ix++;\\n        }\\n        return  ans;   \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k,0);\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> d1(10);\\n        vector<vector<int>> d2(10);\\n        for(int i=0; i<n1; i++) d1[nums1[i]].push_back(i);\\n        for(int i=0; i<n2; i++) d2[nums2[i]].push_back(i);\\n        int ix1[10]={0};\\n        int ix2[10]={0};\\n        int ix = 0;\\n        queue<pair<int,int>> q1;\\n        queue<pair<int,int>> q2;\\n        queue<pair<int,int>> &q = q1;\\n        queue<pair<int,int>> &q_next = q2;\\n        q.push({0,0});\\n        unordered_map<int,int> hash;\\n        while (ix < k)\\n        {\\n            while(!q.empty())\\n            {\\n                int ix1 = q.front().first;\\n                int ix2 = q.front().second;\\n                q.pop();\\n                if (hash.count(ix1*512+ix2)) continue;  // Avoid duplication\\n                hash[ix1*512+ix2]++;\\n                for(int d = 9; d>=ans[ix]; d--)\\n                {\\n                    int i;\\n                    for (i=0; i<d1[d].size(); i++) \\n                    {\\n                        if (d1[d][i] < ix1) continue;\\n                        if (n1+n2-ix2-d1[d][i]>=k-ix) break;  // find largest available\\n                    }\\n                    if (i<d1[d].size())    \\n                    {\\n                         if (ans[ix] < d) \\n                        {  // if better than prev (same ix) clear prev\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({d1[d][i]+1,ix2});  // add curent combination\\n                        break;\\n                    }\\n                }\\n                for(int d = 9; d>=ans[ix]; d--) \\n                {\\n                    int i;\\n                    for (i=0; i<d2[d].size(); i++) \\n                    {\\n                        if (d2[d][i] < ix2)continue;\\n                        if (n1+n2-ix1-d2[d][i]>=k-ix) break;\\n                    }\\n                    if (i<d2[d].size())    \\n                    {  \\n                        if (ans[ix] < d) \\n                        {\\n                            while(!q_next.empty()) q_next.pop();\\n                            ans[ix] = d;\\n                        }\\n                        q_next.push({ix1,d2[d][i]+1});\\n                        break;\\n                    }\\n                }\\n            }\\n            swap(q,q_next);  // prepare next queue\\n            ix++;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n/*\\n[3,4,6,5]\\n[9,1,2,5,8,3]\\n5\\n\\n[6,7]\\n[6,0,4]\\n5\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2122879,
                "title": "python-98-faster-greedy-dp-segment-tree-for-range-query",
                "content": "\\n\\n```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Node(object):\\n    def __init__(self, beg, end):\\n        self.beg = beg\\n        self.end = end\\n        self.range_max = None\\n        self.left = None\\n        self.right = None\\n\\n    def is_leaf(self):\\n        return self.beg == self.end\\n\\n    def __repr__(self):\\n        if self.is_leaf():\\n            return f\"{self.beg}: {self.range_max}\"\\n        else:\\n            return f\"{self.beg}~{self.end}: {self.range_max}\"\\n\\n    def query(self, beg, end):\\n        # Totally out of range\\n        if beg > self.end or end < self.beg:\\n            return float(\"-inf\"), -1\\n\\n        # Query range contains node range\\n        elif self.beg >= beg and self.end <= end:\\n            return self.range_max\\n\\n        # Intersection\\n        else:\\n            return max(self.left.query(beg, end), self.right.query(beg, end))\\n\\n\\ndef build_range_tree(a, beg, end):\\n    node = Node(beg, end)\\n    if beg == end:\\n        node.range_max = (a[beg], -beg)\\n    else:\\n        mid = (beg + end) // 2\\n        node.left = build_range_tree(a, beg, mid)\\n        node.right = build_range_tree(a, mid + 1, end)\\n        node.range_max = max(node.left.range_max, node.right.range_max)\\n\\n    return node\\n\\n\\ndef comp_array(a, b, beg_a, beg_b):\\n    for i, j in zip(range(beg_a, len(a)), range(beg_b, len(b))):\\n        if a[i] > b[j]:\\n            return 1\\n        elif a[i] < b[j]:\\n            return -1\\n\\n    if len(a) - beg_a > len(b) - beg_b:\\n        return 1\\n    elif len(a) - beg_a < len(b) - beg_b:\\n        return -1\\n    else:\\n        return 0\\n\\n\\ndef merge_2_arrays(a, b, beg_a, beg_b):\\n    ptr1 = beg_a\\n    ptr2 = beg_b\\n\\n    while True:\\n        if ptr1 == len(a) or ptr2 == len(b):\\n            break\\n        comp_res = comp_array(a, b, ptr1, ptr2)\\n        if comp_res == 1:\\n            yield a[ptr1]\\n            ptr1 += 1\\n        else:\\n            yield b[ptr2]\\n            ptr2 += 1\\n\\n    for i in range(ptr1, len(a)):\\n        yield a[i]\\n\\n    for i in range(ptr2, len(b)):\\n        yield b[i]\\n\\n\\ndef pick_k_numbers(a, tree_a, beg_a, k):\\n    if k == 0:\\n        return []\\n    len_a = len(a) - beg_a\\n    num_elements_to_drop = len_a - k\\n    if num_elements_to_drop == 0:\\n        return a[beg_a:]\\n\\n    end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n\\n    max_val, max_idx = tree_a.query(beg_a, end_a)\\n    max_idx = -max_idx\\n\\n    return [a[max_idx]] + pick_k_numbers(a, tree_a, max_idx + 1, k - 1)\\n\\n\\ndef fetch_dp_table(a, b, tree_a, tree_b, beg_a, beg_b, k, dp_table):\\n\\n    if k == 0:\\n        return []\\n\\n    if (beg_a, beg_b, k) not in dp_table:\\n\\n        len_a = len(a) - beg_a\\n        len_b = len(b) - beg_b\\n\\n        num_elements_to_drop = len_a + len_b - k\\n\\n        if num_elements_to_drop == 0:\\n            res = list(merge_2_arrays(a, b, beg_a, beg_b))\\n\\n        elif len_b == 0:\\n            res = pick_k_numbers(a, tree_a, beg_a, k)\\n\\n        elif len_a == 0:\\n            res = pick_k_numbers(b, tree_b, beg_b, k)\\n\\n        else:\\n            end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n            end_b = min(beg_b + num_elements_to_drop, len(b) - 1)\\n\\n            max_val_a, max_idx_a = (\\n                tree_a.query(beg_a, end_a) if len_a > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_a = -max_idx_a\\n\\n            max_val_b, max_idx_b = (\\n                tree_b.query(beg_b, end_b) if len_b > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_b = -max_idx_b\\n\\n            if max_val_a > max_val_b:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                res = [max_val_a] + next_vals\\n            elif max_val_b > max_val_a:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_b] + next_vals\\n            else:\\n                vala = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                valb = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_a] + max(vala, valb)\\n\\n        dp_table[(beg_a, beg_b, k)] = res\\n    else:\\n        pass\\n\\n    return dp_table[(beg_a, beg_b, k)]\\n\\n\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        tree_1 = build_range_tree(nums1, 0, len(nums1) - 1)\\n        tree_2 = build_range_tree(nums2, 0, len(nums2) - 1)\\n        dp_table = {}\\n        res = fetch_dp_table(nums1, nums2, tree_1, tree_2, 0, 0, k, dp_table)\\n        return res\\n\\n\\nif __name__ == \"__main__\":\\n    nums1 = [3,4,6,5]\\n    nums2 = [9,1,2,5,8,3]\\n    k = 5\\n    # res = Solution().maxNumber(nums1, nums2, k)\\n    # print(res)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Node(object):\\n    def __init__(self, beg, end):\\n        self.beg = beg\\n        self.end = end\\n        self.range_max = None\\n        self.left = None\\n        self.right = None\\n\\n    def is_leaf(self):\\n        return self.beg == self.end\\n\\n    def __repr__(self):\\n        if self.is_leaf():\\n            return f\"{self.beg}: {self.range_max}\"\\n        else:\\n            return f\"{self.beg}~{self.end}: {self.range_max}\"\\n\\n    def query(self, beg, end):\\n        # Totally out of range\\n        if beg > self.end or end < self.beg:\\n            return float(\"-inf\"), -1\\n\\n        # Query range contains node range\\n        elif self.beg >= beg and self.end <= end:\\n            return self.range_max\\n\\n        # Intersection\\n        else:\\n            return max(self.left.query(beg, end), self.right.query(beg, end))\\n\\n\\ndef build_range_tree(a, beg, end):\\n    node = Node(beg, end)\\n    if beg == end:\\n        node.range_max = (a[beg], -beg)\\n    else:\\n        mid = (beg + end) // 2\\n        node.left = build_range_tree(a, beg, mid)\\n        node.right = build_range_tree(a, mid + 1, end)\\n        node.range_max = max(node.left.range_max, node.right.range_max)\\n\\n    return node\\n\\n\\ndef comp_array(a, b, beg_a, beg_b):\\n    for i, j in zip(range(beg_a, len(a)), range(beg_b, len(b))):\\n        if a[i] > b[j]:\\n            return 1\\n        elif a[i] < b[j]:\\n            return -1\\n\\n    if len(a) - beg_a > len(b) - beg_b:\\n        return 1\\n    elif len(a) - beg_a < len(b) - beg_b:\\n        return -1\\n    else:\\n        return 0\\n\\n\\ndef merge_2_arrays(a, b, beg_a, beg_b):\\n    ptr1 = beg_a\\n    ptr2 = beg_b\\n\\n    while True:\\n        if ptr1 == len(a) or ptr2 == len(b):\\n            break\\n        comp_res = comp_array(a, b, ptr1, ptr2)\\n        if comp_res == 1:\\n            yield a[ptr1]\\n            ptr1 += 1\\n        else:\\n            yield b[ptr2]\\n            ptr2 += 1\\n\\n    for i in range(ptr1, len(a)):\\n        yield a[i]\\n\\n    for i in range(ptr2, len(b)):\\n        yield b[i]\\n\\n\\ndef pick_k_numbers(a, tree_a, beg_a, k):\\n    if k == 0:\\n        return []\\n    len_a = len(a) - beg_a\\n    num_elements_to_drop = len_a - k\\n    if num_elements_to_drop == 0:\\n        return a[beg_a:]\\n\\n    end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n\\n    max_val, max_idx = tree_a.query(beg_a, end_a)\\n    max_idx = -max_idx\\n\\n    return [a[max_idx]] + pick_k_numbers(a, tree_a, max_idx + 1, k - 1)\\n\\n\\ndef fetch_dp_table(a, b, tree_a, tree_b, beg_a, beg_b, k, dp_table):\\n\\n    if k == 0:\\n        return []\\n\\n    if (beg_a, beg_b, k) not in dp_table:\\n\\n        len_a = len(a) - beg_a\\n        len_b = len(b) - beg_b\\n\\n        num_elements_to_drop = len_a + len_b - k\\n\\n        if num_elements_to_drop == 0:\\n            res = list(merge_2_arrays(a, b, beg_a, beg_b))\\n\\n        elif len_b == 0:\\n            res = pick_k_numbers(a, tree_a, beg_a, k)\\n\\n        elif len_a == 0:\\n            res = pick_k_numbers(b, tree_b, beg_b, k)\\n\\n        else:\\n            end_a = min(beg_a + num_elements_to_drop, len(a) - 1)\\n            end_b = min(beg_b + num_elements_to_drop, len(b) - 1)\\n\\n            max_val_a, max_idx_a = (\\n                tree_a.query(beg_a, end_a) if len_a > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_a = -max_idx_a\\n\\n            max_val_b, max_idx_b = (\\n                tree_b.query(beg_b, end_b) if len_b > 0 else (float(\"-inf\"), -1)\\n            )\\n            max_idx_b = -max_idx_b\\n\\n            if max_val_a > max_val_b:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                res = [max_val_a] + next_vals\\n            elif max_val_b > max_val_a:\\n                next_vals = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_b] + next_vals\\n            else:\\n                vala = fetch_dp_table(\\n                    a, b, tree_a, tree_b, max_idx_a + 1, beg_b, k - 1, dp_table\\n                )\\n                valb = fetch_dp_table(\\n                    a, b, tree_a, tree_b, beg_a, max_idx_b + 1, k - 1, dp_table\\n                )\\n                res = [max_val_a] + max(vala, valb)\\n\\n        dp_table[(beg_a, beg_b, k)] = res\\n    else:\\n        pass\\n\\n    return dp_table[(beg_a, beg_b, k)]\\n\\n\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        tree_1 = build_range_tree(nums1, 0, len(nums1) - 1)\\n        tree_2 = build_range_tree(nums2, 0, len(nums2) - 1)\\n        dp_table = {}\\n        res = fetch_dp_table(nums1, nums2, tree_1, tree_2, 0, 0, k, dp_table)\\n        return res\\n\\n\\nif __name__ == \"__main__\":\\n    nums1 = [3,4,6,5]\\n    nums2 = [9,1,2,5,8,3]\\n    k = 5\\n    # res = Solution().maxNumber(nums1, nums2, k)\\n    # print(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105459,
                "title": "python-easy-to-understand-greedy-dynamic-programminng",
                "content": "To solve the problem, we can define the subproblem \"getMaxNumberString(i, j, length)\": get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2.\\n\\ngetMaxNumberString(i, j, length)\\n- if nums1 has bigger digit, getMaxNumberString(i, j, length) = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n- if nums2 has bigger digit, getMaxNumberString(i, j, length) = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n- if nums1 and nums2 have the same big digit, getMaxNumberString(i, j, length) = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1),  str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = {}\\n        \\n        # get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2\\n        # using number string to easy to compare\\n        def getMaxNumberString(i, j, length):\\n            if length == 0:\\n                return \"\"\\n            \\n            # using memoization to optimize for the overlapping subproblems\\n            key = (i, j, length)\\n            if key in dp:\\n                return dp[key]\\n            \\n            # greedy to find the possible max digit from nums1 and nums2\\n            # 1) bigger digit in the higher position of the number will get bigger number\\n            # 2) at the same time, we need to ensure that we still have enough digits to form a number with \"length\" digits\\n            \\n            # try to find the possible max digit from index i in nums1\\n            index1 = None\\n            for ii in range(i, m):\\n                if (m - ii + n - j) < length:\\n                    break\\n                if index1 is None or nums1[index1] < nums1[ii]:\\n                    index1 = ii\\n            \\n            # try to find the possible max digit from index j in nums2\\n            index2 = None\\n            for jj in range(j, n):\\n                if (m - i + n - jj) < length:\\n                    break\\n                if index2 is None or nums2[index2] < nums2[jj]:\\n                    index2 = jj\\n                    \\n            maxNumberStr = None\\n            if index1 is not None and index2 is not None:\\n                if nums1[index1] > nums2[index2]:\\n                    maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n                elif nums1[index1] < nums2[index2]:\\n                    maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n                else:\\n                    # get the same digit from nums1 and nums2, so need to try two cases and get the max one \\n                    maxNumberStr = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1), str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n            elif index1 is not None:\\n                maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n            elif index2 is not None:\\n                maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n            \\n            dp[key] = maxNumberStr\\n            return maxNumberStr\\n\\n        result_str = getMaxNumberString(0, 0, k)\\n        \\n        # number string to digit array\\n        result = []\\n        for c in result_str:\\n            result.append(int(c))\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = {}\\n        \\n        # get the max number string with \"length\" from index \"i\" in nums1 and index \"j\" in nums2\\n        # using number string to easy to compare\\n        def getMaxNumberString(i, j, length):\\n            if length == 0:\\n                return \"\"\\n            \\n            # using memoization to optimize for the overlapping subproblems\\n            key = (i, j, length)\\n            if key in dp:\\n                return dp[key]\\n            \\n            # greedy to find the possible max digit from nums1 and nums2\\n            # 1) bigger digit in the higher position of the number will get bigger number\\n            # 2) at the same time, we need to ensure that we still have enough digits to form a number with \"length\" digits\\n            \\n            # try to find the possible max digit from index i in nums1\\n            index1 = None\\n            for ii in range(i, m):\\n                if (m - ii + n - j) < length:\\n                    break\\n                if index1 is None or nums1[index1] < nums1[ii]:\\n                    index1 = ii\\n            \\n            # try to find the possible max digit from index j in nums2\\n            index2 = None\\n            for jj in range(j, n):\\n                if (m - i + n - jj) < length:\\n                    break\\n                if index2 is None or nums2[index2] < nums2[jj]:\\n                    index2 = jj\\n                    \\n            maxNumberStr = None\\n            if index1 is not None and index2 is not None:\\n                if nums1[index1] > nums2[index2]:\\n                    maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n                elif nums1[index1] < nums2[index2]:\\n                    maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n                else:\\n                    # get the same digit from nums1 and nums2, so need to try two cases and get the max one \\n                    maxNumberStr = max(str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1), str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1))\\n            elif index1 is not None:\\n                maxNumberStr = str(nums1[index1]) + getMaxNumberString(index1 + 1, j, length - 1)\\n            elif index2 is not None:\\n                maxNumberStr = str(nums2[index2]) + getMaxNumberString(i, index2 + 1, length - 1)\\n            \\n            dp[key] = maxNumberStr\\n            return maxNumberStr\\n\\n        result_str = getMaxNumberString(0, 0, k)\\n        \\n        # number string to digit array\\n        result = []\\n        for c in result_str:\\n            result.append(int(c))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982077,
                "title": "python3-monotonic-stack-greedy",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def find_k_max_number_in_an_array(nums, k):\\n            drop_possible = len(nums) - k\\n            n = len(nums)\\n            stack = []\\n            for i, val in enumerate(nums):\\n                while stack and drop_possible and stack[-1] < val:\\n                    drop_possible -= 1\\n                    stack.pop()\\n                \\n                stack.append(val)\\n            \\n            return stack[:k]\\n                \\n        \\n        def merge_two_array(arr1, arr2):\\n            #print(arr1, arr2)\\n            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]\\n\\n        def compare_two_array(arr1, arr2):\\n            \"\"\"\\n            determine whether arr1 is greater than arr2\\n            \"\"\"\\n            if not arr2:\\n                return True\\n            i = j = 0\\n            n = len(arr1)\\n            while i < n and j < n:\\n                if arr1[i] > arr2[j]:\\n                    return True\\n                elif arr1[i] < arr2[j]:\\n                    return False\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        ans = 0\\n        for i in range(k + 1):\\n            p = k - i\\n            \\n            if i > len(nums1) or p > len(nums2):\\n                continue\\n            \\n            # get this two array by solving function find_k_max_number_in_an_array\\n            # using similar concept of 402. Remove K Digits\\n            first_arr = find_k_max_number_in_an_array(nums1, i)\\n            second_arr = find_k_max_number_in_an_array(nums2, p)\\n            \\n            # merge two array with everytime taking lexicographily larger list\\n            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B\\n            # see explanation\\n            curr_arr = merge_two_array(first_arr, second_arr)\\n            #print(curr_arr)\\n            \\n            # can be directly use python max function\\n            if compare_two_array(curr_arr, ans):\\n                ans = curr_arr\\n            # ans = max(ans, curr_arr) if ans else curr_arr\\n            \\n            #print(ans)\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        def find_k_max_number_in_an_array(nums, k):\\n            drop_possible = len(nums) - k\\n            n = len(nums)\\n            stack = []\\n            for i, val in enumerate(nums):\\n                while stack and drop_possible and stack[-1] < val:\\n                    drop_possible -= 1\\n                    stack.pop()\\n                \\n                stack.append(val)\\n            \\n            return stack[:k]\\n                \\n        \\n        def merge_two_array(arr1, arr2):\\n            #print(arr1, arr2)\\n            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]\\n\\n        def compare_two_array(arr1, arr2):\\n            \"\"\"\\n            determine whether arr1 is greater than arr2\\n            \"\"\"\\n            if not arr2:\\n                return True\\n            i = j = 0\\n            n = len(arr1)\\n            while i < n and j < n:\\n                if arr1[i] > arr2[j]:\\n                    return True\\n                elif arr1[i] < arr2[j]:\\n                    return False\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        ans = 0\\n        for i in range(k + 1):\\n            p = k - i\\n            \\n            if i > len(nums1) or p > len(nums2):\\n                continue\\n            \\n            # get this two array by solving function find_k_max_number_in_an_array\\n            # using similar concept of 402. Remove K Digits\\n            first_arr = find_k_max_number_in_an_array(nums1, i)\\n            second_arr = find_k_max_number_in_an_array(nums2, p)\\n            \\n            # merge two array with everytime taking lexicographily larger list\\n            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B\\n            # see explanation\\n            curr_arr = merge_two_array(first_arr, second_arr)\\n            #print(curr_arr)\\n            \\n            # can be directly use python max function\\n            if compare_two_array(curr_arr, ans):\\n                ans = curr_arr\\n            # ans = max(ans, curr_arr) if ans else curr_arr\\n            \\n            #print(ans)\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902698,
                "title": "c-solution-well-explained",
                "content": "**Explanation:**\\n\\nIdea 1: the first thing that popped into my head was to use recursion, the initial idea was to select an initial number and in each call stack have three different paths to take.\\n1. \\tchoose a number from array one\\n2. \\tchoose a number from array two\\n3. \\tdon\\'t choose a number and move along \\n\\t\\t\\t* \\tThe problem with this approach is that it is both time and memory expensive\\n\\t\\t\\nIdea 2: a greedy approach where i would take the lexigraphically greatest portion of array one merge it with the lexigraphically greatest portion of array two and collapse the arrays into themselves to be of size k, this idea works but we have to be careful.\\n\\nAlgorithm explained:\\n\\t1. \\tpartition both arrays into a sub array of k, where each array contains the maximum lexigraphical order it can hold.\\n\\t\\tThe subarrays are partitioned as such, (k - i) where i <= k would get you the first half and i gets the other half of that k sized array.\\n*  \\t\\t    auto first = findMax(nums1, k - i);\\n* \\t\\t      auto second = findMax(nums2, i);\\n\\t\\n2. \\tThen merge those two arrays ( k - i) and i into an array of size k , where the array of size K respects the rule of being in the greatest lexigraphical order it can hold.\\n* \\t\\t while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n3. Lastly compare with our answer derived from previous iterations and update if needed.\\n\\t\\t*`ans = compare(ans, tmp);`\\n\\n```\\nclass Solution\\n{\\npublic:\\n    void print(vector<int> & res){\\n        for(int x : res)\\n            cout << x << \" \";\\n        cout << endl;\\n    }\\n    \\n    vector<int> findMax(vector<int> &nums, int k)\\n    {\\n        vector<int> res;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int m = res.size();\\n            while (m && res.back() < nums[i])\\n            {\\n                if (((n - i) + m - 1) >= k)\\n                {\\n                    res.pop_back();\\n                    m--;\\n                }\\n                else\\n                    break;\\n            }\\n            if (m < k)\\n            {\\n                m++;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> compare(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if (n > m)\\n            return nums1;\\n        if (m > n)\\n            return nums2;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums1[i] > nums2[i])\\n                return nums1;\\n            else if (nums1[i] < nums2[i])\\n                return nums2;\\n        }\\n        return nums1;\\n    }\\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        vector<int> res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int nP = 0;\\n        int mP = 0;\\n        while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n        while (nP < n)\\n            res.push_back(nums1[nP++]);\\n        while (mP < m)\\n            res.push_back(nums2[mP++]);\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n    {\\n        vector<int> ans;\\n        for (int i = 0; i < k; i++)\\n        {\\n            auto first = findMax(nums1, k - i);\\n            auto second = findMax(nums2, i);\\n            auto tmp = merge(first, second);\\n            ans = compare(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void print(vector<int> & res){\\n        for(int x : res)\\n            cout << x << \" \";\\n        cout << endl;\\n    }\\n    \\n    vector<int> findMax(vector<int> &nums, int k)\\n    {\\n        vector<int> res;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int m = res.size();\\n            while (m && res.back() < nums[i])\\n            {\\n                if (((n - i) + m - 1) >= k)\\n                {\\n                    res.pop_back();\\n                    m--;\\n                }\\n                else\\n                    break;\\n            }\\n            if (m < k)\\n            {\\n                m++;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> compare(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        if (n > m)\\n            return nums1;\\n        if (m > n)\\n            return nums2;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums1[i] > nums2[i])\\n                return nums1;\\n            else if (nums1[i] < nums2[i])\\n                return nums2;\\n        }\\n        return nums1;\\n    }\\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        vector<int> res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int nP = 0;\\n        int mP = 0;\\n        while (nP < n && mP < m)\\n        {\\n              if(nums1[nP] == nums2[mP]){  \\n                  int i = nP;  \\n                  int j = mP;\\n                  \\n                  while( i < n && j < m && nums1[i] == nums2[j]){\\n                      i++;\\n                      j++;\\n                  } \\n                  \\n                  if(i == n)\\n                      res.push_back(nums2[mP++]);\\n                  \\n                  else if ( j == m)\\n                      res.push_back(nums1[nP++]);\\n                  \\n                  else if(nums1[i] > nums2[j])\\n                     res.push_back(nums1[nP++]); \\n                  \\n                  else\\n                     res.push_back(nums2[mP++]); \\n                    \\n                continue; \\n          } \\n          if (nums1[nP] > nums2[mP])\\n                res.push_back(nums1[nP++]);\\n           else if(nums2[mP] > nums1[nP]) \\n                res.push_back(nums2[mP++]);\\n        }\\n        while (nP < n)\\n            res.push_back(nums1[nP++]);\\n        while (mP < m)\\n            res.push_back(nums2[mP++]);\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n    {\\n        vector<int> ans;\\n        for (int i = 0; i < k; i++)\\n        {\\n            auto first = findMax(nums1, k - i);\\n            auto second = findMax(nums2, i);\\n            auto tmp = merge(first, second);\\n            ans = compare(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1860099,
                "title": "java-simple-solution-monotonic-stack-merge-all-combinations",
                "content": "class Solution {\\n    \\n    public int[] largeNum(int[] nums,int k){\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            \\n            while(stack.size() > 0 && stack.peek() < nums[i] && k - stack.size() <= n - i - 1){\\n                stack.pop();\\n            }\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        int[] ans = new int[stack.size()];\\n        int ptr = stack.size() - 1;\\n        \\n        while(!stack.isEmpty()){\\n            ans[ptr--] = stack.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    boolean isGreater(int[] max1,int[] max2,int i,int j){\\n        \\n        while(i < max1.length || j < max2.length){\\n            \\n            if(i >= max1.length) return false;\\n            else if(j >= max2.length) return true;\\n            else if(max1[i] < max2[j]) return false;\\n            else if(max1[i] > max2[j]) return true;\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    \\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        \\n        int[] ans = new int[k];\\n        \\n        for(int i = 0;i <= k;i++){\\n            \\n            if(i > nums1.length || k - i > nums2.length) continue;\\n            \\n            int[] max1 = largeNum(nums1,i);\\n            int[] max2 = largeNum(nums2,k - i);\\n            \\n            //merge\\n            int a = 0;\\n            int b = 0;\\n            int[] temp = new int[k];\\n            int ptr = 0;\\n            while(a < max1.length || b < max2.length){\\n                if(ptr >= k){\\n                    break;\\n                }\\n                if(a >= max1.length) temp[ptr++] = max2[b++];\\n                else if(b >= max2.length) temp[ptr++] = max1[a++];\\n                else if(max1[a] < max2[b]) temp[ptr++] = max2[b++];\\n                else if(max1[a] > max2[b]) temp[ptr++] = max1[a++];\\n                else{\\n                    if(isGreater(max1,max2,a,b)){\\n                        temp[ptr++] = max1[a++];\\n                    }\\n                    else{\\n                        temp[ptr++] = max2[b++];\\n                    }\\n                }\\n            }\\n            // for(int j = 0;j < k;j++){\\n            //     System.out.print(temp[j] + \" \");\\n            // }\\n            //System.out.println();\\n            if(isGreater(temp,ans,0,0)){\\n                System.out.print(\"In\");\\n                ans = temp;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    \\n    public int[] largeNum(int[] nums,int k){\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0;i < n;i++){\\n            \\n            while(stack.size() > 0 && stack.peek() < nums[i] && k - stack.size() <= n - i - 1){\\n                stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1774232,
                "title": "javascript-greedy",
                "content": "```\\nconst maxNumber = (a, b, k) => {\\n    let m = a.length, n = b.length;\\n    let res = [];\\n    for (let i = Math.max(0, k - n); i <= Math.min(k, m); i++) {\\n        let maxA = maxArray(a, i), maxB = maxArray(b, k - i);\\n        let merge = mergeArray(maxA, maxB);\\n        if (merge > res) res = merge;\\n    }\\n    return res;\\n};\\n\\nconst maxArray = (a, k) => {\\n    let drop = a.length - k, res = [];\\n    for (const x of a) {\\n        while (drop > 0 && res.length && res[res.length - 1] < x) {\\n            res.pop();\\n            drop--;\\n        }\\n        res.push(x);\\n    }\\n    if (res.length >= k) {\\n        res = res.slice(0, k);\\n    } else {\\n        res = res.concat(Array(k - res.length).fill(0));\\n    }\\n    return res;\\n};\\n\\nconst mergeArray = (a, b) => {\\n    let res = [];\\n    while (a.length + b.length) res.push(a > b ? a.shift() : b.shift())\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst maxNumber = (a, b, k) => {\\n    let m = a.length, n = b.length;\\n    let res = [];\\n    for (let i = Math.max(0, k - n); i <= Math.min(k, m); i++) {\\n        let maxA = maxArray(a, i), maxB = maxArray(b, k - i);\\n        let merge = mergeArray(maxA, maxB);\\n        if (merge > res) res = merge;\\n    }\\n    return res;\\n};\\n\\nconst maxArray = (a, k) => {\\n    let drop = a.length - k, res = [];\\n    for (const x of a) {\\n        while (drop > 0 && res.length && res[res.length - 1] < x) {\\n            res.pop();\\n            drop--;\\n        }\\n        res.push(x);\\n    }\\n    if (res.length >= k) {\\n        res = res.slice(0, k);\\n    } else {\\n        res = res.concat(Array(k - res.length).fill(0));\\n    }\\n    return res;\\n};\\n\\nconst mergeArray = (a, b) => {\\n    let res = [];\\n    while (a.length + b.length) res.push(a > b ? a.shift() : b.shift())\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736251,
                "title": "create-maximum-number",
                "content": "c++solution\\ntime and space surpass 90%+\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// #define DEBUG\\nclass Solution {\\npublic:\\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int m = nums1.size(), n = nums2.size();\\n    int *ret = NULL;\\n    if(m > n) {\\n      return maxNumber(nums2, nums1, k);\\n    }\\n    // make sure that m is smaller than or equal to m\\n    int begin = max(0, k-n);\\n    int end = min(m, k);\\n    for(int i = begin; i <= end; i++) {\\n      int *maxSub1 = maxSubsequence(nums1, i);\\n      int *maxSub2 = maxSubsequence(nums2, k - i);\\n      #ifdef DEBUG\\n      cout << i << \"---------------------------\\\\n\";\\n      dump(maxSub1, i);\\n      dump(maxSub2, k-i);\\n      cout << \"-------------------------\\\\n\";\\n      #endif\\n      int *maxSub = merge(maxSub1, i, maxSub2, k-i);\\n      ret = comapreAndSwap(ret, maxSub, k);\\n    }\\n    return vector<int>(ret, ret + k);\\n  }\\n  void dump(int *sub, int size) {\\n    for(int i = 0; i < size; i++) {\\n      cout << sub[i] << \" \";\\n    }\\n    cout << endl;\\n    return;\\n  }\\n  int *maxSubsequence(vector<int> &nums, int k) {\\n    int n = nums.size();\\n    int discard = n-k;\\n    int *ret = (int *)malloc(k * sizeof(int));\\n    int top = 0;\\n    for(auto i : nums) {\\n      while(top > 0 && ret[top-1] < i && discard > 0) {\\n        discard--;\\n        top--;\\n      }\\n\\n      if(top < k) {\\n        ret[top++] = i;\\n      }else{\\n        discard--;\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int *merge(int *sub1, int size1, int *sub2, int size2) {\\n    int idx1 = 0, idx2 = 0;\\n    int *ret = (int *)malloc((size1 + size2) * sizeof(int));\\n    for(int i = 0; i < size1 + size2; i++) {\\n      if(compare(sub1, size1, idx1, sub2, size2, idx2)) {\\n        ret[i] = sub1[idx1++];\\n      }else{\\n        ret[i] = sub2[idx2++];\\n      }\\n    }\\n    free(sub1);\\n    free(sub2);\\n    return ret;\\n  }\\n\\n  int *comapreAndSwap(int *ret, int *sub, int k) {\\n    if(compare(ret, k, 0, sub, k, 0)) {\\n      free(sub);\\n      return ret;\\n    }else{\\n      free(ret);\\n      return sub;\\n    }\\n  }\\n\\n  int compare(int *sub1, int size1, int idx1, int *sub2, int size2, int idx2) {\\n    if(size1 == idx1 || sub1 == NULL) {\\n      return 0;\\n    }else if(size2 == idx2) {\\n      return 1;\\n    }\\n\\n    if(sub1[idx1] > sub2[idx2]) {\\n      return 1;\\n    }else if(sub1[idx1] < sub2[idx2]){\\n      return 0;\\n    }else{\\n      return compare(sub1, size1, idx1+1, sub2, size2, idx2+1);\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n// #define DEBUG\\nclass Solution {\\npublic:\\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int m = nums1.size(), n = nums2.size();\\n    int *ret = NULL;\\n    if(m > n) {\\n      return maxNumber(nums2, nums1, k);\\n    }\\n    // make sure that m is smaller than or equal to m\\n    int begin = max(0, k-n);\\n    int end = min(m, k);\\n    for(int i = begin; i <= end; i++) {\\n      int *maxSub1 = maxSubsequence(nums1, i);\\n      int *maxSub2 = maxSubsequence(nums2, k - i);\\n      #ifdef DEBUG\\n      cout << i << \"---------------------------\\\\n\";\\n      dump(maxSub1, i);\\n      dump(maxSub2, k-i);\\n      cout << \"-------------------------\\\\n\";\\n      #endif\\n      int *maxSub = merge(maxSub1, i, maxSub2, k-i);\\n      ret = comapreAndSwap(ret, maxSub, k);\\n    }\\n    return vector<int>(ret, ret + k);\\n  }\\n  void dump(int *sub, int size) {\\n    for(int i = 0; i < size; i++) {\\n      cout << sub[i] << \" \";\\n    }\\n    cout << endl;\\n    return;\\n  }\\n  int *maxSubsequence(vector<int> &nums, int k) {\\n    int n = nums.size();\\n    int discard = n-k;\\n    int *ret = (int *)malloc(k * sizeof(int));\\n    int top = 0;\\n    for(auto i : nums) {\\n      while(top > 0 && ret[top-1] < i && discard > 0) {\\n        discard--;\\n        top--;\\n      }\\n\\n      if(top < k) {\\n        ret[top++] = i;\\n      }else{\\n        discard--;\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int *merge(int *sub1, int size1, int *sub2, int size2) {\\n    int idx1 = 0, idx2 = 0;\\n    int *ret = (int *)malloc((size1 + size2) * sizeof(int));\\n    for(int i = 0; i < size1 + size2; i++) {\\n      if(compare(sub1, size1, idx1, sub2, size2, idx2)) {\\n        ret[i] = sub1[idx1++];\\n      }else{\\n        ret[i] = sub2[idx2++];\\n      }\\n    }\\n    free(sub1);\\n    free(sub2);\\n    return ret;\\n  }\\n\\n  int *comapreAndSwap(int *ret, int *sub, int k) {\\n    if(compare(ret, k, 0, sub, k, 0)) {\\n      free(sub);\\n      return ret;\\n    }else{\\n      free(ret);\\n      return sub;\\n    }\\n  }\\n\\n  int compare(int *sub1, int size1, int idx1, int *sub2, int size2, int idx2) {\\n    if(size1 == idx1 || sub1 == NULL) {\\n      return 0;\\n    }else if(size2 == idx2) {\\n      return 1;\\n    }\\n\\n    if(sub1[idx1] > sub2[idx2]) {\\n      return 1;\\n    }else if(sub1[idx1] < sub2[idx2]){\\n      return 0;\\n    }else{\\n      return compare(sub1, size1, idx1+1, sub2, size2, idx2+1);\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1733338,
                "title": "merger-of-nearestgreaterelement-and-lexicographical",
                "content": "**Do below problems before attempt this problem**\\n\\nhttps://leetcode.com/problems/remove-k-digits/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/remove-duplicate-letters/\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\n\\t\\t   vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tfor (int i = 0; i <=k; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint j = k - i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i>nums1.size()||j>nums2.size()) continue;\\n\\n\\t\\t\\t\\t\\tvector<int> n1 = calculateNGEType(nums1, i);\\n\\t\\t\\t\\t\\tvector<int> n2 = calculateNGEType(nums2, j);\\n\\t\\t\\t\\t\\tvector<int> t = merge(n1, n2,k);\\n\\t\\t\\t\\t\\tif(t>ans)ans=t;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tbool greater(vector<int> n1, vector<int> n2,int i,int j){\\n\\t\\t\\t\\tint ns1 = n1.size();\\n\\t\\t\\t\\tint ns2 = n2.size();\\n\\t\\t\\t\\twhile (i < ns1 || j < ns2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i >= ns1)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\telse if (j >= ns2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (n1[i] > n2[j])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (n1[i] < n2[j])\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++,j++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> merge(vector<int> n1, vector<int> n2,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ns1 = n1.size();\\n\\t\\t\\t\\tint ns2 = n2.size();\\n\\t\\t\\t\\tint i = 0, j = 0, l = 0;\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\twhile ((i < ns1 || j < ns2)&&k>0 )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i >= ns1)\\n\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\telse if (j >= ns2)\\n\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\telse if (n1[i] > n2[j])\\n\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\telse if (n1[i] < n2[j])\\n\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(greater(n1,n2,i,j))\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(n1[i++]);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(n2[j++]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> calculateNGEType(vector<int> &nums1, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint removal = nums1.size() - k;\\n\\t\\t\\t\\tvector<int> n1;\\n\\n\\t\\t\\t\\tfor (int i = 0; i < nums1.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (n1.size() > 0 && removal > 0 && n1.back() < nums1[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tremoval--;\\n\\t\\t\\t\\t\\t\\tn1.pop_back();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tn1.push_back(nums1[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn n1;\\n\\t\\t\\t}\\n\\n\\n\\t\\t};",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\n\\t\\t   vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tfor (int i = 0; i <=k; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint j = k - i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i>nums1.size()||j>nums2.size()) continue;\\n\\n\\t\\t\\t\\t\\tvector<int> n1 = calculateNGEType(nums1, i);\\n\\t\\t\\t\\t\\tvector<int> n2 = calculateNGEType(nums2, j);\\n\\t\\t\\t\\t\\tvector<int> t = merge(n1, n2,k);\\n\\t\\t\\t\\t\\tif(t>ans)ans=t;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1604538,
                "title": "c-recursion-memo",
                "content": "```cs\\npublic class Solution {\\n\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        var lst = MaxNumber(GetMap(nums1), GetMap(nums2), nums1.Length + nums2.Length, 0, 0, k); lst.Reverse();\\n        return lst.ToArray();\\n    }\\n        \\n    \\n    private IDictionary<(int,int,int),List<int>> memo = new Dictionary<(int,int,int),List<int>>();\\n    \\n    private List<int> MaxNumber(IReadOnlyDictionary<int,List<int>> map1, IReadOnlyDictionary<int,List<int>> map2, int count, int pos1, int pos2, int k) {\\n        \\n        if (k == 0)\\n            return new List<int>();\\n        \\n        var key = (pos1,pos2,k);\\n        if (memo.TryGetValue(key, out List<int> m))\\n            return new List<int>(m);\\n        \\n        var has1 = TryGetValue(map1, pos1, count - pos2 - k, out int val1, out int next1);\\n        var has2 = TryGetValue(map2, pos2, count - pos1 - k, out int val2, out int next2);\\n        \\n        if (!has1 || has2 && val2 > val1) {\\n            var list = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1); list.Add(val2);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n            \\n        if (!has2 || has1 && val1 > val2) {\\n            var list = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1); list.Add(val1);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n        \\n        var list1 = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1);\\n        var list2 = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1);\\n        \\n        var lst = IsLess(list1, list2) ? list2 : list1; lst.Add(val1);\\n        memo[key] = new List<int>(lst);\\n        return lst;\\n    }\\n    \\n    private IReadOnlyDictionary<int,List<int>> GetMap(int[] nums) {\\n        var dic = Enumerable.Range(0, 10).ToDictionary(i => i, i => new List<int>());\\n        for(var i = 0; i < nums.Length; i++)\\n            dic[nums[i]].Add(i);\\n        return dic;\\n    }\\n    \\n    private bool TryGetValue(IReadOnlyDictionary<int,List<int>> map, int from, int to, out int value, out int pos) {\\n        for(value = 9; value >= 0; value--) {\\n            var idx = map[value].BinarySearch(from);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (idx >= map[value].Count)\\n                continue;\\n            if (map[value][idx] > to)\\n                continue;\\n            pos = map[value][idx];\\n            return true;\\n        }\\n        pos = -1;\\n        return false;\\n    }\\n    \\n    private bool IsLess(List<int> lst1, List<int> lst2) {\\n        for(var i = lst1.Count - 1; i >= 0; i--) {\\n            if (lst1[i] < lst2[i])\\n                return true;\\n            if (lst1[i] > lst2[i])\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cs\\npublic class Solution {\\n\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        var lst = MaxNumber(GetMap(nums1), GetMap(nums2), nums1.Length + nums2.Length, 0, 0, k); lst.Reverse();\\n        return lst.ToArray();\\n    }\\n        \\n    \\n    private IDictionary<(int,int,int),List<int>> memo = new Dictionary<(int,int,int),List<int>>();\\n    \\n    private List<int> MaxNumber(IReadOnlyDictionary<int,List<int>> map1, IReadOnlyDictionary<int,List<int>> map2, int count, int pos1, int pos2, int k) {\\n        \\n        if (k == 0)\\n            return new List<int>();\\n        \\n        var key = (pos1,pos2,k);\\n        if (memo.TryGetValue(key, out List<int> m))\\n            return new List<int>(m);\\n        \\n        var has1 = TryGetValue(map1, pos1, count - pos2 - k, out int val1, out int next1);\\n        var has2 = TryGetValue(map2, pos2, count - pos1 - k, out int val2, out int next2);\\n        \\n        if (!has1 || has2 && val2 > val1) {\\n            var list = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1); list.Add(val2);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n            \\n        if (!has2 || has1 && val1 > val2) {\\n            var list = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1); list.Add(val1);\\n            memo[key] = new List<int>(list);\\n            return list;\\n        }\\n        \\n        var list1 = MaxNumber(map1, map2, count, next1 + 1, pos2, k - 1);\\n        var list2 = MaxNumber(map1, map2, count, pos1, next2 + 1, k - 1);\\n        \\n        var lst = IsLess(list1, list2) ? list2 : list1; lst.Add(val1);\\n        memo[key] = new List<int>(lst);\\n        return lst;\\n    }\\n    \\n    private IReadOnlyDictionary<int,List<int>> GetMap(int[] nums) {\\n        var dic = Enumerable.Range(0, 10).ToDictionary(i => i, i => new List<int>());\\n        for(var i = 0; i < nums.Length; i++)\\n            dic[nums[i]].Add(i);\\n        return dic;\\n    }\\n    \\n    private bool TryGetValue(IReadOnlyDictionary<int,List<int>> map, int from, int to, out int value, out int pos) {\\n        for(value = 9; value >= 0; value--) {\\n            var idx = map[value].BinarySearch(from);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (idx >= map[value].Count)\\n                continue;\\n            if (map[value][idx] > to)\\n                continue;\\n            pos = map[value][idx];\\n            return true;\\n        }\\n        pos = -1;\\n        return false;\\n    }\\n    \\n    private bool IsLess(List<int> lst1, List<int> lst2) {\\n        for(var i = lst1.Count - 1; i >= 0; i--) {\\n            if (lst1[i] < lst2[i])\\n                return true;\\n            if (lst1[i] > lst2[i])\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467393,
                "title": "c-321-create-maximum-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k); \\n        \\n        auto fn = [](vector<int>& arr, int k) {\\n            vector<int> ans(k); \\n            for (int i = 0, n = 0; i < arr.size(); ++i) {\\n                while (n && ans[n-1] < arr[i] && n + arr.size() - i > k) --n; \\n                if (n < k) ans[n++] = arr[i]; \\n            }\\n            return ans; \\n        };\\n        \\n        auto cmp = [](vector<int>& val1, int i1, vector<int>& val2, int i2) {\\n            for (; i1 < val1.size() && i2 < val2.size(); i1++, i2++) {\\n                if (val1[i1] > val2[i2]) return true; \\n                if (val1[i1] < val2[i2]) return false; \\n            }\\n            return i2 == val2.size(); \\n        };\\n        \\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= nums1.size() && k-i <= nums2.size()) {\\n                vector<int> val1 = fn(nums1, i), val2 = fn(nums2, k - i); \\n                vector<int> cand; \\n                for (int i1 = 0, i2 = 0; i1 < val1.size() || i2 < val2.size(); ) \\n                    if (cmp(val1, i1, val2, i2)) cand.push_back(val1[i1++]);\\n                    else cand.push_back(val2[i2++]); \\n                ans = max(ans, cand); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans(k); \\n        \\n        auto fn = [](vector<int>& arr, int k) {\\n            vector<int> ans(k); \\n            for (int i = 0, n = 0; i < arr.size(); ++i) {\\n                while (n && ans[n-1] < arr[i] && n + arr.size() - i > k) --n; \\n                if (n < k) ans[n++] = arr[i]; \\n            }\\n            return ans; \\n        };\\n        \\n        auto cmp = [](vector<int>& val1, int i1, vector<int>& val2, int i2) {\\n            for (; i1 < val1.size() && i2 < val2.size(); i1++, i2++) {\\n                if (val1[i1] > val2[i2]) return true; \\n                if (val1[i1] < val2[i2]) return false; \\n            }\\n            return i2 == val2.size(); \\n        };\\n        \\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= nums1.size() && k-i <= nums2.size()) {\\n                vector<int> val1 = fn(nums1, i), val2 = fn(nums2, k - i); \\n                vector<int> cand; \\n                for (int i1 = 0, i2 = 0; i1 < val1.size() || i2 < val2.size(); ) \\n                    if (cmp(val1, i1, val2, i2)) cand.push_back(val1[i1++]);\\n                    else cand.push_back(val2[i2++]); \\n                ans = max(ans, cand); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403797,
                "title": "c-concise-solution",
                "content": "code comments itself.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    std::deque<int> getMax(const std::vector<int> &nums, int k)\\n    {\\n        if(k == 0){\\n            return {};\\n        }\\n        \\n        std::deque<int> result;\\n        const int drop = std::max<int>(0, nums.size() - k);\\n\\n        for(int d = 0; const auto e: nums){\\n            while(!result.empty() && result.back() < e && d < drop){\\n                result.pop_back();\\n                d++;\\n            }\\n            result.push_back(e);\\n        }\\n        \\n        while(result.size() > k){\\n            result.resize(k);\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> merge(std::deque<int> p, std::deque<int> q)\\n    {\\n        std::vector<int> result;\\n        while(!(p.empty() && q.empty())){\\n            if(p > q){\\n                result.push_back(p.front());\\n                p.pop_front();\\n            }\\n            else{\\n                result.push_back(q.front());\\n                q.pop_front();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        std::vector<int> result;\\n        for(int i = 0; i <= k && i <= nums1.size(); ++i){\\n            if(int j = k - i; j <= nums2.size()){\\n                result = std::max(result, merge(getMax(nums1, i), getMax(nums2, j)));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    std::deque<int> getMax(const std::vector<int> &nums, int k)\\n    {\\n        if(k == 0){\\n            return {};\\n        }\\n        \\n        std::deque<int> result;\\n        const int drop = std::max<int>(0, nums.size() - k);\\n\\n        for(int d = 0; const auto e: nums){\\n            while(!result.empty() && result.back() < e && d < drop){\\n                result.pop_back();\\n                d++;\\n            }\\n            result.push_back(e);\\n        }\\n        \\n        while(result.size() > k){\\n            result.resize(k);\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> merge(std::deque<int> p, std::deque<int> q)\\n    {\\n        std::vector<int> result;\\n        while(!(p.empty() && q.empty())){\\n            if(p > q){\\n                result.push_back(p.front());\\n                p.pop_front();\\n            }\\n            else{\\n                result.push_back(q.front());\\n                q.pop_front();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        std::vector<int> result;\\n        for(int i = 0; i <= k && i <= nums1.size(); ++i){\\n            if(int j = k - i; j <= nums2.size()){\\n                result = std::max(result, merge(getMax(nums1, i), getMax(nums2, j)));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387317,
                "title": "concise-commented-dp-greedy-soln",
                "content": "\\nclass Solution {\\npublic:\\n    vector<string> single_array(vector<int>& arr1,int k)\\n    {\\n        int n = arr1.size();\\n        vector<vector<string>> dp(min(n,k),vector<string>(n,\"\"));//i+1 digits and ending at j maintaining ordering\\n        vector<string> dp1(min(n,k),\"\"); //max i-digit number formed maintaing ordering\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j].push_back((char)(arr1[j]+\\'0\\'));\\n            dp1[0] = max(dp1[0],dp[0][j]);\\n            if(j>0) dp[0][j] = max(dp[0][j],dp[0][j-1]);\\n        }\\n        \\n        for(int i=1;i<dp1.size();i++)\\n        {\\n            // num of digits required is i+1\\n            // we start at i, not before that\\n            for(int j=i;j<n;j++)\\n            {\\n                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+(char)(arr1[j]+\\'0\\'));\\n                dp1[i] = max(dp[i][j],dp1[i]);\\n                if(j>i) dp[i][j] = max(dp[i][j],dp[i][j-1]); \\n                // beware : max on strings works as expected when both strings are of same size\\n            }\\n        }\\n        return dp1;\\n        \\n    }\\n    \\n    string merge(string r1,string r2)\\n    {\\n        string fin = \"\";\\n        int n = r1.size();\\n        int m = r2.size();\\n        int p1 = 0;\\n        int p2 = 0;\\n        while(p1<n && p2<m)\\n        {\\n            if(r1[p1]>r2[p2])\\n            {\\n                fin.push_back(r1[p1]);\\n                p1++;\\n            }\\n            else if(r1[p1]<r2[p2])\\n            {\\n                fin.push_back(r2[p2]);\\n                p2++;\\n            }\\n            else\\n            {\\n                if(r1.substr(p1)>=r2.substr(p2))\\n                {\\n                    fin.push_back(r1[p1]);\\n                    p1++;\\n                }\\n                else\\n                {\\n                    fin.push_back(r2[p2]);\\n                    p2++;\\n                }\\n            }\\n        }\\n        while(p1<n) \\n        {\\n            fin.push_back(r1[p1]);p1++;\\n        }\\n        while(p2<m) \\n        {\\n            fin.push_back(r2[p2]);p2++;\\n        }\\n        return fin;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& arr1, vector<int>& arr2, int k) \\n    {\\n        vector<int> ans;\\n        int n = arr1.size();\\n        int m = arr2.size();\\n        if(n==0 && m==0) return ans;\\n        if(k==0) return ans;\\n        \\n        vector<string> dp1 = single_array(arr1,k);\\n        vector<string> dp2 = single_array(arr2,k);\\n        \\n        string an = \"\";\\n        for(int i=0;i<=k;i++)\\n        {\\n            int sz1 = i;\\n            int sz2 = k-i;\\n            if(sz1==0 && sz2<=m) an = max(an,dp2[sz2-1]);\\n            else if(sz2==0 && sz1<=n) an = max(an,dp1[sz1-1]);\\n            else if(sz1<=n && sz2<=m) an = max(an,merge(dp1[sz1-1],dp2[sz2-1]));\\n        }\\n        \\n        \\n        for(auto c:an) ans.push_back(c-\\'0\\');\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> single_array(vector<int>& arr1,int k)\\n    {\\n        int n = arr1.size();\\n        vector<vector<string>> dp(min(n,k),vector<string>(n,\"\"));//i+1 digits and ending at j maintaining ordering\\n        vector<string> dp1(min(n,k),\"\"); //max i-digit number formed maintaing ordering\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j].push_back((char)(arr1[j]+\\'0\\'));\\n            dp1[0] = max(dp1[0],dp[0][j]);\\n            if(j>0) dp[0][j] = max(dp[0][j],dp[0][j-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 968913,
                "title": "bfs-runtime-112-ms-faster-than-100-00-current-python",
                "content": "Runtime: 112 ms, faster than 100.00%\\nMemory Usage: 14.4 MB, less than 63.64%\\n# Explanation:\\nLet N1 be the lenghth of nums1, and N2 the length of nums2.\\nThe `remain` is initialized to `k`, and reduced by 1 after choosed a candidate every time.\\n\\nThe 1st candidate must be in `nums1[0:min(len(nums1), max_skip+1)]` and `nums2[0:min(len(nums2), max_skip+1)]`, and the `max_skip` is the max number we can drop which equal to `N1 + N2 - remain`.\\n\\nAsume we get the 1st number at index `i1` in nums1.\\nThe 2nd candidate must be in `nums1[i1+1:min(len(nums1), i1+1+max_skip+1)]` and `nums2[0:min(len(nums2), max_skip+1)]`. the `max_skip` is `N1-i1+N2-0-remain`\\n....\\nThe (k+1)th candidate must be in `nums1[i1+1:min(len(nums1), i1+1+max_skip+1)]` and `nums2[i2+1:min(len(nums2), i2+1+max_skip+1)]`. the `max_skip` is `N1-i1+N2-i2-remain`\\n\\nFor each level (represented by remain), we can we choose the best value for the current number.\\n\\nI hope this solution can help you.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: [int], nums2: [int], k: int) -> [int]:\\n        N1 = len(nums1)\\n        N2 = len(nums2)\\n\\n        def _get_candidate(nums, start, max_skip):\\n            j = start\\n            v = -1\\n            for i in range(start, min(len(nums), start+max_skip+1)):\\n                if v < nums[i]:\\n                    j = i\\n                    v = nums[j]\\n                    if nums[j] == 9:break\\n            return j,v\\n        \\n        next_candidates = {(0,0)}\\n        ret = [0]*k\\n        for remain in range(k,0,-1):\\n            candidates = next_candidates\\n            next_candidates = set()\\n            value_max = -1\\n            for (i1,i2) in candidates:\\n                if i1 >= N1 and i2 >= N2: continue\\n                r1 = N1 - i1\\n                r2 = N2 - i2\\n                max_skip = r1 + r2 - remain\\n\\n                j1,v1 = _get_candidate(nums1, i1, max_skip)\\n                j2,v2 = _get_candidate(nums2, i2, max_skip)\\n\\n                if v1 > value_max:\\n                    next_candidates = {(j1+1, i2)}\\n                    value_max = v1\\n                elif v1 == value_max:\\n                    next_candidates.add((j1+1, i2))\\n                \\n                if v2 > value_max:\\n                    next_candidates = {(i1, j2+1)}\\n                    value_max = v2\\n                elif v2 == value_max:\\n                    next_candidates.add((i1, j2+1))\\n            ret[-remain] = value_max\\n            \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: [int], nums2: [int], k: int) -> [int]:\\n        N1 = len(nums1)\\n        N2 = len(nums2)\\n\\n        def _get_candidate(nums, start, max_skip):\\n            j = start\\n            v = -1\\n            for i in range(start, min(len(nums), start+max_skip+1)):\\n                if v < nums[i]:\\n                    j = i\\n                    v = nums[j]\\n                    if nums[j] == 9:break\\n            return j,v\\n        \\n        next_candidates = {(0,0)}\\n        ret = [0]*k\\n        for remain in range(k,0,-1):\\n            candidates = next_candidates\\n            next_candidates = set()\\n            value_max = -1\\n            for (i1,i2) in candidates:\\n                if i1 >= N1 and i2 >= N2: continue\\n                r1 = N1 - i1\\n                r2 = N2 - i2\\n                max_skip = r1 + r2 - remain\\n\\n                j1,v1 = _get_candidate(nums1, i1, max_skip)\\n                j2,v2 = _get_candidate(nums2, i2, max_skip)\\n\\n                if v1 > value_max:\\n                    next_candidates = {(j1+1, i2)}\\n                    value_max = v1\\n                elif v1 == value_max:\\n                    next_candidates.add((j1+1, i2))\\n                \\n                if v2 > value_max:\\n                    next_candidates = {(i1, j2+1)}\\n                    value_max = v2\\n                elif v2 == value_max:\\n                    next_candidates.add((i1, j2+1))\\n            ret[-remain] = value_max\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721063,
                "title": "go-divide-and-conquer",
                "content": "```\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n    res := make([]int, k)\\n    for i := 0; i <= k; i++ {\\n        if len(nums1) >= i && len(nums2) >= k - i {\\n            res1 := getMax(nums1, i)\\n            res2 := getMax(nums2, k - i)\\n            temp := merge(res1, res2)\\n            if isLarger(temp, res) {\\n                res = temp\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc getMax(nums []int, k int) []int {\\n    discard := len(nums) - k\\n    var stack []int\\n    for i := 0; i < len(nums); i++ {\\n        for len(stack) > 0 && discard > 0 && stack[len(stack) - 1] < nums[i] {\\n            stack = stack[:len(stack) - 1]\\n            discard--\\n        }\\n        stack = append(stack, nums[i])\\n    }\\n    return stack[:k]\\n}\\n\\nfunc merge(a []int, b []int) []int {\\n    var res []int\\n    for len(a) > 0 && len(b) > 0 {\\n        if isLarger(a, b) {\\n            res = append(res, a[0])\\n            a = a[1:]\\n        } else {\\n            res = append(res, b[0])\\n            b = b[1:]\\n        }\\n    }\\n    \\n    if len(a) > 0 {\\n        res = append(res, a...)\\n    }\\n    \\n    if len(b) > 0 {\\n        res = append(res, b...)\\n    }\\n    \\n    return res\\n}\\n\\nfunc isLarger(a []int, b []int) bool {\\n    l := min(len(a), len(b))\\n    for i := 0; i < l; i++ {\\n        if a[i] < b[i] {\\n            return false\\n        } else if a[i] > b[i] {\\n            return true\\n        }\\n    }\\n    return len(a) > len(b)\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n    res := make([]int, k)\\n    for i := 0; i <= k; i++ {\\n        if len(nums1) >= i && len(nums2) >= k - i {\\n            res1 := getMax(nums1, i)\\n            res2 := getMax(nums2, k - i)\\n            temp := merge(res1, res2)\\n            if isLarger(temp, res) {\\n                res = temp\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc getMax(nums []int, k int) []int {\\n    discard := len(nums) - k\\n    var stack []int\\n    for i := 0; i < len(nums); i++ {\\n        for len(stack) > 0 && discard > 0 && stack[len(stack) - 1] < nums[i] {\\n            stack = stack[:len(stack) - 1]\\n            discard--\\n        }\\n        stack = append(stack, nums[i])\\n    }\\n    return stack[:k]\\n}\\n\\nfunc merge(a []int, b []int) []int {\\n    var res []int\\n    for len(a) > 0 && len(b) > 0 {\\n        if isLarger(a, b) {\\n            res = append(res, a[0])\\n            a = a[1:]\\n        } else {\\n            res = append(res, b[0])\\n            b = b[1:]\\n        }\\n    }\\n    \\n    if len(a) > 0 {\\n        res = append(res, a...)\\n    }\\n    \\n    if len(b) > 0 {\\n        res = append(res, b...)\\n    }\\n    \\n    return res\\n}\\n\\nfunc isLarger(a []int, b []int) bool {\\n    l := min(len(a), len(b))\\n    for i := 0; i < l; i++ {\\n        if a[i] < b[i] {\\n            return false\\n        } else if a[i] > b[i] {\\n            return true\\n        }\\n    }\\n    return len(a) > len(b)\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720999,
                "title": "10-lines-with-explanation",
                "content": "### Gready + Merge Sort\\nSince we need construct the maximum number from given arrays, the gready approach seems to be the core diea resovling this problem, which is to select the maximum number and check if we can pick it. We can\\'t pick the current number if the number of remaining elements are smaller than *K* as we don\\'t have enough elements to pick *k* times. There are two different apparchs for us to select maximum elements. The first one is to find maximum between 2 arrays, namely we combine 2 arraysy and pick the maximum number to construct the global maximum result. The other one is to select maximum number for each array respectively, and merge it as local maximum and return the maximum one. As the local maximum is not always the global maximum in the first approach, we need go with second appraoch, which is much easier to implement as well.\\nHence, the algorithm could be\\n1. We pick the first `length` th maximum numbers from *nums1* and the other `k - length` th maximum numbers from *nums2*\\n2. Construct the local maximum nubmer by merging and record it if it\\'s the maximum so far\\n3. Repeat the process for the `length` + 1 until it reaches the `min(k, nums1.length)`\\n\\nNote, we have variance on the `merge`, where we pick larger one if `nums1[i] != nums2[j]`, otherwise the one with larger successors.\\n\\n```python\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        \\n        def getMax(nums, k):\\n            ans, i, n = [], 0, len(nums)\\n            while i < n:\\n                while ans and nums[i] > ans[-1] and n - i + len(ans) > k:\\n                    ans.pop()\\n                ans.append(nums[i]) \\n                i += 1\\n            return ans[:k]\\n        \\n        def merge(nums1, nums2):\\n            return [max(nums1, nums2).popleft() for _ in range(len(nums1) + len(nums2))]\\n            \\n        return max(merge(deque(getMax(nums1, length)), deque(getMax(nums2, k - length))) for length in range(max(0, k - n), min(k, m) + 1))\\n```\\n\\n*Time Complexity* = **O(k(n1 + n2)^2)**, *n1*, *n2* denotes the length of arrays respectively\\n*Space Complexity* = **O(k)**",
                "solutionTags": [],
                "code": "```python\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m = len(nums1)\\n        n = len(nums2)\\n        \\n        def getMax(nums, k):\\n            ans, i, n = [], 0, len(nums)\\n            while i < n:\\n                while ans and nums[i] > ans[-1] and n - i + len(ans) > k:\\n                    ans.pop()\\n                ans.append(nums[i]) \\n                i += 1\\n            return ans[:k]\\n        \\n        def merge(nums1, nums2):\\n            return [max(nums1, nums2).popleft() for _ in range(len(nums1) + len(nums2))]\\n            \\n        return max(merge(deque(getMax(nums1, length)), deque(getMax(nums2, k - length))) for length in range(max(0, k - n), min(k, m) + 1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694946,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        if(A.length==0)return get(B,k,true);\\n        if(B.length==0)return get(A,k,true);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            int A1[]=get(A,i,false);\\n            int A2[]=get(B,k-i,false);\\n            if(A1==null||A2==null)continue;\\n            int newA[]=merge(A1,A2);\\n            if(compare(res,newA)){\\n                res=newA;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean compare(int A[],int B[]){\\n        for(int i=0;i<A.length;i++){\\n            if(B[i]==A[i])continue;\\n            if(B[i]>A[i])return true;\\n            else return false;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] merge(int A[],int B[]){\\n        int res[]=new int[A.length+B.length-2];\\n        int i=0,j=0,k=0;\\n        while(i<A.length-1&&j<B.length-1){\\n            if(A[i]>B[j]){\\n                res[k++]=A[i++];\\n            }else if(B[j]>A[i]){\\n                res[k++]=B[j++];\\n            }else{//equal\\n                int ii=i,jj=j;\\n                int prei=i,prej=j;\\n                while(ii<A.length-1&&jj<B.length-1){\\n                    while(ii<A.length-1&&A[ii]==A[prei])ii++;\\n                    while(jj<B.length-1&&B[jj]==B[prej])jj++;\\n                    if(ii<A.length-1&&jj<B.length-1&&A[ii]==B[jj]&&(ii-i==jj-j)){\\n                        prei=ii;prej=jj;\\n                        continue;\\n                    }\\n                    else break;\\n                }\\n                if(ii-i==jj-j){\\n                    if(A[ii]>B[jj])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else if(ii-i<jj-j){\\n                    if(A[ii]>B[prej])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else{\\n                   if(B[jj]>A[prei])res[k++]=B[j++];\\n                    else res[k++]=A[i++]; \\n                }\\n                \\n            }\\n        }\\n        while(i<A.length-1)res[k++]=A[i++];\\n        while(j<B.length-1)res[k++]=B[j++];\\n        return res;\\n    }\\n    \\n    public void print(int A[]){\\n        for(int i:A)System.out.print(i+\"  \");\\n        System.out.println();\\n    }\\n    \\n    public int[] get(int A[],int k,boolean flag){\\n        if(k>A.length)return null;\\n        Stack<Integer>stack=new Stack<>();\\n        int res[]=new int[k];\\n        for(int i=0;i<A.length;i++){\\n            int remain=A.length-(i+1);\\n            while(stack.size()!=0&&A[i]>stack.peek()&&stack.size()+remain>=k)stack.pop();\\n            stack.push(A[i]);\\n        }\\n        int index=res.length-1;\\n        while(stack.size()>k)stack.pop();\\n        while(stack.size()!=0){\\n            res[index--]=stack.pop();\\n        }\\n        if(flag)return res;\\n        int ans[]=new int[res.length+1];\\n        for(int i=0;i<res.length;i++)ans[i]=res[i];\\n        ans[ans.length-1]=Integer.MIN_VALUE;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] A, int[] B, int k) {\\n        if(A.length==0)return get(B,k,true);\\n        if(B.length==0)return get(A,k,true);\\n        int res[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            int A1[]=get(A,i,false);\\n            int A2[]=get(B,k-i,false);\\n            if(A1==null||A2==null)continue;\\n            int newA[]=merge(A1,A2);\\n            if(compare(res,newA)){\\n                res=newA;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean compare(int A[],int B[]){\\n        for(int i=0;i<A.length;i++){\\n            if(B[i]==A[i])continue;\\n            if(B[i]>A[i])return true;\\n            else return false;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] merge(int A[],int B[]){\\n        int res[]=new int[A.length+B.length-2];\\n        int i=0,j=0,k=0;\\n        while(i<A.length-1&&j<B.length-1){\\n            if(A[i]>B[j]){\\n                res[k++]=A[i++];\\n            }else if(B[j]>A[i]){\\n                res[k++]=B[j++];\\n            }else{//equal\\n                int ii=i,jj=j;\\n                int prei=i,prej=j;\\n                while(ii<A.length-1&&jj<B.length-1){\\n                    while(ii<A.length-1&&A[ii]==A[prei])ii++;\\n                    while(jj<B.length-1&&B[jj]==B[prej])jj++;\\n                    if(ii<A.length-1&&jj<B.length-1&&A[ii]==B[jj]&&(ii-i==jj-j)){\\n                        prei=ii;prej=jj;\\n                        continue;\\n                    }\\n                    else break;\\n                }\\n                if(ii-i==jj-j){\\n                    if(A[ii]>B[jj])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else if(ii-i<jj-j){\\n                    if(A[ii]>B[prej])res[k++]=A[i++];\\n                    else res[k++]=B[j++];\\n                }else{\\n                   if(B[jj]>A[prei])res[k++]=B[j++];\\n                    else res[k++]=A[i++]; \\n                }\\n                \\n            }\\n        }\\n        while(i<A.length-1)res[k++]=A[i++];\\n        while(j<B.length-1)res[k++]=B[j++];\\n        return res;\\n    }\\n    \\n    public void print(int A[]){\\n        for(int i:A)System.out.print(i+\"  \");\\n        System.out.println();\\n    }\\n    \\n    public int[] get(int A[],int k,boolean flag){\\n        if(k>A.length)return null;\\n        Stack<Integer>stack=new Stack<>();\\n        int res[]=new int[k];\\n        for(int i=0;i<A.length;i++){\\n            int remain=A.length-(i+1);\\n            while(stack.size()!=0&&A[i]>stack.peek()&&stack.size()+remain>=k)stack.pop();\\n            stack.push(A[i]);\\n        }\\n        int index=res.length-1;\\n        while(stack.size()>k)stack.pop();\\n        while(stack.size()!=0){\\n            res[index--]=stack.pop();\\n        }\\n        if(flag)return res;\\n        int ans[]=new int[res.length+1];\\n        for(int i=0;i<res.length;i++)ans[i]=res[i];\\n        ans[ans.length-1]=Integer.MIN_VALUE;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678498,
                "title": "c-a-horrible-but-efficient-solution",
                "content": "The idea is to build a binary tree based on sorted indices. The binary tree definition is as follows:\\n\\n```\\nstruct MyTreeNode{\\n\\xA0 \\xA0 MyTreeNode(int idx, int val): idx(idx), val(val), left(nullptr), right(nullptr){}\\n\\xA0\\n\\xA0 \\xA0 int idx;\\n\\xA0 \\xA0 int val;\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 MyTreeNode * left;\\n\\xA0 \\xA0 MyTreeNode * right;\\n};\\n```\\n\\nTha property val holds the value and idx holds the corresponding inex.\\nWe build a binary tree from each of the input arrays as follows. First we pick the largest element in the vector. Suppose it has index i. We create the root node from it. The index i splits the vector into two  (not necessarily equal) parts. The right node of the root is the largest element on the right side, i.e. max(nums[j] ) j>i and the left one is the largest in the left side.  \\n\\nThe code that builds the binary tree looks as follows:\\n\\n```\\nMyTreeNode * getTree( const vector<int>& nums){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nums.empty())\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return nullptr;\\n\\t\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> indices(nums.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 0; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 indices[i] = i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// after this the vector indices will hold the indices that sort nums in descending order\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(indices.begin(), indices.end(), [&](const int & a, const int &b){ if(nums[a] == nums[b]) return a <b; else return nums[a] > nums[b]; });\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * head = new MyTreeNode(indices[0], nums[indices[0]]); \\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 1; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head, indices[i], nums[indices[i]]);\\n\\xA0 \\xA0 \\xA0 \\xA0 return head;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void insert(MyTreeNode * head, int idx, int val){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(idx > head->idx) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->right)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->right, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->right = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->left)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->left, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->left = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n```\\n\\nHaving the corresponding tree it easy to find the next candidate element to pick. For each array we keep the last picked index idx1 ord idx2. \\n\\nWe start from the root of each tree. The candidate node should have idx value greater than the last picked index. So, if for any node *cur* this condition is not satisfyed we move to its right child.  On the other hand, the element can be so much right in the array, that the number of the remaining items is not enough for filling the resulting vector with k elements. If this is the case then we move to the left. As soon as we arrive to a node, we can be sure that it is the largest node that satifies both requirements.\\n\\nThe code for this navigation reads:\\n\\n```\\nMyTreeNode * \\xA0getCandidate(MyTreeNode * node, int idx1, int remaining_items){\\n\\xA0 \\xA0 while(node){\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(remaining_items \\xA0- \\xA0node->idx < 0)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->left;\\n\\xA0 \\xA0 \\xA0 \\xA0 else if (node->idx <= idx1 )\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->right;\\n\\xA0 \\xA0 \\xA0 \\xA0 else \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n \\xA0 }\\n\\xA0 \\xA0return node;\\n}\\n```\\n\\n**Solution with no collisions** (Attention: this one is not accepted).\\n\\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    MyTreeNode * cur1 = getCandidate(t1, idx1, nums1.size() \\xA0+ nums2.size() - idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * cur2 = getCandidate(t2, idx2, nums1.size() \\xA0+ nums2.size() - idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t// We then merge sort these trees into the result\\n\\t\\t\\tif(cur1 && cur2){\\n\\t\\t\\t    if(cur1->val == cur2->val){\\n\\t\\t\\t\\t    // this one is tricky so let us for a moment assume that we do not encounter such cases\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(cur1->val > cur2->val){\\n\\t\\t\\t\\t    // Move the last picked index of the first array \\n\\t\\t\\t\\t    idx1 = cur1->idx;\\n\\t\\t\\t\\t\\t// Append to the result\\n\\t\\t\\t\\t\\tresult.push_back(cur1->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\t\\tresult.push_back(cur2->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(cur1){\\n\\t\\t\\t     idx1 = cur1->idx;\\n\\t\\t\\t     result.push_back(cur1->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\tresult.push_back(cur2->val);\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\\n\\nThe problem arises when the values of the candidate nodes are equal. I could not find a better solution to this rather than to maintain all possible paths until at some stage some of the paths give a smaller value to pick. For this reason let us introduce\\n\\n```\\nstruct State{\\n\\xA0 \\xA0 State(int idx1, int idx2, int value=numeric_limits<int>::min()): idx1(idx1), idx2(idx2), max_value(value){}\\n\\t\\n\\tint idx1;\\n\\xA0 \\xA0 int idx2; \\xA0 \\n\\xA0 \\xA0 int max_value;\\n\\t\\n    bool operator ==(const State & other) const {\\n        return idx1 == other.idx1 && idx2 == other.idx2;\\n    }\\n};\\n```\\n\\n\\nAnd the code becomes (ugly!!!):\\n\\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tlist<State> states;\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 states.push_front (State(-1,-1));\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    int max_value = numeric_limits<int>::min();\\n\\t\\t\\tlist<State> states_to_add;\\n\\t\\t    for(State & st: states){\\n\\n                MyTreeNode * cur1 = getCandidate(t1, st.idx1, nums1.size() \\xA0+ nums2.size() - st.idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0     MyTreeNode * cur2 = getCandidate(t2, st.idx2, nums1.size() \\xA0+ nums2.size() - st.idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t    // We then merge sort these trees into the result\\n\\t\\t\\t    if(cur1 && cur2){\\n\\t\\t\\t        if(cur1->val == cur2->val){\\n\\t\\t\\t\\t        // We create 2 new states instead of one so that the comuptation will be done for both possible paths\\n\\t\\t\\t\\t\\t\\tmax_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(cur1->idx, st.idx2, cur1->value));\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(st.idx1, cur2->idx, cur2->value));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// We set this so it is removed in below\\n\\t\\t\\t\\t\\t\\tst.max_value = numeric_limits<int>::min();\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else if(cur1->val > cur2->val){\\t\\t\\t\\t    \\n\\t\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else {\\n\\t\\t\\t\\t         st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t     max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t\\t     st.max_value = cur2->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t\\t    else if(cur1){\\n\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t    }\\n\\t\\t\\t    else{\\n\\t\\t\\t        st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t    st.max_value = cur2->val;\\t\\n\\t\\t\\t    }\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t    result.push_back(max_value);\\n\\t\\t\\t// We should remove all the states which are doing worse than the best one\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n            states.remove_if([&](const State & st){return st.max_value < max_value;});\\n\\t\\t\\t\\n\\t\\t\\t// Add newly create states\\n\\t\\t\\tfor(State st: states_to_add)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(st.max_value == max_value)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 states.push_front(st);\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\\n\\nIt turns out, however, that the picking paths are not unique and states can merge later. I was lazy to find a good solution for this so just copy-pasted a similar code from one of my projects. We just add hashing function to the std namespace (outside any scope )\\n\\n```\\nnamespace std{\\ntemplate<>\\nstruct hash<State> {\\n  std::size_t operator()(const State & state) const noexcept {\\n    std::hash<int> hasher;\\n    size_t seed = hasher(state.idx1);\\n\\t// from boost\\n    seed ^= hasher(state.idx2) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    return seed;\\n  }\\n};\\n}\\n```\\n\\nAnd at the very end of the while(k > result.size()) loop just add this stupid code \\n\\n```\\nunordered_set<State> unique_states(states.begin(), states.end());\\nif(unique_states.size()!= states.size()){\\n    states.clear();\\n    for(const State &st: unique_states)\\n        states.push_front(st);\\n}\\n```\\n\\n\\nI will appretiate if someone points a good way to tackle the state problem and/or any other comments",
                "solutionTags": [],
                "code": "```\\nstruct MyTreeNode{\\n\\xA0 \\xA0 MyTreeNode(int idx, int val): idx(idx), val(val), left(nullptr), right(nullptr){}\\n\\xA0\\n\\xA0 \\xA0 int idx;\\n\\xA0 \\xA0 int val;\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 MyTreeNode * left;\\n\\xA0 \\xA0 MyTreeNode * right;\\n};\\n```\n```\\nMyTreeNode * getTree( const vector<int>& nums){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nums.empty())\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return nullptr;\\n\\t\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> indices(nums.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 0; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 indices[i] = i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// after this the vector indices will hold the indices that sort nums in descending order\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(indices.begin(), indices.end(), [&](const int & a, const int &b){ if(nums[a] == nums[b]) return a <b; else return nums[a] > nums[b]; });\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * head = new MyTreeNode(indices[0], nums[indices[0]]); \\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i = 1; i < indices.size(); ++i)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head, indices[i], nums[indices[i]]);\\n\\xA0 \\xA0 \\xA0 \\xA0 return head;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void insert(MyTreeNode * head, int idx, int val){\\n\\xA0 \\xA0 \\xA0 \\xA0 if(idx > head->idx) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->right)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->right, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->right = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(head->left)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 insert(head->left, idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 else\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 head->left = new MyTreeNode(idx, val);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n```\n```\\nMyTreeNode * \\xA0getCandidate(MyTreeNode * node, int idx1, int remaining_items){\\n\\xA0 \\xA0 while(node){\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(remaining_items \\xA0- \\xA0node->idx < 0)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->left;\\n\\xA0 \\xA0 \\xA0 \\xA0 else if (node->idx <= idx1 )\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 node = node->right;\\n\\xA0 \\xA0 \\xA0 \\xA0 else \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n \\xA0 }\\n\\xA0 \\xA0return node;\\n}\\n```\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    MyTreeNode * cur1 = getCandidate(t1, idx1, nums1.size() \\xA0+ nums2.size() - idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * cur2 = getCandidate(t2, idx2, nums1.size() \\xA0+ nums2.size() - idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t// We then merge sort these trees into the result\\n\\t\\t\\tif(cur1 && cur2){\\n\\t\\t\\t    if(cur1->val == cur2->val){\\n\\t\\t\\t\\t    // this one is tricky so let us for a moment assume that we do not encounter such cases\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(cur1->val > cur2->val){\\n\\t\\t\\t\\t    // Move the last picked index of the first array \\n\\t\\t\\t\\t    idx1 = cur1->idx;\\n\\t\\t\\t\\t\\t// Append to the result\\n\\t\\t\\t\\t\\tresult.push_back(cur1->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\t\\tresult.push_back(cur2->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(cur1){\\n\\t\\t\\t     idx1 = cur1->idx;\\n\\t\\t\\t     result.push_back(cur1->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t    idx2 = cur2->idx;\\n\\t\\t\\t\\tresult.push_back(cur2->val);\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\n```\\nstruct State{\\n\\xA0 \\xA0 State(int idx1, int idx2, int value=numeric_limits<int>::min()): idx1(idx1), idx2(idx2), max_value(value){}\\n\\t\\n\\tint idx1;\\n\\xA0 \\xA0 int idx2; \\xA0 \\n\\xA0 \\xA0 int max_value;\\n\\t\\n    bool operator ==(const State & other) const {\\n        return idx1 == other.idx1 && idx2 == other.idx2;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n   vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        MyTreeNode * t1 = getTree(nums1);\\n\\xA0 \\xA0 \\xA0 \\xA0 MyTreeNode * t2 = getTree(nums2);\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> result;\\n\\t\\t\\n\\t\\tlist<State> states;\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 states.push_front (State(-1,-1));\\n\\t\\t\\n\\t\\tint idx1 = -1, idx2 = -1;\\n\\t\\twhile(k > result.size()){\\n\\t\\t    int max_value = numeric_limits<int>::min();\\n\\t\\t\\tlist<State> states_to_add;\\n\\t\\t    for(State & st: states){\\n\\n                MyTreeNode * cur1 = getCandidate(t1, st.idx1, nums1.size() \\xA0+ nums2.size() - st.idx2 -1 - k + result.size());\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0     MyTreeNode * cur2 = getCandidate(t2, st.idx2, nums1.size() \\xA0+ nums2.size() - st.idx1 -1 - k + result.size());\\n\\t\\t\\t\\n\\t\\t\\t    // We then merge sort these trees into the result\\n\\t\\t\\t    if(cur1 && cur2){\\n\\t\\t\\t        if(cur1->val == cur2->val){\\n\\t\\t\\t\\t        // We create 2 new states instead of one so that the comuptation will be done for both possible paths\\n\\t\\t\\t\\t\\t\\tmax_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(cur1->idx, st.idx2, cur1->value));\\n\\t\\t\\t\\t\\t\\tstates_to_add.push_front(State(st.idx1, cur2->idx, cur2->value));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// We set this so it is removed in below\\n\\t\\t\\t\\t\\t\\tst.max_value = numeric_limits<int>::min();\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else if(cur1->val > cur2->val){\\t\\t\\t\\t    \\n\\t\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    else {\\n\\t\\t\\t\\t         st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t     max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t\\t     st.max_value = cur2->val;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t\\t    else if(cur1){\\n\\t\\t\\t        st.idx1 = cur1->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur1->val );\\n\\t\\t\\t\\t    st.max_value = cur1->val;\\n\\t\\t\\t    }\\n\\t\\t\\t    else{\\n\\t\\t\\t        st.idx2 = cur2->idx;\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t    max_value  = max(max_value, cur2->val );\\n\\t\\t\\t\\t    st.max_value = cur2->val;\\t\\n\\t\\t\\t    }\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t    result.push_back(max_value);\\n\\t\\t\\t// We should remove all the states which are doing worse than the best one\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n            states.remove_if([&](const State & st){return st.max_value < max_value;});\\n\\t\\t\\t\\n\\t\\t\\t// Add newly create states\\n\\t\\t\\tfor(State st: states_to_add)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(st.max_value == max_value)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 states.push_front(st);\\n\\t\\t}\\n\\n    }\\n\\n};\\n```\n```\\nnamespace std{\\ntemplate<>\\nstruct hash<State> {\\n  std::size_t operator()(const State & state) const noexcept {\\n    std::hash<int> hasher;\\n    size_t seed = hasher(state.idx1);\\n\\t// from boost\\n    seed ^= hasher(state.idx2) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n    return seed;\\n  }\\n};\\n}\\n```\n```\\nunordered_set<State> unique_states(states.begin(), states.end());\\nif(unique_states.size()!= states.size()){\\n    states.clear();\\n    for(const State &st: unique_states)\\n        states.push_front(st);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454161,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nbool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j)\\n{\\n\\tint loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n\\tfor (int i = 0; i < loop_size; i++)\\n\\t{\\n\\t\\tif (nums1[i + start_i] < nums2[i + start_j])\\n\\t\\t\\treturn true;\\n\\t\\telse if (nums1[i + start_i] > nums2[i + start_j])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn nums1.size() - start_i < nums2.size() - start_j;\\n}\\n\\nvector<vector<int>> largetsNum(vector<int>& nums)\\n{\\n\\tvector<vector<int>> res;\\n\\tres.resize(nums.size() + 1);\\n\\tres.back() = nums;\\n\\n\\tfor (int i = res.size() - 2; i >= 0; i--)\\n\\t{\\t\\n\\t\\tint idx = 0;\\n\\t\\twhile (idx + 1 < res[i + 1].size())\\n\\t\\t{\\n\\t\\t\\tif (res[i + 1][idx] < res[i + 1][idx + 1])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < res[i + 1].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif (idx != j)\\n\\t\\t\\t\\tres[i].push_back(res[i + 1][j]);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> merge(vector<int>& nums1, vector<int>& nums2)\\n{\\n\\tvector<int> res;\\n\\tint i = 0, j = 0;\\n\\twhile (i < nums1.size() || j < nums2.size())\\n\\t{\\n\\t\\t\\tif (compare(nums1, nums2, i, j))\\n\\t\\t\\t\\tres.push_back(nums2[j++]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tres.push_back(nums1[i++]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) \\n{\\n\\tvector<vector<int>> largest_num1 = largetsNum(nums1);\\n\\tvector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n\\tvector<int> res;\\n\\n\\tint start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n\\tfor (int i = start; i < largest_num1.size() && i <= k; i++)\\n\\t{\\n\\t\\tvector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n\\t\\tif (res.empty() || compare(res, tmp, 0, 0))\\n\\t\\t\\tres = tmp;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nbool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j)\\n{\\n\\tint loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n\\tfor (int i = 0; i < loop_size; i++)\\n\\t{\\n\\t\\tif (nums1[i + start_i] < nums2[i + start_j])\\n\\t\\t\\treturn true;\\n\\t\\telse if (nums1[i + start_i] > nums2[i + start_j])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn nums1.size() - start_i < nums2.size() - start_j;\\n}\\n\\nvector<vector<int>> largetsNum(vector<int>& nums)\\n{\\n\\tvector<vector<int>> res;\\n\\tres.resize(nums.size() + 1);\\n\\tres.back() = nums;\\n\\n\\tfor (int i = res.size() - 2; i >= 0; i--)\\n\\t{\\t\\n\\t\\tint idx = 0;\\n\\t\\twhile (idx + 1 < res[i + 1].size())\\n\\t\\t{\\n\\t\\t\\tif (res[i + 1][idx] < res[i + 1][idx + 1])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 0; j < res[i + 1].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif (idx != j)\\n\\t\\t\\t\\tres[i].push_back(res[i + 1][j]);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> merge(vector<int>& nums1, vector<int>& nums2)\\n{\\n\\tvector<int> res;\\n\\tint i = 0, j = 0;\\n\\twhile (i < nums1.size() || j < nums2.size())\\n\\t{\\n\\t\\t\\tif (compare(nums1, nums2, i, j))\\n\\t\\t\\t\\tres.push_back(nums2[j++]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tres.push_back(nums1[i++]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) \\n{\\n\\tvector<vector<int>> largest_num1 = largetsNum(nums1);\\n\\tvector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n\\tvector<int> res;\\n\\n\\tint start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n\\tfor (int i = start; i < largest_num1.size() && i <= k; i++)\\n\\t{\\n\\t\\tvector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n\\t\\tif (res.empty() || compare(res, tmp, 0, 0))\\n\\t\\t\\tres = tmp;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325763,
                "title": "python-simple-intuitive-3-dimention-solution",
                "content": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, length):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums1) + len(nums2) < length:\\n            return []\\n    \\n        dp = [[[0 for _ in xrange(length + 1)] for _ in xrange(len(nums2) + 1)] for _ in xrange(len(nums1) + 1)]\\n        for k in xrange(1,length + 1):\\n            for j in xrange(k,len(nums2) + 1):\\n                dp[0][j][k] = max(dp[0][j - 1][k],10 * dp[0][j - 1][k - 1] + nums2[j - 1])\\n            for i in xrange(k,len(nums1) + 1):\\n                dp[i][0][k] = max(dp[i - 1][0][k],10 * dp[i - 1][0][k - 1] + nums1[i - 1])\\n                \\n            for i in xrange(1,len(nums1) + 1):\\n                for j in xrange(1,len(nums2) + 1):\\n                    if i + j < k:\\n                        continue\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k],dp[i][j - 1][k])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k - 1] * 10 + nums1[i - 1])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i][j - 1][k - 1] * 10 + nums2[j - 1])\\n            \\n        return map(int,list(str(dp[-1][-1][-1])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, length):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums1) + len(nums2) < length:\\n            return []\\n    \\n        dp = [[[0 for _ in xrange(length + 1)] for _ in xrange(len(nums2) + 1)] for _ in xrange(len(nums1) + 1)]\\n        for k in xrange(1,length + 1):\\n            for j in xrange(k,len(nums2) + 1):\\n                dp[0][j][k] = max(dp[0][j - 1][k],10 * dp[0][j - 1][k - 1] + nums2[j - 1])\\n            for i in xrange(k,len(nums1) + 1):\\n                dp[i][0][k] = max(dp[i - 1][0][k],10 * dp[i - 1][0][k - 1] + nums1[i - 1])\\n                \\n            for i in xrange(1,len(nums1) + 1):\\n                for j in xrange(1,len(nums2) + 1):\\n                    if i + j < k:\\n                        continue\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k],dp[i][j - 1][k])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j][k - 1] * 10 + nums1[i - 1])\\n                    dp[i][j][k] = max(dp[i][j][k],dp[i][j - 1][k - 1] * 10 + nums2[j - 1])\\n            \\n        return map(int,list(str(dp[-1][-1][-1])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221188,
                "title": "python-greedy",
                "content": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m = len(nums1), len(nums2)\\n        ans = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: \\n                continue\\n                \\n            left = self.maxOneNumber(nums1, n, i)\\n            right = self.maxOneNumber(nums2, m, j)\\n            cur = self.merge(collections.deque(left), collections.deque(right))\\n            ans = max(ans, cur)\\n\\n        return ans\\n    \\n    def maxOneNumber(self, nums, n, k):\\n        ans = [-1] * k\\n        j = 0\\n        for i in range(n):\\n            while n - i > k - j and j > 0 and ans[j-1] < nums[i]:\\n                j -= 1\\n            if j < k:\\n                ans[j] = nums[i]\\n                j += 1\\n        return ans\\n    \\n    def merge(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans.append(nums1.popleft())\\n            else:\\n                ans.append(nums2.popleft())\\n        return ans\\n            \\n        \\n    \\n            \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m = len(nums1), len(nums2)\\n        ans = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: \\n                continue\\n                \\n            left = self.maxOneNumber(nums1, n, i)\\n            right = self.maxOneNumber(nums2, m, j)\\n            cur = self.merge(collections.deque(left), collections.deque(right))\\n            ans = max(ans, cur)\\n\\n        return ans\\n    \\n    def maxOneNumber(self, nums, n, k):\\n        ans = [-1] * k\\n        j = 0\\n        for i in range(n):\\n            while n - i > k - j and j > 0 and ans[j-1] < nums[i]:\\n                j -= 1\\n            if j < k:\\n                ans[j] = nums[i]\\n                j += 1\\n        return ans\\n    \\n    def merge(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans.append(nums1.popleft())\\n            else:\\n                ans.append(nums2.popleft())\\n        return ans\\n            \\n        \\n    \\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 190916,
                "title": "the-basic-traditional-dp-solution",
                "content": "Tips: Also this is not the final solution, As you need change the int to string , to solve the integer overload issue.\nbut i think this is the basic DP. thanks\n\nDP[m][i][j] means the largest value when select m elements from A[0]-A[i] and B[0]- B[j] \n\nInit:\nDP[m][0][j] >> seleect 0-m  from  B[0]- B[j] \nDP[m][i][0] >>seleect 0-m  from  A[0]- A[i] \n\nDP:\nDP[m][i][j] = Max(\n\t                                   ++++ did not inlcude [i][j] in m elements+++++\n\t\t\t              res[m][i][j-1];                                              >> select m elements from [i][j-1]\n\t\t\t\t\t\t\t\t\t\tres[m][i-1][j];                                             >> select m elements from [i-1][j]\n\t\t\t\t\t\t\t\t\t\t                   ++++ inlcude [i][j] in m elements+++++                                            \n\t\t\t\t\t\t\t\t\t\tres[m-1][i-1][j]*10+nums1[i-1];                >> end with nums1[i-1]\n\t\t\t\t\t\t\t\t\t\tres[m-1][i][j-1]*10+nums2[j-1];\n\t\t\t\t\t\t\t\t\t\tnums1[i-1]*10^m-1+res[m-1][0][j];         >> start with nums1[i-1]\n\t\t\t\t\t\t\t\t\t\tnums2[j-1]*10^m-1+res[m-1][i][0];\n)\n'''\nclass Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        \n        vector<vector<vector<int> > > res (k+1,vector<vector<int>>(len1+1,vector<int>(len2+1,0)));\n        \n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(j >=m)\n                    {\n                        res[m][0][j] = max(res[m][0][j-1],res[m-1][0][j-1]*10+nums2[j-1]);\n                    }\n                }\n        }\n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int i =1;i<=len1;i++)\n                {\n                    if(i >=m)\n                    {\n                        res[m][i][0] = max(res[m][i-1][0],res[m-1][i-1][0]*10+nums1[i-1]);\n                    }\n                }\n        }\n        \n        for(int m=1;m<=k;m++)\n        {\n            for(int i=1; i<=len1;i++)\n            {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(i+j >=m)\n                    {\n                        vector<int> tmp;\n                        tmp.push_back(res[m][i][j-1]);\n                        tmp.push_back(res[m][i-1][j]);\n                        \n                        tmp.push_back(res[m-1][i-1][j]*10+nums1[i-1]);\n                        tmp.push_back(res[m-1][i][j-1]*10+nums2[j-1]);\n                        \n                        int dl = 0;\n                        int dt = 0;\n                        for(int p=0;p<m-1;p++)\n                        {\n                           dl = nums1[i-1]*10;\n                           dt = nums2[j-1]*10;\n                        }\n                        tmp.push_back(dl+res[m-1][0][j]);\n                        tmp.push_back(dt+res[m-1][i][0]);\n                        \n                        sort(tmp.begin(),tmp.end());\n                        res[m][i][j] = tmp[tmp.size()-1];\n                    }\n                }\n                   \n            }\n        }\n        \n        int ans = res[k][len1][len2];\n        vector<int> data;\n        while(ans!=0)\n        {\n            data.push_back(ans%10);\n            ans =ans/10;\n        }\n        reverse(data.begin(),data.end());\n        return data;\n    }\n};\n'''",
                "solutionTags": [],
                "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        \n        vector<vector<vector<int> > > res (k+1,vector<vector<int>>(len1+1,vector<int>(len2+1,0)));\n        \n        \n        for(int m=1;m<=k;m++)\n        {\n                for(int j =1;j<=len2;j++)\n                {\n                    if(j >=m)\n                    {\n                        res[m][0][j] = max(res[m][0][j-1],res[m-1][0][j-1]*10+nums2[j-1]);\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 174212,
                "title": "my-readable-python-solution",
                "content": "* After struggling for awhile, i came with this solution and i think most of the solutions are similar.\\n* If we will make an array of length k, we can take some elements from nums1, and complete rest from nums2.\\n* Logic is simple. Get the max possible array from the targeted array in makeArr function.\\n* Merge two array one by one to get merged max array.\\n* Return max merged array from choices.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        def merge(arr1, arr2):\\n            res, i, j = [], 0, 0\\n            while i < len(arr1) and j < len(arr2):\\n                if arr1[i:] >= arr2[j:]:\\n                    res.append(arr1[i])\\n                    i += 1\\n                else: \\n                    res.append(arr2[j])\\n                    j += 1\\n            if i < len(arr1): res += arr1[i:]\\n            elif j < len(arr2): res += arr2[j:]\\n            return res     \\n        \\n        def makeArr(arr, l):\\n            i, res = 0, []\\n            for r in range(l - 1, -1, -1):\\n                num, i = max(arr[i:-r] or arr[i:])\\n                i = -i + 1\\n                res.append(num)\\n            return res\\n        \\n        nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []\\n        for m in range(k + 1):\\n            if m > len(nums1) or k - m > len(nums2): continue\\n            arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)  \\n            choices.append(merge(arr1, arr2))\\n        return max(choices)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        def merge(arr1, arr2):\\n            res, i, j = [], 0, 0\\n            while i < len(arr1) and j < len(arr2):\\n                if arr1[i:] >= arr2[j:]:\\n                    res.append(arr1[i])\\n                    i += 1\\n                else: \\n                    res.append(arr2[j])\\n                    j += 1\\n            if i < len(arr1): res += arr1[i:]\\n            elif j < len(arr2): res += arr2[j:]\\n            return res     \\n        \\n        def makeArr(arr, l):\\n            i, res = 0, []\\n            for r in range(l - 1, -1, -1):\\n                num, i = max(arr[i:-r] or arr[i:])\\n                i = -i + 1\\n                res.append(num)\\n            return res\\n        \\n        nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []\\n        for m in range(k + 1):\\n            if m > len(nums1) or k - m > len(nums2): continue\\n            arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)  \\n            choices.append(merge(arr1, arr2))\\n        return max(choices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169934,
                "title": "a-tip-for-c-programmer",
                "content": "The basic idea is sorts of like brute force, since we just pick 1 number from nums1, k-1 from nums2, \\nnext we pick 2 from nums1, k-2 from nums2 , and so on........\\nThanks to post \"share my greedy solution\"(ranking number 1 under this topic), I write a similiar one, but in C++.\\nThe only thing I\\'d like to share is, under such situation, it seems that we need to always copy a vector to another. And this will cost a lot. \\nBut actually it shouldn\\'t. Unlike Java, if you do something like`int a[] , int b[], a = b`, in java, the just a copy of **reference** , but in c++, it will automatically call the **copy** method, which indeed costs a lot.\\nHowever we can still use assignment in term of reference by calling std::move. And if you do not know the method or the difference between rvalue and lvalue, please look up on C++ reference......\\n```\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k,0);\\n        for (int i=std::max(0,k-m);i<=k && i<=n;i++){\\n            vector<int> candidate = std::move(merge(maxArray(nums1,i),maxArray(nums2,k-i)));\\n            if (greater(candidate,0,ans,0)) ans = std::move(candidate);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n        while (i<nums1.size() && j< nums2.size() && nums1[i] == nums2[j]){i++;j++;}\\n        return (j == nums2.size()) || (i<nums1.size() && nums1[i] > nums2[j]);\\n    }\\n    vector<int> merge(vector<int> && nums1, vector<int> && nums2){\\n        int k = nums1.size() + nums2.size();\\n        vector<int> ans(k);\\n        for (int r=0, i = 0 , j = 0; r < k ;r++)\\n             ans[r] = greater(nums1,i,nums2,j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    vector<int> maxArray(vector<int> & nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(k);\\n        for (int i=0,j=0;i<n;i++){\\n            while (n-i+j > k && j > 0 && ans[j-1] < nums[i]) j--;\\n            if (j<k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n```\\nHope it helps.",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k,0);\\n        for (int i=std::max(0,k-m);i<=k && i<=n;i++){\\n            vector<int> candidate = std::move(merge(maxArray(nums1,i),maxArray(nums2,k-i)));\\n            if (greater(candidate,0,ans,0)) ans = std::move(candidate);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n        while (i<nums1.size() && j< nums2.size() && nums1[i] == nums2[j]){i++;j++;}\\n        return (j == nums2.size()) || (i<nums1.size() && nums1[i] > nums2[j]);\\n    }\\n    vector<int> merge(vector<int> && nums1, vector<int> && nums2){\\n        int k = nums1.size() + nums2.size();\\n        vector<int> ans(k);\\n        for (int r=0, i = 0 , j = 0; r < k ;r++)\\n             ans[r] = greater(nums1,i,nums2,j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    vector<int> maxArray(vector<int> & nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(k);\\n        for (int i=0,j=0;i<n;i++){\\n            while (n-i+j > k && j > 0 && ans[j-1] < nums[i]) j--;\\n            if (j<k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 111742,
                "title": "share-my-java-solution",
                "content": "find(): for every possible combination of digit counts from the two arrays, find the digits from each array that is the largest.\\nmerge(): merge two arrays of digits found from the two arrays.\\ncompare(): compare the current merged number with existing one.\\n\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res = new int[k];\\n        for(int i = 0; i <= k; i ++) {\\n            int j = k - i;\\n            if(i > nums1.length || j > nums2.length) continue;\\n            int[] digits1 = find(nums1, i);\\n            int[] digits2 = find(nums2, j);\\n            int[] digits = merge(digits1, digits2);\\n            res = compare(digits, res) > 0? digits: res;\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int[] nums, int count) {\\n        int n = nums.length, remain = count;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < n; i ++) {\\n            while(!stack.isEmpty() && nums[i] > stack.peek() && n - i - 1 >= remain) {\\n                stack.pop();\\n                remain ++;\\n            }\\n            if(remain > 0) {\\n                stack.push(nums[i]);\\n                remain --;\\n            }\\n        }\\n        int[] num = new int[count];\\n        int i = 0;\\n        for(Integer s: stack) {\\n            num[i ++] = s.intValue();\\n        }\\n        return num;\\n    }\\n    \\n    public int[] merge(int[] digits1, int[] digits2) {\\n        int i = 0, j = 0, p = 0, len1 = digits1.length, len2 = digits2.length;\\n        int[] res = new int[len1 + len2];\\n        while(i < len1 && j < len2) {\\n            if(digits1[i] > digits2[j]) {\\n                res[p ++] = digits1[i ++];\\n            } else if(digits1[i] < digits2[j]) {\\n                res[p ++] = digits2[j ++];\\n            } else {\\n                int istart = i, jstart = j;\\n                while(i < len1 && j < len2 && digits1[i] == digits2[j]) {\\n                    i ++;\\n                    j ++;\\n                }\\n                if(( i < len1 & j < len2 && digits1[i] > digits2[j]) \\n                  || (j == len2)) {\\n                    res[p ++] = digits1[istart ++];\\n                } else {\\n                    res[p ++] = digits2[jstart ++];\\n                }\\n                i = istart;\\n                j = jstart;\\n            }\\n        }\\n        while(i < len1) {\\n            res[p ++] = digits1[i ++];\\n        }\\n        while(j < len2) {\\n            res[p ++] = digits2[j ++];\\n        }\\n        return res;\\n    }\\n    \\n    public int compare(int[] n1, int[] n2) {\\n        for(int i = 0; i < n1.length; i ++) {\\n            if(n1[i] < n2[i]) return -1;\\n            else if(n1[i] > n2[i]) return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res = new int[k];\\n        for(int i = 0; i <= k; i ++) {\\n            int j = k - i;\\n            if(i > nums1.length || j > nums2.length) continue;\\n            int[] digits1 = find(nums1, i);\\n            int[] digits2 = find(nums2, j);\\n            int[] digits = merge(digits1, digits2);\\n            res = compare(digits, res) > 0? digits: res;\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int[] nums, int count) {\\n        int n = nums.length, remain = count;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < n; i ++) {\\n            while(!stack.isEmpty() && nums[i] > stack.peek() && n - i - 1 >= remain) {\\n                stack.pop();\\n                remain ++;\\n            }\\n            if(remain > 0) {\\n                stack.push(nums[i]);\\n                remain --;\\n            }\\n        }\\n        int[] num = new int[count];\\n        int i = 0;\\n        for(Integer s: stack) {\\n            num[i ++] = s.intValue();\\n        }\\n        return num;\\n    }\\n    \\n    public int[] merge(int[] digits1, int[] digits2) {\\n        int i = 0, j = 0, p = 0, len1 = digits1.length, len2 = digits2.length;\\n        int[] res = new int[len1 + len2];\\n        while(i < len1 && j < len2) {\\n            if(digits1[i] > digits2[j]) {\\n                res[p ++] = digits1[i ++];\\n            } else if(digits1[i] < digits2[j]) {\\n                res[p ++] = digits2[j ++];\\n            } else {\\n                int istart = i, jstart = j;\\n                while(i < len1 && j < len2 && digits1[i] == digits2[j]) {\\n                    i ++;\\n                    j ++;\\n                }\\n                if(( i < len1 & j < len2 && digits1[i] > digits2[j]) \\n                  || (j == len2)) {\\n                    res[p ++] = digits1[istart ++];\\n                } else {\\n                    res[p ++] = digits2[jstart ++];\\n                }\\n                i = istart;\\n                j = jstart;\\n            }\\n        }\\n        while(i < len1) {\\n            res[p ++] = digits1[i ++];\\n        }\\n        while(j < len2) {\\n            res[p ++] = digits2[j ++];\\n        }\\n        return res;\\n    }\\n    \\n    public int compare(int[] n1, int[] n2) {\\n        for(int i = 0; i < n1.length; i ++) {\\n            if(n1[i] < n2[i]) return -1;\\n            else if(n1[i] > n2[i]) return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77292,
                "title": "fastest-c-solution-13ms-beasts-100",
                "content": "The basic idea:\\n    First, find i max numbers (arr1[]) from nums1, and j max numbers (arr2[]) from nums2. (i + j = k)\\n    Then, merge arr1[] and arr2[] to get a max number.\\n```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77296,
                "title": "python-solution-172ms-beats-100",
                "content": "```python\\nimport math\\n\\nclass RMQ(object):\\n    def __init__(self, nums):\\n        self.nums = nums\\n        n = len(nums)\\n        if n:\\n            d = int(math.log(n, 2)) + 1;\\n            self.table = [[-1 for _ in range(n)] for _ in range(d)]\\n            for j in range(n):\\n                self.table[0][j] = j;\\n            for i in range(1, d):\\n                for j in range(n - (1 << i) + 1):\\n                    i1 = self.table[i-1][j]\\n                    i2 = self.table[i-1][j+(1<<(i-1))]\\n                    if nums[i1] >= nums[i2]:\\n                        self.table[i][j] = i1\\n                    else:\\n                        self.table[i][j] = i2\\n\\n    def get(self, left, right):\\n        if right < left:\\n            return -1\\n        l = right - left + 1\\n        d = int(math.log(l, 2))\\n        i1 = self.table[d][left]\\n        i2 = self.table[d][right+1-(1<<d)]\\n        if self.nums[i1] >= self.nums[i2]:\\n            return i1\\n        return i2\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        n, m = len(nums1), len(nums2)\\n        rmq1, rmq2 = RMQ(nums1), RMQ(nums2)\\n        \\n        start_positions = {0: 0}\\n        \\n        res = []\\n        while k:\\n            max_digit = 0\\n            new_start_positions = {}\\n            for s1, s2 in start_positions.items():\\n                e1 = n - max(1, k - (m - s2))\\n                e2 = m - max(1, k - (n - s1))\\n    \\n                if s1 < n and s2 < m:\\n                    i1 = rmq1.get(s1, e1)\\n                    i2 = rmq2.get(s2, e2)\\n                    if nums1[i1] > nums2[i2]:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                    elif nums1[i1] < nums2[i2]:\\n                        if nums2[i2] >= max_digit:\\n                            if nums2[i2] > max_digit:\\n                                max_digit = nums2[i2]\\n                                new_start_positions = {}\\n                            new_start_positions[s1] = i2 + 1\\n                    else:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                            new_start_positions[s1] = i2 + 1\\n                elif s1 < n:\\n                    i = rmq1.get(s1, e1)\\n                    if nums1[i] >= max_digit:\\n                        if nums1[i] > max_digit:\\n                            max_digit = nums1[i]\\n                            new_start_positions = {}\\n                        new_start_positions[i + 1] = s2\\n                else:\\n                    i = rmq2.get(s2, e2)\\n                    if nums2[i] >= max_digit:\\n                        if nums2[i] > max_digit:\\n                            max_digit = nums2[i]\\n                            new_start_positions = {}\\n                        new_start_positions[s1] = i + 1\\n            res.append(max_digit)\\n            start_positions = new_start_positions\\n            k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nimport math\\n\\nclass RMQ(object):\\n    def __init__(self, nums):\\n        self.nums = nums\\n        n = len(nums)\\n        if n:\\n            d = int(math.log(n, 2)) + 1;\\n            self.table = [[-1 for _ in range(n)] for _ in range(d)]\\n            for j in range(n):\\n                self.table[0][j] = j;\\n            for i in range(1, d):\\n                for j in range(n - (1 << i) + 1):\\n                    i1 = self.table[i-1][j]\\n                    i2 = self.table[i-1][j+(1<<(i-1))]\\n                    if nums[i1] >= nums[i2]:\\n                        self.table[i][j] = i1\\n                    else:\\n                        self.table[i][j] = i2\\n\\n    def get(self, left, right):\\n        if right < left:\\n            return -1\\n        l = right - left + 1\\n        d = int(math.log(l, 2))\\n        i1 = self.table[d][left]\\n        i2 = self.table[d][right+1-(1<<d)]\\n        if self.nums[i1] >= self.nums[i2]:\\n            return i1\\n        return i2\\n\\nclass Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        n, m = len(nums1), len(nums2)\\n        rmq1, rmq2 = RMQ(nums1), RMQ(nums2)\\n        \\n        start_positions = {0: 0}\\n        \\n        res = []\\n        while k:\\n            max_digit = 0\\n            new_start_positions = {}\\n            for s1, s2 in start_positions.items():\\n                e1 = n - max(1, k - (m - s2))\\n                e2 = m - max(1, k - (n - s1))\\n    \\n                if s1 < n and s2 < m:\\n                    i1 = rmq1.get(s1, e1)\\n                    i2 = rmq2.get(s2, e2)\\n                    if nums1[i1] > nums2[i2]:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                    elif nums1[i1] < nums2[i2]:\\n                        if nums2[i2] >= max_digit:\\n                            if nums2[i2] > max_digit:\\n                                max_digit = nums2[i2]\\n                                new_start_positions = {}\\n                            new_start_positions[s1] = i2 + 1\\n                    else:\\n                        if nums1[i1] >= max_digit:\\n                            if nums1[i1] > max_digit:\\n                                max_digit = nums1[i1]\\n                                new_start_positions = {}\\n                            new_start_positions[i1 + 1] = s2\\n                            new_start_positions[s1] = i2 + 1\\n                elif s1 < n:\\n                    i = rmq1.get(s1, e1)\\n                    if nums1[i] >= max_digit:\\n                        if nums1[i] > max_digit:\\n                            max_digit = nums1[i]\\n                            new_start_positions = {}\\n                        new_start_positions[i + 1] = s2\\n                else:\\n                    i = rmq2.get(s2, e2)\\n                    if nums2[i] >= max_digit:\\n                        if nums2[i] > max_digit:\\n                            max_digit = nums2[i]\\n                            new_start_positions = {}\\n                        new_start_positions[s1] = i + 1\\n            res.append(max_digit)\\n            start_positions = new_start_positions\\n            k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77313,
                "title": "questions-about-the-merge-function",
                "content": "Here I am talking about the most common merge() function appearing in the posted solutions. Actually, I am not quite convinced about the way to handle the cases where we have two equal elements. I know, intuitively, we should move forward the pointer of the array that has a larger element after passing through the equal part, as this makes the larger element more likely to be encountered sooner, thus appear in a more significant digit. But can anyone post a rigorous mathematical proof of this?\\n```\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n            int[] merged = new int[ nums1.length+nums2.length ];\\n            int cnt, cnt1, cnt2;\\n\\n            for(cnt = cnt1 = cnt2 = 0; cnt1<nums1.length && cnt2<nums2.length; ) {\\n                merged[ cnt++ ] = greater(nums1, nums2, cnt1, cnt2)?nums1[ cnt1++ ]:nums2[ cnt2++ ];\\n            }\\n\\n            for(; cnt1 < nums1.length; merged[ cnt++ ] = nums1[ cnt1++ ]);\\n            for(; cnt2 < nums2.length; merged[ cnt++ ] = nums2[ cnt2++ ]);\\n\\n            return merged;\\n        }\\n\\n        private boolean greater(int[] nums1, int[] nums2, int start1, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int[] merge(int[] nums1, int[] nums2) {\\n            int[] merged = new int[ nums1.length+nums2.length ];\\n            int cnt, cnt1, cnt2;\\n\\n            for(cnt = cnt1 = cnt2 = 0; cnt1<nums1.length && cnt2<nums2.length; ) {\\n                merged[ cnt++ ] = greater(nums1, nums2, cnt1, cnt2)?nums1[ cnt1++ ]:nums2[ cnt2++ ];\\n            }\\n\\n            for(; cnt1 < nums1.length; merged[ cnt++ ] = nums1[ cnt1++ ]);\\n            for(; cnt2 < nums2.length; merged[ cnt++ ] = nums2[ cnt2++ ]);\\n\\n            return merged;\\n        }\\n\\n        private boolean greater(int[] nums1, int[] nums2, int start1, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77318,
                "title": "c-greedy-method",
                "content": "    class Solution {\\n    public:\\n        vector<int> getMaxArray(vector<int>& nums, int k){\\n            vector<int> ans;\\n            int len = nums.size();\\n            for(int i = 0, j = 0; i < len; ++i){\\n                while(j > 0 && len - i + j > k && ans[j - 1] < nums[i]){\\n                    ans.pop_back();\\n                    --j;\\n                }\\n                if(j < k){\\n                    ans.push_back(nums[i]);\\n                    ++j;\\n                }\\n            }\\n            return ans;\\n        }\\n        bool greater(vector<int>& nums1, int i, vector<int>& nums2, int j){\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            while(i < len1 && j < len2 && nums1[i] == nums2[j]){\\n                ++i;\\n                ++j;\\n            }\\n            if(j == len2 || (i < len1 && nums1[i] > nums2[j])){\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            vector<int> ans;\\n            //for_each(nums1.begin(), nums1.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            //for_each(nums2.begin(), nums2.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            for(int i = 0, j = 0, m = 0;i < len1 || j < len2;){\\n                ans.push_back((greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++]));\\n            }\\n            //for_each(ans.begin(), ans.end(), [](int x){cout<<x<<\" \";}), cout<<endl;\\n            return ans;\\n        }\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            int len1 = nums1.size();\\n            int len2 = nums2.size();\\n            if(len1 < len2){\\n                return maxNumber(nums2, nums1, k);\\n            }\\n            vector<int> ans;\\n            for(int i = max(0, k - len1); i <= min(k, len2); ++i){\\n                vector<int> c2 = getMaxArray(nums2, i);\\n                vector<int> c1 = getMaxArray(nums1, k - i);\\n                vector<int> c = merge(c1, c2);\\n                if(ans.empty() || greater(c, 0, ans, 0)){\\n                    ans = c;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> getMaxArray(vector<int>& nums, int k){\\n            vector<int> ans;\\n            int len = nums.size();\\n            for(int i = 0, j = 0; i < len; ++i){\\n                while(j > 0 && len - i + j > k && ans[j - 1] < nums[i]){\\n                    ans.pop_back();\\n                    --j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77322,
                "title": "intuitive-solution-yet-efficient-enough-in-c-well-commented",
                "content": "    class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }\\n                }\\n                if (i == n - 1) nums.erase(nums.begin() + i);\\n            }\\n            return nums;\\n        }\\n    \\n        //compare two vectors from certain index adopting lexical order;\\n        //if the first vector is bigger return true otherwise return false;\\n        bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) \\n        {\\n            while (i<nums1.size() && j<nums2.size() && nums1[i]==nums2[j]) ++i, ++j;\\n            if (j == nums2.size()) return true;\\n            if (i<nums1.size() && nums1[i]>nums2[j]) return true;\\n            return false;\\n        }\\n    \\n        vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) \\n        {\\n            vector<int> res(k, 0);\\n            for (int i=0, j=0, r=0; r < k; ++r) \\n                res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n            return res;\\n        }\\n    \\n        //AC - 386ms - the most intuitive solution;\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            int len1=nums1.size(), len2=nums2.size();\\n            vector<int> res(k, 0);\\n            for (int i = max(0, k-len2); i <= min(k, len1); ++i) \\n            {\\n                auto v1 = maxVector(nums1, i);\\n                auto v2 = maxVector(nums2, k - i);\\n                auto tmp = merge(v1, v2, k);\\n                if (compare(tmp, 0, res, 0)) res = tmp;\\n            }\\n            return res;\\n        }\\n    };\\n\\n\\n----------",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        //select the maximal number in certain length within one vector;\\n        vector<int> maxVector(vector<int> nums, int k) \\n        {\\n            while (nums.size() > k) \\n            {\\n                int i = 0, n = nums.size();\\n                for (; i < n - 1; ++i)  //at least erase one element each time;\\n                {\\n                    if (nums[i] < nums[i + 1]) \\n                    {\\n                        nums.erase(nums.begin() + i);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77332,
                "title": "c-136ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n            vector<int> res;\\n            bool first = true;\\n            for (int i=0; i<=k; i++) {\\n                \\n                if (i > nums1.size() || k-i > nums2.size())\\n                    continue;\\n                \\n                // Find max number from nums1 of length i\\n                vector<int> maxNum1 = findMax(nums1, i);\\n    \\n                // Find max number from nums2 of length k-i\\n                vector<int> maxNum2 = findMax(nums2, k-i);\\n    \\n                // Interleave to find the global max number\\n                vector<int> candidate = interleave(maxNum1, maxNum2);\\n                \\n                if (first) {\\n                    res = candidate;\\n                    first = false;\\n                }\\n                else if (compare(res, 0, candidate, 0))\\n                    res = candidate;\\n            }\\n            return res;\\n        }\\n        vector<int> findMax(vector<int>& nums, int len) {\\n            vector<int> maxNum;\\n            int prev_pos = -1;\\n            int maxi;\\n            for (int i=0; i<len; i++) {\\n                maxi = -1;\\n                int limit = nums.size()-len+i;\\n                for (int j=prev_pos+1; j<=limit; j++) {\\n                    if (nums[j] > maxi) {\\n                        maxi = nums[j];\\n                        prev_pos = j;\\n                    }\\n                }\\n                maxNum.push_back(maxi);\\n            }\\n            return maxNum;\\n        }\\n        vector<int> interleave(vector<int>& maxNum1, vector<int>& maxNum2) {\\n            vector<int> res;\\n            int i1=0, i2=0;\\n            while (i1<maxNum1.size() || i2<maxNum2.size()) {\\n                if (compare(maxNum1, i1, maxNum2, i2)) {\\n                    res.push_back(maxNum2[i2++]);\\n                }\\n                else {\\n                    res.push_back(maxNum1[i1++]);\\n                }\\n            }\\n            return res;\\n        }\\n        // Returns true if the new vec (starting at position j) is better than the old vec (starting at position i)\\n        bool compare(vector<int>& old_vec, int i, vector<int>& new_vec, int j) {\\n            \\n            while (i < old_vec.size() && j < new_vec.size() && old_vec[i]==new_vec[j]) {\\n                i++;\\n                j++;\\n            }\\n            return i==old_vec.size() || (j!=new_vec.size() && old_vec[i] < new_vec[j]);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n            vector<int> res;\\n            bool first = true;\\n            for (int i=0; i<=k; i++) {\\n                \\n                if (i > nums1.size() || k-i > nums2.size())\\n                    continue;\\n                \\n                // Find max number from nums1 of length i\\n                vector<int> maxNum1 = findMax(nums1, i);\\n    \\n                // Find max number from nums2 of length k-i\\n                vector<int> maxNum2 = findMax(nums2, k-i);\\n    \\n                // Interleave to find the global max number\\n                vector<int> candidate = interleave(maxNum1, maxNum2);\\n                \\n                if (first) {\\n                    res = candidate;\\n                    first = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 77334,
                "title": "easy-to-understand-dp-c-implementation-but-with-tle",
                "content": "As we can see, this problem is really fuck!!!\\n\\nUsing directly with THE DP idea will cause TLE problem !!\\n\\nBut it is also good for us to use the traditional DP ideas to solve this kind of problem.\\n\\nYou can get the recursion equation from my code implementation.\\n\\nHere is the DP code implemented by myself without referring any others' post.\\n\\nWelcome your advice !\\n\\nCode : \\n\\n\\n     class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            /**\\n             * dp[k][i][j] = max(nums1[i-1]+10*dp[k-1][i-1][j], nums2[j-1]+10*dp[k-1][i][j-1], \\n             *                    dp[k][i-1][j-1])\\n             * \\n             **/\\n            vector<int> result;\\n            int len1=nums1.size(), len2=nums2.size();\\n            if(len1+len2<k)  return result;\\n            vector<vector<vector<int>>> dp(2, vector<vector<int>>(len1+1, vector<int>(len2+1, 0)));\\n            for(int kk=0; kk<=k; kk++){\\n                for(int i=0; i<=len1; i++){\\n                    for(int j=0; j<=len2; j++){\\n                        if(kk==0)    \\n                            dp[0][i][j]=0;\\n                        else if(i==0 && j==0)   \\n                            dp[kk&1][0][0]=0;\\n                        else if(i==0){\\n                            if(kk>j)  \\n                                dp[kk&1][0][j]=0;\\n                            else \\n                                dp[kk&1][0][j]=max(dp[kk&1][0][j-1], 10*dp[(kk-1)&1][0][j-1]+nums2[j-1]);\\n                        }\\n                        else if(j==0){\\n                            if(kk>i)  \\n                                dp[kk&1][i][0]=0;\\n                            else \\n                                dp[kk&1][i][0]=max(dp[kk&1][i-1][0], 10*dp[(kk-1)&1][i-1][0]+nums1[i-1]);\\n                        }\\n                        else{\\n                             dp[kk&1][i][j] = max(max(nums1[i-1]+10*dp[(kk-1)&1][i-1][j], \\n                                nums2[j-1]+10*dp[(kk-1)&1][i][j-1]), dp[kk&1][i-1][j-1]);\\n                        }   \\n                    }\\n                }\\n            }\\n            int value=dp[k&1][len1][len2];\\n            while(value>0){\\n                result.push_back(value%10);\\n                value=value/10;\\n            }\\n            reverse(result.begin(), result.end());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            /**\\n             * dp[k][i][j] = max(nums1[i-1]+10*dp[k-1][i-1][j], nums2[j-1]+10*dp[k-1][i][j-1], \\n             *                    dp[k][i-1][j-1])\\n             * \\n             **/\\n            vector<int> result;\\n            int len1=nums1.size(), len2=nums2.size();\\n            if(len1+len2<k)  return result;\\n            vector<vector<vector<int>>> dp(2, vector<vector<int>>(len1+1, vector<int>(len2+1, 0)));\\n            for(int kk=0; kk<=k; kk++){\\n                for(int i=0; i<=len1; i++){\\n                    for(int j=0; j<=len2; j++){\\n                        if(kk==0)    \\n                            dp[0][i][j]=0;\\n                        else if(i==0 && j==0)   \\n                            dp[kk&1][0][0]=0;\\n                        else if(i==0){\\n                            if(kk>j)  \\n                                dp[kk&1][0][j]=0;\\n                            else \\n                                dp[kk&1][0][j]=max(dp[kk&1][0][j-1], 10*dp[(kk-1)&1][0][j-1]+nums2[j-1]);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 77340,
                "title": "my-c-solution-just-want-to-give-a-c-solution-because-it-seem-there-are-no-c-submission",
                "content": "###Here is my code, used 58ms, if someone has a better solution in c, please contact me.\\n\\n    void Findmax(int *nums, int size, int *cache, int length);\\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache);\\n    int compare(int* nums1, int *nums2, int size);\\n    \\n    int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){\\n    \\tint* cache = (int*)malloc(sizeof(int) * k);\\n    \\tmemset(cache, 0, k * sizeof(int));\\n    \\tint* cache3 = (int*)malloc(sizeof(int) * k);\\n    \\tint i, j, t;\\n    \\t*returnSize = k;\\n    \\tfor(i = 0; i <= k; ++i){\\n    \\t\\tint left = i;\\n    \\t\\tint cache1[left];\\n    \\t\\tint right = k - i;\\n    \\t\\tint cache2[right];\\n    \\n    \\t\\tif(left > nums1Size || right > nums2Size){\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tFindmax(nums1, nums1Size, cache1, left);\\n    \\t\\tFindmax(nums2, nums2Size, cache2, right);\\n    \\n    \\t\\tMerge(cache1, left, cache2, right, cache3);\\n    \\t\\tt = compare(cache, cache3, k);\\n    \\t\\tif(t < 0){\\n    \\t\\t\\tfor(j = 0; j < k; ++j){\\n    \\t\\t\\t\\tcache[j] = cache3[j];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\n    \\treturn cache;\\n    }\\n    \\n    void Findmax(int *nums, int size, int *cache, int length){\\n    \\tint start = 0;\\n    \\tint end = size - length;\\n    \\tint i, j, sum;\\n    \\tfor(i = 0; i < length; ++i){\\n    \\t\\tsum = -1;\\n    \\t\\tfor(j = start; j <= end; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif(sum < nums[j]){\\n    \\t\\t\\t\\tsum = nums[j];\\n    \\t\\t\\t\\tstart = j + 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif(end != size - 1){\\n    \\t\\t\\tend += 1;\\n    \\t\\t}\\n    \\t\\tcache[i] = sum;\\n    \\t}\\n    }\\n    \\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache){\\n    \\tint i = 0;\\n    \\tint j = 0;\\n    \\tint k = 0;\\n    \\twhile(i < left && j < right){\\n    \\t\\tif(nums1[i] > nums2[j]){\\n    \\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t}\\n    \\t\\telse if(nums1[i] == nums2[j]){\\n    \\t\\t\\tint temp = left - i <= right - j ? \\tleft - i : right - j;\\n    \\t\\t\\tint temp2 = compare(nums1 + i, nums2 + j, temp);\\n    \\t\\t\\tif(temp2 == 0){\\n    \\t\\t\\t\\tif(temp == left - i){\\n    \\t\\t\\t\\t\\ttemp2 = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp2 = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(temp2 > 0){\\n    \\t\\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t}\\n    \\t}\\n    \\twhile(i < left){\\n    \\t\\tcache[k++] = nums1[i++];\\n    \\t}\\n    \\twhile(j < right){\\n    \\t\\tcache[k++] = nums2[j++];\\n    \\t}\\n    }\\n    \\n    int compare(int* nums1, int *nums2, int size){\\n    \\tint i;\\n    \\tfor(i = 0; i < size; ++i){\\n    \\t\\tif(nums1[i] > nums2[i]){\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\t\\tif(nums1[i] < nums2[i]){\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }",
                "solutionTags": [],
                "code": "###Here is my code, used 58ms, if someone has a better solution in c, please contact me.\\n\\n    void Findmax(int *nums, int size, int *cache, int length);\\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache);\\n    int compare(int* nums1, int *nums2, int size);\\n    \\n    int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){\\n    \\tint* cache = (int*)malloc(sizeof(int) * k);\\n    \\tmemset(cache, 0, k * sizeof(int));\\n    \\tint* cache3 = (int*)malloc(sizeof(int) * k);\\n    \\tint i, j, t;\\n    \\t*returnSize = k;\\n    \\tfor(i = 0; i <= k; ++i){\\n    \\t\\tint left = i;\\n    \\t\\tint cache1[left];\\n    \\t\\tint right = k - i;\\n    \\t\\tint cache2[right];\\n    \\n    \\t\\tif(left > nums1Size || right > nums2Size){\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tFindmax(nums1, nums1Size, cache1, left);\\n    \\t\\tFindmax(nums2, nums2Size, cache2, right);\\n    \\n    \\t\\tMerge(cache1, left, cache2, right, cache3);\\n    \\t\\tt = compare(cache, cache3, k);\\n    \\t\\tif(t < 0){\\n    \\t\\t\\tfor(j = 0; j < k; ++j){\\n    \\t\\t\\t\\tcache[j] = cache3[j];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\n    \\treturn cache;\\n    }\\n    \\n    void Findmax(int *nums, int size, int *cache, int length){\\n    \\tint start = 0;\\n    \\tint end = size - length;\\n    \\tint i, j, sum;\\n    \\tfor(i = 0; i < length; ++i){\\n    \\t\\tsum = -1;\\n    \\t\\tfor(j = start; j <= end; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif(sum < nums[j]){\\n    \\t\\t\\t\\tsum = nums[j];\\n    \\t\\t\\t\\tstart = j + 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif(end != size - 1){\\n    \\t\\t\\tend += 1;\\n    \\t\\t}\\n    \\t\\tcache[i] = sum;\\n    \\t}\\n    }\\n    \\n    void Merge(int *nums1, int left, int* nums2, int right, int* cache){\\n    \\tint i = 0;\\n    \\tint j = 0;\\n    \\tint k = 0;\\n    \\twhile(i < left && j < right){\\n    \\t\\tif(nums1[i] > nums2[j]){\\n    \\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t}\\n    \\t\\telse if(nums1[i] == nums2[j]){\\n    \\t\\t\\tint temp = left - i <= right - j ? \\tleft - i : right - j;\\n    \\t\\t\\tint temp2 = compare(nums1 + i, nums2 + j, temp);\\n    \\t\\t\\tif(temp2 == 0){\\n    \\t\\t\\t\\tif(temp == left - i){\\n    \\t\\t\\t\\t\\ttemp2 = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp2 = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(temp2 > 0){\\n    \\t\\t\\t\\tcache[k++] = nums1[i++];\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tcache[k++] = nums2[j++];\\n    \\t\\t}\\n    \\t}\\n    \\twhile(i < left){\\n    \\t\\tcache[k++] = nums1[i++];\\n    \\t}\\n    \\twhile(j < right){\\n    \\t\\tcache[k++] = nums2[j++];\\n    \\t}\\n    }\\n    \\n    int compare(int* nums1, int *nums2, int size){\\n    \\tint i;\\n    \\tfor(i = 0; i < size; ++i){\\n    \\t\\tif(nums1[i] > nums2[i]){\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\t\\tif(nums1[i] < nums2[i]){\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77320,
                "title": "o-m-n-k-k-algorithm-with-dp-and-greedy",
                "content": "This is a very challenging problem.\\n\\nThe first step is to use dp solution find the num[m, i], which means the max number with i digits from num[0]~num[m]. This part of DP is already a hard question, and many similar questions can be found (e.g.: Problem 72 or 115). The recursive equation is: dp(m,k) = max(dp(m-1, k), dp(m-1,k-1)+num[m]). But, here, since the backtrace is only 1 step ahead, we can save memory to be O(k) of less-than-k-digit numbers. We can use O(m*k) time to run through the dp, and each max comparison will take another O(k) time to finish. Thus the overall the generation of maxNum(m, k) is O(m*k*k). This piece of function is here:\\n\\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n\\nThe rest will be a greedy algorithm. For each i in [0,k], we have maxNum(num1, i) and maxNum(num2, k-i). The maximized merged number can be easily generated by a greedy algorithm follow a lex order. The largest merged number will be the final solution. This piece of algorithm with known maxNum(num1, i) and maxNum(num2, k-i) from DP is only O(k*k). \\n\\nThus the overall time complexity of algorithm is O((m+n)*k*k). The space complexity is O((m+n)*k). \\n\\nHere is the overall solution:\\n\\n    vector<int> maxVector(vector<int> &a, vector<int> &b) {\\n        if (a.size() > b.size()) return a;\\n        else if (a.size() < b.size()) return b;\\n        else {\\n            for (int i = 0; i<a.size(); ++i) {\\n                if (a[i] > b[i]) return a;\\n                else if (a[i] < b[i]) return b;\\n            }\\n            return a;\\n        }\\n    }\\n    \\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n    \\n    vector<int> maxMerge(vector<int> & a, vector<int> & b) {\\n        vector<int> res;\\n        int i = 0;\\n        int j = 0;\\n        while (i<a.size() || j<b.size()) {\\n            if (i == a.size()) res.push_back(b[j++]);\\n            else if (j == b.size()) res.push_back(a[i++]);\\n            else if (a[i]>b[j]) res.push_back(a[i++]);\\n            else if (a[i]<b[j]) res.push_back(b[j++]);\\n            else {\\n                int ii = i, jj = j;\\n                while (ii<a.size() && jj<b.size() && a[ii] == b[jj]) {ii++; jj++;}\\n                if (ii == a.size() && jj == b.size()) res.push_back(a[i++]);\\n                else if (ii == a.size() || a[ii] < b[jj]) res.push_back(b[j++]);\\n                else if (jj == b.size() || a[ii] > b[jj]) res.push_back(a[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if (nums1.size()+nums2.size() == k) return maxMerge(nums1, nums2);\\n        vector<vector<int> > range1 = maxNum(nums1, k);\\n        vector<vector<int> > range2 = maxNum(nums2, k);\\n    \\n        vector<int> maxResult;\\n        for (int n1 = 0; n1 <= k; ++n1) {\\n            int n2 = k-n1;\\n            vector<int> temp = maxMerge(range1[n1], range2[n2]);\\n            maxResult = maxVector(maxResult, temp);\\n        }\\n        return maxResult;\\n    }\\n\\nBTW, this piece of code passes all my local tests, but it always reports failure in a simple test case in the leetcode test environment. \\n\\n    [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3]\\n    [7,6,7,1,0,1,0,5,6,0,5,0]\\n    31\\n\\nI suspect the leetcode compiling system might have some bugs somewhere.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "This is a very challenging problem.\\n\\nThe first step is to use dp solution find the num[m, i], which means the max number with i digits from num[0]~num[m]. This part of DP is already a hard question, and many similar questions can be found (e.g.: Problem 72 or 115). The recursive equation is: dp(m,k) = max(dp(m-1, k), dp(m-1,k-1)+num[m]). But, here, since the backtrace is only 1 step ahead, we can save memory to be O(k) of less-than-k-digit numbers. We can use O(m*k) time to run through the dp, and each max comparison will take another O(k) time to finish. Thus the overall the generation of maxNum(m, k) is O(m*k*k). This piece of function is here:\\n\\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n\\nThe rest will be a greedy algorithm. For each i in [0,k], we have maxNum(num1, i) and maxNum(num2, k-i). The maximized merged number can be easily generated by a greedy algorithm follow a lex order. The largest merged number will be the final solution. This piece of algorithm with known maxNum(num1, i) and maxNum(num2, k-i) from DP is only O(k*k). \\n\\nThus the overall time complexity of algorithm is O((m+n)*k*k). The space complexity is O((m+n)*k). \\n\\nHere is the overall solution:\\n\\n    vector<int> maxVector(vector<int> &a, vector<int> &b) {\\n        if (a.size() > b.size()) return a;\\n        else if (a.size() < b.size()) return b;\\n        else {\\n            for (int i = 0; i<a.size(); ++i) {\\n                if (a[i] > b[i]) return a;\\n                else if (a[i] < b[i]) return b;\\n            }\\n            return a;\\n        }\\n    }\\n    \\n    vector<vector<int>> maxNum(vector<int> & nums, int k) {\\n        vector<vector<int> > record(k+1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int kk = k; kk >= 1; --kk) {\\n                if (kk>i) record[kk].clear();\\n                vector<int> temp = record[kk-1];\\n                temp.push_back(nums[i]);\\n                record[kk] = maxVector(record[kk], temp);\\n            }\\n        }\\n        return record;     \\n    }\\n    \\n    vector<int> maxMerge(vector<int> & a, vector<int> & b) {\\n        vector<int> res;\\n        int i = 0;\\n        int j = 0;\\n        while (i<a.size() || j<b.size()) {\\n            if (i == a.size()) res.push_back(b[j++]);\\n            else if (j == b.size()) res.push_back(a[i++]);\\n            else if (a[i]>b[j]) res.push_back(a[i++]);\\n            else if (a[i]<b[j]) res.push_back(b[j++]);\\n            else {\\n                int ii = i, jj = j;\\n                while (ii<a.size() && jj<b.size() && a[ii] == b[jj]) {ii++; jj++;}\\n                if (ii == a.size() && jj == b.size()) res.push_back(a[i++]);\\n                else if (ii == a.size() || a[ii] < b[jj]) res.push_back(b[j++]);\\n                else if (jj == b.size() || a[ii] > b[jj]) res.push_back(a[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if (nums1.size()+nums2.size() == k) return maxMerge(nums1, nums2);\\n        vector<vector<int> > range1 = maxNum(nums1, k);\\n        vector<vector<int> > range2 = maxNum(nums2, k);\\n    \\n        vector<int> maxResult;\\n        for (int n1 = 0; n1 <= k; ++n1) {\\n            int n2 = k-n1;\\n            vector<int> temp = maxMerge(range1[n1], range2[n2]);\\n            maxResult = maxVector(maxResult, temp);\\n        }\\n        return maxResult;\\n    }\\n\\nBTW, this piece of code passes all my local tests, but it always reports failure in a simple test case in the leetcode test environment. \\n\\n    [5,0,2,1,0,1,0,3,9,1,2,8,0,9,8,1,4,7,3]\\n    [7,6,7,1,0,1,0,5,6,0,5,0]\\n    31\\n\\nI suspect the leetcode compiling system might have some bugs somewhere.",
                "codeTag": "Unknown"
            },
            {
                "id": 77344,
                "title": "40ms-clean-c-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        vector<vector<int>> dp(const vector<int>& nums)\\n        {\\n            int len = nums.size();\\n            vector< vector<int> > mem(len+1);\\n            mem[len] = nums;\\n            for (int i=len-1; i >=0; i--)\\n            {\\n                mem[i] = mem[i+1];\\n                for (int j=1; j <  mem[i].size(); j++)\\n                {\\n                    if ( mem[i][j] > mem[i][j-1])\\n                    {\\n                        mem[i].erase( mem[i].begin() + j-1);\\n                        break;\\n                    }\\n                }\\n                mem[i].resize(i);\\n            }\\n            \\n            return mem;\\n        }\\n    \\n        vector<int> special_merge(const vector<int>& res1,const vector<int>& res2, int k)\\n        {\\n                vector<int> res(k);\\n                int idx1=0, idx2=0, idx=0;\\n         \\n                // take the largest number. In case of equality take from the sequence that leads faster to a larger number.\\n                while ( idx1 < res1.size() && idx2 < res2.size())\\n                {\\n                    if (res1[idx1] > res2[idx2]) \\n                    {\\n                        res[idx++] =  res1[idx1++];\\n                    }\\n                    else if (res1[idx1] < res2[idx2])\\n                    {\\n                        res[idx++] = res2[idx2++];\\n                    }\\n                    else\\n                    {\\n                        int tmp = res1[idx1];\\n                        auto r = lexicographical_compare( res1.begin() + idx1, res1.end(), res2.begin() + idx2, res2.end() )\\n                        ? make_pair( ref(res2), ref(idx2)) : make_pair( ref(res1), ref(idx1));\\n                       \\n                        while ( r.second < r.first.size() && r.first[r.second] == tmp)\\n                        {\\n                            res[idx++] =  r.first[r.second++];\\n                        }\\n                    }\\n                }\\n                auto it = copy(res1.begin()+idx1, res1.end(), res.begin() + idx );\\n                copy( res2.begin()+idx2, res2.end(), it );\\n                return res;\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) \\n        {\\n            // find best sub-sequences of nums1 and nums2 for all possible lengths\\n            auto mem1 = dp(nums1); \\n            auto mem2 = dp(nums2);\\n            \\n            int M = min( k ,  (int) nums1.size());  // Maximum items we can take from nums1\\n            int m = std::max(0, k - (int) nums2.size() ); // Minimum items we can take from nums1\\n            \\n            vector<int> result;\\n            for (int n1 =m; n1 <= M; n1++)\\n            {\\n                result = max( result,  special_merge( mem1[ n1], mem2[k-n1], k) );\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        vector<vector<int>> dp(const vector<int>& nums)\\n        {\\n            int len = nums.size();\\n            vector< vector<int> > mem(len+1);\\n            mem[len] = nums;\\n            for (int i=len-1; i >=0; i--)\\n            {\\n                mem[i] = mem[i+1];\\n                for (int j=1; j <  mem[i].size(); j++)\\n                {\\n                    if ( mem[i][j] > mem[i][j-1])\\n                    {\\n                        mem[i].erase( mem[i].begin() + j-1);\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 77350,
                "title": "o-m-n-2-with-linear-time-suffix-array-construction",
                "content": "    #define FOR(i, a, b) for (int i = (a); i < (b); i++)\\n    #define REP(i, n) for (int i = 0; i < (n); i++)\\n    #define ROF(i, a, b) for (int i = (b); --i >= (a); )\\n    \\n    namespace KoAluru\\n    {\\n      bool *t;\\n      int *b;\\n    \\n      template<typename T>\\n      void bucket(T a[], int n, int k, bool end)\\n      {\\n        fill_n(b, k, 0);\\n        REP(i, n) b[a[i]]++;\\n        if (end)\\n          FOR(i, 1, k)\\n            b[i] += b[i-1];\\n        else {\\n          int s = 0;\\n          REP(i, k)\\n            s += b[i], b[i] = s-b[i];\\n        }\\n      }\\n    \\n      template<typename T>\\n      void plus_to_minus(T a[], int sa[], int n, int k)\\n      {\\n        bucket(a, n, k, false);\\n        sa[b[a[n-1]]++] = n-1;\\n        REP(i, n-1) {\\n          int j = sa[i]-1;\\n          if (j >= 0 && ! t[j])\\n            sa[b[a[j]]++] = j;\\n        }\\n      }\\n    \\n      template<typename T>\\n      void minus_to_plus(T a[], int sa[], int n, int k)\\n      {\\n        bucket(a, n, k, true);\\n        ROF(i, 0, n) {\\n          int j = sa[i]-1;\\n          if (j >= 0 && t[j])\\n            sa[--b[a[j]]] = j;\\n        }\\n      }\\n    \\n      template<typename T>\\n      void ka(const T a[], int n, int k, int sa[])\\n      {\\n        t[n-1] = false;\\n        ROF(i, 0, n-1)\\n          t[i] = a[i] < a[i+1] || a[i] == a[i+1] && t[i+1];\\n        bool minor = 2 * count(t, t+n, false) > n;\\n    \\n        bucket(a, n, k, minor);\\n        fill_n(sa, n, -1);\\n        if (minor) {\\n          REP(i, n)\\n            if (t[i])\\n              sa[--b[a[i]]] = i;\\n          plus_to_minus(a, sa, n, k);\\n          minus_to_plus(a, sa, n, k);\\n        } else {\\n          sa[b[a[n-1]]++] = n-1;\\n          REP(i, n-1)\\n            if (! t[i])\\n              sa[b[a[i]]++] = i;\\n          minus_to_plus(a, sa, n, k);\\n          plus_to_minus(a, sa, n, k);\\n        }\\n    \\n        int last = -1, name = 0, nn = count(t, t+n, minor);\\n        int *sa2, *pi;\\n        if (minor)\\n          sa2 = sa, pi = sa+n-nn;\\n        else\\n          sa2 = sa+n-nn, pi = sa;\\n        fill_n(b, n, -1);\\n        REP(i, n)\\n          if (sa[i] >= 0 && minor == t[sa[i]]) {\\n            bool diff = last == -1;\\n            int p = sa[i];\\n            if (! diff)\\n              REP(j, n) {\\n                if (last+j >= n || p+j >= n || a[last+j] != a[p+j] || t[last+j] != t[p+j]) {\\n                  diff = true;\\n                  break;\\n                } else if (j > 0 && (minor == t[last+j] || minor == t[p+j]))\\n                  break;\\n              }\\n            if (diff) {\\n              name++;\\n              last = p;\\n            }\\n            b[p] = name-1;\\n          }\\n        nn = 0;\\n        REP(i, n)\\n          if (b[i] >= 0)\\n            pi[nn++] = b[i];\\n    \\n        if (name < nn)\\n          ka(pi, nn, name, sa2);\\n        else\\n          REP(i, nn)\\n            sa2[pi[i]] = i;\\n    \\n        ROF(i, 0, nn)\\n          t[i] = a[i] < a[i+1] || a[i] == a[i+1] && t[i+1];\\n    \\n        nn = 0;\\n        bucket(a, n, k, minor);\\n        if (minor) {\\n          REP(i, n)\\n            if (minor == t[i])\\n              pi[nn++] = i;\\n          REP(i, nn)\\n            sa[i] = pi[sa2[i]];\\n          ROF(i, 0, nn) {\\n            int j = sa[i];\\n            sa[i] = -1;\\n            sa[--b[a[j]]] = j;\\n          }\\n        } else {\\n          REP(i, n)\\n            if (minor == t[i])\\n              pi[nn++] = i;\\n          ROF(i, 0, nn)\\n            sa[n-nn+i] = pi[sa2[i]];\\n          REP(i, nn) {\\n            int j = sa[n-nn+i];\\n            sa[n-nn+i] = -1;\\n            sa[b[a[j]]++] = j;\\n          }\\n        }\\n        if (minor)\\n          plus_to_minus(a, sa, n, k);\\n        else\\n          minus_to_plus(a, sa, n, k);\\n      }\\n    \\n      template<typename T>\\n      void main(const T a[], int n, int k, int sa[], int b[])\\n      {\\n        if (n > 0) {\\n          KoAluru::b = b;\\n          t = new bool[n];\\n          ka(a, n, k, sa);\\n          delete[] t;\\n        }\\n      }\\n    };\\n    \\n    class Solution {\\n      vector<int> maxSubseq(const vector<int> &a, int c) {\\n        vector<int> r;\\n        REP(i, a.size()) {\\n          while (r.size()+a.size()-i > c && r.size() && r.back() < a[i])\\n            r.pop_back();\\n          if (r.size() < c)\\n            r.push_back(a[i]);\\n        }\\n        return r;\\n      }\\n      vector<int> interleave(vector<int> a, const vector<int> &b) {\\n        int m = a.size(), n = b.size(), i = 0, j = 0, k = 0;\\n        vector<int> sa(m+n+1), rnk(max(m+n+1, 10+1));\\n        a.resize(m+n+1);\\n        REP(i, m)\\n          a[i]++;\\n        a[m] = 0;\\n        REP(i, n)\\n          a[m+1+i] = b[i]+1;\\n        KoAluru::main(&a[0], m+n+1, 10+1, &sa[0], &rnk[0]);\\n        REP(i, m+n+1)\\n          rnk[sa[i]] = i;\\n        while (i < m || j < n)\\n          if (j == n || i < m && rnk[i] > rnk[m+1+j])\\n            sa[k++] = a[i++]-1;\\n          else\\n            sa[k++] = b[j++];\\n        sa.pop_back();\\n        return sa;\\n      }\\n    public:\\n      vector<int> maxNumber(vector<int> &a, vector<int> &b, int k) {\\n        int m = a.size(), n = b.size();\\n        vector<int> mx;\\n        for (int i = max(k-n, 0); i <= min(k, m); i++) {\\n          auto t = interleave(maxSubseq(a, i), maxSubseq(b, k-i));\\n          if (lexicographical_compare(mx.begin(), mx.end(), t.begin(), t.end()))\\n            mx.swap(t);\\n        }\\n        return mx;\\n      }\\n    };\\n\\n[https://github.com/MaskRay/LeetCode/blob/master/create-maximum-number.cc][1]\\n\\n\\n  [1]: https://github.com/MaskRay/LeetCode/blob/master/create-maximum-number.cc",
                "solutionTags": [],
                "code": "class Solution {\\n      vector<int> maxSubseq(const vector<int> &a, int c) {\\n        vector<int> r;\\n        REP(i, a.size()) {\\n          while (r.size()+a.size()-i > c && r.size() && r.back() < a[i])\\n            r.pop_back();\\n          if (r.size() < c)\\n            r.push_back(a[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77351,
                "title": "tle-python-dp-solution-o-k-m-n-m-n",
                "content": "Short but TLE... :P\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            len1 = len(nums1)\\n            len2 = len(nums2)\\n            dp = [[[[]] * (len2 + 1) for x in range(len1 + 1)] for y in range(k + 1)]\\n            for z in range(1, k + 1):\\n                for x in range(len1 + 1):\\n                    for y in range(len2 + 1):\\n                        for p in range(x):\\n                            if len(dp[z-1][p][y]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][p][y]+[nums1[p]])\\n                        for q in range(y):\\n                            if len(dp[z-1][x][q]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][x][q]+[nums2[q]])\\n            return dp[k][len1][len2]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Short but TLE... :P\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            len1 = len(nums1)\\n            len2 = len(nums2)\\n            dp = [[[[]] * (len2 + 1) for x in range(len1 + 1)] for y in range(k + 1)]\\n            for z in range(1, k + 1):\\n                for x in range(len1 + 1):\\n                    for y in range(len2 + 1):\\n                        for p in range(x):\\n                            if len(dp[z-1][p][y]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][p][y]+[nums1[p]])\\n                        for q in range(y):\\n                            if len(dp[z-1][x][q]) == z - 1:\\n                                dp[z][x][y] = max(dp[z][x][y], dp[z-1][x][q]+[nums2[q]])\\n            return dp[k][len1][len2]",
                "codeTag": "Java"
            },
            {
                "id": 4077513,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string&str1 , string&str2 , int i , int j){\\n        while(i < str1.size() || j < str2.size()){\\n            if(i >= str1.size()) return false;\\n            else if(j >= str2.size())return true;\\n            else if(str1[i] < str2[j])return false;\\n            else if(str1[i] > str2[j])return true;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    string mergeSort(string &str1 , string str2){\\n        int n = str1.size();\\n        int m = str2.size();\\n\\n        string result = \"\";\\n        int i = 0 , j = 0;\\n        while(i < n && j < m){\\n            if(str1[i]==str2[j]){\\n                if(check(str1 , str2 , i + 1 , j + 1)==true){\\n                    result+=str1[i++];\\n                }else{\\n                    result+=str2[j++];\\n                }\\n            }\\n            else if(str1[i] > str2[j]){\\n                result += str1[i];\\n                i++;\\n            }else{\\n                result+=str2[j];\\n                j++;\\n            }\\n        }\\n        while(i < n){\\n            result += str1[i++];\\n        }\\n        while(j < m){\\n            result += str2[j++];\\n        }\\n        return result;\\n    }\\n    string findMaxK(vector<int>&nums , int k){\\n        int n = nums.size();\\n        int toRemove = n - k;\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            int number = nums[i];\\n            while(st.size() && st.top()<number && toRemove>0){\\n                toRemove--;\\n                st.pop();\\n            }\\n            st.push(number);\\n        }\\n        while(toRemove>0){\\n            st.pop();\\n            toRemove--;\\n        }\\n        string result = \"\";\\n        while(st.size()){\\n            result += (st.top() + \\'0\\');\\n            st.pop();\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        string result(k , \\'0\\');\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i <= k ; i++){\\n            int fromFirst = i;\\n            int fromSecond = k - i;\\n            if(fromFirst > n || fromSecond > m)continue;\\n            string first = findMaxK(nums1 , fromFirst);\\n            string second = findMaxK(nums2 , fromSecond);\\n            string answer = mergeSort(first , second);\\n            result = max(result , answer);\\n            cout<<result<<endl;\\n        }\\n        cout<<findMaxK(nums1 , 1)<<endl;\\n        vector<int> answer;\\n        for(auto ch : result)answer.push_back(ch - \\'0\\');\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string&str1 , string&str2 , int i , int j){\\n        while(i < str1.size() || j < str2.size()){\\n            if(i >= str1.size()) return false;\\n            else if(j >= str2.size())return true;\\n            else if(str1[i] < str2[j])return false;\\n            else if(str1[i] > str2[j])return true;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    string mergeSort(string &str1 , string str2){\\n        int n = str1.size();\\n        int m = str2.size();\\n\\n        string result = \"\";\\n        int i = 0 , j = 0;\\n        while(i < n && j < m){\\n            if(str1[i]==str2[j]){\\n                if(check(str1 , str2 , i + 1 , j + 1)==true){\\n                    result+=str1[i++];\\n                }else{\\n                    result+=str2[j++];\\n                }\\n            }\\n            else if(str1[i] > str2[j]){\\n                result += str1[i];\\n                i++;\\n            }else{\\n                result+=str2[j];\\n                j++;\\n            }\\n        }\\n        while(i < n){\\n            result += str1[i++];\\n        }\\n        while(j < m){\\n            result += str2[j++];\\n        }\\n        return result;\\n    }\\n    string findMaxK(vector<int>&nums , int k){\\n        int n = nums.size();\\n        int toRemove = n - k;\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i = 1 ; i < n ; i++){\\n            int number = nums[i];\\n            while(st.size() && st.top()<number && toRemove>0){\\n                toRemove--;\\n                st.pop();\\n            }\\n            st.push(number);\\n        }\\n        while(toRemove>0){\\n            st.pop();\\n            toRemove--;\\n        }\\n        string result = \"\";\\n        while(st.size()){\\n            result += (st.top() + \\'0\\');\\n            st.pop();\\n        }\\n        reverse(result.begin() , result.end());\\n        return result;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        string result(k , \\'0\\');\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i <= k ; i++){\\n            int fromFirst = i;\\n            int fromSecond = k - i;\\n            if(fromFirst > n || fromSecond > m)continue;\\n            string first = findMaxK(nums1 , fromFirst);\\n            string second = findMaxK(nums2 , fromSecond);\\n            string answer = mergeSort(first , second);\\n            result = max(result , answer);\\n            cout<<result<<endl;\\n        }\\n        cout<<findMaxK(nums1 , 1)<<endl;\\n        vector<int> answer;\\n        for(auto ch : result)answer.push_back(ch - \\'0\\');\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4022386,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSub(vector<int>&num,int l){\\n        vector<int>ans;\\n        int n=num.size();\\n        for(int i=0;i<num.size();i++){\\n            while(!ans.empty() && ans.back()<num[i] && n-i-1>=l-ans.size()){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<l){\\n                ans.push_back(num[i]);\\n            }\\n        }\\n        // for(auto it:ans){cout<<it;}cout<<endl;\\n        return ans;\\n    }\\n    bool check(vector<int>&s1,vector<int>&s2,int i,int j){\\n        // int i=0;\\n        // int j=0;\\n        vector<int>ans;\\n        //checks whether s1>s2 lexo or not\\n        while(i<s1.size() || j<s2.size()){\\n            if(i>=s1.size()){\\n                return 0;\\n            }else if(j>=s2.size()){\\n                return 1;\\n            }else if(s1[i]>s2[j]){\\n                return 1;\\n            }else if(s2[j]>s1[i]){\\n                return 0;\\n            }else{\\n               i++;j++;\\n            }\\n        }\\n        return 1;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int>res;\\n        for(int k1=0;k1<=k;k1++){\\n            int k2=k-k1;\\n            if(k1>nums1.size() || k2>nums2.size()){\\n                continue;\\n            }\\n            vector<int>s1=maxSub(nums1,k1);\\n            vector<int>s2=maxSub(nums2,k2);\\n            int i=0;\\n            int j=0;\\n            vector<int>ans;\\n            while(i<s1.size() || j<s2.size()){\\n                if(i>=s1.size()){\\n                    ans.push_back(s2[j++]);\\n                }else if(j>=s2.size()){\\n                    ans.push_back(s1[i++]);\\n                }else if(s1[i]>s2[j]){\\n                    ans.push_back(s1[i++]);\\n                }else if(s2[j]>s1[i]){\\n                    ans.push_back(s2[j++]);\\n                }else{\\n                    //find the greater subs vector\\n                    if(check(s1,s2,i,j)){\\n                        ans.push_back(s1[i++]);\\n                    }else{\\n                        ans.push_back(s2[j++]);\\n                    }\\n                }\\n            }\\n            if(res<ans){\\n                res=ans;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# **PLEASE UPVOTE IF YOU LIKED!!**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSub(vector<int>&num,int l){\\n        vector<int>ans;\\n        int n=num.size();\\n        for(int i=0;i<num.size();i++){\\n            while(!ans.empty() && ans.back()<num[i] && n-i-1>=l-ans.size()){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<l){\\n                ans.push_back(num[i]);\\n            }\\n        }\\n        // for(auto it:ans){cout<<it;}cout<<endl;\\n        return ans;\\n    }\\n    bool check(vector<int>&s1,vector<int>&s2,int i,int j){\\n        // int i=0;\\n        // int j=0;\\n        vector<int>ans;\\n        //checks whether s1>s2 lexo or not\\n        while(i<s1.size() || j<s2.size()){\\n            if(i>=s1.size()){\\n                return 0;\\n            }else if(j>=s2.size()){\\n                return 1;\\n            }else if(s1[i]>s2[j]){\\n                return 1;\\n            }else if(s2[j]>s1[i]){\\n                return 0;\\n            }else{\\n               i++;j++;\\n            }\\n        }\\n        return 1;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int>res;\\n        for(int k1=0;k1<=k;k1++){\\n            int k2=k-k1;\\n            if(k1>nums1.size() || k2>nums2.size()){\\n                continue;\\n            }\\n            vector<int>s1=maxSub(nums1,k1);\\n            vector<int>s2=maxSub(nums2,k2);\\n            int i=0;\\n            int j=0;\\n            vector<int>ans;\\n            while(i<s1.size() || j<s2.size()){\\n                if(i>=s1.size()){\\n                    ans.push_back(s2[j++]);\\n                }else if(j>=s2.size()){\\n                    ans.push_back(s1[i++]);\\n                }else if(s1[i]>s2[j]){\\n                    ans.push_back(s1[i++]);\\n                }else if(s2[j]>s1[i]){\\n                    ans.push_back(s2[j++]);\\n                }else{\\n                    //find the greater subs vector\\n                    if(check(s1,s2,i,j)){\\n                        ans.push_back(s1[i++]);\\n                    }else{\\n                        ans.push_back(s2[j++]);\\n                    }\\n                }\\n            }\\n            if(res<ans){\\n                res=ans;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3909404,
                "title": "monotonic-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        int n = v1.size(), m = v2.size();\\n        // 1st wale se i, le rha , second se k - i\\n        vector<int> chk;\\n        for(int i=0;i<k;i++){\\n            chk.push_back(0);\\n        }\\n        for(int i=0;i<=n and k-i>=0;i++){\\n            int fstNeed = i, secNeed = k - i;\\n            int fstRem = n - fstNeed, secRem = m - secNeed;\\n            vector<int> ans;\\n            if(secRem < 0) continue;\\n            stack<int> s;\\n            vector<int> fst;\\n            for(int j=0;j<n;j++){\\n                while(s.size() > 0 and v1[j] > s.top() and fstRem){\\n                    s.pop();\\n                    fstRem --;\\n                }\\n                s.push(v1[j]);\\n            }\\n            while(fstRem --) s.pop();\\n            while(s.size() > 0) fst.push_back(s.top()), s.pop();\\n            reverse(fst.begin(), fst.end());\\n            vector<int> sec;\\n            for(int j=0;j<m;j++){\\n                while(s.size() > 0 and v2[j] > s.top() and secRem){\\n                    s.pop(); secRem --;\\n                }\\n                s.push(v2[j]);\\n            }\\n            while(secRem --) s.pop();\\n            while(s.size() > 0) sec.push_back(s.top()), s.pop();\\n            reverse(sec.begin(), sec.end());\\n            if(sec.size() == 0 or fst.size() == 0){\\n                if(sec.size() == 0) ans = fst;\\n                else ans = sec;\\n            }\\n            else{\\n                int k1 = 0, k2 = 0;\\n                while(k1 < ((int)fst.size()) and k2 < ((int)sec.size())){\\n                    if(fst[k1] > sec[k2]){\\n                        ans.push_back(fst[k1]);\\n                        k1++;\\n                    }\\n                    else if(sec[k2] > fst[k1]){\\n                        ans.push_back(sec[k2]);\\n                        k2++;\\n                    }\\n                    else{\\n                        // equal wala scene\\n                        int vp = -1;\\n                        for(int l=0;;l++){\\n                            if(k1+l >= fst.size()){\\n                                ans.push_back(sec[k2]), k2++;\\n                                break;\\n                            }\\n                            if(k2+l >= sec.size()){\\n                                ans.push_back(fst[k1]), k1++;\\n                                break;\\n                            }\\n                            if(fst[k1+l] > sec[k2+l]){\\n                                vp = 1;\\n                                break;\\n                            }\\n                            else if(fst[k1+l] < sec[k2+l]){\\n                                vp = 0;\\n                                break;\\n                            }\\n                        }\\n                        if(vp == 1) ans.push_back(fst[k1]), k1++;\\n                        else if(vp == 0) ans.push_back(sec[k2]), k2++;\\n                    }\\n                }\\n                for(int j=k1;j<fst.size();j++){\\n                    ans.push_back(fst[j]);\\n                }\\n                for(int j=k2;j<sec.size();j++){\\n                    ans.push_back(sec[j]);\\n                }\\n            }\\n            if(ans > chk){\\n                chk = ans;\\n            }\\n        }\\n        return chk;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        int n = v1.size(), m = v2.size();\\n        // 1st wale se i, le rha , second se k - i\\n        vector<int> chk;\\n        for(int i=0;i<k;i++){\\n            chk.push_back(0);\\n        }\\n        for(int i=0;i<=n and k-i>=0;i++){\\n            int fstNeed = i, secNeed = k - i;\\n            int fstRem = n - fstNeed, secRem = m - secNeed;\\n            vector<int> ans;\\n            if(secRem < 0) continue;\\n            stack<int> s;\\n            vector<int> fst;\\n            for(int j=0;j<n;j++){\\n                while(s.size() > 0 and v1[j] > s.top() and fstRem){\\n                    s.pop();\\n                    fstRem --;\\n                }\\n                s.push(v1[j]);\\n            }\\n            while(fstRem --) s.pop();\\n            while(s.size() > 0) fst.push_back(s.top()), s.pop();\\n            reverse(fst.begin(), fst.end());\\n            vector<int> sec;\\n            for(int j=0;j<m;j++){\\n                while(s.size() > 0 and v2[j] > s.top() and secRem){\\n                    s.pop(); secRem --;\\n                }\\n                s.push(v2[j]);\\n            }\\n            while(secRem --) s.pop();\\n            while(s.size() > 0) sec.push_back(s.top()), s.pop();\\n            reverse(sec.begin(), sec.end());\\n            if(sec.size() == 0 or fst.size() == 0){\\n                if(sec.size() == 0) ans = fst;\\n                else ans = sec;\\n            }\\n            else{\\n                int k1 = 0, k2 = 0;\\n                while(k1 < ((int)fst.size()) and k2 < ((int)sec.size())){\\n                    if(fst[k1] > sec[k2]){\\n                        ans.push_back(fst[k1]);\\n                        k1++;\\n                    }\\n                    else if(sec[k2] > fst[k1]){\\n                        ans.push_back(sec[k2]);\\n                        k2++;\\n                    }\\n                    else{\\n                        // equal wala scene\\n                        int vp = -1;\\n                        for(int l=0;;l++){\\n                            if(k1+l >= fst.size()){\\n                                ans.push_back(sec[k2]), k2++;\\n                                break;\\n                            }\\n                            if(k2+l >= sec.size()){\\n                                ans.push_back(fst[k1]), k1++;\\n                                break;\\n                            }\\n                            if(fst[k1+l] > sec[k2+l]){\\n                                vp = 1;\\n                                break;\\n                            }\\n                            else if(fst[k1+l] < sec[k2+l]){\\n                                vp = 0;\\n                                break;\\n                            }\\n                        }\\n                        if(vp == 1) ans.push_back(fst[k1]), k1++;\\n                        else if(vp == 0) ans.push_back(sec[k2]), k2++;\\n                    }\\n                }\\n                for(int j=k1;j<fst.size();j++){\\n                    ans.push_back(fst[j]);\\n                }\\n                for(int j=k2;j<sec.size();j++){\\n                    ans.push_back(sec[j]);\\n                }\\n            }\\n            if(ans > chk){\\n                chk = ans;\\n            }\\n        }\\n        return chk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885687,
                "title": "bfs-solution-c-93-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    If you are interested in knowing how the solution is working, please reply below as I would like to explain the approach only if there is someone interested in knowing. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Comb {\\n        int i;\\n        int j;\\n        int lastNum;\\n        Comb(){\\n            i=0;\\n            j=0;\\n        }\\n    };\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> res;\\n        queue<Comb> q;\\n        Comb cmb;\\n        q.push(cmb);\\n        vector<vector<bool>> done(n+1, vector<bool>(m+1, false));\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<Comb> combStk;\\n            int mxLastVal = 0;\\n\\n            while(siz--){\\n                Comb top = q.front();\\n                q.pop();\\n                if (done[top.i][top.j]) continue;\\n                done[top.i][top.j] = true;\\n                int rem = k - res.size();\\n                int tot = (n-top.i) + (m-top.j);\\n                \\n                int iMax = min(tot-rem+top.i, n-1);\\n                int jMax = min(tot-rem+top.j, m-1);\\n\\n                int imxIdx = top.i;\\n                int jmxIdx = top.j;\\n\\n                for(int i=top.i; i<= iMax; i++){\\n                    if (nums1[i] > nums1[imxIdx]) imxIdx = i;\\n                }\\n                for(int j=top.j; j<= jMax; j++){\\n                    if (nums2[j] > nums2[jmxIdx]) jmxIdx = j;\\n                }\\n\\n                if ( (imxIdx <= iMax && jmxIdx > jMax) ||  ( imxIdx <= iMax && nums1[imxIdx] >= nums2[jmxIdx]) ){\\n                    Comb iChild;\\n                    iChild.lastNum = nums1[imxIdx];\\n                    iChild.i = imxIdx+1;\\n                    iChild.j = top.j;\\n                    combStk.push_back(iChild);\\n                    mxLastVal = max(mxLastVal, nums1[imxIdx]);\\n                }\\n                if ( (jmxIdx <= jMax && imxIdx > iMax) ||   ( jmxIdx <= jMax &&  nums1[imxIdx] <= nums2[jmxIdx]) ){\\n                    Comb jChild;\\n                    jChild.lastNum = nums2[jmxIdx];\\n                    jChild.i = top.i;\\n                    jChild.j = jmxIdx+1;\\n                    combStk.push_back(jChild);\\n                    mxLastVal = max(mxLastVal, nums2[jmxIdx]);\\n                }\\n\\n            }\\n            res.push_back(mxLastVal);\\n\\n            if (k == res.size()) return res;\\n            for(Comb comb : combStk){\\n                if (comb.lastNum < mxLastVal) continue;\\n                q.push(comb);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Comb {\\n        int i;\\n        int j;\\n        int lastNum;\\n        Comb(){\\n            i=0;\\n            j=0;\\n        }\\n    };\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> res;\\n        queue<Comb> q;\\n        Comb cmb;\\n        q.push(cmb);\\n        vector<vector<bool>> done(n+1, vector<bool>(m+1, false));\\n        while(!q.empty()){\\n            int siz = q.size();\\n            vector<Comb> combStk;\\n            int mxLastVal = 0;\\n\\n            while(siz--){\\n                Comb top = q.front();\\n                q.pop();\\n                if (done[top.i][top.j]) continue;\\n                done[top.i][top.j] = true;\\n                int rem = k - res.size();\\n                int tot = (n-top.i) + (m-top.j);\\n                \\n                int iMax = min(tot-rem+top.i, n-1);\\n                int jMax = min(tot-rem+top.j, m-1);\\n\\n                int imxIdx = top.i;\\n                int jmxIdx = top.j;\\n\\n                for(int i=top.i; i<= iMax; i++){\\n                    if (nums1[i] > nums1[imxIdx]) imxIdx = i;\\n                }\\n                for(int j=top.j; j<= jMax; j++){\\n                    if (nums2[j] > nums2[jmxIdx]) jmxIdx = j;\\n                }\\n\\n                if ( (imxIdx <= iMax && jmxIdx > jMax) ||  ( imxIdx <= iMax && nums1[imxIdx] >= nums2[jmxIdx]) ){\\n                    Comb iChild;\\n                    iChild.lastNum = nums1[imxIdx];\\n                    iChild.i = imxIdx+1;\\n                    iChild.j = top.j;\\n                    combStk.push_back(iChild);\\n                    mxLastVal = max(mxLastVal, nums1[imxIdx]);\\n                }\\n                if ( (jmxIdx <= jMax && imxIdx > iMax) ||   ( jmxIdx <= jMax &&  nums1[imxIdx] <= nums2[jmxIdx]) ){\\n                    Comb jChild;\\n                    jChild.lastNum = nums2[jmxIdx];\\n                    jChild.i = top.i;\\n                    jChild.j = jmxIdx+1;\\n                    combStk.push_back(jChild);\\n                    mxLastVal = max(mxLastVal, nums2[jmxIdx]);\\n                }\\n\\n            }\\n            res.push_back(mxLastVal);\\n\\n            if (k == res.size()) return res;\\n            for(Comb comb : combStk){\\n                if (comb.lastNum < mxLastVal) continue;\\n                q.push(comb);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838340,
                "title": "java-solution-with-descriptive-comments-on-each-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    * This function firstly fetches the digits from each array with all combinations\\n    * By combination I mean, let say k = 5, then from both the arrays number of digits can be any number less than equal to k\\n    * For eg, [6,7,1] [6,0,4] and k =5 -> we can choose 3 digits from first array and 2 from second; or vice-a-versa.\\n    * Note : the digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    *\\n    *\\n    * This function creates all those combinations and then merges the chosen digits from 1st array and 2nd array.\\n    *\\n    * Then it sorts all the merged combinations and return the largest one.\\n    */\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        List<String> allPossibleNumbers = new ArrayList<>();\\n        int num1Start = Math.min(k, nums1.length);\\n        for (int i = 0; i < k; i++) {\\n            String num1LargestNumberOfSizeRem = getLargestNumber(nums1, num1Start);\\n            int rem = k - (num1LargestNumberOfSizeRem.length());\\n            if (rem > nums2.length) {\\n                break;\\n            }\\n            String num2LargestNumberOfSizeRem = getLargestNumber(nums2, rem);\\n            String mergedNumber = mergeNumbers(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem);\\n            allPossibleNumbers.add(mergedNumber);\\n            num1Start--;\\n        }\\n        allPossibleNumbers.sort((o1, o2) -> -1 * (o1.compareTo(o2)));\\n        String largestNumber = allPossibleNumbers.get(0);\\n        int[] res = new int[k];\\n        int index = 0;\\n        while (index < largestNumber.length()) {\\n            res[index] = largestNumber.charAt(index) - \\'0\\';\\n            index++;\\n        }\\n        return res;\\n    }\\n\\n    /*\\n    *  We\\'ll not do the direct comparison of digits as it can give wrong answer\\n    *  So, we\\'ll use compare function to check which string digit should be used. By checking which one is small, and if equal\\n        then what are the subsequent digits.\\n    *  For example - Let say we get two strings - 6,7 and 6,0,4. If we want to compare the characters of these two strings in\\n        case of first element which is 6, it is mandatory that I choose from string 1, as i should be pointing at 7\\n        so that on next comparison 7 should be compared with 6 of second string.\\n        If we do Vice-a-Versa, 0 will compared with 6 of string 1 and we\\'ll get two 66 in the start which will be wrong.\\n    */\\n    private String mergeNumbers(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem) {\\n        StringBuilder largestNumber = new StringBuilder();\\n        int i = 0, j = 0, indexOfMergedString = 0;\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n        while (i < num1Len && j < num2Len) {\\n            if (considerNum1Character(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem, i, j)) {\\n                largestNumber.insert(indexOfMergedString, num1LargestNumberOfSizeRem.charAt(i));\\n                i++;\\n            } else {\\n                largestNumber.insert(indexOfMergedString, num2LargestNumberOfSizeRem.charAt(j));\\n                j++;\\n            }\\n            indexOfMergedString++;\\n        }\\n        while (i < num1Len) {\\n            largestNumber.insert(indexOfMergedString++, num1LargestNumberOfSizeRem.charAt(i));\\n            i++;\\n        }\\n        while (j < num2Len) {\\n            largestNumber.insert(indexOfMergedString++, num2LargestNumberOfSizeRem.charAt(j));\\n            j++;\\n        }\\n        return largestNumber.toString();\\n    }\\n\\n    /*\\n        This method is to check if we can consider the first string, by comparing both the string subsequent characters\\n    */\\n    private boolean considerNum1Character(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem, int i, int j) {\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n\\n        while (i < num1Len && j < num2Len && num1LargestNumberOfSizeRem.charAt(i) == num2LargestNumberOfSizeRem.charAt(j)) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2Len || (i < num1Len && num1LargestNumberOfSizeRem.charAt(i) > num2LargestNumberOfSizeRem.charAt(j));\\n    }\\n\\n    /*\\n    * The digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    * It uses monotonously decreasing stack algorithm.\\n    */\\n    private String getLargestNumber(int[] number, int size) {\\n        if (size <= 0) {\\n            return \"\";\\n        }\\n        int maxDigitsThatCanBeIgnored = number.length - size;\\n        Stack<Integer> stack = new Stack<>();\\n        int i = 0;\\n        while (i < number.length) {\\n            while (maxDigitsThatCanBeIgnored > 0 && stack.size() > 0 && stack.peek() < number[i]) {\\n                stack.pop();\\n                maxDigitsThatCanBeIgnored--;\\n            }\\n            stack.push(number[i]);\\n            i++;\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (stack.size() > 0) {\\n            res.insert(0, stack.pop());\\n        }\\n        return res.substring(0, size);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    * This function firstly fetches the digits from each array with all combinations\\n    * By combination I mean, let say k = 5, then from both the arrays number of digits can be any number less than equal to k\\n    * For eg, [6,7,1] [6,0,4] and k =5 -> we can choose 3 digits from first array and 2 from second; or vice-a-versa.\\n    * Note : the digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    *\\n    *\\n    * This function creates all those combinations and then merges the chosen digits from 1st array and 2nd array.\\n    *\\n    * Then it sorts all the merged combinations and return the largest one.\\n    */\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        List<String> allPossibleNumbers = new ArrayList<>();\\n        int num1Start = Math.min(k, nums1.length);\\n        for (int i = 0; i < k; i++) {\\n            String num1LargestNumberOfSizeRem = getLargestNumber(nums1, num1Start);\\n            int rem = k - (num1LargestNumberOfSizeRem.length());\\n            if (rem > nums2.length) {\\n                break;\\n            }\\n            String num2LargestNumberOfSizeRem = getLargestNumber(nums2, rem);\\n            String mergedNumber = mergeNumbers(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem);\\n            allPossibleNumbers.add(mergedNumber);\\n            num1Start--;\\n        }\\n        allPossibleNumbers.sort((o1, o2) -> -1 * (o1.compareTo(o2)));\\n        String largestNumber = allPossibleNumbers.get(0);\\n        int[] res = new int[k];\\n        int index = 0;\\n        while (index < largestNumber.length()) {\\n            res[index] = largestNumber.charAt(index) - \\'0\\';\\n            index++;\\n        }\\n        return res;\\n    }\\n\\n    /*\\n    *  We\\'ll not do the direct comparison of digits as it can give wrong answer\\n    *  So, we\\'ll use compare function to check which string digit should be used. By checking which one is small, and if equal\\n        then what are the subsequent digits.\\n    *  For example - Let say we get two strings - 6,7 and 6,0,4. If we want to compare the characters of these two strings in\\n        case of first element which is 6, it is mandatory that I choose from string 1, as i should be pointing at 7\\n        so that on next comparison 7 should be compared with 6 of second string.\\n        If we do Vice-a-Versa, 0 will compared with 6 of string 1 and we\\'ll get two 66 in the start which will be wrong.\\n    */\\n    private String mergeNumbers(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem) {\\n        StringBuilder largestNumber = new StringBuilder();\\n        int i = 0, j = 0, indexOfMergedString = 0;\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n        while (i < num1Len && j < num2Len) {\\n            if (considerNum1Character(num1LargestNumberOfSizeRem, num2LargestNumberOfSizeRem, i, j)) {\\n                largestNumber.insert(indexOfMergedString, num1LargestNumberOfSizeRem.charAt(i));\\n                i++;\\n            } else {\\n                largestNumber.insert(indexOfMergedString, num2LargestNumberOfSizeRem.charAt(j));\\n                j++;\\n            }\\n            indexOfMergedString++;\\n        }\\n        while (i < num1Len) {\\n            largestNumber.insert(indexOfMergedString++, num1LargestNumberOfSizeRem.charAt(i));\\n            i++;\\n        }\\n        while (j < num2Len) {\\n            largestNumber.insert(indexOfMergedString++, num2LargestNumberOfSizeRem.charAt(j));\\n            j++;\\n        }\\n        return largestNumber.toString();\\n    }\\n\\n    /*\\n        This method is to check if we can consider the first string, by comparing both the string subsequent characters\\n    */\\n    private boolean considerNum1Character(String num1LargestNumberOfSizeRem, String num2LargestNumberOfSizeRem, int i, int j) {\\n        int num1Len = num1LargestNumberOfSizeRem.length();\\n        int num2Len = num2LargestNumberOfSizeRem.length();\\n\\n        while (i < num1Len && j < num2Len && num1LargestNumberOfSizeRem.charAt(i) == num2LargestNumberOfSizeRem.charAt(j)) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2Len || (i < num1Len && num1LargestNumberOfSizeRem.charAt(i) > num2LargestNumberOfSizeRem.charAt(j));\\n    }\\n\\n    /*\\n    * The digits it chooses(let say of size 3) are the best 3 digits of that array.\\n    * It uses monotonously decreasing stack algorithm.\\n    */\\n    private String getLargestNumber(int[] number, int size) {\\n        if (size <= 0) {\\n            return \"\";\\n        }\\n        int maxDigitsThatCanBeIgnored = number.length - size;\\n        Stack<Integer> stack = new Stack<>();\\n        int i = 0;\\n        while (i < number.length) {\\n            while (maxDigitsThatCanBeIgnored > 0 && stack.size() > 0 && stack.peek() < number[i]) {\\n                stack.pop();\\n                maxDigitsThatCanBeIgnored--;\\n            }\\n            stack.push(number[i]);\\n            i++;\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (stack.size() > 0) {\\n            res.insert(0, stack.pop());\\n        }\\n        return res.substring(0, size);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806927,
                "title": "efficient-js-solution-beat-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/d0b8979a-7415-4d0f-aec0-5b7c82007afe_1690136461.6128085.png)\\n\\n# Complexity\\n- Time complexity: $$O(k * (m+n))$$\\n- Space complexity: $$O(k + m + n)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxNumber = function (nums1, nums2, k) {\\n  const n1 = nums1.length;\\n  const n2 = nums2.length;\\n  let result = Array(k).fill(0);\\n  let candidate = Array(k).fill(0);\\n  const part1 = Array(k + 1).fill(0);\\n  const part2 = Array(k + 1).fill(0);\\n\\n  /**\\n   * @param {number[]} source\\n   * @param {number[]} target\\n   * @param {number} k\\n   */\\n  function pickPart(source, target, k) {\\n    let rm = source.length - k;\\n    let j = 0;\\n\\n    for (let i = 0; i < source.length; i++) {\\n      while (rm && j && source[i] > target[j - 1]) {\\n        rm--;\\n        j--;\\n      }\\n      target[j++] = source[i];\\n    }\\n\\n    target[k] = -1;\\n    return target;\\n  }\\n\\n  const lowerL = Math.max(0, k - n2);\\n  const upperL = Math.min(n1, k);\\n  let l2, opt;\\n\\n  function merge() {\\n    let i1 = 0;\\n    let i2 = 0;\\n    let flagOpt = false;\\n\\n    for (let i = 0; i < k; i++) {\\n      let r1 = i1;\\n      let r2 = i2;\\n      while (part1[r1] === part2[r2] && part1[r1] !== -1) {\\n        r1++;\\n        r2++;\\n      }\\n      if (part1[r1] > part2[r2]) {\\n        candidate[i] = part1[i1++];\\n      } else {\\n        candidate[i] = part2[i2++];\\n      }\\n      if (!flagOpt) {\\n        if (candidate[i] > result[i]) flagOpt = true;\\n        else if (candidate[i] < result[i]) return false;\\n      }\\n    }\\n\\n    return flagOpt;\\n  }\\n\\n  for (let l1 = lowerL; l1 <= upperL; l1++) {\\n    l2 = k - l1;\\n    pickPart(nums1, part1, l1);\\n    pickPart(nums2, part2, l2);\\n    opt = merge(l1, l2);\\n    if (opt) [result, candidate] = [candidate, result];\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Greedy"
                ],
                "code": "```jsx\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxNumber = function (nums1, nums2, k) {\\n  const n1 = nums1.length;\\n  const n2 = nums2.length;\\n  let result = Array(k).fill(0);\\n  let candidate = Array(k).fill(0);\\n  const part1 = Array(k + 1).fill(0);\\n  const part2 = Array(k + 1).fill(0);\\n\\n  /**\\n   * @param {number[]} source\\n   * @param {number[]} target\\n   * @param {number} k\\n   */\\n  function pickPart(source, target, k) {\\n    let rm = source.length - k;\\n    let j = 0;\\n\\n    for (let i = 0; i < source.length; i++) {\\n      while (rm && j && source[i] > target[j - 1]) {\\n        rm--;\\n        j--;\\n      }\\n      target[j++] = source[i];\\n    }\\n\\n    target[k] = -1;\\n    return target;\\n  }\\n\\n  const lowerL = Math.max(0, k - n2);\\n  const upperL = Math.min(n1, k);\\n  let l2, opt;\\n\\n  function merge() {\\n    let i1 = 0;\\n    let i2 = 0;\\n    let flagOpt = false;\\n\\n    for (let i = 0; i < k; i++) {\\n      let r1 = i1;\\n      let r2 = i2;\\n      while (part1[r1] === part2[r2] && part1[r1] !== -1) {\\n        r1++;\\n        r2++;\\n      }\\n      if (part1[r1] > part2[r2]) {\\n        candidate[i] = part1[i1++];\\n      } else {\\n        candidate[i] = part2[i2++];\\n      }\\n      if (!flagOpt) {\\n        if (candidate[i] > result[i]) flagOpt = true;\\n        else if (candidate[i] < result[i]) return false;\\n      }\\n    }\\n\\n    return flagOpt;\\n  }\\n\\n  for (let l1 = lowerL; l1 <= upperL; l1++) {\\n    l2 = k - l1;\\n    pickPart(nums1, part1, l1);\\n    pickPart(nums2, part2, l2);\\n    opt = merge(l1, l2);\\n    if (opt) [result, candidate] = [candidate, result];\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800466,
                "title": "python-divide-into-subproblems",
                "content": "The credits to this approach -> https://www.youtube.com/watch?v=ZHexy3JW2JA\\n\\nBasically, we can divide this problem into sub problems and then solve each of the subproblem.\\n\\nWe want to make the maximum number by picking numbers from two different lists but the thing is we can only pick them in the same order as they appear in each of the lists.\\n\\nWhat that means is,\\n\\n    Suppose, we have nums1 = [1,8,9] and nums2 = [3,4] and k = 4\\n\\n    We are asked to create the maximum number of length \"4\"\\n\\n    In that case, we cannot pick \"9\" to be the first digit\\n    Because if we do that, then we only have two numbers left to choose from  - \"3\" and \"4\".\\n    We cannot choose \"1\" and \"8\" because we have already chosen \"9\" and we are asked to preserve the order\\n\\n    So, we have to choose \"8\" as the first digit, \"9\" as second, \"3\" as third and \"4\" as forth.\\n\\n    So, the output in this case will be [8,9,3,4]\\n\\n\\nSo, as we see, we have to make a choice of picking numbers. We can take some amount of numbers from one list and some amount from other.\\nIt is also possible that we take numbers from only one list.\\n\\n    E.g. if nums1 = [9,9,9] and nums2 = [1,2,3] and k = 3\\n\\n    Then we simply return [9,9,9] since there cannot be any greater number that we can create of length 3\\n\\n    So, in this case, we picked 0 elements from second list.\\n\\n\\nSo, how can we know how many numbers we should take from one list and how many we should take from the other?\\n\\nWell, we cannot. So, we have to try all the possible combinations.\\n\\nThat is, suppose, k = 4 and nums1 = [1,2,3] and nums2 = [1,5,4]\\n\\n\\tPick 0 numbers from nums1 and 4 numbers from nums2 -> Invalid since length of nums2 is \"3\"\\n\\tPick 1 number from nums1 and 3 numbers from nums2 -> [3] and [1,5,4] will be the best combo\\n\\tPick 2 numbers from nums1 and 2 numbers from nums2 -> [2,3] and [5,4] will be the best combo\\n\\tPick 3 numbers from nums1 and 1 number from nums2 -> [1,2,3] and [5] will be the best combo\\n\\tPick 4 numbers from nums1 and 0 number from nums2 -> Invalid since length of nums1 is \"3\"\\n\\nHence, for all the valid cases, we will get two lists and those two lists have to be the most optimal ones. \\n\\nThat is, if we want to pick \"2\" numbers from nums1, that subsequence of length 2 should be the lexicographically greatest subsequence of nums1.\\n\\nOnce we get these two lists, now it\\'s time to merge the two together to form one single list of length \"k\". We have to merge the two such that we generate the maximum possible number by combining the two.\\n\\n\\tFor example, if list1 is [2,3] and list2 is [5,4] the merged result will be [5,4,2,3]\\n\\nBut, it is not always the case that we have different numbers in both lists.\\n\\nWe may encounter cases when there are same numbers so we have to choose which one to put in our merged list and what pointer to increment.\\n\\nAnd for that case, we have to write a separate logic.\\n\\nSince we want the lexicographically largest subsequence, if we have a case where both pointers are pointing to the same number, we will then compare the values after those pointers to see which subsequence will give us a bigger value first. We will then pick that subsequence. In short, we will pick the lexicographically greater subsequence out of the two.\\n\\nLet\\'s take an example to understand it - \\n\\n    Suppose, list1 is [2,1,1,0,2,0] and list2 is [1,1,1,0,2,1]\\n\\n    At first, we will put the item \"2\" in the merged list as first digit since it is greater than \"1\" in list2\\n\\t\\n\\t\\n\\t [2,1,1,0,2,0]\\n\\t    p1\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t  p2\\n\\n    so, after that pointer1 will be at index 1 in list1\\n    And pointer2 will still be at index 0\\n\\n    And as we can see, at both pointers we have the element \"1\"\\n\\n    So, which one to pick and which pointer to increment?\\n\\n    At this point, we have to see which subarray will give us a greater element first.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t   i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t  j\\n\\n    At i index we have element \"1\"\\n    But at j as well, we have \"1\"\\n\\n    So, we increment both of them since so far, both subsequences the same.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t     i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t    j\\n\\t\\n\\tAt i index we have element \"1\"\\n    But at j as well, we have \"1\"\\n\\n    So, we increment both of them since so far, both subsequences the same.\\n\\t\\n\\t[2,1,1,0,2,0]\\n\\t       i\\n\\t \\n\\t [1,1,1,0,2,1]\\n\\t      j\\n\\n    Now, At i index we have element \"0\"\\n    But at j, we have \"1\" \\n\\n    This means, the second subarray is lexicographically greater than first one.\\n\\n    So, we will pick element at pointer2 and increment pointer2. \\n\\nThis situation will come when elements are equal at both pointers.\\n\\nAlright. So, let\\'s say we formed a merged list.\\n\\nNow, whether it is the maximum or not, that depends on whether it is greater than the previous merged list we formed.\\n\\nSo, whenever we form a merged list, we compare it with the previous one and update accordingly.\\n\\nAnd so, finally, our output will point to the maximum number generated.\\n\\n```\\nclass Solution:\\n    # Helper method to get the greatest subsequence out of a list of a given length\\n    def getGreatestSubsequence(self, nums, subsequenceLength):\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Stack to efficiently compare numbers\\n        stack = []\\n        \\n        # Loop over the list\\n        for i in range(n):\\n            \\n            # If current element is greater than element on top of stack\\n            # We can remove it\\n            # But only if we have enough elements to put in stack so that required subsequenceLength is matched\\n            # (n-i) gives us the remaining elements to traverse\\n            # (len(stack) - 1) gives us the length of stack if we pop one element\\n            # So, what we are saying is \"The elements in stack after we pop + elements left to traverse\" should be >= subsequenceLength\\n            # Only then we can pop\\n            while stack and stack[-1] < nums[i] and (n - i) + (len(stack) - 1) >= subsequenceLength: stack.pop()\\n                \\n            \\n            # Now we can put the index of current element in the stack (only if we don\\'t already have \\'subsequenceLength\\' elements in the stack)\\n            if len(stack) < subsequenceLength: stack.append(nums[i])\\n            \\n        # Return this stack\\n        return stack\\n            \\n    # Helper method to compare subarrays of two lists such that one starts at index i and the other at index j\\n    # We do this comparison when we have same value at the two pointers so we have to decide which one to choose\\n    def isGreater(self, nums1, nums2, i, j):\\n        \\n        # Length of first list\\n        m = len(nums1)\\n        \\n        # Length of second list\\n        n = len(nums2)\\n        \\n        # While Loop to compare by positions\\n        while i < m or j < n:\\n            \\n            # If indices go out of bounds\\n            \\n            # If i is >= m, then nums1 is not lexicographically greater than nums2\\n            if i >= m: return False\\n            \\n            # If j is >= n, then nums1 is lexicographically greater than nums2\\n            elif j >= n: return True\\n        \\n            # If indices are not out of bounds, we can compare the elements\\n            \\n            # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n            # Then nums1 is lexicographically greater than nums2\\n            elif nums1[i] > nums2[j]: return True\\n            \\n            # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n            # Then nums1 is not lexicographically greater than nums2\\n            elif nums1[i] < nums2[j]: return False\\n            \\n            # If both are equal, move on to next comparison\\n            i += 1\\n            j += 1\\n            \\n        # If we didn\\'t return anything, then both subarrays are the same\\n        # So we can return either True or False since we can choose any of the two\\n        # Let\\'s return true\\n        return True\\n            \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        # Final output to return\\n        output = []\\n        \\n        # If we had only one list then it would\\'ve been super simple \\n        # to get a lexicographically greatest number\\n        # But, in this problem, we have two numbers\\n        # And what we don\\'t exactly know is, how many numbers we should take from nums1 and how many from nums2\\n        \\n        \\n        # Since k <= m + n\\n        # We can try every possible combination. Since m and n can be at most 500 so it shouldn\\'t give us TLE\\n        \\n        # For example, if k = 5 then we can maybe take 1 number from nums1 and 4 from nums2\\n        # Or maybe take 2 from nums1 and 3 from nums2\\n        # And so on...\\n        \\n        # And then, we will merge the two lists that we will get to get the final output\\n        # And return the output that gives us the maximum number\\n        \\n        # So, first step is to go through every possible choice of taking numbers from nums1 and nums2\\n        for count in range(k + 1):\\n            \\n            # Suppose k = 5 but nums1 has only 2 elements\\n            # In that case, we can only pick either 0 or 1 or 2 elements from nums1\\n            # It doesn\\'t make sense when we say pick \"3\" elements from nums1 and \"2\" from nums2\\n            # Because nums1 doesn\\'t even have 3 elements in the first place\\n            # So, in such case, we won\\'t do anything and we will move on to next combination\\n            if count > len(nums1) or (k - count) > len(nums2): continue\\n            \\n            list1 = self.getGreatestSubsequence(nums1, count)\\n            list2 = self.getGreatestSubsequence(nums2, k - count)\\n            \\n            # After we get the two lists, we will now merge them\\n            mergedList = []\\n            \\n            # Pointers for the two lists\\n            i,j = 0,0\\n            \\n            # While Loop to compare by positions\\n            while i < len(list1) or j < len(list2):\\n\\n                # If indices go out of bounds\\n\\n                # If i is >= m, then pick \"j\" element in list2\\n                if i >= len(list1): \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If j is >= n, then pick \"i\" element in list1\\n                elif j >= len(list2):\\n                    mergedList.append(list1[i])\\n                    i += 1\\n                    \\n                    \\n                # If indices are not out of bounds, we can compare the elements\\n\\n                # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n                # Then pick the i element of nums1\\n                elif list1[i] > list2[j]: \\n                    mergedList.append(list1[i])\\n                    i += 1\\n\\n                # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n                # Then pick the j element of nums2\\n                elif list1[i] < list2[j]: \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If both are equal, we use the helper method to choose \\n                else:\\n                    # If subsequence of nums1 starting at index \"i\"\\n                    # if lexicographically greater than subsequence of nums2 starting at \"j\"\\n                    # We pick the i element\\n                    if self.isGreater(list1, list2, i, j):\\n                        mergedList.append(list1[i])\\n                        i += 1\\n                        \\n                    # Otherwise, we pick the \"j\" element\\n                    else:\\n                        mergedList.append(list2[j])\\n                        j += 1\\n            \\n            \\n            # Finally, we get our merged list\\n            # Now we can compare it with previous merged list to see which one is the bigger lexicographically\\n            # Based on that we can update the output list\\n            if output < mergedList: output = mergedList\\n        return output\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # Helper method to get the greatest subsequence out of a list of a given length\\n    def getGreatestSubsequence(self, nums, subsequenceLength):\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Stack to efficiently compare numbers\\n        stack = []\\n        \\n        # Loop over the list\\n        for i in range(n):\\n            \\n            # If current element is greater than element on top of stack\\n            # We can remove it\\n            # But only if we have enough elements to put in stack so that required subsequenceLength is matched\\n            # (n-i) gives us the remaining elements to traverse\\n            # (len(stack) - 1) gives us the length of stack if we pop one element\\n            # So, what we are saying is \"The elements in stack after we pop + elements left to traverse\" should be >= subsequenceLength\\n            # Only then we can pop\\n            while stack and stack[-1] < nums[i] and (n - i) + (len(stack) - 1) >= subsequenceLength: stack.pop()\\n                \\n            \\n            # Now we can put the index of current element in the stack (only if we don\\'t already have \\'subsequenceLength\\' elements in the stack)\\n            if len(stack) < subsequenceLength: stack.append(nums[i])\\n            \\n        # Return this stack\\n        return stack\\n            \\n    # Helper method to compare subarrays of two lists such that one starts at index i and the other at index j\\n    # We do this comparison when we have same value at the two pointers so we have to decide which one to choose\\n    def isGreater(self, nums1, nums2, i, j):\\n        \\n        # Length of first list\\n        m = len(nums1)\\n        \\n        # Length of second list\\n        n = len(nums2)\\n        \\n        # While Loop to compare by positions\\n        while i < m or j < n:\\n            \\n            # If indices go out of bounds\\n            \\n            # If i is >= m, then nums1 is not lexicographically greater than nums2\\n            if i >= m: return False\\n            \\n            # If j is >= n, then nums1 is lexicographically greater than nums2\\n            elif j >= n: return True\\n        \\n            # If indices are not out of bounds, we can compare the elements\\n            \\n            # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n            # Then nums1 is lexicographically greater than nums2\\n            elif nums1[i] > nums2[j]: return True\\n            \\n            # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n            # Then nums1 is not lexicographically greater than nums2\\n            elif nums1[i] < nums2[j]: return False\\n            \\n            # If both are equal, move on to next comparison\\n            i += 1\\n            j += 1\\n            \\n        # If we didn\\'t return anything, then both subarrays are the same\\n        # So we can return either True or False since we can choose any of the two\\n        # Let\\'s return true\\n        return True\\n            \\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        \\n        # Final output to return\\n        output = []\\n        \\n        # If we had only one list then it would\\'ve been super simple \\n        # to get a lexicographically greatest number\\n        # But, in this problem, we have two numbers\\n        # And what we don\\'t exactly know is, how many numbers we should take from nums1 and how many from nums2\\n        \\n        \\n        # Since k <= m + n\\n        # We can try every possible combination. Since m and n can be at most 500 so it shouldn\\'t give us TLE\\n        \\n        # For example, if k = 5 then we can maybe take 1 number from nums1 and 4 from nums2\\n        # Or maybe take 2 from nums1 and 3 from nums2\\n        # And so on...\\n        \\n        # And then, we will merge the two lists that we will get to get the final output\\n        # And return the output that gives us the maximum number\\n        \\n        # So, first step is to go through every possible choice of taking numbers from nums1 and nums2\\n        for count in range(k + 1):\\n            \\n            # Suppose k = 5 but nums1 has only 2 elements\\n            # In that case, we can only pick either 0 or 1 or 2 elements from nums1\\n            # It doesn\\'t make sense when we say pick \"3\" elements from nums1 and \"2\" from nums2\\n            # Because nums1 doesn\\'t even have 3 elements in the first place\\n            # So, in such case, we won\\'t do anything and we will move on to next combination\\n            if count > len(nums1) or (k - count) > len(nums2): continue\\n            \\n            list1 = self.getGreatestSubsequence(nums1, count)\\n            list2 = self.getGreatestSubsequence(nums2, k - count)\\n            \\n            # After we get the two lists, we will now merge them\\n            mergedList = []\\n            \\n            # Pointers for the two lists\\n            i,j = 0,0\\n            \\n            # While Loop to compare by positions\\n            while i < len(list1) or j < len(list2):\\n\\n                # If indices go out of bounds\\n\\n                # If i is >= m, then pick \"j\" element in list2\\n                if i >= len(list1): \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If j is >= n, then pick \"i\" element in list1\\n                elif j >= len(list2):\\n                    mergedList.append(list1[i])\\n                    i += 1\\n                    \\n                    \\n                # If indices are not out of bounds, we can compare the elements\\n\\n                # If \"i\" element in nums1 is greater than \"j\" element in nums2\\n                # Then pick the i element of nums1\\n                elif list1[i] > list2[j]: \\n                    mergedList.append(list1[i])\\n                    i += 1\\n\\n                # If \"i\" element in nums1 is smaller than \"j\" element in nums2\\n                # Then pick the j element of nums2\\n                elif list1[i] < list2[j]: \\n                    mergedList.append(list2[j])\\n                    j += 1\\n\\n                # If both are equal, we use the helper method to choose \\n                else:\\n                    # If subsequence of nums1 starting at index \"i\"\\n                    # if lexicographically greater than subsequence of nums2 starting at \"j\"\\n                    # We pick the i element\\n                    if self.isGreater(list1, list2, i, j):\\n                        mergedList.append(list1[i])\\n                        i += 1\\n                        \\n                    # Otherwise, we pick the \"j\" element\\n                    else:\\n                        mergedList.append(list2[j])\\n                        j += 1\\n            \\n            \\n            # Finally, we get our merged list\\n            # Now we can compare it with previous merged list to see which one is the bigger lexicographically\\n            # Based on that we can update the output list\\n            if output < mergedList: output = mergedList\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792618,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] result = new int[k];\\n        for (int i = Math.Max(0, k - n); i <= k && i <= m; i++)\\n        {\\n            int[] candidate = MergeArrays(GetMaxSubsequence(nums1, i), GetMaxSubsequence(nums2, k - i));\\n            if (IsGreater(candidate, 0, result, 0)) result = candidate;\\n        }\\n        return result;\\n    }\\n\\n    private int[] GetMaxSubsequence(int[] nums, int k)\\n    {\\n        int[] result = new int[k];\\n        int length = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (length > 0 && nums[i] > result[length - 1] && nums.Length - i + length > k) length--;\\n            if (length < k) result[length++] = nums[i];\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int[] MergeArrays(int[] nums1, int[] nums2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] merged = new int[m + n];\\n        int i = 0, j = 0, idx = 0;\\n    \\n        while (i < m && j < n)\\n        {\\n            if (IsGreater(nums1, i, nums2, j)) merged[idx++] = nums1[i++];\\n            else merged[idx++] = nums2[j++]; \\n        }   \\n        while (i < m) merged[idx++] = nums1[i++];\\n        while (j < n) merged[idx++] = nums2[j++];\\n        \\n        return merged;\\n    }\\n\\n    private bool IsGreater(int[] nums1, int idx1, int[] nums2, int idx2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        \\n        while (idx1 < m && idx2 < n)\\n        {\\n            if (nums1[idx1] > nums2[idx2]) return true;\\n            else if (nums1[idx1] < nums2[idx2]) return false;\\n                   \\n            idx1++;\\n            idx2++;\\n        }\\n        \\n        return idx1 != m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] result = new int[k];\\n        for (int i = Math.Max(0, k - n); i <= k && i <= m; i++)\\n        {\\n            int[] candidate = MergeArrays(GetMaxSubsequence(nums1, i), GetMaxSubsequence(nums2, k - i));\\n            if (IsGreater(candidate, 0, result, 0)) result = candidate;\\n        }\\n        return result;\\n    }\\n\\n    private int[] GetMaxSubsequence(int[] nums, int k)\\n    {\\n        int[] result = new int[k];\\n        int length = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (length > 0 && nums[i] > result[length - 1] && nums.Length - i + length > k) length--;\\n            if (length < k) result[length++] = nums[i];\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int[] MergeArrays(int[] nums1, int[] nums2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        int[] merged = new int[m + n];\\n        int i = 0, j = 0, idx = 0;\\n    \\n        while (i < m && j < n)\\n        {\\n            if (IsGreater(nums1, i, nums2, j)) merged[idx++] = nums1[i++];\\n            else merged[idx++] = nums2[j++]; \\n        }   \\n        while (i < m) merged[idx++] = nums1[i++];\\n        while (j < n) merged[idx++] = nums2[j++];\\n        \\n        return merged;\\n    }\\n\\n    private bool IsGreater(int[] nums1, int idx1, int[] nums2, int idx2)\\n    {\\n        int m = nums1.Length;\\n        int n = nums2.Length;\\n        \\n        while (idx1 < m && idx2 < n)\\n        {\\n            if (nums1[idx1] > nums2[idx2]) return true;\\n            else if (nums1[idx1] < nums2[idx2]) return false;\\n                   \\n            idx1++;\\n            idx2++;\\n        }\\n        \\n        return idx1 != m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779111,
                "title": "greedy-algorithm-and-merge-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. the **everymax fuction** use the greedy algorithm to create the maximum number of length **n** from a given array.\\n\\n    it iterate through the array, maintain a stack to store the maximum number sofar. it campare each element with the top of the stack to decide whether to discard it or include it and also maintain the desired length of \"n\".\\n\\n**the greedy algorithm ensure the resulting number is lexicographically maximum** \\n\\n2. the **merge** function compre the first element of two arrays and append it to result until one of the array is exhuasted. this operation maintain the relative order of elements ensuring the resulting number is maximum possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def everymax(nums,n):\\n            stack=[]\\n            to_pop=len(nums)-n\\n            for num in nums:\\n                while to_pop and stack and num>stack[-1]:\\n                    stack.pop()\\n                    to_pop-=1\\n                stack.append(num)\\n            return stack[:n]\\n\\n        def merge(nums1,nums2):\\n            result=[]\\n            while nums1 and nums2:\\n                if nums1>nums2:\\n                    result.append(nums1[0])\\n                    nums1=nums1[1:]\\n                else:\\n                    result.append(nums2[0])\\n                    nums2=nums2[1:]\\n            result.extend(nums1)\\n            result.extend(nums2)\\n            return result\\n\\n        ans=[]\\n        for i in range(k+1):\\n            if i <=len(nums1) and (k-i)<=len(nums2):\\n                maxnums1=everymax(nums1,i)\\n                maxnums2=everymax(nums2,k-i)\\n                merged=merge(maxnums1,maxnums2)\\n                ans=max(ans,merged)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def everymax(nums,n):\\n            stack=[]\\n            to_pop=len(nums)-n\\n            for num in nums:\\n                while to_pop and stack and num>stack[-1]:\\n                    stack.pop()\\n                    to_pop-=1\\n                stack.append(num)\\n            return stack[:n]\\n\\n        def merge(nums1,nums2):\\n            result=[]\\n            while nums1 and nums2:\\n                if nums1>nums2:\\n                    result.append(nums1[0])\\n                    nums1=nums1[1:]\\n                else:\\n                    result.append(nums2[0])\\n                    nums2=nums2[1:]\\n            result.extend(nums1)\\n            result.extend(nums2)\\n            return result\\n\\n        ans=[]\\n        for i in range(k+1):\\n            if i <=len(nums1) and (k-i)<=len(nums2):\\n                maxnums1=everymax(nums1,i)\\n                maxnums2=everymax(nums2,k-i)\\n                merged=merge(maxnums1,maxnums2)\\n                ans=max(ans,merged)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773836,
                "title": "o-n-3-stack-c",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> getNums(vector<int> &nums, int x){\\n        if (x == 0) {\\n            return {};\\n        }\\n        stack<int>s;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if (s.empty()) {\\n                s.push(nums[i]);\\n            } else {\\n                while(s.size() > 0 && s.top() < nums[i] && s.size()-1 + nums.size() - i >= x) {\\n                    s.pop();\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n\\n        while(s.size() > x) {\\n            s.pop();\\n        }\\n\\n        vector<int> ans;\\n        while(!s.empty()) {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n\\n    bool isGreater(vector<int> &n1, vector<int> &n2, int i, int j) {\\n        while(i < n1.size() && j <n2.size()) {\\n            if (n1[i] > n2[j]){\\n                return true;\\n            }\\n            if (n1[i] < n2[j]) {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if (i < n1.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> merge(vector<int> &n1, vector<int> &n2) {\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < n1.size() && j < n2.size()) {\\n            if (isGreater(n1, n2, i, j)) {\\n                ans.push_back(n1[i]);\\n                i++;\\n            } else {\\n                ans.push_back(n2[j]);\\n                j++;\\n            }\\n        }\\n        while(i < n1.size()) {\\n            ans.push_back(n1[i]);\\n            i++;\\n        }\\n        while(j < n2.size()) {\\n            ans.push_back(n2[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> getMaxArray(vector<int> &ans, vector<int> &mergedSub){\\n        if (ans.size() == 0) {\\n            return mergedSub;\\n        }\\n        for (int i = 0 ; i < mergedSub.size(); i++) {\\n            if (ans[i] > mergedSub[i]) {\\n                return ans;\\n            } else if (ans[i] < mergedSub[i]) {\\n                return mergedSub;\\n            }\\n        }\\n        return mergedSub;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans;\\n        for (int i = 0 ; i <= k; i++) {\\n            int nums1Elements = i;\\n            int nums2Elements = k-i;\\n            if (nums2Elements < 0 || nums2Elements > nums2.size()) {\\n                continue;\\n            }\\n            if (nums1Elements < 0 || nums1Elements > nums1.size()) {\\n                continue;\\n            }\\n\\n            vector<int> nums1Sub = getNums(nums1, i);\\n            vector<int> nums2Sub = getNums(nums2, k-i);\\n\\n            vector<int> mergedSub = merge(nums1Sub, nums2Sub);\\n            ans = getMaxArray(ans, mergedSub);\\n        } \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> getNums(vector<int> &nums, int x){\\n        if (x == 0) {\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 3746717,
                "title": "java-solution-explained",
                "content": "# Intuition - \\nThe problem requires finding the maximum number that can be formed by selecting k elements from two input arrays, nums1 and nums2. The elements should maintain their relative order within each array. The solution involves dividing the problem into smaller subproblems, finding the maximum numbers that can be formed by selecting a certain number of elements from each array, and then merging those numbers to form the overall maximum number.\\n\\n# Approach - \\n1. Initialize the result array of size k to store the maximum number.\\n2. Iterate over the number of elements (i) to be selected from nums1, which ranges from 0 to the minimum of k and the length of nums1.\\n   - Calculate the corresponding number of elements (j) to be selected from nums2, which is equal to k - i.\\n   - Find the maximum subsequence of length i from nums1 using the `findMax` function.\\n   - Find the maximum subsequence of length j from nums2 using the `findMax` function.\\n   - Merge the two subsequences obtained from nums1 and nums2 using the `merge` function.\\n   - If the merged sequence is greater than the current result, update the result to the merged sequence.\\n3. Return the resulting maximum number.\\n\\n# Complexity Analysis - \\nLet n be the length of nums1 and m be the length of nums2.\\n- The overall **time complexity of the solution is O((n + m)^3)** since we have three nested loops: one for iterating over the number of elements to be selected from nums1, one for iterating over the elements of nums1 and nums2 in the `merge` function, and one for iterating over the elements of nums in the `findMax` function.\\n- The **space complexity is O(k)** since we are using a result array of size k to store the maximum number.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        for (int i = Math.max(0, k - nums2.length); i <= Math.min(nums1.length, k); i++) {\\n            int j = k - i;\\n            int[] part1 = findMax(nums1, i);\\n            int[] part2 = findMax(nums2, j);\\n            int[] cand = merge(part1, part2);\\n            if (greater(cand, 0, result, 0)) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean greater(int[] nums1, int start1, int[] nums2, int start2) {\\n        while (start1 < nums1.length && start2 < nums2.length && nums1[start1] == nums2[start2]) {\\n            start1++;\\n            start2++;\\n        }\\n        return start2 == nums2.length || (start1 < nums1.length && nums1[start1] > nums2[start2]);\\n    }\\n\\n    private int[] merge(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length + nums2.length];\\n        int i = 0, j = 0, k = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (greater(nums1, i, nums2, j)) {\\n                result[k++] = nums1[i++];\\n            } else {\\n                result[k++] = nums2[j++];\\n            }\\n        }\\n        while (i < nums1.length) {\\n            result[k++] = nums1[i++];\\n        }\\n        while (j < nums2.length) {\\n            result[k++] = nums2[j++];\\n        }\\n        return result;\\n    }\\n\\n    private int[] findMax(int[] nums, int k) {\\n        int[] result = new int[k];\\n        int j = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (j > 0 && result[j - 1] < nums[i] && j + nums.length - i > k) {\\n                j--;\\n            }\\n            if (j < k) {\\n                result[j++] = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        for (int i = Math.max(0, k - nums2.length); i <= Math.min(nums1.length, k); i++) {\\n            int j = k - i;\\n            int[] part1 = findMax(nums1, i);\\n            int[] part2 = findMax(nums2, j);\\n            int[] cand = merge(part1, part2);\\n            if (greater(cand, 0, result, 0)) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean greater(int[] nums1, int start1, int[] nums2, int start2) {\\n        while (start1 < nums1.length && start2 < nums2.length && nums1[start1] == nums2[start2]) {\\n            start1++;\\n            start2++;\\n        }\\n        return start2 == nums2.length || (start1 < nums1.length && nums1[start1] > nums2[start2]);\\n    }\\n\\n    private int[] merge(int[] nums1, int[] nums2) {\\n        int[] result = new int[nums1.length + nums2.length];\\n        int i = 0, j = 0, k = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (greater(nums1, i, nums2, j)) {\\n                result[k++] = nums1[i++];\\n            } else {\\n                result[k++] = nums2[j++];\\n            }\\n        }\\n        while (i < nums1.length) {\\n            result[k++] = nums1[i++];\\n        }\\n        while (j < nums2.length) {\\n            result[k++] = nums2[j++];\\n        }\\n        return result;\\n    }\\n\\n    private int[] findMax(int[] nums, int k) {\\n        int[] result = new int[k];\\n        int j = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (j > 0 && result[j - 1] < nums[i] && j + nums.length - i > k) {\\n                j--;\\n            }\\n            if (j < k) {\\n                result[j++] = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698678,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length, n=nums2.length;\\n        int sol[] = new int [k];\\n\\n        for (int i= 0; i <= m ; i++){  // number of items taken form nums1 in the solution\\n            if (i > k || i+n < k) continue;\\n\\n            int [] nums1contibution = chooseK(nums1,i); \\n            int [] nums2contibution = chooseK(nums2,k-i);\\n\\n            boolean bestSol = false;\\n            int iter1=0 , iter2=0;\\n\\n            for (int j=0; j<k ; j++){\\n                boolean useNums1 = false; \\n                if (iter1 == i)  useNums1 = false; \\n                else {\\n                    if (iter2 == k-i) useNums1 = true; \\n                    else {\\n                        if (nums2contibution[iter2] > nums1contibution[iter1]) useNums1 = false; \\n                        else if (nums2contibution[iter2] < nums1contibution[iter1]) useNums1 = true; \\n                        else useNums1 = firstBigger (nums1contibution,iter1, nums2contibution,iter2);\\n                    }\\n                }\\n                int next = (useNums1) ? nums1contibution[iter1++] : nums2contibution[iter2++];\\n\\n                if (!bestSol && next < sol[j]) break; // better solution already exist\\n                if (next > sol[j]) bestSol = true; // this is the best solution so far - write it down to the end\\n                sol[j] = next; \\n            }\\n        }\\n        return sol;\\n    }\\n\\n    private boolean firstBigger(int[] nums1,int start1, int []nums2, int start2){\\n        int next1 = nums1[start1] , next2 = nums2[start2];\\n        while (next1 == next2){\\n            next1 = (++start1 == nums1.length) ? -1 : nums1[start1];\\n            next2 = (++start2 == nums2.length) ? -1 : nums2[start2];\\n            if (next1 == -1) return false;\\n        }\\n        return (next1>next2);\\n    }\\n\\n    private int[] chooseK(int[] nums, int k) { // choose best k lexicographic order from nums \\n        //could be optimaized a lot: given choosek(k) we can use it to calculate choosek(k-1) \\n        int [] sol = new int [k];\\n        int choosen = 0 , iter = 0; // left to choose = k - choosen\\n        while (choosen < k){\\n            int max = nums[iter], indexMax = iter;\\n            for (int i = iter; i + (k - choosen) <= nums.length; i++){\\n                if (max == 9) break;\\n                if (nums[i] > max){\\n                    max = nums[i];\\n                    indexMax = i;\\n                }\\n            }\\n            iter = indexMax +1; \\n            sol[choosen++] = max; \\n        }\\n        return sol;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length, n=nums2.length;\\n        int sol[] = new int [k];\\n\\n        for (int i= 0; i <= m ; i++){  // number of items taken form nums1 in the solution\\n            if (i > k || i+n < k) continue;\\n\\n            int [] nums1contibution = chooseK(nums1,i); \\n            int [] nums2contibution = chooseK(nums2,k-i);\\n\\n            boolean bestSol = false;\\n            int iter1=0 , iter2=0;\\n\\n            for (int j=0; j<k ; j++){\\n                boolean useNums1 = false; \\n                if (iter1 == i)  useNums1 = false; \\n                else {\\n                    if (iter2 == k-i) useNums1 = true; \\n                    else {\\n                        if (nums2contibution[iter2] > nums1contibution[iter1]) useNums1 = false; \\n                        else if (nums2contibution[iter2] < nums1contibution[iter1]) useNums1 = true; \\n                        else useNums1 = firstBigger (nums1contibution,iter1, nums2contibution,iter2);\\n                    }\\n                }\\n                int next = (useNums1) ? nums1contibution[iter1++] : nums2contibution[iter2++];\\n\\n                if (!bestSol && next < sol[j]) break; // better solution already exist\\n                if (next > sol[j]) bestSol = true; // this is the best solution so far - write it down to the end\\n                sol[j] = next; \\n            }\\n        }\\n        return sol;\\n    }\\n\\n    private boolean firstBigger(int[] nums1,int start1, int []nums2, int start2){\\n        int next1 = nums1[start1] , next2 = nums2[start2];\\n        while (next1 == next2){\\n            next1 = (++start1 == nums1.length) ? -1 : nums1[start1];\\n            next2 = (++start2 == nums2.length) ? -1 : nums2[start2];\\n            if (next1 == -1) return false;\\n        }\\n        return (next1>next2);\\n    }\\n\\n    private int[] chooseK(int[] nums, int k) { // choose best k lexicographic order from nums \\n        //could be optimaized a lot: given choosek(k) we can use it to calculate choosek(k-1) \\n        int [] sol = new int [k];\\n        int choosen = 0 , iter = 0; // left to choose = k - choosen\\n        while (choosen < k){\\n            int max = nums[iter], indexMax = iter;\\n            for (int i = iter; i + (k - choosen) <= nums.length; i++){\\n                if (max == 9) break;\\n                if (nums[i] > max){\\n                    max = nums[i];\\n                    indexMax = i;\\n                }\\n            }\\n            iter = indexMax +1; \\n            sol[choosen++] = max; \\n        }\\n        return sol;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609231,
                "title": "simple-monotonic-stack-merge-vector-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMonotonic stack and merge sorted vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    For all i possible brute \\n    split k into i and k-i\\n    i-> the no of element from a \\n    k-i -> the no of element from b\\n    Use Monotonic stack to find the max subseq of req. length\\n    Merge the 2 sorted vectors\\n    Find max of all such vectors\\n\\n\\n# Complexity\\n- Time complexity $$O(nk + nk)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        vector<int> ans(k,0);\\n        //For all i possible brute \\n        for(int i=max(0,k-m);i<=min(n,k);i++){\\n            //i-> the no of element from a \\n            //k-i -> the no of element from b\\n            vector<int> stk1,stk2;\\n            int rem1=n-i;\\n            int rem2=m-(k-i);\\n            //Use Monotonic stack to find the max subseq of req. length\\n            for(int i=0;i<n;i++){\\n                while(stk1.size() && rem1 && a[i]>stk1.back()) stk1.pop_back(), rem1--;\\n                stk1.push_back(a[i]);\\n            }\\n            while(rem1>0 && rem1--) stk1.pop_back();\\n\\n            for(int i=0;i<m;i++){\\n                while(stk2.size() && rem2 && b[i]>stk2.back()) stk2.pop_back(), rem2--;\\n                stk2.push_back(b[i]);\\n            }\\n            //Merge the 2 sorted vectors\\n            while(rem2>0 && rem2--) stk2.pop_back();\\n            vector<int> temp;\\n            int p1=0,p2=0;\\n            while(p1<i && p2<k-i){\\n                if(stk1[p1] == stk2[p2]){\\n                    int ti= p1;\\n                    int tj= p2;\\n                    while(ti<i && tj<k-i && stk1[ti]==stk2[tj]){\\n                        ti++;\\n                        tj++;\\n                    }\\n                    if(tj == k-i) temp.push_back(stk1[p1]), p1++;\\n                    else if(ti == i) temp.push_back(stk2[p2]), p2++;\\n                    else if(stk1[ti]>stk2[tj]) temp.push_back(stk1[p1]), p1++;\\n                    else temp.push_back(stk2[p2]), p2++;\\n                }\\n                else if(stk1[p1]>stk2[p2]){\\n                    temp.push_back(stk1[p1]);\\n                    p1++;\\n                }\\n                else{\\n                    temp.push_back(stk2[p2]);\\n                    p2++;\\n                }\\n            }\\n            while(p1<i) temp.push_back(stk1[p1]), p1++;\\n            while(p2<k-i) temp.push_back(stk2[p2]), p2++;\\n            //Find max of all such vectors\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        vector<int> ans(k,0);\\n        //For all i possible brute \\n        for(int i=max(0,k-m);i<=min(n,k);i++){\\n            //i-> the no of element from a \\n            //k-i -> the no of element from b\\n            vector<int> stk1,stk2;\\n            int rem1=n-i;\\n            int rem2=m-(k-i);\\n            //Use Monotonic stack to find the max subseq of req. length\\n            for(int i=0;i<n;i++){\\n                while(stk1.size() && rem1 && a[i]>stk1.back()) stk1.pop_back(), rem1--;\\n                stk1.push_back(a[i]);\\n            }\\n            while(rem1>0 && rem1--) stk1.pop_back();\\n\\n            for(int i=0;i<m;i++){\\n                while(stk2.size() && rem2 && b[i]>stk2.back()) stk2.pop_back(), rem2--;\\n                stk2.push_back(b[i]);\\n            }\\n            //Merge the 2 sorted vectors\\n            while(rem2>0 && rem2--) stk2.pop_back();\\n            vector<int> temp;\\n            int p1=0,p2=0;\\n            while(p1<i && p2<k-i){\\n                if(stk1[p1] == stk2[p2]){\\n                    int ti= p1;\\n                    int tj= p2;\\n                    while(ti<i && tj<k-i && stk1[ti]==stk2[tj]){\\n                        ti++;\\n                        tj++;\\n                    }\\n                    if(tj == k-i) temp.push_back(stk1[p1]), p1++;\\n                    else if(ti == i) temp.push_back(stk2[p2]), p2++;\\n                    else if(stk1[ti]>stk2[tj]) temp.push_back(stk1[p1]), p1++;\\n                    else temp.push_back(stk2[p2]), p2++;\\n                }\\n                else if(stk1[p1]>stk2[p2]){\\n                    temp.push_back(stk1[p1]);\\n                    p1++;\\n                }\\n                else{\\n                    temp.push_back(stk2[p2]);\\n                    p2++;\\n                }\\n            }\\n            while(p1<i) temp.push_back(stk1[p1]), p1++;\\n            while(p2<k-i) temp.push_back(stk2[p2]), p2++;\\n            //Find max of all such vectors\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564988,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k * n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      for (i <- Math.max(0, k - nums2.length) to Math.min(k, nums1.length)) {\\n        val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k)\\n        if (greater(candidate, 0, res, 0)) res.indices.foreach(j => res(j) = candidate(j))\\n      }\\n      res\\n    }\\n\\n    def merge(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      var i = 0\\n      var j = 0\\n      for (r <- res.indices)\\n        res(r) = if (greater(nums1, i, nums2, j)) {\\n            i += 1\\n            nums1(i - 1)\\n          } else {\\n            j += 1\\n            nums2(j - 1)\\n          }\\n      res\\n    }\\n\\n    def greater(nums1: Array[Int], i: Int, nums2: Array[Int], j: Int): Boolean = {\\n      var ii = i\\n      var jj = j\\n      while (ii < nums1.length && jj < nums2.length && nums1(ii) == nums2(jj)) {\\n        ii += 1\\n        jj += 1\\n      }\\n      jj == nums2.length || (ii < nums1.length && nums1(ii) > nums2(jj))\\n    }\\n\\n    def maxArray(nums: Array[Int], k: Int): Array[Int] = {\\n      val ans = Array.ofDim[Int](k)\\n      var j = 0\\n      for (i <- nums.indices) {\\n        while (nums.length - i + j > k && j > 0 && ans(j - 1) < nums(i)) j -= 1\\n        if (j < k) {\\n          ans(j) = nums(i)\\n          j += 1\\n        }\\n      }\\n      ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      for (i <- Math.max(0, k - nums2.length) to Math.min(k, nums1.length)) {\\n        val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k)\\n        if (greater(candidate, 0, res, 0)) res.indices.foreach(j => res(j) = candidate(j))\\n      }\\n      res\\n    }\\n\\n    def merge(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\\n      val res = Array.ofDim[Int](k)\\n      var i = 0\\n      var j = 0\\n      for (r <- res.indices)\\n        res(r) = if (greater(nums1, i, nums2, j)) {\\n            i += 1\\n            nums1(i - 1)\\n          } else {\\n            j += 1\\n            nums2(j - 1)\\n          }\\n      res\\n    }\\n\\n    def greater(nums1: Array[Int], i: Int, nums2: Array[Int], j: Int): Boolean = {\\n      var ii = i\\n      var jj = j\\n      while (ii < nums1.length && jj < nums2.length && nums1(ii) == nums2(jj)) {\\n        ii += 1\\n        jj += 1\\n      }\\n      jj == nums2.length || (ii < nums1.length && nums1(ii) > nums2(jj))\\n    }\\n\\n    def maxArray(nums: Array[Int], k: Int): Array[Int] = {\\n      val ans = Array.ofDim[Int](k)\\n      var j = 0\\n      for (i <- nums.indices) {\\n        while (nums.length - i + j > k && j > 0 && ans(j - 1) < nums(i)) j -= 1\\n        if (j < k) {\\n          ans(j) = nums(i)\\n          j += 1\\n        }\\n      }\\n      ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3538339,
                "title": "fast-solution-using-slice-and-hashmap",
                "content": "# Intuition\\n\\n- `nums1.length + nums2.length - k` digits can be dropped.\\n- Taking largest digit first and drop all digits before it.\\n- Recursive solve when there is tie, dynamic programming can be of help.\\n\\n# Approach\\n\\n- If digits can be dropped,\\n  Get max digit in each array in first `drop + 1` digits.\\n    - if one array\\'s max digit is greater than other,\\n      take that digit, drop all previous before it.\\n    - if both are equal then check both option using recursion.\\n- Else add node from larger array to smaller one.\\n\\n# Code\\n```rust\\nimpl Solution {\\n    fn merge(mut nums1: &[i32], mut nums2: &[i32], merged: &mut Vec<i32>) {\\n        while !nums1.is_empty() || !nums2.is_empty() {\\n            // pop from bigger vector\\n            if nums1 > nums2 {\\n                merged.push(nums1[0]);\\n                nums1 = &nums1[1..];\\n            } else {\\n                merged.push(nums2[0]);\\n                nums2 = &nums2[1..];\\n            }\\n        }\\n    }\\n\\n    fn get_max_index(nums: &[i32]) -> Option<usize> {\\n        nums.iter()\\n            .enumerate()\\n            .min_by_key(|(idx, &value)| (-value, *idx))\\n            .map(|(idx, _)| idx)\\n    }\\n\\n    pub fn max_number_dp<\\'a>(\\n        mut nums1: &[i32],\\n        mut nums2: &[i32],\\n        mut k: usize,\\n        memory: &\\'a mut HashMap<(usize, usize, usize), Vec<i32>>,\\n    ) -> &\\'a std::vec::Vec<i32> {\\n        let key = (nums1.len(), nums2.len(), k);\\n        if memory.contains_key(&key) {\\n            return memory.get(&key).unwrap();\\n        } else {\\n            let mut ans = Vec::with_capacity(k);\\n            while k > 0 {\\n                // number of drop allowed\\n                let drop_allowed = nums1.len() + nums2.len() - k;\\n                if drop_allowed == 0 {\\n                    Self::merge(nums1, nums2, &mut ans);\\n                    break;\\n                } else {\\n                    let nums1_idx =\\n                        Self::get_max_index(&nums1[..(drop_allowed + 1).min(nums1.len())]);\\n                    let nums2_idx =\\n                        Self::get_max_index(&nums2[..(drop_allowed + 1).min(nums2.len())]);\\n                    match nums1_idx\\n                        .and_then(|x| nums1.get(x))\\n                        .cmp(&nums2_idx.and_then(|x| nums2.get(x)))\\n                    {\\n                        std::cmp::Ordering::Less => {\\n                            let idx = nums2_idx.unwrap();\\n                            ans.push(nums2[idx]);\\n                            nums2 = &nums2[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            let idx = nums1_idx.unwrap();\\n                            ans.push(nums1[idx]);\\n                            nums1 = &nums1[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            let nums2_ = &nums2[nums2_idx.unwrap() + 1..];\\n                            let nums1_ = &nums1[nums1_idx.unwrap() + 1..];\\n                            ans.push(nums1[nums1_idx.unwrap()]);\\n\\n                            let len = ans.len();\\n                            k -= 1;\\n                            ans.extend(Self::max_number_dp(nums1_, nums2, k, memory));\\n                            let nums = Self::max_number_dp(nums1, nums2_, k, memory);\\n                            if &ans[len..] < nums {\\n                                ans.truncate(len);\\n                                ans.extend(nums);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            memory.entry(key).or_insert(ans)\\n        }\\n    }\\n\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut memory = HashMap::new();\\n        Self::max_number_dp(&nums1, &nums2, k as usize, &mut memory);\\n        memory\\n            .remove(&(nums1.len(), nums2.len(), k as usize))\\n            .unwrap()\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    fn merge(mut nums1: &[i32], mut nums2: &[i32], merged: &mut Vec<i32>) {\\n        while !nums1.is_empty() || !nums2.is_empty() {\\n            // pop from bigger vector\\n            if nums1 > nums2 {\\n                merged.push(nums1[0]);\\n                nums1 = &nums1[1..];\\n            } else {\\n                merged.push(nums2[0]);\\n                nums2 = &nums2[1..];\\n            }\\n        }\\n    }\\n\\n    fn get_max_index(nums: &[i32]) -> Option<usize> {\\n        nums.iter()\\n            .enumerate()\\n            .min_by_key(|(idx, &value)| (-value, *idx))\\n            .map(|(idx, _)| idx)\\n    }\\n\\n    pub fn max_number_dp<\\'a>(\\n        mut nums1: &[i32],\\n        mut nums2: &[i32],\\n        mut k: usize,\\n        memory: &\\'a mut HashMap<(usize, usize, usize), Vec<i32>>,\\n    ) -> &\\'a std::vec::Vec<i32> {\\n        let key = (nums1.len(), nums2.len(), k);\\n        if memory.contains_key(&key) {\\n            return memory.get(&key).unwrap();\\n        } else {\\n            let mut ans = Vec::with_capacity(k);\\n            while k > 0 {\\n                // number of drop allowed\\n                let drop_allowed = nums1.len() + nums2.len() - k;\\n                if drop_allowed == 0 {\\n                    Self::merge(nums1, nums2, &mut ans);\\n                    break;\\n                } else {\\n                    let nums1_idx =\\n                        Self::get_max_index(&nums1[..(drop_allowed + 1).min(nums1.len())]);\\n                    let nums2_idx =\\n                        Self::get_max_index(&nums2[..(drop_allowed + 1).min(nums2.len())]);\\n                    match nums1_idx\\n                        .and_then(|x| nums1.get(x))\\n                        .cmp(&nums2_idx.and_then(|x| nums2.get(x)))\\n                    {\\n                        std::cmp::Ordering::Less => {\\n                            let idx = nums2_idx.unwrap();\\n                            ans.push(nums2[idx]);\\n                            nums2 = &nums2[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            let idx = nums1_idx.unwrap();\\n                            ans.push(nums1[idx]);\\n                            nums1 = &nums1[idx + 1..];\\n                            k -= 1;\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            let nums2_ = &nums2[nums2_idx.unwrap() + 1..];\\n                            let nums1_ = &nums1[nums1_idx.unwrap() + 1..];\\n                            ans.push(nums1[nums1_idx.unwrap()]);\\n\\n                            let len = ans.len();\\n                            k -= 1;\\n                            ans.extend(Self::max_number_dp(nums1_, nums2, k, memory));\\n                            let nums = Self::max_number_dp(nums1, nums2_, k, memory);\\n                            if &ans[len..] < nums {\\n                                ans.truncate(len);\\n                                ans.extend(nums);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            memory.entry(key).or_insert(ans)\\n        }\\n    }\\n\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut memory = HashMap::new();\\n        Self::max_number_dp(&nums1, &nums2, k as usize, &mut memory);\\n        memory\\n            .remove(&(nums1.len(), nums2.len(), k as usize))\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517799,
                "title": "java-7ms-beats-98-56",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k*(m+n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(m+n)\\n<!-- Add your\\n-  space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n       int[] res = null;\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= nums1.length && k - i <= nums2.length) {\\n                int[] max1 = getMaxSub(nums1, i);\\n                int[] max2 = getMaxSub(nums2, k - i);\\n                if (max1 == null || max2 == null) continue;\\n                int[] tmp = mergeMax(max1, max2);\\n                if (compareArr(tmp, res)) {\\n                    res = tmp;\\n                }\\n            }\\n        }\\n    return res;\\n}\\n\\n    private boolean compareArr(int[] tmp, int[] res) {\\n        if(res == null) return true;\\n        for (int i = 0; i < res.length; i++) {\\n            if (tmp[i] < res[i]) return false;\\n            if (tmp[i] > res[i]) return true;\\n        }\\n        return true;\\n    }\\n\\n    public int[] mergeMax(int[] max1, int[] max2) {\\n        int i = 0, j = 0, id = 0;\\n        int size1 = max1.length;\\n        int size2 = max2.length;\\n        int[] res = new int[size1 + size2];\\n        while (size1 > 0 && size2 > 0 && i < size1 && j < size2) {\\n            if (max1[i] > max2[j]) {\\n                res[id++] = max1[i++];\\n            } else if (max1[i] == (max2[j])) {\\n                if (i + 1 < size1 && j + 1 < size2) {\\n                    if (max1[i + 1] == max2[j + 1]) {\\n                        if (max1[i + 1] >= max1[i]) {\\n                            int m = i + 2, n = j + 2;\\n                            boolean goToMax1 = true;\\n                            boolean isTracking = false;\\n                            while (m < size1 && n < size2) {\\n                                if (max1[m] != max2[n]) {\\n                                    if (max1[m] > max2[n]) {\\n                                        isTracking = true;\\n                                    } else {\\n                                        isTracking = true;\\n                                        goToMax1 = false;\\n                                    }\\n                                    break;\\n                                }\\n                                m++;\\n                                n++;\\n                            }\\n                            if (isTracking) {\\n                                if (goToMax1) {\\n                                    res[id++] = max1[i++];\\n                                } else {\\n                                    res[id++] = max2[j++];\\n                                }\\n                            } else {\\n                                if (m >= size1 && n < size2) {\\n                                    if (max2[--n] > max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else {\\n                                        res[id++] = max1[i++];\\n                                    }\\n\\n                                } else if (m < size1) {\\n                                    if (max1[--m] > max2[j]) {\\n                                        res[id++] = max1[i++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max1[i++];\\n                                    } else {\\n                                        res[id++] = max2[j++];\\n                                    }\\n                                } else {\\n                                    res[id++] = max1[i++];\\n                                    res[id++] = max2[j++];\\n                                }\\n                            }\\n                        } else {\\n                            res[id++] = max1[i++];\\n                            res[id++] = max2[j++];\\n                        }\\n                    } else if (max1[i + 1] > max2[j] && max1[i + 1] > max2[j + 1]) {\\n                        res[id++] = max1[i++]; // [6, 8] vs [6, 7]\\n                    } else if (max2[j + 1] > max1[i] && max2[j + 1] > max1[i + 1]) {\\n                        res[id++] = max2[j++]; // [6, 7] vs [6, 8]\\n                    } else {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    }\\n                } else if (i + 1 >= size1 && j + 1 >= size2) {\\n                    if (max1[i] > max2[j]) {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                        res[id++] = max1[i++];\\n                    }\\n                } else if (i + 1 < size1) {\\n                    if (max1[i + 1] >= max2[j]) {\\n                        res[id++] = max1[i++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                    }\\n                } else {\\n                    if (max2[j + 1] >= max1[i]) {\\n                        // [1, 3] vs [1]\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max1[i++];\\n                    }\\n                }\\n            } else {\\n                res[id++] = max2[j++];\\n            }\\n        }\\n        if (size1 == 0 || i >= size1) {\\n            for (int k = j; k < size2; k++) {\\n                res[id++] = max2[k];\\n            }\\n        } else {\\n            for (int k = i; k < size1; k++) {\\n                res[id++] = max1[k];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int[] getMaxSub(int[] nums, int k) {\\n        if (k == 0) return new int[]{};\\n        if (k > nums.length) return null;\\n        int[] res = new int[k];\\n        res[0] = nums[0];\\n        int last = nums.length - 1;\\n        int cnt = 1;\\n        // 5 6 4 2 3 6 k = 3\\n        // 5 6  and k = 1\\n        for (int i = 1; i <= last; i++) {\\n            while (cnt > 0 && res[cnt - 1] < nums[i] && last - i >= k - cnt) {\\n                cnt--;\\n            }\\n            if (cnt < k) {\\n                res[cnt] = nums[i];\\n                cnt++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n       int[] res = null;\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= nums1.length && k - i <= nums2.length) {\\n                int[] max1 = getMaxSub(nums1, i);\\n                int[] max2 = getMaxSub(nums2, k - i);\\n                if (max1 == null || max2 == null) continue;\\n                int[] tmp = mergeMax(max1, max2);\\n                if (compareArr(tmp, res)) {\\n                    res = tmp;\\n                }\\n            }\\n        }\\n    return res;\\n}\\n\\n    private boolean compareArr(int[] tmp, int[] res) {\\n        if(res == null) return true;\\n        for (int i = 0; i < res.length; i++) {\\n            if (tmp[i] < res[i]) return false;\\n            if (tmp[i] > res[i]) return true;\\n        }\\n        return true;\\n    }\\n\\n    public int[] mergeMax(int[] max1, int[] max2) {\\n        int i = 0, j = 0, id = 0;\\n        int size1 = max1.length;\\n        int size2 = max2.length;\\n        int[] res = new int[size1 + size2];\\n        while (size1 > 0 && size2 > 0 && i < size1 && j < size2) {\\n            if (max1[i] > max2[j]) {\\n                res[id++] = max1[i++];\\n            } else if (max1[i] == (max2[j])) {\\n                if (i + 1 < size1 && j + 1 < size2) {\\n                    if (max1[i + 1] == max2[j + 1]) {\\n                        if (max1[i + 1] >= max1[i]) {\\n                            int m = i + 2, n = j + 2;\\n                            boolean goToMax1 = true;\\n                            boolean isTracking = false;\\n                            while (m < size1 && n < size2) {\\n                                if (max1[m] != max2[n]) {\\n                                    if (max1[m] > max2[n]) {\\n                                        isTracking = true;\\n                                    } else {\\n                                        isTracking = true;\\n                                        goToMax1 = false;\\n                                    }\\n                                    break;\\n                                }\\n                                m++;\\n                                n++;\\n                            }\\n                            if (isTracking) {\\n                                if (goToMax1) {\\n                                    res[id++] = max1[i++];\\n                                } else {\\n                                    res[id++] = max2[j++];\\n                                }\\n                            } else {\\n                                if (m >= size1 && n < size2) {\\n                                    if (max2[--n] > max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max2[j++];\\n                                    } else {\\n                                        res[id++] = max1[i++];\\n                                    }\\n\\n                                } else if (m < size1) {\\n                                    if (max1[--m] > max2[j]) {\\n                                        res[id++] = max1[i++];\\n                                    } else if (max2[--n] == max1[i]) {\\n                                        res[id++] = max1[i++];\\n                                    } else {\\n                                        res[id++] = max2[j++];\\n                                    }\\n                                } else {\\n                                    res[id++] = max1[i++];\\n                                    res[id++] = max2[j++];\\n                                }\\n                            }\\n                        } else {\\n                            res[id++] = max1[i++];\\n                            res[id++] = max2[j++];\\n                        }\\n                    } else if (max1[i + 1] > max2[j] && max1[i + 1] > max2[j + 1]) {\\n                        res[id++] = max1[i++]; // [6, 8] vs [6, 7]\\n                    } else if (max2[j + 1] > max1[i] && max2[j + 1] > max1[i + 1]) {\\n                        res[id++] = max2[j++]; // [6, 7] vs [6, 8]\\n                    } else {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    }\\n                } else if (i + 1 >= size1 && j + 1 >= size2) {\\n                    if (max1[i] > max2[j]) {\\n                        res[id++] = max1[i++];\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                        res[id++] = max1[i++];\\n                    }\\n                } else if (i + 1 < size1) {\\n                    if (max1[i + 1] >= max2[j]) {\\n                        res[id++] = max1[i++];\\n                    } else {\\n                        res[id++] = max2[j++];\\n                    }\\n                } else {\\n                    if (max2[j + 1] >= max1[i]) {\\n                        // [1, 3] vs [1]\\n                        res[id++] = max2[j++];\\n                    } else {\\n                        res[id++] = max1[i++];\\n                    }\\n                }\\n            } else {\\n                res[id++] = max2[j++];\\n            }\\n        }\\n        if (size1 == 0 || i >= size1) {\\n            for (int k = j; k < size2; k++) {\\n                res[id++] = max2[k];\\n            }\\n        } else {\\n            for (int k = i; k < size1; k++) {\\n                res[id++] = max1[k];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int[] getMaxSub(int[] nums, int k) {\\n        if (k == 0) return new int[]{};\\n        if (k > nums.length) return null;\\n        int[] res = new int[k];\\n        res[0] = nums[0];\\n        int last = nums.length - 1;\\n        int cnt = 1;\\n        // 5 6 4 2 3 6 k = 3\\n        // 5 6  and k = 1\\n        for (int i = 1; i <= last; i++) {\\n            while (cnt > 0 && res[cnt - 1] < nums[i] && last - i >= k - cnt) {\\n                cnt--;\\n            }\\n            if (cnt < k) {\\n                res[cnt] = nums[i];\\n                cnt++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425897,
                "title": "python-constructive-please-update-constraints",
                "content": "Leetcode , Please update constraints in Question.\\nTime Complexity - O(k*(m+n)^2)\\nSolve independantly for both arrays for all possible combinations for i and j such that i+j==k and 0<=i<=k and 0<=j<=k.\\nUse next greater or equal to array to check if subarray starting from next greater on right can complete our length.\\nThen use solve function to merge both arrays. Cant merge them lineraly coz both arrays are not sorted.So we need to check at every comparsion which of both subarray can give lexicographically max array and update pointer accordingly.\\n```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m,n=len(nums1),len(nums2)\\n        def nge(arr,par):\\n            x=m if par==1 else n\\n            right=[-1]*x\\n            stack,temp=[],nums1 if par==1 else nums2\\n            for i in range(x-1,-1,-1):\\n                while stack and temp[stack[-1]]<=temp[i]: stack.pop()\\n                if stack: right[i]=stack[-1]\\n                stack.append(i)\\n            return right\\n        right1,right2=nge(nums1,1),nge(nums2,2)\\n        def mmax1(x):\\n            res=[]\\n            for i in range(m):\\n                if x==0: break\\n                r1=right1[i]\\n                if r1==-1 or m-r1<x:\\n                    res.append(nums1[i])\\n                    x-=1\\n            return res\\n        def mmax2(x):\\n            res=[]\\n            for i in range(n):\\n                if x==0: break\\n                r2=right2[i]\\n                if r2==-1 or n-r2<x:\\n                    res.append(nums2[i])\\n                    x-=1\\n            return res\\n        def isgreater(gg1, gg2, i, j):\\n            while i < len(gg1) and j < len(gg2) and gg1[i] == gg2[j]:\\n                i += 1\\n                j += 1\\n            if(j == len(gg2)): return 1\\n            if (i < len(gg1) and gg1[i] > gg2[j]): return 1\\n            return 0\\n        def solve(gg1,gg2):\\n            l1,l2=len(gg1),len(gg2)\\n            i,j=0,0\\n            res=[]\\n            while i<l1 and j<l2:\\n                if isgreater(gg1, gg2, i, j):\\n                    res.append(gg1[i])\\n                    i+=1\\n                else:\\n                    res.append(gg2[j])\\n                    j+=1\\n            while i<l1:\\n                res.append(gg1[i])\\n                i+=1\\n            while j<l2:\\n                res.append(gg2[j])\\n                j+=1\\n            return res\\n        ans=[]\\n        for i in range(k+1):\\n            j=k-i\\n            if i<=m and j<=n:\\n                res=solve(mmax1(i),mmax2(j))\\n                if not ans or res>ans:\\n                    ans=res\\n        return ans\\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        m,n=len(nums1),len(nums2)\\n        def nge(arr,par):\\n            x=m if par==1 else n\\n            right=[-1]*x\\n            stack,temp=[],nums1 if par==1 else nums2\\n            for i in range(x-1,-1,-1):\\n                while stack and temp[stack[-1]]<=temp[i]: stack.pop()\\n                if stack: right[i]=stack[-1]\\n                stack.append(i)\\n            return right\\n        right1,right2=nge(nums1,1),nge(nums2,2)\\n        def mmax1(x):\\n            res=[]\\n            for i in range(m):\\n                if x==0: break\\n                r1=right1[i]\\n                if r1==-1 or m-r1<x:\\n                    res.append(nums1[i])\\n                    x-=1\\n            return res\\n        def mmax2(x):\\n            res=[]\\n            for i in range(n):\\n                if x==0: break\\n                r2=right2[i]\\n                if r2==-1 or n-r2<x:\\n                    res.append(nums2[i])\\n                    x-=1\\n            return res\\n        def isgreater(gg1, gg2, i, j):\\n            while i < len(gg1) and j < len(gg2) and gg1[i] == gg2[j]:\\n                i += 1\\n                j += 1\\n            if(j == len(gg2)): return 1\\n            if (i < len(gg1) and gg1[i] > gg2[j]): return 1\\n            return 0\\n        def solve(gg1,gg2):\\n            l1,l2=len(gg1),len(gg2)\\n            i,j=0,0\\n            res=[]\\n            while i<l1 and j<l2:\\n                if isgreater(gg1, gg2, i, j):\\n                    res.append(gg1[i])\\n                    i+=1\\n                else:\\n                    res.append(gg2[j])\\n                    j+=1\\n            while i<l1:\\n                res.append(gg1[i])\\n                i+=1\\n            while j<l2:\\n                res.append(gg2[j])\\n                j+=1\\n            return res\\n        ans=[]\\n        for i in range(k+1):\\n            j=k-i\\n            if i<=m and j<=n:\\n                res=solve(mmax1(i),mmax2(j))\\n                if not ans or res>ans:\\n                    ans=res\\n        return ans\\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396659,
                "title": "share-my-rust-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    /* \\u4ECE\\u6570\\u7EC4\\u4E2D\\u9009\\u51FAk\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4ED6\\u6700\\u5927\\u3002 */\\n    pub fn helper(nums: & Vec<i32>, k: usize) -> Vec<i32> {\\n        let mut stk: Vec<i32> = Vec::new();\\n        if k == 0 {\\n            return stk;\\n        }\\n        let mut size = k; /* \\u6808\\u5269\\u4F59\\u7684\\u5BB9\\u91CF */\\n        let mut left = nums.len(); /* \\u5269\\u4F59\\u7684\\u6570\\u5B57 */\\n        for v in nums {\\n            let v = *v;\\n            /* \\u5BB9\\u91CF\\u521A\\u597D\\u586B\\u6EE1\\u65F6\\uFF0Call in\\u3002 */\\n            if size == left || stk.is_empty() {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            let mut top = *stk.last().unwrap();\\n            if top >= v && size == 0 {\\n                left -= 1;\\n                continue;\\n            }\\n            if top >= v && size > 0 {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            /* \\u53EA\\u8981\\u8FD8\\u80FD\\u586B\\u6EE1\\uFF0C\\u5E76\\u4E14\\u6808\\u9876\\u7684\\u503C\\u6BD4\\u5F53\\u524D\\u503C\\u8981\\u5C0F\\uFF0C\\u5C31\\u4E00\\u76F4\\u51FA\\u6808\\u3002 */\\n            while size < left && !stk.is_empty() {\\n                top = *stk.last().unwrap();\\n                if top < v {\\n                    stk.pop();\\n                    size += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            stk.push(v);\\n            size -= 1;\\n            left -= 1;\\n        }\\n        stk\\n    }\\n    /* \\u628A\\u4E24\\u4E2A\\u6570\\u7EC4\\u7EC4\\u5408\\u8D77\\u6765\\u627E\\u6700\\u5927\\u7684\\u503C */\\n    fn combine(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut k = 0;\\n        let mut res = Vec::new();\\n        while i < nums1.len() && k < nums2.len() {\\n            /* \\u8C01\\u5927\\u9009\\u8C01 */\\n            if nums1[i] < nums2[k] {\\n                res.push(nums2[k]);\\n                k += 1;\\n            } else if nums1[i] > nums2[k] {\\n                res.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                /* \\u5982\\u679C\\u5019\\u9009\\u4EBA\\u4E00\\u6837\\u7684\\u8BDD\\uFF0C\\u5C31\\u6709\\u4E9B\\u96BE\\u5904\\u7406\\u4E86\\u3002\\n                 * \\u9700\\u8981\\u6328\\u4E2A\\u770B\\u540E\\u9762\\u7684\\u503C\\u8C01\\u5927\\uFF0C\\u9009\\u5927\\u7684\\u3002 */\\n                let ori_i = i;\\n                let ori_k = k;\\n                i += 1;\\n                k += 1;\\n                let mut use_i = false;\\n                while i < nums1.len() && k < nums2.len() {\\n                    if nums1[i] < nums2[k] {\\n                        use_i = false;\\n                        break;\\n                    } else if nums1[i] > nums2[k] {\\n                        use_i = true;\\n                        break;\\n                    }\\n                    i += 1;\\n                    k += 1;\\n                }\\n                /* \\u6BD4\\u5230\\u6700\\u540E\\u8FD8\\u662F\\u4E00\\u6837\\uFF0C\\u9009\\u540E\\u9762\\u8FD8\\u6709\\u6570\\u7684\\u3002 */\\n                if i == nums1.len() && k < nums2.len() {\\n                    use_i = false;\\n                } else if i < nums1.len() && k == nums2.len() {\\n                    use_i = true;\\n                }\\n                /* \\u8BB0\\u5F97\\u628A\\u5E8F\\u53F7\\u6062\\u590D\\u56DE\\u6765\\u3002 */\\n                if use_i {\\n                    res.push(nums1[ori_i]);\\n                    i = ori_i + 1;\\n                    k = ori_k;\\n                } else {\\n                    res.push(nums2[ori_k]);\\n                    i = ori_i;\\n                    k = ori_k + 1;\\n                }\\n            }\\n        }\\n        while i < nums1.len() {\\n            res.push(nums1[i]);\\n            i += 1;\\n        }\\n        while k < nums2.len() {\\n            res.push(nums2[k]);\\n            k += 1;\\n        }\\n        res\\n    }\\n    /* \\u6BD4\\u8F83\\u4E24\\u4E2A\\u6570\\u7EC4\\u54EA\\u4E2A\\u5927 */\\n    fn nums1_larger(nums1: & Vec<i32>, nums2: & Vec<i32>) -> bool {\\n        let length = nums1.len();\\n        for i in 0..length {\\n            if nums1[i] > nums2[i] {\\n                return true;\\n            } else if nums1[i] < nums2[i] {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let large: Vec<i32>;\\n        let small: Vec<i32>;\\n        if nums1.len() > nums2.len() {\\n            large = nums1;\\n            small = nums2;\\n        } else {\\n            large = nums2;\\n            small = nums1;\\n        }\\n        let start = if k as usize > large.len() {\\n            k as usize - large.len()\\n        } else {\\n            0\\n        };\\n        let stop = std::cmp::min(k as usize + 1, small.len() + 1);\\n        let mut res = vec![0; k as usize];\\n        for i in start..stop {\\n            let v1 = Solution::helper(&small, i);\\n            let v2 = Solution::helper(&large, k as usize - i);\\n            let cur = Solution::combine(v1, v2);\\n            if Solution::nums1_larger(&cur, &res) {\\n                res = cur;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    /* \\u4ECE\\u6570\\u7EC4\\u4E2D\\u9009\\u51FAk\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4ED6\\u6700\\u5927\\u3002 */\\n    pub fn helper(nums: & Vec<i32>, k: usize) -> Vec<i32> {\\n        let mut stk: Vec<i32> = Vec::new();\\n        if k == 0 {\\n            return stk;\\n        }\\n        let mut size = k; /* \\u6808\\u5269\\u4F59\\u7684\\u5BB9\\u91CF */\\n        let mut left = nums.len(); /* \\u5269\\u4F59\\u7684\\u6570\\u5B57 */\\n        for v in nums {\\n            let v = *v;\\n            /* \\u5BB9\\u91CF\\u521A\\u597D\\u586B\\u6EE1\\u65F6\\uFF0Call in\\u3002 */\\n            if size == left || stk.is_empty() {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            let mut top = *stk.last().unwrap();\\n            if top >= v && size == 0 {\\n                left -= 1;\\n                continue;\\n            }\\n            if top >= v && size > 0 {\\n                stk.push(v);\\n                size -= 1;\\n                left -= 1;\\n                continue;\\n            }\\n            /* \\u53EA\\u8981\\u8FD8\\u80FD\\u586B\\u6EE1\\uFF0C\\u5E76\\u4E14\\u6808\\u9876\\u7684\\u503C\\u6BD4\\u5F53\\u524D\\u503C\\u8981\\u5C0F\\uFF0C\\u5C31\\u4E00\\u76F4\\u51FA\\u6808\\u3002 */\\n            while size < left && !stk.is_empty() {\\n                top = *stk.last().unwrap();\\n                if top < v {\\n                    stk.pop();\\n                    size += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            stk.push(v);\\n            size -= 1;\\n            left -= 1;\\n        }\\n        stk\\n    }\\n    /* \\u628A\\u4E24\\u4E2A\\u6570\\u7EC4\\u7EC4\\u5408\\u8D77\\u6765\\u627E\\u6700\\u5927\\u7684\\u503C */\\n    fn combine(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut k = 0;\\n        let mut res = Vec::new();\\n        while i < nums1.len() && k < nums2.len() {\\n            /* \\u8C01\\u5927\\u9009\\u8C01 */\\n            if nums1[i] < nums2[k] {\\n                res.push(nums2[k]);\\n                k += 1;\\n            } else if nums1[i] > nums2[k] {\\n                res.push(nums1[i]);\\n                i += 1;\\n            } else {\\n                /* \\u5982\\u679C\\u5019\\u9009\\u4EBA\\u4E00\\u6837\\u7684\\u8BDD\\uFF0C\\u5C31\\u6709\\u4E9B\\u96BE\\u5904\\u7406\\u4E86\\u3002\\n                 * \\u9700\\u8981\\u6328\\u4E2A\\u770B\\u540E\\u9762\\u7684\\u503C\\u8C01\\u5927\\uFF0C\\u9009\\u5927\\u7684\\u3002 */\\n                let ori_i = i;\\n                let ori_k = k;\\n                i += 1;\\n                k += 1;\\n                let mut use_i = false;\\n                while i < nums1.len() && k < nums2.len() {\\n                    if nums1[i] < nums2[k] {\\n                        use_i = false;\\n                        break;\\n                    } else if nums1[i] > nums2[k] {\\n                        use_i = true;\\n                        break;\\n                    }\\n                    i += 1;\\n                    k += 1;\\n                }\\n                /* \\u6BD4\\u5230\\u6700\\u540E\\u8FD8\\u662F\\u4E00\\u6837\\uFF0C\\u9009\\u540E\\u9762\\u8FD8\\u6709\\u6570\\u7684\\u3002 */\\n                if i == nums1.len() && k < nums2.len() {\\n                    use_i = false;\\n                } else if i < nums1.len() && k == nums2.len() {\\n                    use_i = true;\\n                }\\n                /* \\u8BB0\\u5F97\\u628A\\u5E8F\\u53F7\\u6062\\u590D\\u56DE\\u6765\\u3002 */\\n                if use_i {\\n                    res.push(nums1[ori_i]);\\n                    i = ori_i + 1;\\n                    k = ori_k;\\n                } else {\\n                    res.push(nums2[ori_k]);\\n                    i = ori_i;\\n                    k = ori_k + 1;\\n                }\\n            }\\n        }\\n        while i < nums1.len() {\\n            res.push(nums1[i]);\\n            i += 1;\\n        }\\n        while k < nums2.len() {\\n            res.push(nums2[k]);\\n            k += 1;\\n        }\\n        res\\n    }\\n    /* \\u6BD4\\u8F83\\u4E24\\u4E2A\\u6570\\u7EC4\\u54EA\\u4E2A\\u5927 */\\n    fn nums1_larger(nums1: & Vec<i32>, nums2: & Vec<i32>) -> bool {\\n        let length = nums1.len();\\n        for i in 0..length {\\n            if nums1[i] > nums2[i] {\\n                return true;\\n            } else if nums1[i] < nums2[i] {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let large: Vec<i32>;\\n        let small: Vec<i32>;\\n        if nums1.len() > nums2.len() {\\n            large = nums1;\\n            small = nums2;\\n        } else {\\n            large = nums2;\\n            small = nums1;\\n        }\\n        let start = if k as usize > large.len() {\\n            k as usize - large.len()\\n        } else {\\n            0\\n        };\\n        let stop = std::cmp::min(k as usize + 1, small.len() + 1);\\n        let mut res = vec![0; k as usize];\\n        for i in start..stop {\\n            let v1 = Solution::helper(&small, i);\\n            let v2 = Solution::helper(&large, k as usize - i);\\n            let cur = Solution::combine(v1, v2);\\n            if Solution::nums1_larger(&cur, &res) {\\n                res = cur;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323553,
                "title": "javascript-321-create-maximum-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMain function is more difficult to understand\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxNumber = function (a, b, k) {\\n    let m = a.length,\\n        n = b.length,\\n        ss = Math.max(0, k - n),\\n        ee = Math.min(k, m),\\n        maxSubsequence = new Array(k).fill(0);\\n    for (let i = ss; i <= ee; i++) {\\n        let ss1 = new MaxSubsequence(a, i);\\n        let ss2 = new MaxSubsequence(b, k - i);\\n        let curMaxSubsequence = merge(ss1, ss2);\\n        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\\n            maxSubsequence.splice(0, k, ...curMaxSubsequence);\\n        }\\n    }\\n    return maxSubsequence;\\n};\\n\\nvar MaxSubsequence = function (a, mustTakeOptions) {\\n    let n = a.length;\\n\\n    let canThrowAwayOptions = n - mustTakeOptions;\\n    let st = [];\\n    let top = -1;\\n    for (let e of a) {\\n        if (\\n            top + 1 < mustTakeOptions || //\\n            (canThrowAwayOptions && st[top] < e)\\n        ) {\\n            while (canThrowAwayOptions && st[top] < e) {\\n                top--;\\n                canThrowAwayOptions--;\\n            }\\n            top++;\\n            st[top] = e;\\n        } else {\\n            canThrowAwayOptions--;\\n        }\\n    }\\n    return st;\\n};\\n\\nvar merge = (a, b) => {\\n    let m = a.length;\\n    let n = b.length;\\n    let o = m + n;\\n\\n    let c = new Array(o);\\n    let i = 0;\\n    let j = 0;\\n    for (let k = 0; k < o; k++) {\\n        if (compare(a, i, b, j) > 0) {\\n            c[k] = a[i];\\n            i++;\\n        } else {\\n            c[k] = b[j];\\n            j++;\\n        }\\n    }\\n    return c;\\n};\\n\\nvar compare = (a, i, b, j) => {\\n    let m = a.length;\\n    let n = b.length;\\n    while (i < m && j < n) {\\n        if (a[i] !== b[j]) {\\n            return a[i] - b[j];\\n        }\\n        i++;\\n        j++;\\n    }\\n    return m - i - (n - j);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumber = function (a, b, k) {\\n    let m = a.length,\\n        n = b.length,\\n        ss = Math.max(0, k - n),\\n        ee = Math.min(k, m),\\n        maxSubsequence = new Array(k).fill(0);\\n    for (let i = ss; i <= ee; i++) {\\n        let ss1 = new MaxSubsequence(a, i);\\n        let ss2 = new MaxSubsequence(b, k - i);\\n        let curMaxSubsequence = merge(ss1, ss2);\\n        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\\n            maxSubsequence.splice(0, k, ...curMaxSubsequence);\\n        }\\n    }\\n    return maxSubsequence;\\n};\\n\\nvar MaxSubsequence = function (a, mustTakeOptions) {\\n    let n = a.length;\\n\\n    let canThrowAwayOptions = n - mustTakeOptions;\\n    let st = [];\\n    let top = -1;\\n    for (let e of a) {\\n        if (\\n            top + 1 < mustTakeOptions || //\\n            (canThrowAwayOptions && st[top] < e)\\n        ) {\\n            while (canThrowAwayOptions && st[top] < e) {\\n                top--;\\n                canThrowAwayOptions--;\\n            }\\n            top++;\\n            st[top] = e;\\n        } else {\\n            canThrowAwayOptions--;\\n        }\\n    }\\n    return st;\\n};\\n\\nvar merge = (a, b) => {\\n    let m = a.length;\\n    let n = b.length;\\n    let o = m + n;\\n\\n    let c = new Array(o);\\n    let i = 0;\\n    let j = 0;\\n    for (let k = 0; k < o; k++) {\\n        if (compare(a, i, b, j) > 0) {\\n            c[k] = a[i];\\n            i++;\\n        } else {\\n            c[k] = b[j];\\n            j++;\\n        }\\n    }\\n    return c;\\n};\\n\\nvar compare = (a, i, b, j) => {\\n    let m = a.length;\\n    let n = b.length;\\n    while (i < m && j < n) {\\n        if (a[i] !== b[j]) {\\n            return a[i] - b[j];\\n        }\\n        i++;\\n        j++;\\n    }\\n    return m - i - (n - j);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3283742,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nchecking every possible subarray and comparing with previously calculated max subarray\\n if it is greater than previous we update it,other wise we just check other possible subarrays\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        return this.sol(nums1,nums2,k);\\n    }\\n    public int[] sol(int[] nums1,int[] nums2,int k) {\\n        int start = Math.max(k - nums2.length,0);\\n        int end = Math.min(nums1.length,k);\\n        int[] nums = new int[k];\\n        for(int i = start;i <= end;i++) {\\n            int[] first = new int[i];\\n            int[] second = new int[k - i];\\n            int[] result = new int[k];\\n            first = this.max(nums1,i);\\n            second = this.max(nums2,k - i);\\n            int start1 = 0,start2  =0,counter =0;\\n            int i1 = 0,j1 = 0;\\n            while(i1  < first.length && j1 < second.length) {\\n                if(first[i1] == second[j1]) {\\n                    int temp1 = i1;\\n                    int temp2 = j1;\\n                    while(temp1 < first.length && temp2 < second.length && first[temp1] == second[temp2]) {\\n                        temp1++;\\n                        temp2++;\\n                    }\\n                    if(temp1 == first.length) {\\n                        result[counter++] = second[j1++]; \\n                    }\\n                    else if(temp2 == second.length) {\\n                        result[counter++] = first[i1++];\\n                    }\\n                    else {\\n                        if(first[temp1] > second[temp2]) {\\n                            result[counter++] = first[i1++];\\n                        }\\n                        else {\\n                            result[counter++] = second[j1++];\\n                        }\\n                    }\\n                }\\n                else if(first[i1] > second[j1]) {\\n                    result[counter++] = first[i1++];\\n                }\\n                else {\\n                    result[counter++] = second[j1++];\\n                }\\n            }\\n            while(i1 < first.length) {\\n                result[counter++] = first[i1++];\\n            }\\n            while(j1 < second.length) {\\n                result[counter++] = second[j1++];\\n            }\\n            boolean visited = false;\\n            start1 = 0;\\n            start2 = 0;\\n            while(start1 < result.length || start2 < nums.length) {\\n                if(result[start1] > nums[start2]) {\\n                    visited = true;\\n                    break;\\n                }\\n                else if(nums[start2] > result[start1]) {\\n                    break;\\n                }\\n                else {\\n                    start1++;\\n                    start2++;\\n                    if(start1 == result.length) {\\n                        visited = true;\\n                    }\\n                }\\n            }\\n            if(visited) {\\n                nums  = result;\\n            }\\n\\n        }\\n        return nums;\\n    }\\n    \\n    public int[] max(int[] nums,int k) {\\n        int[] res = new int[k];\\n        int len =0;\\n        for(int i =0;i < nums.length;i++) {\\n            while( len > 0 && res[len - 1] < nums[i] && k - len < nums.length - i) {\\n                len--;\\n            }\\n            if(len < k) {\\n                res[len++] = nums[i];\\n            }\\n        }\\n        return  res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        return this.sol(nums1,nums2,k);\\n    }\\n    public int[] sol(int[] nums1,int[] nums2,int k) {\\n        int start = Math.max(k - nums2.length,0);\\n        int end = Math.min(nums1.length,k);\\n        int[] nums = new int[k];\\n        for(int i = start;i <= end;i++) {\\n            int[] first = new int[i];\\n            int[] second = new int[k - i];\\n            int[] result = new int[k];\\n            first = this.max(nums1,i);\\n            second = this.max(nums2,k - i);\\n            int start1 = 0,start2  =0,counter =0;\\n            int i1 = 0,j1 = 0;\\n            while(i1  < first.length && j1 < second.length) {\\n                if(first[i1] == second[j1]) {\\n                    int temp1 = i1;\\n                    int temp2 = j1;\\n                    while(temp1 < first.length && temp2 < second.length && first[temp1] == second[temp2]) {\\n                        temp1++;\\n                        temp2++;\\n                    }\\n                    if(temp1 == first.length) {\\n                        result[counter++] = second[j1++]; \\n                    }\\n                    else if(temp2 == second.length) {\\n                        result[counter++] = first[i1++];\\n                    }\\n                    else {\\n                        if(first[temp1] > second[temp2]) {\\n                            result[counter++] = first[i1++];\\n                        }\\n                        else {\\n                            result[counter++] = second[j1++];\\n                        }\\n                    }\\n                }\\n                else if(first[i1] > second[j1]) {\\n                    result[counter++] = first[i1++];\\n                }\\n                else {\\n                    result[counter++] = second[j1++];\\n                }\\n            }\\n            while(i1 < first.length) {\\n                result[counter++] = first[i1++];\\n            }\\n            while(j1 < second.length) {\\n                result[counter++] = second[j1++];\\n            }\\n            boolean visited = false;\\n            start1 = 0;\\n            start2 = 0;\\n            while(start1 < result.length || start2 < nums.length) {\\n                if(result[start1] > nums[start2]) {\\n                    visited = true;\\n                    break;\\n                }\\n                else if(nums[start2] > result[start1]) {\\n                    break;\\n                }\\n                else {\\n                    start1++;\\n                    start2++;\\n                    if(start1 == result.length) {\\n                        visited = true;\\n                    }\\n                }\\n            }\\n            if(visited) {\\n                nums  = result;\\n            }\\n\\n        }\\n        return nums;\\n    }\\n    \\n    public int[] max(int[] nums,int k) {\\n        int[] res = new int[k];\\n        int len =0;\\n        for(int i =0;i < nums.length;i++) {\\n            while( len > 0 && res[len - 1] < nums[i] && k - len < nums.length - i) {\\n                len--;\\n            }\\n            if(len < k) {\\n                res[len++] = nums[i];\\n            }\\n        }\\n        return  res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239435,
                "title": "rust-short-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_number(mut nums1: Vec<i32>, mut nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        fn prepare(nums: &mut Vec<i32>, k: usize) -> Vec<i32> {\\n            let mut drop = nums.len() - k;\\n            let mut stack = vec![];\\n            for n in nums.iter() {\\n                while !stack.is_empty() && drop > 0 && *stack.last().unwrap() < *n {\\n                    stack.pop();\\n                    drop -= 1;\\n                }\\n                stack.push(*n);\\n            }\\n            stack[0..k].iter().copied().take(k).collect()\\n        }\\n\\n        fn merge(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n            use std::collections::VecDeque;\\n            let mut a = VecDeque::from(a);\\n            let mut b = VecDeque::from(b);\\n            let mut merged = vec![];\\n            while a.len() + b.len() > 0 {\\n                let n = if a > b { &mut a } else { &mut b };\\n                merged.push(n.pop_front().unwrap());\\n            }\\n            merged\\n        }\\n\\n        let k = k as usize;\\n        let mut ans = vec![];\\n        let mut k1 = (k as i32 - nums2.len() as i32).max(0) as usize;\\n        while k1 <= k.min(nums1.len()) {\\n            let p1 = prepare(&mut nums1, k1);\\n            let p2 = prepare(&mut nums2, k - k1);\\n            let merged = merge(p1, p2);\\n            ans = ans.max(merged);\\n            k1 += 1;\\n        }\\n        ans        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_number(mut nums1: Vec<i32>, mut nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        fn prepare(nums: &mut Vec<i32>, k: usize) -> Vec<i32> {\\n            let mut drop = nums.len() - k;\\n            let mut stack = vec![];\\n            for n in nums.iter() {\\n                while !stack.is_empty() && drop > 0 && *stack.last().unwrap() < *n {\\n                    stack.pop();\\n                    drop -= 1;\\n                }\\n                stack.push(*n);\\n            }\\n            stack[0..k].iter().copied().take(k).collect()\\n        }\\n\\n        fn merge(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n            use std::collections::VecDeque;\\n            let mut a = VecDeque::from(a);\\n            let mut b = VecDeque::from(b);\\n            let mut merged = vec![];\\n            while a.len() + b.len() > 0 {\\n                let n = if a > b { &mut a } else { &mut b };\\n                merged.push(n.pop_front().unwrap());\\n            }\\n            merged\\n        }\\n\\n        let k = k as usize;\\n        let mut ans = vec![];\\n        let mut k1 = (k as i32 - nums2.len() as i32).max(0) as usize;\\n        while k1 <= k.min(nums1.len()) {\\n            let p1 = prepare(&mut nums1, k1);\\n            let p2 = prepare(&mut nums2, k - k1);\\n            let merged = merge(p1, p2);\\n            ans = ans.max(merged);\\n            k1 += 1;\\n        }\\n        ans        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3184102,
                "title": "collection-of-3-subproblems",
                "content": "# Easy C++ Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxArray(vector<int>&nums,int k){\\n        int n=nums.size();\\n        stack<int>seen;\\n        for(int i=0;i<n;i++){\\n            int right=n-i-1;\\n            while(not seen.empty() and seen.top()<nums[i] and right+seen.size()>=k)seen.pop();\\n            if(seen.size()<k)seen.push(nums[i]);\\n        }\\n        vector<int>res(k,0);\\n        for(int i=res.size()-1;i>=0;i--){\\n            res[i]=seen.top();\\n            seen.pop();\\n        }\\n        return res;\\n    }\\n    bool greater(vector<int>&arr1,int i,vector<int>&arr2,int j){\\n        for(;i<arr1.size() and j<arr2.size();i++,j++){\\n            if(arr1[i]==arr2[j])continue;\\n            return arr1[i]>arr2[j];\\n        }\\n        return i!=arr1.size();\\n    }\\n    vector<int> merge(vector<int>&arr1,vector<int>&arr2){\\n        vector<int>res(arr1.size()+arr2.size());\\n        for(int ind=0,i=0,j=0;ind<res.size();ind++){\\n            if(greater(arr1,i,arr2,j)){\\n                res[ind]=arr1[i];\\n                i++;\\n            }else{\\n                res[ind]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(),n=nums2.size();\\n        vector<int>ans;\\n        for(int len1=max(0,k-n);len1<=min(m,k);len1++){\\n            int len2 = k-len1;\\n            vector<int> arr1 = maxArray(nums1,len1);\\n            vector<int> arr2 = maxArray(nums2,len2);\\n            vector<int> temp_res = merge(arr1,arr2);\\n            if(greater(temp_res,0,ans,0)){\\n                ans.resize(temp_res.size());\\n                for(int i=0;i<temp_res.size();i++){\\n                    ans[i]=temp_res[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxArray(vector<int>&nums,int k){\\n        int n=nums.size();\\n        stack<int>seen;\\n        for(int i=0;i<n;i++){\\n            int right=n-i-1;\\n            while(not seen.empty() and seen.top()<nums[i] and right+seen.size()>=k)seen.pop();\\n            if(seen.size()<k)seen.push(nums[i]);\\n        }\\n        vector<int>res(k,0);\\n        for(int i=res.size()-1;i>=0;i--){\\n            res[i]=seen.top();\\n            seen.pop();\\n        }\\n        return res;\\n    }\\n    bool greater(vector<int>&arr1,int i,vector<int>&arr2,int j){\\n        for(;i<arr1.size() and j<arr2.size();i++,j++){\\n            if(arr1[i]==arr2[j])continue;\\n            return arr1[i]>arr2[j];\\n        }\\n        return i!=arr1.size();\\n    }\\n    vector<int> merge(vector<int>&arr1,vector<int>&arr2){\\n        vector<int>res(arr1.size()+arr2.size());\\n        for(int ind=0,i=0,j=0;ind<res.size();ind++){\\n            if(greater(arr1,i,arr2,j)){\\n                res[ind]=arr1[i];\\n                i++;\\n            }else{\\n                res[ind]=arr2[j];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m=nums1.size(),n=nums2.size();\\n        vector<int>ans;\\n        for(int len1=max(0,k-n);len1<=min(m,k);len1++){\\n            int len2 = k-len1;\\n            vector<int> arr1 = maxArray(nums1,len1);\\n            vector<int> arr2 = maxArray(nums2,len2);\\n            vector<int> temp_res = merge(arr1,arr2);\\n            if(greater(temp_res,0,ans,0)){\\n                ans.resize(temp_res.size());\\n                for(int i=0;i<temp_res.size();i++){\\n                    ans[i]=temp_res[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002707,
                "title": "c-easy-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> maxLex(vector<int> nums, int k) {\\n        int N = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0; i<N; i++) {\\n            while(!res.empty() and nums[i] > res.back() and k - (int)res.size() <= N - i - 1) {\\n                res.pop_back();\\n            }\\n            if(res.size() < k)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool greater(vector<int>& nums1, vector<int>& nums2, int a, int b) {\\n        while(a < nums1.size() or b < nums2.size()) {\\n            if(a >= nums1.size())\\n                return false;\\n            else if(b >= nums2.size())\\n                return true;\\n            else if(nums1[a] < nums2[b]) \\n                return false;\\n            else if(nums1[a] > nums2[b])\\n                return true;\\n            else \\n                ++a,++b;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<=k; i++) {\\n            int j = k - i;\\n            \\n            if(i > nums1.size() or j > nums2.size())\\n                continue;\\n            \\n            vector<int> max1 = maxLex(nums1,i);\\n            vector<int> max2 = maxLex(nums2,j);\\n            \\n            vector<int> merged;\\n            \\n            int a = 0;\\n            int b = 0;\\n            \\n            while(a < max1.size() or b < max2.size()) {\\n                if(a >= max1.size())\\n                    merged.push_back(max2[b++]);\\n                else if(b >= max2.size())\\n                    merged.push_back(max1[a++]);\\n                else if(max1[a] < max2[b]) \\n                    merged.push_back(max2[b++]);\\n                else if(max1[a] > max2[b])\\n                    merged.push_back(max1[a++]);\\n                else{\\n                    if(greater(max1,max2,a,b)) {\\n                        merged.push_back(max1[a++]);\\n                    }\\n                    else {\\n                        merged.push_back(max2[b++]);\\n                    }\\n                }\\n            }\\n            if(merged > ans)\\n                ans = merged;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844981,
                "title": "efficient-c-solution-beat-96-runtime-beat-99-6-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> construct(const vector<int>& nums){\\n        int sz = nums.size();\\n        vector<int> ret(sz, sz);\\n        vector<int> pos(10, sz);\\n        for(int i = sz-1; i >= 0; i--){\\n            for(int j = nums[i]+1; j <= 9; j++) ret[i] = min(ret[i], pos[j]);\\n            pos[nums[i]] = i;\\n        }\\n        return ret;\\n    }\\n\\n    int next_pos(const vector<int>& larger_pos, int p, int len, int remain_len){\\n        while(remain_len > 0 && len-larger_pos[p] >= remain_len) p= larger_pos[p];\\n        return p;\\n    }\\n\\n    int get_x(const vector<int>& nums, int p, int remain_len){\\n        if(remain_len <=0 || p >= nums.size()) return -1;\\n        return nums[p];\\n    }\\n\\n    void explore(const vector<int>& nums1, const vector<int>& nums2,const vector<int>& larger_pos1, const vector<int>& larger_pos2, vector<int>& ret, int len1, int len2) {\\n        int p1 = 0; int p2 = 0;\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        bool is_larger = false;\\n        p1= next_pos(larger_pos1, p1, sz1, len1);\\n        p2= next_pos(larger_pos2, p2, sz2, len2);\\n        for(int i = 0; i < k; ++i){\\n            int x1 = len1? nums1[p1] : -1;\\n            int x2 = len2? nums2[p2] : -1;\\n            if((!is_larger) && ret[i] > max(x1, x2)) return;\\n            int iter = 1; int nxp1 = p1; int nxp2 = p2;\\n            int x1_ =  0; int x2_ = 0;\\n            while(x1_ == x2_ && x1_ != -1){\\n                nxp1 = next_pos(larger_pos1, nxp1+1, sz1, len1-iter);\\n                nxp2 = next_pos(larger_pos2, nxp2+1, sz2, len2-iter);\\n                x1_ = get_x(nums1, nxp1, len1-iter);\\n                x2_ = get_x(nums2, nxp2, len2-iter);\\n                iter++;\\n            }\\n            if(x1 > x2 || (x1==x2&&(x1_ > x2_))){\\n                p1 = next_pos(larger_pos1, p1+1, sz1, len1-1);\\n                len1--;\\n            } else {\\n                p2 = next_pos(larger_pos2, p2+1, sz2, len2-1);\\n                len2--;\\n            }\\n            if(ret[i] < max(x1, x2)) is_larger = true;\\n            ret[i] = max(x1, x2);\\n        }\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k_) {\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        k = k_;\\n        vector<int> ret(k);\\n        auto larger_pos1 = construct(nums1);\\n        auto larger_pos2 = construct(nums2);\\n\\n        for(int i = max(k-sz2, 0); i <= min(sz1, k); ++i){\\n            explore(nums1, nums2, larger_pos1, larger_pos2, ret, i, k-i);\\n        }\\n\\n        return ret;\\n    }\\n\\nint k;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> construct(const vector<int>& nums){\\n        int sz = nums.size();\\n        vector<int> ret(sz, sz);\\n        vector<int> pos(10, sz);\\n        for(int i = sz-1; i >= 0; i--){\\n            for(int j = nums[i]+1; j <= 9; j++) ret[i] = min(ret[i], pos[j]);\\n            pos[nums[i]] = i;\\n        }\\n        return ret;\\n    }\\n\\n    int next_pos(const vector<int>& larger_pos, int p, int len, int remain_len){\\n        while(remain_len > 0 && len-larger_pos[p] >= remain_len) p= larger_pos[p];\\n        return p;\\n    }\\n\\n    int get_x(const vector<int>& nums, int p, int remain_len){\\n        if(remain_len <=0 || p >= nums.size()) return -1;\\n        return nums[p];\\n    }\\n\\n    void explore(const vector<int>& nums1, const vector<int>& nums2,const vector<int>& larger_pos1, const vector<int>& larger_pos2, vector<int>& ret, int len1, int len2) {\\n        int p1 = 0; int p2 = 0;\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        bool is_larger = false;\\n        p1= next_pos(larger_pos1, p1, sz1, len1);\\n        p2= next_pos(larger_pos2, p2, sz2, len2);\\n        for(int i = 0; i < k; ++i){\\n            int x1 = len1? nums1[p1] : -1;\\n            int x2 = len2? nums2[p2] : -1;\\n            if((!is_larger) && ret[i] > max(x1, x2)) return;\\n            int iter = 1; int nxp1 = p1; int nxp2 = p2;\\n            int x1_ =  0; int x2_ = 0;\\n            while(x1_ == x2_ && x1_ != -1){\\n                nxp1 = next_pos(larger_pos1, nxp1+1, sz1, len1-iter);\\n                nxp2 = next_pos(larger_pos2, nxp2+1, sz2, len2-iter);\\n                x1_ = get_x(nums1, nxp1, len1-iter);\\n                x2_ = get_x(nums2, nxp2, len2-iter);\\n                iter++;\\n            }\\n            if(x1 > x2 || (x1==x2&&(x1_ > x2_))){\\n                p1 = next_pos(larger_pos1, p1+1, sz1, len1-1);\\n                len1--;\\n            } else {\\n                p2 = next_pos(larger_pos2, p2+1, sz2, len2-1);\\n                len2--;\\n            }\\n            if(ret[i] < max(x1, x2)) is_larger = true;\\n            ret[i] = max(x1, x2);\\n        }\\n    }\\n\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k_) {\\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        k = k_;\\n        vector<int> ret(k);\\n        auto larger_pos1 = construct(nums1);\\n        auto larger_pos2 = construct(nums2);\\n\\n        for(int i = max(k-sz2, 0); i <= min(sz1, k); ++i){\\n            explore(nums1, nums2, larger_pos1, larger_pos2, ret, i, k-i);\\n        }\\n\\n        return ret;\\n    }\\n\\nint k;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714234,
                "title": "i-finally-tend-this-beast",
                "content": "```cpp\\n// generate all the maximum number from `nums\\' that with length from `n\\' to 1.\\nvoid max_nu(vector<int>& nums, vector<vector<int>>& ret)\\n{\\n\\t// the original `nums\\' is the maximum number of length `n\\'\\n\\tret.push_back(nums);\\n\\tint n = nums.size();\\n\\t\\n\\t// in each iteration, we generate the maximum number of length `n - 1\\'\\n\\t// from the previous maximum number of length `n\\', \\n\\t// by droping one digit.\\n\\twhile (n)\\n\\t{\\n\\t\\tvector<int> nu;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\t// for each digit in the maximum number of length `n\\', \\n\\t\\twhile (i < n)\\n\\t\\t{\\n\\t\\t\\t// drop this digit\\n\\t\\t\\tif (ret.back()[i - 1] < ret.back()[i])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t// keep this digit\\n\\t\\t\\tnu.push_back(ret.back()[i - 1]);\\n\\t\\t\\t++ i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// append the rest digits\\n\\t\\twhile (i < n)\\n\\t\\t\\tnu.push_back(ret.back()[i ++]);\\n\\t\\t\\n\\t\\t// save the maximum number of length `n - 1\\'\\n\\t\\t// move to next iteration\\n\\t\\tret.push_back(nu);\\n\\t\\tn = nu.size();\\n\\t}\\n}\\n\\n// check if the number from the index `i\\' of `n1\\' is larger than the number from the index `j\\' of `n2\\'\\nbool isLarger(vector<int>& n1, vector<int>& n2, int i = 0, int j = 0)\\n{\\n\\tfor (; i < n1.size() && j < n2.size(); ++i, ++j)\\n\\t\\tif (n1[i] != n2[j])\\n\\t\\t\\tbreak;\\n\\t\\n\\t// if the length of `n1\\' from index `i\\' is longer than that of `n2\\' from index `j\\', or\\n\\t// a digit in `n1\\' is larger than the corresponding digit in `n2\\' \\n\\treturn i < n1.size() && (j == n2.size() || n1[i] > n2[j]);\\n}\\n\\n// `nn\\' will be the maximum number constructed by merge `n1\\' and `n2\\'\\nvoid merge(vector<int>& n1, vector<int>& n2, vector<int>& nn)\\n{\\n\\tint m = n1.size();\\n\\tint n = n2.size();\\n\\tint i = 0;\\n\\tint j = 0;\\n\\t\\n\\twhile (i < m && j < n)\\n\\t{\\n\\t\\tif (isLarger(n1, n2, i, j))\\n\\t\\t\\tnn.push_back(n1[i ++]);\\n\\t\\telse\\n\\t\\t\\tnn.push_back(n2[j ++]);\\n\\t}\\n\\t\\n\\twhile (i < m)\\n\\t\\tnn.push_back(n1[i ++]);\\n\\t\\n\\twhile (j < n)\\n\\t\\tnn.push_back(n2[j ++]);\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tvector<int> ret;\\n\\tvector<vector<int>> nu1, nu2;\\n\\tint m = nums1.size();\\n\\tint n = nums2.size();\\n\\t\\n\\t// generate maximum numbers of all length from `m\\' to 1 using `nums1\\'\\n\\tmax_nu(nums1, nu1);\\n\\t// likewise.\\n\\tmax_nu(nums2, nu2);\\n\\t\\n\\t// the overall maximum number must come from a maximum number of `nums1\\' of length k1 and\\n\\t// a maximum number of `nums2\\' of length k2, where k1 + k2 == k\\n\\tfor (auto& n1 : nu1)\\n\\t{\\n\\t\\tint k1 = n1.size();\\n\\t\\tint k2 = k - k1;\\n\\t\\t\\n\\t\\tif (k2 < 0 || k2 > n)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// the corresponding maximum number of `nums2\\' of length k2\\n\\t\\tauto& n2 = nu2[nu2.size() - 1 - k2];\\n\\n\\t\\t// merge them to form a local maximum number of length k\\n\\t\\tvector<int> nn;\\n\\t\\tmerge(n1, n2, nn);\\n\\n\\t\\t// determin the global maximum number of length k\\n\\t\\tif (ret.empty() || isLarger(nn, ret))\\n\\t\\t\\tret = nn;\\n\\t}\\n\\t\\n\\treturn ret;        \\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// generate all the maximum number from `nums\\' that with length from `n\\' to 1.\\nvoid max_nu(vector<int>& nums, vector<vector<int>>& ret)\\n{\\n\\t// the original `nums\\' is the maximum number of length `n\\'\\n\\tret.push_back(nums);\\n\\tint n = nums.size();\\n\\t\\n\\t// in each iteration, we generate the maximum number of length `n - 1\\'\\n\\t// from the previous maximum number of length `n\\', \\n\\t// by droping one digit.\\n\\twhile (n)\\n\\t{\\n\\t\\tvector<int> nu;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\t// for each digit in the maximum number of length `n\\', \\n\\t\\twhile (i < n)\\n\\t\\t{\\n\\t\\t\\t// drop this digit\\n\\t\\t\\tif (ret.back()[i - 1] < ret.back()[i])\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t// keep this digit\\n\\t\\t\\tnu.push_back(ret.back()[i - 1]);\\n\\t\\t\\t++ i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// append the rest digits\\n\\t\\twhile (i < n)\\n\\t\\t\\tnu.push_back(ret.back()[i ++]);\\n\\t\\t\\n\\t\\t// save the maximum number of length `n - 1\\'\\n\\t\\t// move to next iteration\\n\\t\\tret.push_back(nu);\\n\\t\\tn = nu.size();\\n\\t}\\n}\\n\\n// check if the number from the index `i\\' of `n1\\' is larger than the number from the index `j\\' of `n2\\'\\nbool isLarger(vector<int>& n1, vector<int>& n2, int i = 0, int j = 0)\\n{\\n\\tfor (; i < n1.size() && j < n2.size(); ++i, ++j)\\n\\t\\tif (n1[i] != n2[j])\\n\\t\\t\\tbreak;\\n\\t\\n\\t// if the length of `n1\\' from index `i\\' is longer than that of `n2\\' from index `j\\', or\\n\\t// a digit in `n1\\' is larger than the corresponding digit in `n2\\' \\n\\treturn i < n1.size() && (j == n2.size() || n1[i] > n2[j]);\\n}\\n\\n// `nn\\' will be the maximum number constructed by merge `n1\\' and `n2\\'\\nvoid merge(vector<int>& n1, vector<int>& n2, vector<int>& nn)\\n{\\n\\tint m = n1.size();\\n\\tint n = n2.size();\\n\\tint i = 0;\\n\\tint j = 0;\\n\\t\\n\\twhile (i < m && j < n)\\n\\t{\\n\\t\\tif (isLarger(n1, n2, i, j))\\n\\t\\t\\tnn.push_back(n1[i ++]);\\n\\t\\telse\\n\\t\\t\\tnn.push_back(n2[j ++]);\\n\\t}\\n\\t\\n\\twhile (i < m)\\n\\t\\tnn.push_back(n1[i ++]);\\n\\t\\n\\twhile (j < n)\\n\\t\\tnn.push_back(n2[j ++]);\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tvector<int> ret;\\n\\tvector<vector<int>> nu1, nu2;\\n\\tint m = nums1.size();\\n\\tint n = nums2.size();\\n\\t\\n\\t// generate maximum numbers of all length from `m\\' to 1 using `nums1\\'\\n\\tmax_nu(nums1, nu1);\\n\\t// likewise.\\n\\tmax_nu(nums2, nu2);\\n\\t\\n\\t// the overall maximum number must come from a maximum number of `nums1\\' of length k1 and\\n\\t// a maximum number of `nums2\\' of length k2, where k1 + k2 == k\\n\\tfor (auto& n1 : nu1)\\n\\t{\\n\\t\\tint k1 = n1.size();\\n\\t\\tint k2 = k - k1;\\n\\t\\t\\n\\t\\tif (k2 < 0 || k2 > n)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// the corresponding maximum number of `nums2\\' of length k2\\n\\t\\tauto& n2 = nu2[nu2.size() - 1 - k2];\\n\\n\\t\\t// merge them to form a local maximum number of length k\\n\\t\\tvector<int> nn;\\n\\t\\tmerge(n1, n2, nn);\\n\\n\\t\\t// determin the global maximum number of length k\\n\\t\\tif (ret.empty() || isLarger(nn, ret))\\n\\t\\t\\tret = nn;\\n\\t}\\n\\t\\n\\treturn ret;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663123,
                "title": "create-maximum-number-c",
                "content": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvoid getMaxNumber(int *nums, int size, int outsize, int *out) {\\n    int len = 0, i, k = size - outsize;\\n    out[0] = nums[0];\\n    for (i = 1; i < size; i++) {\\n        while (len >= 0 && k > 0 && nums[i] > out[len]) k--, len--;\\n        out[++len] = nums[i];\\n    }\\n}\\n\\nint compareArr(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i;\\n    for (i = 0; i < nums1Size && i < nums2Size && nums1[i] == nums2[i]; i++);\\n    //if (i == nums1Size && i == nums2Size) return 0;\\n    if (i == nums1Size) return -1;\\n    if (i == nums2Size) return 1;\\n    return (nums1[i] - nums2[i]);\\n}\\n\\nvoid merge(int* nums1, int nums1Size, int* nums2, int nums2Size, int *out) {\\n    int len = 0, i = 0, j = 0;\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] > nums2[j]) out[len++] = nums1[i++];\\n        else if (nums1[i] < nums2[j]) out[len++] = nums2[j++];\\n        else if (compareArr(nums1 + i, nums1Size - i, nums2 + j, nums2Size - j) >= 0) out[len++] = nums1[i++];\\n        else out[len++] = nums2[j++];\\n    }\\n    while (i < nums1Size) out[len++] = nums1[i++];\\n    while (j < nums2Size) out[len++] = nums2[j++];\\n}\\n\\nint compare(int *arr1, int *arr2, int len) {\\n    int i = 0;\\n    for (; i < len && arr1[i] == arr2[i]; i++);\\n    if (i < len) return arr1[i] - arr2[i];\\n    return 0;\\n}\\n\\nint min(int x, int y) {return x <= y ? x: y;}\\n\\nint* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize) {\\n    int i = 0, j = 0;\\n    int *arr1, *arr2, *ans, *tmp;\\n    if (k <= 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    arr1 = malloc(sizeof(int) * (nums1Size + nums2Size));\\n    arr2 = arr1 + nums1Size;\\n    ans = malloc(sizeof(int) * k);\\n    tmp = malloc(sizeof(int) * k);\\n    for (j = 0; j < k; j++) ans[j] = 0;\\n    for (i = min(k, nums1Size); i >= 0; i--) {\\n        j = k - i;\\n        if (j > nums2Size) break;\\n        if (i > 0) getMaxNumber(nums1, nums1Size, i, arr1);\\n        if (j > 0) getMaxNumber(nums2, nums2Size, j, arr2);\\n        merge(arr1, i, arr2, j, tmp);\\n        if (compare(tmp, ans, k) > 0) {\\n            for (j = 0; j < k; j++) ans[j] = tmp[j];\\n        }\\n    }\\n    free(tmp);\\n    free(arr1);\\n    *returnSize = k; \\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2577370,
                "title": "very-short-c",
                "content": "```\\nclass Solution {\\n    vector<int> removek(vector<int> &nums, int k) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (res.size() && res.back() < num && k) {\\n                res.pop_back();\\n                k--;\\n            }\\n            res.push_back(num);\\n        }\\n        while(k) {\\n            res.pop_back();\\n            k--;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> merge(vector<int> &arr1, vector<int> &arr2) {\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        int N1 = arr1.size(), N2 = arr2.size();\\n        while(i < N1 && j < N2) {\\n            vector<int> tmp1(arr1.begin() + i, arr1.end());\\n            vector<int> tmp2(arr2.begin() + j, arr2.end());\\n            if (tmp1 > tmp2) {\\n                res.push_back(arr1[i++]);\\n            } else {\\n                res.push_back(arr2[j++]);\\n            }\\n        }\\n        while(i < N1) {\\n            res.push_back(arr1[i++]);\\n        }\\n        while(j < N2) {\\n            res.push_back(arr2[j++]);\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int N1 = nums1.size(), N2 = nums2.size();\\n        vector<int> res;\\n        \\n        // N1 - i >= 0 && N2 - (k - i) >= 0\\n        for (int i = max(0, k - N2); i <= k && i <= N1; i++) {\\n            auto arr1 = removek(nums1, N1 - i);\\n            auto arr2 = removek(nums2, N2 - (k - i));\\n            auto arr = merge(arr1, arr2);\\n            res = max(res, arr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> removek(vector<int> &nums, int k) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (res.size() && res.back() < num && k) {\\n                res.pop_back();\\n                k--;\\n            }\\n            res.push_back(num);\\n        }\\n        while(k) {\\n            res.pop_back();\\n            k--;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> merge(vector<int> &arr1, vector<int> &arr2) {\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        int N1 = arr1.size(), N2 = arr2.size();\\n        while(i < N1 && j < N2) {\\n            vector<int> tmp1(arr1.begin() + i, arr1.end());\\n            vector<int> tmp2(arr2.begin() + j, arr2.end());\\n            if (tmp1 > tmp2) {\\n                res.push_back(arr1[i++]);\\n            } else {\\n                res.push_back(arr2[j++]);\\n            }\\n        }\\n        while(i < N1) {\\n            res.push_back(arr1[i++]);\\n        }\\n        while(j < N2) {\\n            res.push_back(arr2[j++]);\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int N1 = nums1.size(), N2 = nums2.size();\\n        vector<int> res;\\n        \\n        // N1 - i >= 0 && N2 - (k - i) >= 0\\n        for (int i = max(0, k - N2); i <= k && i <= N1; i++) {\\n            auto arr1 = removek(nums1, N1 - i);\\n            auto arr2 = removek(nums2, N2 - (k - i));\\n            auto arr = merge(arr1, arr2);\\n            res = max(res, arr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470003,
                "title": "finally",
                "content": "**Solution:**\\n`TC = O((m+n)*(m+n-k)), SC = O(k*(m+n-k))`\\n```\\nvector<int> removeDigits(vector<int> &nums, int k) {\\n\\tif(k == 0) return nums;\\n\\tif(k == nums.size()) return {};\\n\\tstack<int> st;\\n\\tst.push(nums[0]);\\n\\tfor(int i = 1; i < nums.size(); i++) {\\n\\t\\twhile(!st.empty() && st.top() < nums[i] && k > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tst.push(nums[i]);\\n\\t}\\n\\twhile(k > 0) {\\n\\t\\tst.pop();\\n\\t\\tk--;\\n\\t}\\n\\tvector<int> ans;\\n\\twhile(!st.empty()) {\\n\\t\\tans.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n\\nvector<int> merge(vector<int> &v1, vector<int> &v2) {\\n\\tif(v1.size() == 0) return v2;\\n\\tif(v2.size() == 0) return v1;\\n\\tvector<int> v;\\n\\tint i = 0, j = 0;\\n\\twhile(i < v1.size() && j < v2.size()) {\\n\\t\\tif(v1[i] == v2[j]) {\\n\\t\\t\\tint a, b;\\n\\t\\t\\tint i1 = i, j1 = j;\\n\\t\\t\\twhile(i1 < v1.size() && j1 < v2.size() && v1[i1] == v2[j1]) {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t\\tj1++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i1 < v1.size()) a = v1[i1];\\n\\t\\t\\telse a = INT_MIN;\\n\\t\\t\\tif(j1 < v2.size()) b = v2[j1];\\n\\t\\t\\telse b = INT_MIN;\\n\\t\\t\\tif(a >= b) {\\n\\t\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(v1[i] > v2[j]) {\\n\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\twhile(i < v1.size()) {\\n\\t\\tv.push_back(v1[i]);\\n\\t\\ti++;\\n\\t}\\n\\twhile(j < v2.size()) {\\n\\t\\tv.push_back(v2[j]);\\n\\t\\tj++;\\n\\t}\\n\\treturn v;\\n}\\n\\nbool isLargest(vector<int> &nums1, vector<int> &nums2) {\\n\\tint i = 0;\\n\\twhile(i < nums1.size() && nums1[i] == nums2[i]) i++;\\n\\tif(i == nums1.size()) return true;\\n\\tif(nums1[i] > nums2[i]) return true;\\n\\treturn false;\\n}\\n\\nvector<int> findLargest(vector<vector<int>> &possibleAnswers) {\\n\\tint idx = 0;\\n\\tfor(int i = 1; i < possibleAnswers.size(); i++) {\\n\\t\\tif(isLargest(possibleAnswers[i], possibleAnswers[idx])) \\n\\t\\t\\tidx = i;\\n\\t}\\n\\treturn possibleAnswers[idx];\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tint digitsToRemove = nums1.size() + nums2.size() - k;\\n\\tvector<vector<int>> possibleAnswers;\\n\\tfor(int i = 0; i <= digitsToRemove; i++) {\\n\\t\\tint digitsToRemoveFromNums1 = i;\\n\\t\\tint digitsToRemoveFromNums2 = digitsToRemove - i;\\n\\t\\tif(digitsToRemoveFromNums1 <= nums1.size() && \\n\\t\\t   digitsToRemoveFromNums2 <= nums2.size()) {\\n\\t\\t\\tvector<int> nums1AfterRemovingDigits = removeDigits(nums1, digitsToRemoveFromNums1);\\n\\t\\t\\tvector<int> nums2AfterRemovingDigits = removeDigits(nums2, digitsToRemoveFromNums2);\\n\\t\\t\\tpossibleAnswers.push_back(merge(nums1AfterRemovingDigits, nums2AfterRemovingDigits));\\n\\t\\t}\\n\\t}\\n\\treturn findLargest(possibleAnswers);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> removeDigits(vector<int> &nums, int k) {\\n\\tif(k == 0) return nums;\\n\\tif(k == nums.size()) return {};\\n\\tstack<int> st;\\n\\tst.push(nums[0]);\\n\\tfor(int i = 1; i < nums.size(); i++) {\\n\\t\\twhile(!st.empty() && st.top() < nums[i] && k > 0) {\\n\\t\\t\\tst.pop();\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tst.push(nums[i]);\\n\\t}\\n\\twhile(k > 0) {\\n\\t\\tst.pop();\\n\\t\\tk--;\\n\\t}\\n\\tvector<int> ans;\\n\\twhile(!st.empty()) {\\n\\t\\tans.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n\\nvector<int> merge(vector<int> &v1, vector<int> &v2) {\\n\\tif(v1.size() == 0) return v2;\\n\\tif(v2.size() == 0) return v1;\\n\\tvector<int> v;\\n\\tint i = 0, j = 0;\\n\\twhile(i < v1.size() && j < v2.size()) {\\n\\t\\tif(v1[i] == v2[j]) {\\n\\t\\t\\tint a, b;\\n\\t\\t\\tint i1 = i, j1 = j;\\n\\t\\t\\twhile(i1 < v1.size() && j1 < v2.size() && v1[i1] == v2[j1]) {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t\\tj1++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i1 < v1.size()) a = v1[i1];\\n\\t\\t\\telse a = INT_MIN;\\n\\t\\t\\tif(j1 < v2.size()) b = v2[j1];\\n\\t\\t\\telse b = INT_MIN;\\n\\t\\t\\tif(a >= b) {\\n\\t\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(v1[i] > v2[j]) {\\n\\t\\t\\tv.push_back(v1[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tv.push_back(v2[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\twhile(i < v1.size()) {\\n\\t\\tv.push_back(v1[i]);\\n\\t\\ti++;\\n\\t}\\n\\twhile(j < v2.size()) {\\n\\t\\tv.push_back(v2[j]);\\n\\t\\tj++;\\n\\t}\\n\\treturn v;\\n}\\n\\nbool isLargest(vector<int> &nums1, vector<int> &nums2) {\\n\\tint i = 0;\\n\\twhile(i < nums1.size() && nums1[i] == nums2[i]) i++;\\n\\tif(i == nums1.size()) return true;\\n\\tif(nums1[i] > nums2[i]) return true;\\n\\treturn false;\\n}\\n\\nvector<int> findLargest(vector<vector<int>> &possibleAnswers) {\\n\\tint idx = 0;\\n\\tfor(int i = 1; i < possibleAnswers.size(); i++) {\\n\\t\\tif(isLargest(possibleAnswers[i], possibleAnswers[idx])) \\n\\t\\t\\tidx = i;\\n\\t}\\n\\treturn possibleAnswers[idx];\\n}\\n\\nvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\tint digitsToRemove = nums1.size() + nums2.size() - k;\\n\\tvector<vector<int>> possibleAnswers;\\n\\tfor(int i = 0; i <= digitsToRemove; i++) {\\n\\t\\tint digitsToRemoveFromNums1 = i;\\n\\t\\tint digitsToRemoveFromNums2 = digitsToRemove - i;\\n\\t\\tif(digitsToRemoveFromNums1 <= nums1.size() && \\n\\t\\t   digitsToRemoveFromNums2 <= nums2.size()) {\\n\\t\\t\\tvector<int> nums1AfterRemovingDigits = removeDigits(nums1, digitsToRemoveFromNums1);\\n\\t\\t\\tvector<int> nums2AfterRemovingDigits = removeDigits(nums2, digitsToRemoveFromNums2);\\n\\t\\t\\tpossibleAnswers.push_back(merge(nums1AfterRemovingDigits, nums2AfterRemovingDigits));\\n\\t\\t}\\n\\t}\\n\\treturn findLargest(possibleAnswers);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238372,
                "title": "java-convert-to-string-for-easy-comparison-greedy",
                "content": "The merge operation is tricky because, say, we have the following 2 sequences\\n```\\n0, 1, 8 ,5 (A)\\n0, 1, 8 ,4 (B)\\n```\\nIf both pointers are at 0, should we pick `A` or `B`? \\nWe should pick `A` as the resulting sequence would be `0,1,8,5,0,1,8,4`\\nWe can either advance both pointers and determine which to pick until they differ or meet the end, \\nor we can just convert it to string and use `compareTo()`\\n\\n```Java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        String ans=\"\";\\n        for (int i = Math.max(0, k-nums2.length); i <= Math.min(nums1.length, k); i++){ // try all possible lengths from each seq\\n            String one = solve(nums1, i); // find the best seq matching len of i\\n            String two = solve(nums2, k-i); // len of k-i\\n            StringBuilder sb = new StringBuilder();\\n            int a = 0, b = 0;\\n            while(a < i || b < k-i){ // merge it to the max\\n                sb.append(one.substring(a).compareTo(two.substring(b))>=0?one.charAt(a++):two.charAt(b++));\\n            }\\n            if (sb.toString().compareTo(ans)>0){ // if better, we replace.\\n                ans=sb.toString();\\n            }\\n        }\\n        int[] res = new int[k];\\n        for (int i = 0; i < k;++i){\\n            res[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n\\n    private String solve(int[] arr, int k){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0;i<arr.length;++i){\\n            while(!stack.isEmpty()&&arr.length-i+stack.size()>k&&stack.peek()<arr[i]){\\n                stack.pop();\\n            }\\n            stack.push(arr[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < k;i++){\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n0, 1, 8 ,5 (A)\\n0, 1, 8 ,4 (B)\\n```\n```Java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        String ans=\"\";\\n        for (int i = Math.max(0, k-nums2.length); i <= Math.min(nums1.length, k); i++){ // try all possible lengths from each seq\\n            String one = solve(nums1, i); // find the best seq matching len of i\\n            String two = solve(nums2, k-i); // len of k-i\\n            StringBuilder sb = new StringBuilder();\\n            int a = 0, b = 0;\\n            while(a < i || b < k-i){ // merge it to the max\\n                sb.append(one.substring(a).compareTo(two.substring(b))>=0?one.charAt(a++):two.charAt(b++));\\n            }\\n            if (sb.toString().compareTo(ans)>0){ // if better, we replace.\\n                ans=sb.toString();\\n            }\\n        }\\n        int[] res = new int[k];\\n        for (int i = 0; i < k;++i){\\n            res[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return res;\\n    }\\n\\n    private String solve(int[] arr, int k){\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0;i<arr.length;++i){\\n            while(!stack.isEmpty()&&arr.length-i+stack.size()>k&&stack.peek()<arr[i]){\\n                stack.pop();\\n            }\\n            stack.push(arr[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < k;i++){\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190731,
                "title": "create-maximum-number",
                "content": "class Solution {\\npublic:\\nbool Greater(vector<int> &nums1, int i, vector<int> &nums2, int j)\\n{\\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j])\\n    {\\n        ++i;\\n        ++j;\\n    }\\n    if (j == nums2.size())\\n        return true;\\n    if (i < nums1.size() && nums1[i] > nums2[j])\\n        return true;\\n    return false;\\n}\\n    vector<int>HighestNum(vector<int>nums,int k){\\n        int n=nums.size();\\n        vector<int>ans(k);\\n        for(int i=0,j=0;i<n;++i){\\n            while(n -i + j > k && j > 0 && ans[j-1] < nums[i]){\\n                j--; \\n            }\\n            if(j<k){\\n                ans[j++]=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\nvector<int> merge(vector<int> &nums1, vector<int> &nums2, int k)\\n{\\n    vector<int> res(k, 0);\\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\\n    {\\n        res[r] = Greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n    }\\n    return res;\\n}\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans(k, -1);\\n        for (int i = max(0, k - m); i <= min(k, n); i++)\\n        {\\n            vector<int> a = HighestNum(nums1, i);\\n            vector<int> b = HighestNum(nums2, k - i);\\n            ans = max(ans, merge(a, b, k));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nbool Greater(vector<int> &nums1, int i, vector<int> &nums2, int j)\\n{\\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j])\\n    {\\n        ++i;\\n        ++j;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2113081,
                "title": "python-optimised-solution-90",
                "content": "Optimised various available codes in discussion forum.\\n```\\n\\nfrom copy import copy\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def pre_process(self, num):\\n        l = len(num)\\n        summary = [[] for _ in range(l)]\\n        last = [l] * 10\\n        for i in range(l - 1, -1, -1):\\n            last[num[i]] = i\\n            summary[i] = copy(last)\\n        return summary\\n\\n    def get_next(self, summary, start, end):\\n        for i in range(9, -1, -1):\\n            if summary[start][i] < end:\\n                return summary[start][i], i\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        summary1 = self.pre_process(nums1)\\n        summary2 = self.pre_process(nums2)\\n        candidates = {0:0}\\n        max_val = []\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        for i in range(k):\\n            print(max_val)\\n            updated_candidates = defaultdict(lambda: (l2, 0))\\n            round_max = -1\\n            for x, y in candidates.items():\\n                remain = max(0, (k - i) - (l2 - y) - 1)\\n                if l1 - x >= remain and l1 - x > 0:\\n                    if x + 1 == l1 - remain:\\n                        pos1, max1 = x, nums1[x]\\n                    else:\\n                        pos1, max1 = self.get_next(summary1, x, l1 - remain)\\n                else:\\n                    pos1, max1 = l1, -1\\n                remain = max(0, (k - i) - (l1 - x) - 1)\\n                if l2 - y >= remain and l2 - y > 0:\\n                    if y + 1 == l2 - remain:\\n                        pos2, max2 = y, nums2[y]\\n                    else:\\n                        pos2, max2 = self.get_next(summary2, y, l2 - remain)\\n                else:\\n                    pos2, max2 = l2, -1\\n                round_max = max(max1, max2, round_max)\\n                if max1 == round_max:\\n                    updated_candidates[pos1 + 1] = (y, max1)\\n                if max2 == round_max:\\n                    updated_candidates[x] = (pos2 + 1, max2)\\n            max_val.append(round_max)\\n            candidates.clear()\\n            for l, v in updated_candidates.items():\\n                if v[1] == round_max:\\n                    candidates[l] = v[0]\\n        return max_val",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def pre_process(self, num):\\n        l = len(num)\\n        summary = [[] for _ in range(l)]\\n        last = [l] * 10\\n        for i in range(l - 1, -1, -1):\\n            last[num[i]] = i\\n            summary[i] = copy(last)\\n        return summary\\n\\n    def get_next(self, summary, start, end):\\n        for i in range(9, -1, -1):\\n            if summary[start][i] < end:\\n                return summary[start][i], i\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n        summary1 = self.pre_process(nums1)\\n        summary2 = self.pre_process(nums2)\\n        candidates = {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 2094585,
                "title": "c-bfs-pruning",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tint next1[500+1][10];\\n\\tint next2[500+1][10];\\n\\n\\tvoid fillNext(int next[][10], vector<int> &nums) {\\n\\t\\tmemset(next, 0, sizeof next1);\\n\\t\\tfor(int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\tmemcpy(next[i], next[i+1], sizeof next[i]);\\n\\t\\t\\tnext[i][nums[i]] = i+1;\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n#define N nums1.size()\\n#define M nums2.size()\\n\\t\\tvector<int> max;\\n\\t\\tunordered_map<int, int> states = { {0, 0} };\\n\\n\\t\\tfillNext(next1, nums1);\\n\\t\\tfillNext(next2, nums2);\\n\\t\\tmax.reserve(k);\\n\\t\\t\\n\\t\\twhile(max.size() < k) {\\n\\t\\t\\tunordered_map<int, int> newStates;\\n\\t\\t\\tint d;\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor(d = 9; d >= 0; d--) {\\n\\t\\t\\t\\tfor(const auto& [i, j] : states) {\\n\\t\\t\\t\\t\\tint nexti, nextj;\\n\\t\\t\\t\\t\\tif((nexti  = next1[i][d]) && N - nexti + M - j >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[nexti] = newStates[nexti] ? min(newStates[nexti], j) : j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif((nextj = next2[j][d]) && N - i + M - nextj >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[i] = newStates[i] ? min(newStates[i], nextj) : nextj;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(found) break;\\n\\t\\t\\t}\\n\\t\\t\\tstates = std::move(newStates);\\n\\t\\t\\tmax.push_back(d);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint next1[500+1][10];\\n\\tint next2[500+1][10];\\n\\n\\tvoid fillNext(int next[][10], vector<int> &nums) {\\n\\t\\tmemset(next, 0, sizeof next1);\\n\\t\\tfor(int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\tmemcpy(next[i], next[i+1], sizeof next[i]);\\n\\t\\t\\tnext[i][nums[i]] = i+1;\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n#define N nums1.size()\\n#define M nums2.size()\\n\\t\\tvector<int> max;\\n\\t\\tunordered_map<int, int> states = { {0, 0} };\\n\\n\\t\\tfillNext(next1, nums1);\\n\\t\\tfillNext(next2, nums2);\\n\\t\\tmax.reserve(k);\\n\\t\\t\\n\\t\\twhile(max.size() < k) {\\n\\t\\t\\tunordered_map<int, int> newStates;\\n\\t\\t\\tint d;\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor(d = 9; d >= 0; d--) {\\n\\t\\t\\t\\tfor(const auto& [i, j] : states) {\\n\\t\\t\\t\\t\\tint nexti, nextj;\\n\\t\\t\\t\\t\\tif((nexti  = next1[i][d]) && N - nexti + M - j >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[nexti] = newStates[nexti] ? min(newStates[nexti], j) : j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif((nextj = next2[j][d]) && N - i + M - nextj >= k - max.size() - 1) {\\n\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\tnewStates[i] = newStates[i] ? min(newStates[i], nextj) : nextj;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(found) break;\\n\\t\\t\\t}\\n\\t\\t\\tstates = std::move(newStates);\\n\\t\\t\\tmax.push_back(d);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030040,
                "title": "java-solution-with-comments",
                "content": "class Solution {\\n   public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        \\n\\n       \\n\\n       //LEFT boundary can start with max of 0 or k-num2.length\\n       //end or RIGHT boundary ends wid Min(k, num1.length)\\n        //If I take x from first array then remaining k-x from second array \\n        // boundary where we can traverse array element for subSeq is  \\n        //start with 0 or k-num2.len\\n        //e.g. num1=5 and num2=3 and k = 5\\n        // LEFT boundary 5-3 = 2  RIGHT = 5 \\n        int start = Math.max(0,k-nums2.length);  \\n        int end = Math.min(k, nums1.length);   \\n        int[] result =new int[k];\\n        int[] tmp=null;\\n    //try all combination in boundary which can result in max  \\n        for(int i=start;i<=end;i++){\\n\\t\\t\\t//find max subseqences\\n            int[] sub1 = getMaxSubsequence(nums1,i); \\n            int[] sub2 = getMaxSubsequence (nums2,k-i);\\n            //merge array\\n            tmp = merge(sub1,sub2);\\n\\t\\t\\t//store max in result\\n            if(isGreater(tmp,0,result,0)){\\n                result = tmp;\\n            }\\n\\n\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    int[] merge(int[] num1, int[] num2){\\n        int[] res = new int[num1.length+num2.length];\\n        int l1=0,l2=0,l3=0;\\n        while(l3<res.length){\\n            res[l3++] = isGreater(num1,l1,num2,l2)? num1[l1++]:num2[l2++];\\n        }\\n        return res;\\n    }\\n\\n    boolean isGreater(int[] num1, int l1, int[] num2, int l2){\\n        while(l1<num1.length && l2<num2.length){\\n            if(num1[l1]>num2[l2]){\\n                return true;\\n            }else if(num2[l2]>num1[l1]){\\n                return false;\\n            }\\n            l1++;\\n            l2++;\\n        }\\n\\n        return l1!=num1.length;\\n\\n    }\\n\\n    \\n   \\n    \\n    //decreasing Monostack here max odering we can do is numlen-i-1>=remain keeping rest untouched\\n    public int[] getMaxSubsequence(int[] num, int maxSubArrCnt){\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int remain =maxSubArrCnt;\\n        for(int i =0;i<num.length;i++){\\n            while(!stack.isEmpty() && stack.peek()<num[i] && num.length-1-i>=remain){\\n                stack.pop();\\n                remain++;\\n            }\\n            if(remain>0){\\n                stack.push(num[i]);\\n                remain--;\\n            }\\n\\n        }\\n\\n        int[] maxSubArr = new int[maxSubArrCnt];\\n        int len = maxSubArr.length-1;\\n        while(!stack.isEmpty()){\\n            maxSubArr[len--] = stack.pop();\\n        }\\n\\n        return maxSubArr;\\n\\n    }\\n    \\n    \\n    \\n    \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n   public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        \\n\\n       \\n\\n       //LEFT boundary can start with max of 0 or k-num2.length\\n       //end or RIGHT boundary ends wid Min(k, num1.length)\\n        //If I take x from first array then remaining k-x from second array \\n        // boundary where we can traverse array element for subSeq is  \\n        //start with 0 or k-num2.len\\n        //e.g. num1=5 and num2=3 and k = 5\\n        // LEFT boundary 5-3 = 2  RIGHT = 5 \\n        int start = Math.max(0,k-nums2.length);  \\n        int end = Math.min(k, nums1.length);   \\n        int[] result =new int[k];\\n        int[] tmp=null;\\n    //try all combination in boundary which can result in max  \\n        for(int i=start;i<=end;i++){\\n\\t\\t\\t//find max subseqences\\n            int[] sub1 = getMaxSubsequence(nums1,i); \\n            int[] sub2 = getMaxSubsequence (nums2,k-i);\\n            //merge array\\n            tmp = merge(sub1,sub2);\\n\\t\\t\\t//store max in result\\n            if(isGreater(tmp,0,result,0)){\\n                result = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981642,
                "title": "c-wow-greedy-my-solution-haha",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool compute(vector<int> &s, vector<int> &nums, int k){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(s.size() + (nums.size()-i) < k) break;\\n            while(s.size() && s.size() + (nums.size()-i) > k && s.back() < nums[i]) s.pop_back();\\n            if(s.size() < k) s.push_back(nums[i]);\\n        }\\n        \\n        return s.size() >= k;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<string, vector<string>, less<string>> q;\\n        string maxStr = \"\";\\n\\n        for(int i=0;i<=k;i++){\\n            vector<int> s1;\\n            vector<int> s2; \\n            \\n            int ptr1 = i;\\n            int ptr2 = k-i;\\n            \\n            bool ret1 = compute(s1, nums1, ptr1);\\n            bool ret2 = compute(s2, nums2, ptr2);\\n            \\n            string retStr = \"\";\\n            if(ret1 && ret2){\\n                int idx1 = 0;\\n                int idx2 = 0;\\n                while(idx1 < s1.size() && idx2 < s2.size()){               \\n                    if(s1 >= s2) retStr+=s1[idx1]+\\'0\\', s1.erase(s1.begin());\\n                    else retStr+=s2[idx2]+\\'0\\', s2.erase(s2.begin());\\n                }\\n                while(idx1 < s1.size()) retStr += s1[idx1++]+\\'0\\';\\n                while(idx2 < s2.size()) retStr += s2[idx2++]+\\'0\\';   \\n                \\n                if(maxStr < retStr) maxStr = retStr;\\n                // q.push(retStr);\\n            }\\n        }\\n        \\n        vector<int> vec;\\n        for(int i=0;i<maxStr.size();i++){\\n            vec.push_back(maxStr[i]-\\'0\\');\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool compute(vector<int> &s, vector<int> &nums, int k){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(s.size() + (nums.size()-i) < k) break;\\n            while(s.size() && s.size() + (nums.size()-i) > k && s.back() < nums[i]) s.pop_back();\\n            if(s.size() < k) s.push_back(nums[i]);\\n        }\\n        \\n        return s.size() >= k;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<string, vector<string>, less<string>> q;\\n        string maxStr = \"\";\\n\\n        for(int i=0;i<=k;i++){\\n            vector<int> s1;\\n            vector<int> s2; \\n            \\n            int ptr1 = i;\\n            int ptr2 = k-i;\\n            \\n            bool ret1 = compute(s1, nums1, ptr1);\\n            bool ret2 = compute(s2, nums2, ptr2);\\n            \\n            string retStr = \"\";\\n            if(ret1 && ret2){\\n                int idx1 = 0;\\n                int idx2 = 0;\\n                while(idx1 < s1.size() && idx2 < s2.size()){               \\n                    if(s1 >= s2) retStr+=s1[idx1]+\\'0\\', s1.erase(s1.begin());\\n                    else retStr+=s2[idx2]+\\'0\\', s2.erase(s2.begin());\\n                }\\n                while(idx1 < s1.size()) retStr += s1[idx1++]+\\'0\\';\\n                while(idx2 < s2.size()) retStr += s2[idx2++]+\\'0\\';   \\n                \\n                if(maxStr < retStr) maxStr = retStr;\\n                // q.push(retStr);\\n            }\\n        }\\n        \\n        vector<int> vec;\\n        for(int i=0;i<maxStr.size();i++){\\n            vec.push_back(maxStr[i]-\\'0\\');\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950401,
                "title": "recurrsion-approach-92-test-passed",
                "content": "\\'\\'\\'\\n#include<bits/stdc++.h>\\nusing namespace std;\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    vector<int> ans ;\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) \\n    {\\n        if(k == 0)\\n        {\\n            return ans ;\\n        }\\n        else\\n        {\\n            if(v1.size() < v2.size())\\n            {\\n                swap(v1 ,v2) ;\\n            }\\n            if(v2.size() == 0)\\n            {\\n                \\n                \\n                    int max = v1[0] ;\\n                    int indx = 0 ;\\n                    for (int i = 0; i < v1.size(); i++)\\n                    {\\n                        if(v1.size() - i >= k)\\n                        {\\n                            if(v1[i] > max)\\n                            {\\n                                max = v1[i] ;\\n                                indx = i ;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            break ;\\n                        }\\n                    }\\n                    ans.push_back(max) ;\\n                    v1.erase(v1.begin() , v1.begin() + indx + 1) ;\\n                    k-- ;\\n                    return  maxNumber( v1, v2,  k) ;\\n                    \\n                \\n            }\\n\\n\\n            if(v1.size() == v2.size())\\n            {\\n                for (int i = 0; i < v1.size(); i++)\\n                {\\n                    if(v1[i] > v2[i])\\n                    {\\n                        break ;\\n                    }\\n                    else if(v1[i] == v2[i])\\n                    {\\n                        continue ;\\n                    }\\n                    else\\n                    {\\n                        swap(v1,v2) ;\\n                        break ;\\n                    }\\n                }\\n                \\n            }\\n            int m = v1.size() , n = v2.size() ; \\n            pair<int,int> max ;\\n            if(k == v1.size() + v2.size())\\n            {\\n                for (int i = 0; i < min(v1.size() , v2.size()); i++)\\n                {\\n                    if(v1[i] > v2[i])\\n                    {\\n                        break ;\\n                    }\\n                    if(v2[i] > v1[i])\\n                    {\\n                        swap(v1,v2) ;\\n                        break ;\\n                    }\\n                }\\n\\n                ans.push_back(v1[0]) ;\\n                v1.erase(v1.begin()) ;\\n                k-- ;\\n                return maxNumber( v1,  v2,  k) ;\\n                \\n            }\\n            if(v2.size() != 0)\\n            {\\n                max.first = v2[0] ;\\n                max.second = 2 ;\\n            }\\n            else\\n            {\\n                max.first = v1[0] ;\\n                max.second = 1 ;\\n            }\\n\\n\\n            int i = 0 , j = 0 ;\\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if(m - i + n - j >= k)\\n                    {\\n                        if(v1[i] > max.first)\\n                        {\\n                            max.first = v1[i] ;\\n                            max.second = 1 ;\\n                        }\\n                        if(v2[j] > max.first)\\n                        {\\n                            max.first = v2[j] ;\\n                            max.second = 2 ;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break ;\\n                    }\\n                }\\n                \\n            }\\n\\n            ans.push_back(max.first) ;\\n\\n            if(max.second == 1)\\n            {\\n                int indx = 0 ;\\n                for (int i = 0; i < v1.size(); i++)\\n                {\\n                    if(v1[i] == max.first)\\n                    {\\n                        indx = i ;\\n                        break ;\\n                    }\\n                }\\n                v1.erase(v1.begin() , v1.begin() + indx + 1 ) ;\\n                k-- ;\\n                return maxNumber(v1, v2, k) ;\\n                \\n            }\\n            else\\n            {\\n                int indx = 0 ;\\n                for (int i = 0; i < v2.size(); i++)\\n                {\\n                    if(v2[i] == max.first)\\n                    {\\n                        indx = i ;\\n                        break ;\\n                    }\\n                }\\n                v2.erase(v2.begin() , v2.begin() + indx + 1 ) ;\\n                k-- ;\\n                return maxNumber(v1, v2, k) ;\\n            }\\n            \\n        \\n        }\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> ans ;\\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) \\n    {\\n        if(k == 0)\\n        {\\n            return ans ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1812492,
                "title": "c-merge-sln-o-max-n-m-3",
                "content": "```\\nvector<int> findMaxSubsequnce(const vector<int>& v, int k) {\\n        vector<int> ans;\\n        for (int i = 0, n = size(v); i < n; ++i) {\\n            const int left = n - i;\\n            while (!empty(ans) && size(ans) + left > k && v[i] > ans.back()) {\\n                ans.pop_back();\\n            }\\n            if (size(ans) < k) {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> merge(const vector<int>& v1, const vector<int>& v2) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        int i = 0;\\n        int j = 0;\\n        vector<int> ans;\\n        while (i < n && j < m) {\\n            if (v1[i] > v2[j]) {\\n                ans.push_back(v1[i++]);\\n            }\\n            else if (v1[i] < v2[j]) {\\n                ans.push_back(v2[j++]);\\n            }\\n            else {\\n                if (!lexicographical_compare(cbegin(v1) + i, cend(v1), cbegin(v2) + j, cend(v2))) {\\n                    ans.push_back(v1[i++]);\\n                }\\n                else {\\n                    ans.push_back(v2[j++]);\\n                }\\n            }\\n        }\\n        while (i < n) {\\n            ans.push_back(v1[i++]);\\n        }\\n        while (j < m) {\\n            ans.push_back(v2[j++]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        vector<int> ans;\\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= n && k - i <= m) {\\n                ans = max(ans, merge(findMaxSubsequnce(v1, i), findMaxSubsequnce(v2, k - i)));\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> findMaxSubsequnce(const vector<int>& v, int k) {\\n        vector<int> ans;\\n        for (int i = 0, n = size(v); i < n; ++i) {\\n            const int left = n - i;\\n            while (!empty(ans) && size(ans) + left > k && v[i] > ans.back()) {\\n                ans.pop_back();\\n            }\\n            if (size(ans) < k) {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> merge(const vector<int>& v1, const vector<int>& v2) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        int i = 0;\\n        int j = 0;\\n        vector<int> ans;\\n        while (i < n && j < m) {\\n            if (v1[i] > v2[j]) {\\n                ans.push_back(v1[i++]);\\n            }\\n            else if (v1[i] < v2[j]) {\\n                ans.push_back(v2[j++]);\\n            }\\n            else {\\n                if (!lexicographical_compare(cbegin(v1) + i, cend(v1), cbegin(v2) + j, cend(v2))) {\\n                    ans.push_back(v1[i++]);\\n                }\\n                else {\\n                    ans.push_back(v2[j++]);\\n                }\\n            }\\n        }\\n        while (i < n) {\\n            ans.push_back(v1[i++]);\\n        }\\n        while (j < m) {\\n            ans.push_back(v2[j++]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& v1, vector<int>& v2, int k) {\\n        const int n = size(v1);\\n        const int m = size(v2);\\n        vector<int> ans;\\n        for (int i = 0; i <= k; ++i) {\\n            if (i <= n && k - i <= m) {\\n                ans = max(ans, merge(findMaxSubsequnce(v1, i), findMaxSubsequnce(v2, k - i)));\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1742638,
                "title": "clear-and-concise-prerequisite-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void extract(vector<int>& nums, int m, vector<int>& t){\\n        int n = nums.size();\\n        int canBeRemoved = n-m;\\n        t.clear();\\n        for(int i:nums){\\n            while(canBeRemoved && !t.empty() && t.back() < i)\\n                t.pop_back(), canBeRemoved--;\\n            t.push_back(i);\\n        }\\n        while(canBeRemoved)\\n            t.pop_back(), canBeRemoved--;\\n    }\\n    \\n    int comparator(vector<int>& t1, vector<int>& t2, int m1, int m2){\\n        int n1 = t1.size();\\n        int n2 = t2.size();\\n        while(m1 < n1 && m2 < n2){\\n            if(t1[m1] > t2[m2])\\n                return 0;\\n            else if(t1[m1] < t2[m2])\\n                return 1;\\n            else\\n                m1++, m2++;\\n        }\\n        if(m1 == n1 && m2 == n2)\\n            return -1;\\n        if(m1 < n1)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    void merge(vector<int>& t1, vector<int>& t2, vector<int>& maxi){\\n        vector<int> t;\\n        int i = 0, j = 0, n1 = t1.size(), n2 = t2.size(), idx1,idx2;\\n        while(i < n1 && j < n2){\\n            if(t1[i] > t2[j])\\n                t.push_back(t1[i++]);\\n            else if(t1[i] < t2[j])\\n                t.push_back(t2[j++]);\\n            else{\\n                if(comparator(t1,t2,i,j) == 0){\\n                    t.push_back(t1[i++]);\\n                } else\\n                    t.push_back(t2[j++]);\\n            }\\n        }\\n        while(i < n1)\\n            t.push_back(t1[i++]);\\n        while(j < n2)\\n            t.push_back(t2[j++]);\\n        \\n        if(t > maxi)\\n            for(int i = 0; i < t.size(); i++)\\n                maxi[i] = t[i];\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int rem = k;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int m1,m2;\\n        vector<int> t1, t2, ans(k,-1);\\n            for(int i = 0; i <= k; i++){\\n                m1 = i, m2 = k-i;\\n                if(m1 > n1 || m2 > n2)\\n                    continue;\\n                extract(nums1,m1,t1);\\n                extract(nums2,m2,t2);\\n                merge(t1,t2,ans);\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nI suggest you to please solve this problem: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/)\\n\\nHere You will choose k elements from single array, you will come to know that my goal is\\n1. to maintain the sequence as increasing as possible, till you have option to ignore numbers\\n2. When k becomes zero, you will append all the elements at the end\\n\\nSame applies over here.\\nSince you will be given k <= m+n. It is impossible to find the sequence having any k elements from two arrays resulting into max number.\\n\\nchoices: \\n1. Array1: 0 element, Array2: k element\\n2. Array2: 1 element, Array2: k-1 element\\n3. ...\\n4. Array1: k. element, Array2: 0 element.\\n\\nFor each of the choice you apply the algorithm of Competitve sequence, after getting i, k-i element, merge them. Since now only motto is the rearrange the all k elements in the final vector, using merging of two sorted array time algorithm will suffice.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void extract(vector<int>& nums, int m, vector<int>& t){\\n        int n = nums.size();\\n        int canBeRemoved = n-m;\\n        t.clear();\\n        for(int i:nums){\\n            while(canBeRemoved && !t.empty() && t.back() < i)\\n                t.pop_back(), canBeRemoved--;\\n            t.push_back(i);\\n        }\\n        while(canBeRemoved)\\n            t.pop_back(), canBeRemoved--;\\n    }\\n    \\n    int comparator(vector<int>& t1, vector<int>& t2, int m1, int m2){\\n        int n1 = t1.size();\\n        int n2 = t2.size();\\n        while(m1 < n1 && m2 < n2){\\n            if(t1[m1] > t2[m2])\\n                return 0;\\n            else if(t1[m1] < t2[m2])\\n                return 1;\\n            else\\n                m1++, m2++;\\n        }\\n        if(m1 == n1 && m2 == n2)\\n            return -1;\\n        if(m1 < n1)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    void merge(vector<int>& t1, vector<int>& t2, vector<int>& maxi){\\n        vector<int> t;\\n        int i = 0, j = 0, n1 = t1.size(), n2 = t2.size(), idx1,idx2;\\n        while(i < n1 && j < n2){\\n            if(t1[i] > t2[j])\\n                t.push_back(t1[i++]);\\n            else if(t1[i] < t2[j])\\n                t.push_back(t2[j++]);\\n            else{\\n                if(comparator(t1,t2,i,j) == 0){\\n                    t.push_back(t1[i++]);\\n                } else\\n                    t.push_back(t2[j++]);\\n            }\\n        }\\n        while(i < n1)\\n            t.push_back(t1[i++]);\\n        while(j < n2)\\n            t.push_back(t2[j++]);\\n        \\n        if(t > maxi)\\n            for(int i = 0; i < t.size(); i++)\\n                maxi[i] = t[i];\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int rem = k;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int m1,m2;\\n        vector<int> t1, t2, ans(k,-1);\\n            for(int i = 0; i <= k; i++){\\n                m1 = i, m2 = k-i;\\n                if(m1 > n1 || m2 > n2)\\n                    continue;\\n                extract(nums1,m1,t1);\\n                extract(nums2,m2,t2);\\n                merge(t1,t2,ans);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629689,
                "title": "java-intuitive",
                "content": "Here in this solution 2 Utility functions are cretaed\\n1. **getMaxNumber(int[] arr, i9nt countOfRemove) :** This function takes the array and creates a maximum number by removing **countOfRemove** elements from the array.\\n2. **mergetwoArrays(String arr1, String arr2) :** This function takes two array in form of string and merges them. The concept is same as wer merge two arrays in merge sort, the difference is when we encounter equal element in both the array, in that case we simply  compare  the substring from that particular index and whichever is greater we take that value.\\n```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tString str = \"0\";\\n\\t\\tfor(int i=0;i<=k;i++){\\n\\t\\t\\tString temp1 = getMaxNumber(nums1,nums1.length - i);\\n\\t\\t\\tString temp2 = getMaxNumber(nums2,nums2.length - k+i);\\n\\t\\t\\tString finalAns = mergeTwoArray(temp1, temp2);\\n\\t\\t\\tif(str.length() <= finalAns.length()){\\n\\t\\t\\t\\tif(str.length() < finalAns.length())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}else if(str.compareTo(finalAns) < 0){\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr = new int[str.length()];\\n\\t\\tint m = 0;\\n\\t\\tfor(char ch: str.toCharArray()){\\n\\t\\t\\tarr[m++] = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n\\n\\tprivate String getMaxNumber(int[] arr, int countOfRemove){\\n\\t\\tif(countOfRemove > arr.length) return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining());\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint i = 0;\\n\\t\\twhile(i< arr.length && countOfRemove > 0){\\n\\t\\t\\tif(stack.isEmpty() || stack.peek() >= arr[i]){\\n\\t\\t\\t\\tstack.push(arr[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tcountOfRemove--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(i<arr.length){\\n\\t\\t\\tstack.push(arr[i++]);\\n\\t\\t}\\n\\t\\twhile(countOfRemove > 0){\\n\\t\\t\\tstack.pop();\\n\\t\\t\\tcountOfRemove--;\\n\\t\\t}\\n\\t\\treturn stack.stream().map(String::valueOf).collect(Collectors.joining());\\n\\t}\\n\\tprivate String mergeTwoArray(String str1, String str2){\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile(left < str1.length() && right < str2.length()){\\n\\t\\t\\tif(str1.charAt(left) < str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}else if(str1.charAt(left) > str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(str1.substring(left).compareTo(str2.substring(right)) > 0){\\n\\t\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(left < str1.length()){\\n\\t\\t\\tsb.append(str1.charAt(left++));\\n\\t\\t}\\n\\t\\twhile(right < str2.length()){\\n\\t\\t\\tsb.append(str2.charAt(right++));\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\n\\t}\\n}\\n```\\n**Let me kow if video is required for explanation, happy to help !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\t\\tString str = \"0\";\\n\\t\\tfor(int i=0;i<=k;i++){\\n\\t\\t\\tString temp1 = getMaxNumber(nums1,nums1.length - i);\\n\\t\\t\\tString temp2 = getMaxNumber(nums2,nums2.length - k+i);\\n\\t\\t\\tString finalAns = mergeTwoArray(temp1, temp2);\\n\\t\\t\\tif(str.length() <= finalAns.length()){\\n\\t\\t\\t\\tif(str.length() < finalAns.length())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}else if(str.compareTo(finalAns) < 0){\\n\\t\\t\\t\\t\\tstr = finalAns;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr = new int[str.length()];\\n\\t\\tint m = 0;\\n\\t\\tfor(char ch: str.toCharArray()){\\n\\t\\t\\tarr[m++] = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n\\n\\tprivate String getMaxNumber(int[] arr, int countOfRemove){\\n\\t\\tif(countOfRemove > arr.length) return Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining());\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint i = 0;\\n\\t\\twhile(i< arr.length && countOfRemove > 0){\\n\\t\\t\\tif(stack.isEmpty() || stack.peek() >= arr[i]){\\n\\t\\t\\t\\tstack.push(arr[i]);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tcountOfRemove--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(i<arr.length){\\n\\t\\t\\tstack.push(arr[i++]);\\n\\t\\t}\\n\\t\\twhile(countOfRemove > 0){\\n\\t\\t\\tstack.pop();\\n\\t\\t\\tcountOfRemove--;\\n\\t\\t}\\n\\t\\treturn stack.stream().map(String::valueOf).collect(Collectors.joining());\\n\\t}\\n\\tprivate String mergeTwoArray(String str1, String str2){\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile(left < str1.length() && right < str2.length()){\\n\\t\\t\\tif(str1.charAt(left) < str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}else if(str1.charAt(left) > str2.charAt(right)){\\n\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(str1.substring(left).compareTo(str2.substring(right)) > 0){\\n\\t\\t\\t\\t\\tsb.append(str1.charAt(left));\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.append(str2.charAt(right));\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(left < str1.length()){\\n\\t\\t\\tsb.append(str1.charAt(left++));\\n\\t\\t}\\n\\t\\twhile(right < str2.length()){\\n\\t\\t\\tsb.append(str2.charAt(right++));\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593682,
                "title": "java-merging-solution",
                "content": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Leetcode {\\n    static boolean gt(ArrayList<Integer> a1, ArrayList<Integer> a2, int a1i, int a2i) {\\n        while (a1i < a1.size() && a2i < a2.size()) {\\n            if (a1.get(a1i) > a2.get(a2i))\\n                return true;\\n            if (a2.get(a2i) > a1.get(a1i))\\n                return false;\\n            a1i++;\\n            a2i++;\\n        }\\n        if (a1i >= a1.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n\\n    static BigInteger merge(ArrayList<Integer> a1, ArrayList<Integer> a2) {\\n        StringBuilder num = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < a1.size() || j < a2.size()) {\\n            if (gt(a1, a2, i, j)) {\\n                num.append(a1.get(i++));\\n            } else {\\n                num.append(a2.get(j++));\\n            }\\n        }\\n        return new BigInteger(num.toString());\\n    }\\n\\n\\n    static ArrayList<Integer> buildMaxSegmentUtil(int[] a, int sz) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int taken = 0;\\n        int i = 0;\\n        while (taken < sz) {\\n            int remain = sz - taken;\\n            int j = a.length - remain;\\n            int maxi = i;\\n            int max = -1;\\n            for (int k = i; k <= j; k++)\\n                if (a[k] > max) {\\n                    max = a[k];\\n                    maxi = k;\\n                }\\n            res.add(a[maxi]);\\n            i = maxi + 1;\\n            taken++;\\n        }\\n        return res;\\n    }\\n\\n    static ArrayList<Integer>[] buildMaxSegment(int[] a, int k) {\\n        ArrayList<Integer>[] res = new ArrayList[k + 1];\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= a.length)\\n                res[i] = buildMaxSegmentUtil(a, i);\\n        }\\n        return res;\\n    }\\n\\n\\n    public static int[] maxNumber(int[] x, int[] y, int k) {\\n        ArrayList<Integer>[] maxSegmentX = buildMaxSegment(x, k);\\n        ArrayList<Integer>[] maxSegmentY = buildMaxSegment(y, k);\\n        BigInteger mx = new BigInteger(\"-1\");\\n        for (int xCnt = 0; xCnt <= k; xCnt++) {\\n            int yCnt = k - xCnt;\\n            if (xCnt <= x.length && yCnt <= y.length) {\\n                BigInteger tmp = merge(maxSegmentX[xCnt], maxSegmentY[yCnt]);\\n                if (tmp.compareTo(mx) > 0)\\n                    mx = tmp;\\n            }\\n        }\\n        String mxSt = mx.toString();\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++)\\n            res[i] = mxSt.charAt(i) - \\'0\\';\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Leetcode {\\n    static boolean gt(ArrayList<Integer> a1, ArrayList<Integer> a2, int a1i, int a2i) {\\n        while (a1i < a1.size() && a2i < a2.size()) {\\n            if (a1.get(a1i) > a2.get(a2i))\\n                return true;\\n            if (a2.get(a2i) > a1.get(a1i))\\n                return false;\\n            a1i++;\\n            a2i++;\\n        }\\n        if (a1i >= a1.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n\\n    static BigInteger merge(ArrayList<Integer> a1, ArrayList<Integer> a2) {\\n        StringBuilder num = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < a1.size() || j < a2.size()) {\\n            if (gt(a1, a2, i, j)) {\\n                num.append(a1.get(i++));\\n            } else {\\n                num.append(a2.get(j++));\\n            }\\n        }\\n        return new BigInteger(num.toString());\\n    }\\n\\n\\n    static ArrayList<Integer> buildMaxSegmentUtil(int[] a, int sz) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int taken = 0;\\n        int i = 0;\\n        while (taken < sz) {\\n            int remain = sz - taken;\\n            int j = a.length - remain;\\n            int maxi = i;\\n            int max = -1;\\n            for (int k = i; k <= j; k++)\\n                if (a[k] > max) {\\n                    max = a[k];\\n                    maxi = k;\\n                }\\n            res.add(a[maxi]);\\n            i = maxi + 1;\\n            taken++;\\n        }\\n        return res;\\n    }\\n\\n    static ArrayList<Integer>[] buildMaxSegment(int[] a, int k) {\\n        ArrayList<Integer>[] res = new ArrayList[k + 1];\\n        for (int i = 0; i <= k; i++) {\\n            if (i <= a.length)\\n                res[i] = buildMaxSegmentUtil(a, i);\\n        }\\n        return res;\\n    }\\n\\n\\n    public static int[] maxNumber(int[] x, int[] y, int k) {\\n        ArrayList<Integer>[] maxSegmentX = buildMaxSegment(x, k);\\n        ArrayList<Integer>[] maxSegmentY = buildMaxSegment(y, k);\\n        BigInteger mx = new BigInteger(\"-1\");\\n        for (int xCnt = 0; xCnt <= k; xCnt++) {\\n            int yCnt = k - xCnt;\\n            if (xCnt <= x.length && yCnt <= y.length) {\\n                BigInteger tmp = merge(maxSegmentX[xCnt], maxSegmentY[yCnt]);\\n                if (tmp.compareTo(mx) > 0)\\n                    mx = tmp;\\n            }\\n        }\\n        String mxSt = mx.toString();\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++)\\n            res[i] = mxSt.charAt(i) - \\'0\\';\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453068,
                "title": "rust-translation-from-c",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let n1 = nums1.len();\\n        let n2 = nums2.len();\\n        let k = k as usize;\\n        let mut max_merged = None;\\n        for size1 in 0..=k.min(n1) {\\n            let size2 = k - size1;\\n            if size2 > n2 {\\n                continue;\\n            }\\n            let max1 = Self::max_one(&nums1, size1);\\n            let max2 = Self::max_one(&nums2, size2);\\n            let max3 = Self::max_merge(max1, max2);\\n            if let Some(max) = max_merged {\\n                if max < max3 {\\n                    max_merged = Some(max3);\\n                } else {\\n                    max_merged = Some(max);\\n                }\\n            } else {\\n                max_merged = Some(max3);\\n            }\\n        }\\n        max_merged.unwrap()\\n    }\\n\\n    fn max_one(nums: &[i32], k: usize) -> Vec<i32> {\\n        let mut stack = Vec::new();\\n        let n = nums.len();\\n        for (i, &num) in nums.iter().enumerate().take(n) {\\n            let right = n - i;\\n            while let Some(&top) = stack.last() {\\n                if top < num && stack.len() + right > k {\\n                    stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            stack.push(num);\\n        }\\n        while stack.len() > k {\\n            stack.pop();\\n        }\\n        stack\\n    }\\n\\n    fn max_merge(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        let mut j = 0;\\n        loop {\\n            if i < nums1.len() && j < nums2.len() {\\n                if Self::greater(&nums1, &nums2, i, j) {\\n                    res.push(nums1[i]);\\n                    i += 1;\\n                } else {\\n                    res.push(nums2[j]);\\n                    j += 1;\\n                }\\n                continue;\\n            }\\n            if i < nums1.len() {\\n                res.push(nums1[i]);\\n                i += 1;\\n                continue;\\n            }\\n            if j < nums2.len() {\\n                res.push(nums2[j]);\\n                j += 1;\\n                continue;\\n            }\\n            break;\\n        }\\n        res\\n    }\\n\\n    fn greater(nums1: &[i32], nums2: &[i32], mut i: usize, mut j: usize) -> bool {\\n        while i < nums1.len() && j < nums2.len() && nums1[i] == nums2[j] {\\n            i += 1;\\n            j += 1;\\n        }\\n        j == nums2.len() || (i < nums1.len() && nums1[i] > nums2[j])\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\\n        let n1 = nums1.len();\\n        let n2 = nums2.len();\\n        let k = k as usize;\\n        let mut max_merged = None;\\n        for size1 in 0..=k.min(n1) {\\n            let size2 = k - size1;\\n            if size2 > n2 {\\n                continue;\\n            }\\n            let max1 = Self::max_one(&nums1, size1);\\n            let max2 = Self::max_one(&nums2, size2);\\n            let max3 = Self::max_merge(max1, max2);\\n            if let Some(max) = max_merged {\\n                if max < max3 {\\n                    max_merged = Some(max3);\\n                } else {\\n                    max_merged = Some(max);\\n                }\\n            } else {\\n                max_merged = Some(max3);\\n            }\\n        }\\n        max_merged.unwrap()\\n    }\\n\\n    fn max_one(nums: &[i32], k: usize) -> Vec<i32> {\\n        let mut stack = Vec::new();\\n        let n = nums.len();\\n        for (i, &num) in nums.iter().enumerate().take(n) {\\n            let right = n - i;\\n            while let Some(&top) = stack.last() {\\n                if top < num && stack.len() + right > k {\\n                    stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            stack.push(num);\\n        }\\n        while stack.len() > k {\\n            stack.pop();\\n        }\\n        stack\\n    }\\n\\n    fn max_merge(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        let mut j = 0;\\n        loop {\\n            if i < nums1.len() && j < nums2.len() {\\n                if Self::greater(&nums1, &nums2, i, j) {\\n                    res.push(nums1[i]);\\n                    i += 1;\\n                } else {\\n                    res.push(nums2[j]);\\n                    j += 1;\\n                }\\n                continue;\\n            }\\n            if i < nums1.len() {\\n                res.push(nums1[i]);\\n                i += 1;\\n                continue;\\n            }\\n            if j < nums2.len() {\\n                res.push(nums2[j]);\\n                j += 1;\\n                continue;\\n            }\\n            break;\\n        }\\n        res\\n    }\\n\\n    fn greater(nums1: &[i32], nums2: &[i32], mut i: usize, mut j: usize) -> bool {\\n        while i < nums1.len() && j < nums2.len() && nums1[i] == nums2[j] {\\n            i += 1;\\n            j += 1;\\n        }\\n        j == nums2.len() || (i < nums1.len() && nums1[i] > nums2[j])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427203,
                "title": "c-dp-and-merge-solution",
                "content": "we first find out all of possible length combination of nums1 and nums2, and try all of them.\\nwe build a dp array to construct largest lexicographical subseqence of specific length, and merge two subseqence into required answer.\\nmy code:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> d1,d2;\\n    vector<int> a,b;\\n    void merge(vector<int> &ans,vector<int> &num1,vector<int> &num2,int len1,int len2) {\\n        a.resize(len1+1,0),b.resize(len2+1,0);\\n        a[len1]=INT_MIN,b[len2]=INT_MIN;\\n        int len=0,pos=0;\\n        while(len!=len1){\\n            pos=d1[pos][num1.size()-1-len1+len],a[len]=num1[pos],len++,pos++;\\n        }\\n        len=0,pos=0;\\n        while(len!=len2){\\n            pos=d2[pos][num2.size()-1-len2+len],b[len]=num2[pos],len++,pos++;\\n        }\\n        bool equal=true;\\n        for(int i=0,j=0,k=0;i<len1+len2;i++){\\n            if(a[j]>b[k]){\\n                if(ans[i]>a[j]&&equal) return;\\n                if(ans[i]!=a[j]) equal=false;\\n                ans[i]=a[j],j++;\\n            }\\n            else if(b[k]>a[j]){\\n                if(ans[i]>b[k]&&equal) return;\\n                if(ans[i]!=b[k]) equal=false;\\n                ans[i]=b[k],k++;\\n            }\\n            else{\\n                bool ct=true;\\n                if(ans[i]>a[j]&&equal) return;\\n                int x=j,y=k;\\n                while(1){\\n                    if(a[x]>b[y]){\\n                        ct=true;\\n                        break;\\n                    } \\n                    if(b[y]>a[x]){\\n                        ct=false;\\n                        break;\\n                    }\\n                    if(x==len1&&y==len2){\\n                        ct=true;\\n                        break;\\n                    }\\n                    x++,y++;\\n                }\\n                if(ct){\\n                    if(ans[i]!=a[j]) equal=false;\\n                    ans[i]=a[j],j++;\\n                }\\n                else{\\n                    if(ans[i]!=b[k]) equal=false;\\n                    ans[i]=b[k],k++;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        vector<int> ans(k,0);\\n        nums1.push_back(-1),nums2.push_back(-1);\\n        d1.resize(n,vector<int>(n,n));\\n        d2.resize(m,vector<int>(m,m));\\n        d1[0][0]=0;\\n        for(int i=1;i<n;i++){\\n            d1[0][i]=d1[0][i-1];\\n            if(nums1[i]>nums1[d1[0][i-1]]) d1[0][i]=i;\\n        }\\n        for(int i=1;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                d1[i][j]=d1[i][j-1];\\n                if(nums1[j]>nums1[d1[i][j-1]]) d1[i][j]=j;\\n            }\\n        d2[0][0]=0;\\n        for(int i=1;i<m;i++){\\n            d2[0][i]=d2[0][i-1];\\n            if(nums2[i]>nums2[d2[0][i-1]]) d2[0][i]=i;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=i;j<m;j++){\\n                d2[i][j]=d2[i][j-1];\\n                if(nums2[j]>nums2[d2[i][j-1]]) d2[i][j]=j;\\n            }\\n        for(int j=m,i=k-m;i<=n;i++,j--){\\n            if(i>=0&&j>=0) merge(ans,nums1,nums2,i,j);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> d1,d2;\\n    vector<int> a,b;\\n    void merge(vector<int> &ans,vector<int> &num1,vector<int> &num2,int len1,int len2) {\\n        a.resize(len1+1,0),b.resize(len2+1,0);\\n        a[len1]=INT_MIN,b[len2]=INT_MIN;\\n        int len=0,pos=0;\\n        while(len!=len1){\\n            pos=d1[pos][num1.size()-1-len1+len],a[len]=num1[pos],len++,pos++;\\n        }\\n        len=0,pos=0;\\n        while(len!=len2){\\n            pos=d2[pos][num2.size()-1-len2+len],b[len]=num2[pos],len++,pos++;\\n        }\\n        bool equal=true;\\n        for(int i=0,j=0,k=0;i<len1+len2;i++){\\n            if(a[j]>b[k]){\\n                if(ans[i]>a[j]&&equal) return;\\n                if(ans[i]!=a[j]) equal=false;\\n                ans[i]=a[j],j++;\\n            }\\n            else if(b[k]>a[j]){\\n                if(ans[i]>b[k]&&equal) return;\\n                if(ans[i]!=b[k]) equal=false;\\n                ans[i]=b[k],k++;\\n            }\\n            else{\\n                bool ct=true;\\n                if(ans[i]>a[j]&&equal) return;\\n                int x=j,y=k;\\n                while(1){\\n                    if(a[x]>b[y]){\\n                        ct=true;\\n                        break;\\n                    } \\n                    if(b[y]>a[x]){\\n                        ct=false;\\n                        break;\\n                    }\\n                    if(x==len1&&y==len2){\\n                        ct=true;\\n                        break;\\n                    }\\n                    x++,y++;\\n                }\\n                if(ct){\\n                    if(ans[i]!=a[j]) equal=false;\\n                    ans[i]=a[j],j++;\\n                }\\n                else{\\n                    if(ans[i]!=b[k]) equal=false;\\n                    ans[i]=b[k],k++;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        vector<int> ans(k,0);\\n        nums1.push_back(-1),nums2.push_back(-1);\\n        d1.resize(n,vector<int>(n,n));\\n        d2.resize(m,vector<int>(m,m));\\n        d1[0][0]=0;\\n        for(int i=1;i<n;i++){\\n            d1[0][i]=d1[0][i-1];\\n            if(nums1[i]>nums1[d1[0][i-1]]) d1[0][i]=i;\\n        }\\n        for(int i=1;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                d1[i][j]=d1[i][j-1];\\n                if(nums1[j]>nums1[d1[i][j-1]]) d1[i][j]=j;\\n            }\\n        d2[0][0]=0;\\n        for(int i=1;i<m;i++){\\n            d2[0][i]=d2[0][i-1];\\n            if(nums2[i]>nums2[d2[0][i-1]]) d2[0][i]=i;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=i;j<m;j++){\\n                d2[i][j]=d2[i][j-1];\\n                if(nums2[j]>nums2[d2[i][j-1]]) d2[i][j]=j;\\n            }\\n        for(int j=m,i=k-m;i<=n;i++,j--){\\n            if(i>=0&&j>=0) merge(ans,nums1,nums2,i,j);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402477,
                "title": "greedy-javascript-solution",
                "content": "```\\nvar maxNumber = function (nums1, nums2, k) {\\n    let max = Array(k).fill(0);\\n\\n    const findMaxArray = (num, len) => {\\n        let pop = num.length - len,\\n            stack = [],\\n            i = 0;\\n        while (i < num.length) {\\n            while (pop && stack.length && stack[stack.length - 1] < num[i]) {\\n                stack.pop();\\n                pop--;\\n            }\\n            stack.push(num[i++]);\\n        }\\n        return stack.slice(0, len);\\n    };\\n    \\n    const greater = (num1, i, num2, j) => {\\n        while (i < num1.length && j < num2.length && num1[i] == num2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2.length || num1[i] > num2[j];\\n    };\\n\\n    const merge = (num1, num2) => {\\n        let i = 0,\\n            j = 0,\\n            combinedArr = [];\\n        while (i < num1.length || j < num2.length)\\n            combinedArr.push(greater(num1, i, num2, j) ? num1[i++] : num2[j++]);\\n        return combinedArr;\\n    };\\n\\n    for (let i = Math.min(k, nums1.length); i >= 0 && k - i <= nums2.length; i--) {\\n        let combinedArray = merge(findMaxArray(nums1, i), findMaxArray(nums2, k - i));\\n        if (greater(combinedArray, 0, max, 0))\\n            max = combinedArray;\\n    }\\n    return max;\\n};\\n",
                "solutionTags": [],
                "code": "```\\nvar maxNumber = function (nums1, nums2, k) {\\n    let max = Array(k).fill(0);\\n\\n    const findMaxArray = (num, len) => {\\n        let pop = num.length - len,\\n            stack = [],\\n            i = 0;\\n        while (i < num.length) {\\n            while (pop && stack.length && stack[stack.length - 1] < num[i]) {\\n                stack.pop();\\n                pop--;\\n            }\\n            stack.push(num[i++]);\\n        }\\n        return stack.slice(0, len);\\n    };\\n    \\n    const greater = (num1, i, num2, j) => {\\n        while (i < num1.length && j < num2.length && num1[i] == num2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == num2.length || num1[i] > num2[j];\\n    };\\n\\n    const merge = (num1, num2) => {\\n        let i = 0,\\n            j = 0,\\n            combinedArr = [];\\n        while (i < num1.length || j < num2.length)\\n            combinedArr.push(greater(num1, i, num2, j) ? num1[i++] : num2[j++]);\\n        return combinedArr;\\n    };\\n\\n    for (let i = Math.min(k, nums1.length); i >= 0 && k - i <= nums2.length; i--) {\\n        let combinedArray = merge(findMaxArray(nums1, i), findMaxArray(nums2, k - i));\\n        if (greater(combinedArray, 0, max, 0))\\n            max = combinedArray;\\n    }\\n    return max;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1380730,
                "title": "java-drop-and-merge-for-differet-intervals",
                "content": "**Explanation:**\\n1. Code may seem to be un readable.\\n2. Logic is simple.\\n3. add() -\\n\\t1.  finds max number for one array at a time for different size (0<=size<=k)\\n\\t2.  logic - by dropping the lower number (a[i]<a[i+1]) from the given array.\\n4. updateResult() -\\n\\t1. merges the two lists representing maximum number of the 2 given arrays for different sizes.\\n\\t2. while merging itself it compare with previous result and breaks if current number seems to be lower else continues.\\n\\t2. consider k=5, one possible merge will be - maximum number of size 2 from 1st array + maximum number of size 3 from 2nd array. After merge, 2+3=5 will give the answer.\\n\\t3. logic - like merging used in merge sort. But there is a problem, the 2 maximum number lists are not guranteed to be in sorted way.\\n\\t4. list1 - represents maximum number from nums1,\\n\\t5. list2 - represents maximum number from nums2,\\n\\t6. if list1[i]>list2[j], add list1[i] to the result and iterate i.\\n\\t7. if list1[i]<list2[j], add list2[j] to the result and iterate j.\\n\\t8. if they are equal, find in which list, greater number pops up earlier. if it happens in list1, add list1[i] to result and increment i else add list2[j] and increment j.\\n\\n```\\nclass Solution {\\n    public void add(ArrayList<Integer> list, int[] nums, int k)\\n    {\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            list.add(nums[i]);\\n        }\\n        int l=list.size();\\n        int i=0;\\n        while(l>k && i<l-1)\\n        {\\n            if(list.get(i)<list.get(i+1))\\n            {\\n                list.remove(i);\\n                i=0;\\n                l--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        while(l>k)\\n        {\\n            list.remove(l-1);\\n            l--;\\n        }\\n    }\\n    public void updateResult(int[] res, ArrayList<Integer> list1, ArrayList<Integer> list2, int k)\\n    {\\n        if(list1.size()+list2.size()<k)\\n        {\\n            return;\\n        }\\n        int i=0, j=0, t=0;\\n        int accepted=0;\\n        while(i<list1.size() && j<list2.size())\\n        {\\n            if(list1.get(i)>list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list1.get(i);\\n                i++;\\n                t++;\\n            }\\n            else if(list1.get(i)<list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list2.get(j))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list2.get(j))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list2.get(j);\\n                j++;\\n                t++;\\n            }\\n            else\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                res[t]=list1.get(i);\\n                int x=i+1, y=j+1;\\n                boolean unEqualFound=false;\\n                while(x<list1.size() && y<list2.size())\\n                {\\n                    if(list1.get(x)>list2.get(y))\\n                    {\\n                        i++;\\n                    }\\n                    else if(list1.get(x)<list2.get(y))\\n                    {\\n                        j++;\\n                    }\\n                    if(list1.get(x)==list2.get(y))\\n                    {\\n                        x++;\\n                        y++;\\n                    }\\n                    else\\n                    {\\n                        unEqualFound=true;\\n                        break;\\n                    }\\n                }\\n                if(!unEqualFound)\\n                {\\n                    if(x<list1.size())\\n                    {\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        j++;\\n                    }   \\n                }\\n                t++;\\n            }\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(i<list1.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list1.get(i))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list1.get(i))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list1.get(i);\\n            t++;\\n            i++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(j<list2.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list2.get(j))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list2.get(j))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list2.get(j);\\n            j++;\\n            t++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n    }\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res=new int[k];\\n        for(int j=0; j<=k; j++)\\n        {\\n            ArrayList<Integer> list1=new ArrayList<>();\\n            ArrayList<Integer> list2=new ArrayList<>();\\n            add(list1, nums1, k-j);\\n            add(list2, nums2, k-list1.size());\\n            updateResult(res, list1, list2, k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void add(ArrayList<Integer> list, int[] nums, int k)\\n    {\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            list.add(nums[i]);\\n        }\\n        int l=list.size();\\n        int i=0;\\n        while(l>k && i<l-1)\\n        {\\n            if(list.get(i)<list.get(i+1))\\n            {\\n                list.remove(i);\\n                i=0;\\n                l--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        while(l>k)\\n        {\\n            list.remove(l-1);\\n            l--;\\n        }\\n    }\\n    public void updateResult(int[] res, ArrayList<Integer> list1, ArrayList<Integer> list2, int k)\\n    {\\n        if(list1.size()+list2.size()<k)\\n        {\\n            return;\\n        }\\n        int i=0, j=0, t=0;\\n        int accepted=0;\\n        while(i<list1.size() && j<list2.size())\\n        {\\n            if(list1.get(i)>list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list1.get(i);\\n                i++;\\n                t++;\\n            }\\n            else if(list1.get(i)<list2.get(j))\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list2.get(j))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(accepted!=2 && res[t]==list2.get(j))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }   \\n                }\\n                res[t]=list2.get(j);\\n                j++;\\n                t++;\\n            }\\n            else\\n            {\\n                if(accepted!=2)\\n                {\\n                    if(res[t]<list1.get(i))\\n                    {\\n                        accepted=2;\\n                    }\\n                    else if(res[t]==list1.get(i))\\n                    {\\n                        accepted=1;\\n                    }\\n                    if(accepted==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                res[t]=list1.get(i);\\n                int x=i+1, y=j+1;\\n                boolean unEqualFound=false;\\n                while(x<list1.size() && y<list2.size())\\n                {\\n                    if(list1.get(x)>list2.get(y))\\n                    {\\n                        i++;\\n                    }\\n                    else if(list1.get(x)<list2.get(y))\\n                    {\\n                        j++;\\n                    }\\n                    if(list1.get(x)==list2.get(y))\\n                    {\\n                        x++;\\n                        y++;\\n                    }\\n                    else\\n                    {\\n                        unEqualFound=true;\\n                        break;\\n                    }\\n                }\\n                if(!unEqualFound)\\n                {\\n                    if(x<list1.size())\\n                    {\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        j++;\\n                    }   \\n                }\\n                t++;\\n            }\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(i<list1.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list1.get(i))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list1.get(i))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list1.get(i);\\n            t++;\\n            i++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n        while(j<list2.size())\\n        {\\n            if(accepted!=2)\\n            {\\n                if(res[t]<list2.get(j))\\n                {\\n                    accepted=2;\\n                }\\n                else if(accepted!=2 && res[t]==list2.get(j))\\n                {\\n                    accepted=1;\\n                }\\n                if(accepted==0)\\n                {\\n                    break;\\n                }   \\n            }\\n            res[t]=list2.get(j);\\n            j++;\\n            t++;\\n            if(t==k)\\n            {\\n                break;\\n            }\\n            if(accepted==1)\\n            {\\n                accepted=0;\\n            }\\n        }\\n    }\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int[] res=new int[k];\\n        for(int j=0; j<=k; j++)\\n        {\\n            ArrayList<Integer> list1=new ArrayList<>();\\n            ArrayList<Integer> list2=new ArrayList<>();\\n            add(list1, nums1, k-j);\\n            add(list2, nums2, k-list1.size());\\n            updateResult(res, list1, list2, k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270634,
                "title": "go-4ms-100-100-standard-greedy-solution",
                "content": "Leaving this here in case someone is more comfortable with Go than the previously posted solutions / languages.\\n\\n```go\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\n\\t// Each number is definitely smaller than 256 => uint8\\n\\tn1 := make([]uint8, n)\\n\\tfor i, n := range nums1 {\\n\\t\\tn1[i] = uint8(n)\\n\\t}\\n\\tn2 := make([]uint8, m)\\n\\tfor i, n := range nums2 {\\n\\t\\tn2[i] = uint8(n)\\n\\t}\\n\\n\\t// The goal is to pick k items from the two arrays so that the combination\\n\\t// is the greatest possible sequence. The problem is that it is not clear how\\n\\t// many items should be picked from each array, let\\'s call this (k1, k2) where\\n\\t// k = k1+k2. Assuming k == 2, then (k1, k2) can take on (0,2), (1,1), (2,0).\\n\\t// Then combine the max sequence given k1 items in nums1, and k2 items \\n\\t// in nums2.\\n\\tfromFirst := min(n, k)\\n\\tfromSecond := max(0, k-fromFirst)\\n\\n\\tvar bestResult []uint8\\n\\tfor fromFirst >= 0 && fromSecond <= min(k, m) {\\n\\t\\ta := maxNumSingle(n1, fromFirst)\\n\\t\\tb := maxNumSingle(n2, fromSecond)\\n\\t\\tmerged := merge(a, b, fromFirst, fromSecond)\\n\\t\\tif len(bestResult) == 0 || greater(merged, bestResult, k, k, 0, 0) {\\n\\t\\t\\tbestResult = merged\\n\\t\\t}\\n\\t\\tfromFirst--\\n\\t\\tfromSecond++\\n\\t}\\n\\tres := make([]int, k)\\n\\tfor i, num := range bestResult {\\n\\t\\tres[i] = int(num)\\n\\t}\\n\\treturn res\\n}\\n\\n// merge merges the two arrays a and b optimally.\\nfunc merge(a, b []uint8, n, m int) []uint8 {\\n\\tres := make([]uint8, m+n)\\n\\tvar i, j int\\n\\tfor k := 0; k < m+n; k++ {\\n\\t\\tif greater(a, b, n, m, i, j) {\\n\\t\\t\\tres[k] = a[i]\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tres[k] = b[j]\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n// greater compares the provided lists of integers. If the length of one array\\n// is shorted than another, and they are otherwise equal, the longer array is\\n// returned. The reasoning behind this is that the partial array is always at\\n// least as good as the full array. For example, given [1,2], [1,2,3], choosing\\n// the first shorter array would force the use of 1 in the second array, which\\n// is sub-optimal.\\nfunc greater(a, b []uint8, n, m, i, j int) bool {\\n\\tfor ; i < n && j < m; i, j = i+1, j+1 {\\n\\t\\tif a[i] != b[j] {\\n\\t\\t\\treturn a[i] > b[j]\\n\\t\\t}\\n\\t}\\n\\treturn i != n\\n}\\n\\n// maxNumSingle calculates the max sequence in nums of length k.\\nfunc maxNumSingle(nums []uint8, k int) []uint8 {\\n\\t// Stack contains k elements sorted in descending order until it is absolutely\\n\\t// necessary to add more elements. For example, if k == len(nums), then the\\n\\t// result is simply the entire nums array. If k == len(nums)-1, it is ok to\\n\\t// bubble a number at most once.\\n\\tstack := make(uint8Stack, 0, k)\\n\\tn := len(nums)\\n\\tfor i, num := range nums {\\n\\t\\t// If num is greater than any elements in the stack, and there is enough\\n\\t\\t// elements in nums to fill up the remainder, then clean up the stack to\\n\\t\\t// make room for num.\\n\\t\\titemsLeft := n - i\\n\\t\\tfor len(stack) > 0 && itemsLeft > k-len(stack) && num > stack.peek() {\\n\\t\\t\\tstack.pop()\\n\\t\\t}\\n\\t\\tif len(stack) < k {\\n\\t\\t\\tstack.push(num)\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n\\ntype uint8Stack []uint8\\n\\nfunc (s uint8Stack) peek() uint8 {\\n\\treturn s[len(s)-1]\\n}\\n\\nfunc (s *uint8Stack) pop() uint8 {\\n\\tn := len(*s)\\n\\tit := (*s)[n-1]\\n\\t*s = (*s)[:n-1]\\n\\treturn it\\n}\\n\\nfunc (s *uint8Stack) push(x uint8) {\\n\\t*s = append(*s, x)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxNumber(nums1 []int, nums2 []int, k int) []int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\n\\t// Each number is definitely smaller than 256 => uint8\\n\\tn1 := make([]uint8, n)\\n\\tfor i, n := range nums1 {\\n\\t\\tn1[i] = uint8(n)\\n\\t}\\n\\tn2 := make([]uint8, m)\\n\\tfor i, n := range nums2 {\\n\\t\\tn2[i] = uint8(n)\\n\\t}\\n\\n\\t// The goal is to pick k items from the two arrays so that the combination\\n\\t// is the greatest possible sequence. The problem is that it is not clear how\\n\\t// many items should be picked from each array, let\\'s call this (k1, k2) where\\n\\t// k = k1+k2. Assuming k == 2, then (k1, k2) can take on (0,2), (1,1), (2,0).\\n\\t// Then combine the max sequence given k1 items in nums1, and k2 items \\n\\t// in nums2.\\n\\tfromFirst := min(n, k)\\n\\tfromSecond := max(0, k-fromFirst)\\n\\n\\tvar bestResult []uint8\\n\\tfor fromFirst >= 0 && fromSecond <= min(k, m) {\\n\\t\\ta := maxNumSingle(n1, fromFirst)\\n\\t\\tb := maxNumSingle(n2, fromSecond)\\n\\t\\tmerged := merge(a, b, fromFirst, fromSecond)\\n\\t\\tif len(bestResult) == 0 || greater(merged, bestResult, k, k, 0, 0) {\\n\\t\\t\\tbestResult = merged\\n\\t\\t}\\n\\t\\tfromFirst--\\n\\t\\tfromSecond++\\n\\t}\\n\\tres := make([]int, k)\\n\\tfor i, num := range bestResult {\\n\\t\\tres[i] = int(num)\\n\\t}\\n\\treturn res\\n}\\n\\n// merge merges the two arrays a and b optimally.\\nfunc merge(a, b []uint8, n, m int) []uint8 {\\n\\tres := make([]uint8, m+n)\\n\\tvar i, j int\\n\\tfor k := 0; k < m+n; k++ {\\n\\t\\tif greater(a, b, n, m, i, j) {\\n\\t\\t\\tres[k] = a[i]\\n\\t\\t\\ti++\\n\\t\\t} else {\\n\\t\\t\\tres[k] = b[j]\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n// greater compares the provided lists of integers. If the length of one array\\n// is shorted than another, and they are otherwise equal, the longer array is\\n// returned. The reasoning behind this is that the partial array is always at\\n// least as good as the full array. For example, given [1,2], [1,2,3], choosing\\n// the first shorter array would force the use of 1 in the second array, which\\n// is sub-optimal.\\nfunc greater(a, b []uint8, n, m, i, j int) bool {\\n\\tfor ; i < n && j < m; i, j = i+1, j+1 {\\n\\t\\tif a[i] != b[j] {\\n\\t\\t\\treturn a[i] > b[j]\\n\\t\\t}\\n\\t}\\n\\treturn i != n\\n}\\n\\n// maxNumSingle calculates the max sequence in nums of length k.\\nfunc maxNumSingle(nums []uint8, k int) []uint8 {\\n\\t// Stack contains k elements sorted in descending order until it is absolutely\\n\\t// necessary to add more elements. For example, if k == len(nums), then the\\n\\t// result is simply the entire nums array. If k == len(nums)-1, it is ok to\\n\\t// bubble a number at most once.\\n\\tstack := make(uint8Stack, 0, k)\\n\\tn := len(nums)\\n\\tfor i, num := range nums {\\n\\t\\t// If num is greater than any elements in the stack, and there is enough\\n\\t\\t// elements in nums to fill up the remainder, then clean up the stack to\\n\\t\\t// make room for num.\\n\\t\\titemsLeft := n - i\\n\\t\\tfor len(stack) > 0 && itemsLeft > k-len(stack) && num > stack.peek() {\\n\\t\\t\\tstack.pop()\\n\\t\\t}\\n\\t\\tif len(stack) < k {\\n\\t\\t\\tstack.push(num)\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n\\ntype uint8Stack []uint8\\n\\nfunc (s uint8Stack) peek() uint8 {\\n\\treturn s[len(s)-1]\\n}\\n\\nfunc (s *uint8Stack) pop() uint8 {\\n\\tn := len(*s)\\n\\tit := (*s)[n-1]\\n\\t*s = (*s)[:n-1]\\n\\treturn it\\n}\\n\\nfunc (s *uint8Stack) push(x uint8) {\\n\\t*s = append(*s, x)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135237,
                "title": "swift-greedy-solution",
                "content": "Inspired from https://leetcode.com/problems/create-maximum-number/discuss/77285/Share-my-greedy-solution\\n\\n```\\nclass Solution {\\n    func maxNumber(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        let m = nums1.count\\n        let n = nums2.count\\n\\n        var res = Array(repeating: 0, count: k)\\n        for i in max(k-n, 0)...min(k, m) {\\n            let temp = merge(getMaxArr(nums1, i), getMaxArr(nums2, k-i), k)\\n            if larger(temp, 0, res, 0) {\\n                res = temp\\n            }\\n        }\\n        return res\\n    }\\n\\n    func merge(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        var res = Array(repeating: 0, count: k)\\n        var i = 0\\n        var j = 0\\n        for index in 0..<k {\\n             if larger(nums1, i, nums2, j) {\\n                 res[index] = nums1[i]\\n                 i += 1\\n             } else {\\n                 res[index] = nums2[j]\\n                 j += 1\\n             }\\n        }\\n        return res\\n    }\\n\\n    // Given one array of length n, create the maximum number of length k\\n    func getMaxArr(_ nums: [Int], _ k: Int) -> [Int] {\\n        let n = nums.count\\n\\n        var stack = [Int]()\\n\\n        for i in 0..<n {\\n            while stack.count + n - i > k, !stack.isEmpty, stack.last! < nums[i] {\\n                stack.removeLast()\\n            }\\n            if stack.count < k {\\n                stack.append(nums[i])\\n            }\\n        }\\n\\n        var remain = k-stack.count\\n        while remain > 0 {\\n            stack.insert(0, at: 0)\\n            remain -= 1\\n        }\\n        return stack\\n    }\\n\\n    func larger(_ nums1: [Int], _ i1: Int, _ nums2: [Int], _ i2: Int) -> Bool {\\n        var i1 = i1\\n        var i2 = i2\\n        while i1 < nums1.count, i2 < nums2.count, nums1[i1] == nums2[i2] {\\n            i1 += 1\\n            i2 += 1\\n        }\\n        return i2 == nums2.count\\n        ? true\\n        : (i1 < nums1.count && nums1[i1] > nums2[i2])\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxNumber(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        let m = nums1.count\\n        let n = nums2.count\\n\\n        var res = Array(repeating: 0, count: k)\\n        for i in max(k-n, 0)...min(k, m) {\\n            let temp = merge(getMaxArr(nums1, i), getMaxArr(nums2, k-i), k)\\n            if larger(temp, 0, res, 0) {\\n                res = temp\\n            }\\n        }\\n        return res\\n    }\\n\\n    func merge(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {\\n        var res = Array(repeating: 0, count: k)\\n        var i = 0\\n        var j = 0\\n        for index in 0..<k {\\n             if larger(nums1, i, nums2, j) {\\n                 res[index] = nums1[i]\\n                 i += 1\\n             } else {\\n                 res[index] = nums2[j]\\n                 j += 1\\n             }\\n        }\\n        return res\\n    }\\n\\n    // Given one array of length n, create the maximum number of length k\\n    func getMaxArr(_ nums: [Int], _ k: Int) -> [Int] {\\n        let n = nums.count\\n\\n        var stack = [Int]()\\n\\n        for i in 0..<n {\\n            while stack.count + n - i > k, !stack.isEmpty, stack.last! < nums[i] {\\n                stack.removeLast()\\n            }\\n            if stack.count < k {\\n                stack.append(nums[i])\\n            }\\n        }\\n\\n        var remain = k-stack.count\\n        while remain > 0 {\\n            stack.insert(0, at: 0)\\n            remain -= 1\\n        }\\n        return stack\\n    }\\n\\n    func larger(_ nums1: [Int], _ i1: Int, _ nums2: [Int], _ i2: Int) -> Bool {\\n        var i1 = i1\\n        var i2 = i2\\n        while i1 < nums1.count, i2 < nums2.count, nums1[i1] == nums2[i2] {\\n            i1 += 1\\n            i2 += 1\\n        }\\n        return i2 == nums2.count\\n        ? true\\n        : (i1 < nums1.count && nums1[i1] > nums2[i2])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132471,
                "title": "85-71-faster-time-o-k-2-n-m-space-o-max-n-m-k-clear-soln",
                "content": "![image](https://assets.leetcode.com/users/images/24596989-6803-4d61-b13f-208b7ceb37d4_1617004877.3851686.png)\\nFirst we trim the original arrays(if possible)\\nthan we try every combination of removing i,j elements from A & B\\nex: if k = 3 we try these >> i=0 j=3 >> i=1 j=2 >> i=2 j =1 >> i=3 j =0\\nafter trying removing minimum digits from both array we merge trimmed A & B to check if we have landed upon biggest number possible\\n```\\npublic class Solution {\\n    // Time O(k^2*(n+m)) || Space O(Max(n,m,k))\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        nums1 = Trim(nums1, k);     // O(n)\\n        nums2 = Trim(nums2, k);     // O(m)\\n\\n        if (nums1.Length + nums2.Length <= k)\\n            return Merge(nums1, nums2, k);      // O((n+m)*k)\\n\\n        int[] max = null, curr;\\n        for (int i = k, j = 0; i >= 0; i--, j++)// O(k^2*(n+m))\\n            // Make sure we can remove i & j no of nums from A & B respectively\\n            if (nums1.Length >= i && nums2.Length >= j)\\n            {\\n                curr = Merge(Trim(nums1, i), Trim(nums2, j), k);\\n\\n                if (max == null)\\n                    max = curr;\\n                else\\n                    for (int idx = 0; idx < k; idx++)\\n                        // Atleast one non-equal digit is bigger in max\\n                        if (max[idx] > curr[idx])\\n                            break;\\n                        // Atleast one non-equal digit is bigger in curr\\n                        else if (max[idx] < curr[idx])\\n                        {\\n                            max = curr;\\n                            break;\\n                        }\\n            }\\n        return max;\\n\\n        // local helper functions\\n\\n        // Function which trims \\'k\\' elements to maximimze array \\'A\\'\\n        // Time = Space = O(n), n = len of \\'A\"\\n        int[] Trim(int[] A, int toTrim)\\n        {\\n            toTrim = A.Length - toTrim;\\n            // Not enouf elements to trim, return original array\\n            if (toTrim <= 0) return A;\\n\\n            Stack<int> st = new Stack<int>();\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // stack top num is smaller than curr than remove stack top\\n                while (st.Count > 0 && st.Peek() < A[i] && toTrim > 0)\\n                {\\n                    st.Pop();\\n                    toTrim--;\\n                }\\n                st.Push(A[i]);\\n            }\\n            // if still nums left to trim\\n            while (toTrim-- > 0) st.Pop();\\n\\n            return st.Reverse().ToArray();\\n        }\\n\\n        // Merge max possible digits from \\'A\\' & \\'B\\' and return merged max possible array of size \\'l\\'\\n        // Time = O(n+m)*l, n = len of A, m = len of \\'B\\', l = len of Merged Arr\\n        int[] Merge(int[] A, int[] B, int l)\\n        {\\n            int[] merged = new int[l];\\n            int i = 0, j = 0, idx = 0, lenA = A.Length, lenB = B.Length, n1, n2;\\n            while (idx < l)\\n            {\\n                n1 = i < lenA ? A[i] : -1;\\n                n2 = j < lenB ? B[j] : -1;\\n                if (n1 > n2)\\n                    merged[idx] = A[i++];\\n                else if (n1 < n2)\\n                    merged[idx] = B[j++];\\n                else\\n                {\\n                    // find next num which is not equal\\n                    int i1 = i + 1, j1 = j + 1;\\n                    while (i1 < lenA && j1 < lenB && A[i1] == B[j1])\\n                    { i1++; j1++; }\\n\\n                    if (i1 == lenA)\\n                        merged[idx] = B[j++];\\n                    else if (j1 == lenB)\\n                        merged[idx] = A[i++];\\n                    else if (A[i1] < B[j1])\\n                        merged[idx] = B[j++];\\n                    else // if (A[i1] >= B[j1])\\n                        merged[idx] = A[i++];\\n                }\\n                idx++;\\n            }\\n            return merged;\\n        }\\n    }\\n    /*\\n    public int[] MaxNumberBruteForce(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k], currNum = new int[k];\\n        int l1 = nums1.Length, l2 = nums2.Length;\\n        CreateMax();\\n        return maxNum;\\n        // local func\\n        void CreateMax(int i = 0, int j = 0, int idx = 0)\\n        {\\n            if (idx == k)\\n            {\\n                bool newNumIsBigger = false;\\n                // find out if there is atleast one leading digit which is not same in both max and curr array\\n                // and if that digit is greater in currNum array than update the max array\\n                for (int index = 0; index < k; index++)\\n                    if (maxNum[index] != currNum[index])\\n                    {\\n                        if (maxNum[index] < currNum[index])\\n                            newNumIsBigger = true;\\n                        break;\\n                    }\\n\\n                if (newNumIsBigger)\\n                    for (int index = 0; index < k; index++)\\n                        maxNum[index] = currNum[index];\\n            }\\n            else\\n            {\\n                for (int i1 = i; i1 < l1; i1++)\\n                {\\n                    if ((l1 - i1) + (l2 - j) < k - idx) break;\\n                    currNum[idx] = nums1[i1];\\n                    CreateMax(i1 + 1, j, idx + 1);\\n                }\\n\\n                for (int j1 = j; j1 < l2; j1++)\\n                {\\n                    if ((l1 - i) + (l2 - j1) < k - idx) break;\\n                    currNum[idx] = nums2[j1];\\n                    CreateMax(i, j1 + 1, idx + 1);\\n                }\\n            }\\n        }\\n    }\\n    */\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(k^2*(n+m)) || Space O(Max(n,m,k))\\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\\n        nums1 = Trim(nums1, k);     // O(n)\\n        nums2 = Trim(nums2, k);     // O(m)\\n\\n        if (nums1.Length + nums2.Length <= k)\\n            return Merge(nums1, nums2, k);      // O((n+m)*k)\\n\\n        int[] max = null, curr;\\n        for (int i = k, j = 0; i >= 0; i--, j++)// O(k^2*(n+m))\\n            // Make sure we can remove i & j no of nums from A & B respectively\\n            if (nums1.Length >= i && nums2.Length >= j)\\n            {\\n                curr = Merge(Trim(nums1, i), Trim(nums2, j), k);\\n\\n                if (max == null)\\n                    max = curr;\\n                else\\n                    for (int idx = 0; idx < k; idx++)\\n                        // Atleast one non-equal digit is bigger in max\\n                        if (max[idx] > curr[idx])\\n                            break;\\n                        // Atleast one non-equal digit is bigger in curr\\n                        else if (max[idx] < curr[idx])\\n                        {\\n                            max = curr;\\n                            break;\\n                        }\\n            }\\n        return max;\\n\\n        // local helper functions\\n\\n        // Function which trims \\'k\\' elements to maximimze array \\'A\\'\\n        // Time = Space = O(n), n = len of \\'A\"\\n        int[] Trim(int[] A, int toTrim)\\n        {\\n            toTrim = A.Length - toTrim;\\n            // Not enouf elements to trim, return original array\\n            if (toTrim <= 0) return A;\\n\\n            Stack<int> st = new Stack<int>();\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // stack top num is smaller than curr than remove stack top\\n                while (st.Count > 0 && st.Peek() < A[i] && toTrim > 0)\\n                {\\n                    st.Pop();\\n                    toTrim--;\\n                }\\n                st.Push(A[i]);\\n            }\\n            // if still nums left to trim\\n            while (toTrim-- > 0) st.Pop();\\n\\n            return st.Reverse().ToArray();\\n        }\\n\\n        // Merge max possible digits from \\'A\\' & \\'B\\' and return merged max possible array of size \\'l\\'\\n        // Time = O(n+m)*l, n = len of A, m = len of \\'B\\', l = len of Merged Arr\\n        int[] Merge(int[] A, int[] B, int l)\\n        {\\n            int[] merged = new int[l];\\n            int i = 0, j = 0, idx = 0, lenA = A.Length, lenB = B.Length, n1, n2;\\n            while (idx < l)\\n            {\\n                n1 = i < lenA ? A[i] : -1;\\n                n2 = j < lenB ? B[j] : -1;\\n                if (n1 > n2)\\n                    merged[idx] = A[i++];\\n                else if (n1 < n2)\\n                    merged[idx] = B[j++];\\n                else\\n                {\\n                    // find next num which is not equal\\n                    int i1 = i + 1, j1 = j + 1;\\n                    while (i1 < lenA && j1 < lenB && A[i1] == B[j1])\\n                    { i1++; j1++; }\\n\\n                    if (i1 == lenA)\\n                        merged[idx] = B[j++];\\n                    else if (j1 == lenB)\\n                        merged[idx] = A[i++];\\n                    else if (A[i1] < B[j1])\\n                        merged[idx] = B[j++];\\n                    else // if (A[i1] >= B[j1])\\n                        merged[idx] = A[i++];\\n                }\\n                idx++;\\n            }\\n            return merged;\\n        }\\n    }\\n    /*\\n    public int[] MaxNumberBruteForce(int[] nums1, int[] nums2, int k) {\\n        int[] maxNum = new int[k], currNum = new int[k];\\n        int l1 = nums1.Length, l2 = nums2.Length;\\n        CreateMax();\\n        return maxNum;\\n        // local func\\n        void CreateMax(int i = 0, int j = 0, int idx = 0)\\n        {\\n            if (idx == k)\\n            {\\n                bool newNumIsBigger = false;\\n                // find out if there is atleast one leading digit which is not same in both max and curr array\\n                // and if that digit is greater in currNum array than update the max array\\n                for (int index = 0; index < k; index++)\\n                    if (maxNum[index] != currNum[index])\\n                    {\\n                        if (maxNum[index] < currNum[index])\\n                            newNumIsBigger = true;\\n                        break;\\n                    }\\n\\n                if (newNumIsBigger)\\n                    for (int index = 0; index < k; index++)\\n                        maxNum[index] = currNum[index];\\n            }\\n            else\\n            {\\n                for (int i1 = i; i1 < l1; i1++)\\n                {\\n                    if ((l1 - i1) + (l2 - j) < k - idx) break;\\n                    currNum[idx] = nums1[i1];\\n                    CreateMax(i1 + 1, j, idx + 1);\\n                }\\n\\n                for (int j1 = j; j1 < l2; j1++)\\n                {\\n                    if ((l1 - i) + (l2 - j1) < k - idx) break;\\n                    currNum[idx] = nums2[j1];\\n                    CreateMax(i, j1 + 1, idx + 1);\\n                }\\n            }\\n        }\\n    }\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976186,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\nvar maxNumber = function(a1, a2, k) {\\n    var tp = a1.concat(a2).slice(0,k).join(\\'\\')\\n    \\n    var len1 = a1.length, len2 = a2.length\\n    \\n    for(var i=Math.max(0, k-len2); i<=len1 && i<=k; i++) {\\n        \\n        var tp1 = getMax(a1,i)\\n        var tp2 = getMax(a2, k-i)\\n        var tp3 = merge(tp1, tp2)\\n        var tps = tp3.join(\\'\\')\\n        if(tps.localeCompare(tp)>0) {\\n            tp = tps\\n        }\\n    }\\n    return tp.split(\\'\\').map(c=>+c)\\n};\\n\\nvar merge = (a1, a2)=>{\\n    var len1 = a1.length, len2 = a2.length\\n    var res = []\\n    var i=0,j=0\\n    \\n    var greater = (i, j)=>{\\n        while(i<len1 && j<len2 && a1[i]==a2[j]) {\\n            i++\\n            j++\\n        }\\n        return j==len2 || (i<len1 && a1[i]>a2[j])\\n    }\\n    \\n    while(i<len1 && j<len2) {\\n        if(greater(i,j)){\\n            res.push(a1[i])\\n            i++\\n        }else{\\n            res.push(a2[j])\\n            j++\\n        }\\n        \\n    }\\n\\n    while(i<len1){\\n        res.push(a1[i])\\n            i++\\n    }\\n    while(j<len2){\\n        res.push(a2[j])\\n            j++\\n    }\\n    return res\\n}\\n\\n\\nvar getMax = (arr, k) => {\\n    var len = arr.length\\n    if(k==0) return []\\n    var res = new Array(k).fill(0)\\n    for(var i=0, j=0; i<len; i++) {\\n        while(len-i>k-j && j>0 && res[j-1]<arr[i]){\\n            j--\\n        }\\n        if(j<k){\\n            res[j] = arr[i]\\n            j++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxNumber = function(a1, a2, k) {\\n    var tp = a1.concat(a2).slice(0,k).join(\\'\\')\\n    \\n    var len1 = a1.length, len2 = a2.length\\n    \\n    for(var i=Math.max(0, k-len2); i<=len1 && i<=k; i++) {\\n        \\n        var tp1 = getMax(a1,i)\\n        var tp2 = getMax(a2, k-i)\\n        var tp3 = merge(tp1, tp2)\\n        var tps = tp3.join(\\'\\')\\n        if(tps.localeCompare(tp)>0) {\\n            tp = tps\\n        }\\n    }\\n    return tp.split(\\'\\').map(c=>+c)\\n};\\n\\nvar merge = (a1, a2)=>{\\n    var len1 = a1.length, len2 = a2.length\\n    var res = []\\n    var i=0,j=0\\n    \\n    var greater = (i, j)=>{\\n        while(i<len1 && j<len2 && a1[i]==a2[j]) {\\n            i++\\n            j++\\n        }\\n        return j==len2 || (i<len1 && a1[i]>a2[j])\\n    }\\n    \\n    while(i<len1 && j<len2) {\\n        if(greater(i,j)){\\n            res.push(a1[i])\\n            i++\\n        }else{\\n            res.push(a2[j])\\n            j++\\n        }\\n        \\n    }\\n\\n    while(i<len1){\\n        res.push(a1[i])\\n            i++\\n    }\\n    while(j<len2){\\n        res.push(a2[j])\\n            j++\\n    }\\n    return res\\n}\\n\\n\\nvar getMax = (arr, k) => {\\n    var len = arr.length\\n    if(k==0) return []\\n    var res = new Array(k).fill(0)\\n    for(var i=0, j=0; i<len; i++) {\\n        while(len-i>k-j && j>0 && res[j-1]<arr[i]){\\n            j--\\n        }\\n        if(j<k){\\n            res[j] = arr[i]\\n            j++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975787,
                "title": "brute-force-pretty-straight-forward-less-comments-for-explanation",
                "content": "```\\nclass Solution {\\n    public int[] maxNumber(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        int m = b.length;\\n        \\n        int x[][] = new int[n][];\\n        int y[][] = new int[m][];\\n        for(int i=0;i<n;i++)\\n            x[i] = new int[i+1];\\n        for(int i=0;i<m;i++)\\n            y[i] = new int[i+1];\\n        \\n        build(a , x);\\n        build(b , y);\\n        \\n        int ans[] = new int[k];\\n        \\n        for(int i=0;i<=k;i++){\\n            int count1 = i;\\n            int count2 = k-i;\\n            if(count1<=n && count2<=m){\\n                int left[] = new int[0];\\n                int right[] = new int[0];\\n                if(count1>0)\\n                    left = x[count1-1];\\n                if(count2>0)\\n                    right = y[count2-1];\\n                int now[] = max(left , right);\\n                if(less(ans , now)<0){\\n                    ans = now;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int[] max(int a[] , int b[]){\\n        int c[] = new int[a.length+b.length];\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                int x = check(a , b , i , j);\\n                if(x == 0)\\n                    c[k++] = a[i++];\\n                else\\n                    c[k++] = b[j++];\\n            }\\n            else if(a[i]>b[j])\\n                c[k++] = a[i++];\\n            else\\n                c[k++] = b[j++];\\n        }\\n        while(i<a.length)\\n            c[k++] = a[i++];\\n        while(j<b.length)\\n            c[k++] = b[j++];\\n        return c;\\n    }\\n    \\n    public int check(int a[] , int b[] , int s1 , int s2){\\n        // 0 -> a 1 -> b\\n        int i=s1;\\n        int j=s2;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            if(a[i]<b[j])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(i == a.length)\\n            return 1;\\n        return 0;\\n    }\\n    \\n    public void build(int a[] , int x[][]){\\n        for(int i=0;i<a.length;i++){\\n            int num = a[i];\\n            if(i == 0){\\n                x[i][0] = num;\\n                continue;\\n            }\\n            for(int j=i;j>0;j--){\\n                int res = less(x[j] , x[j-1]);\\n                if(res>0);\\n                else if(res == 0){\\n                    if(x[j][j]<num){\\n                        x[j][j] = num;\\n                    }\\n                }\\n                else{\\n                    copy(x[j-1] , x[j]);\\n                    x[j][j] = num;\\n                }\\n            }\\n            if(x[0][0]<num)\\n                x[0][0] = num;\\n        }\\n    }\\n    \\n    public void copy(int a[] , int b[]){\\n        for(int i=0;i<a.length;i++)\\n            b[i] = a[i];\\n    }\\n    \\n    public int less(int a[] , int b[]){\\n        // 0 -> equal -1 -> less 1 -> more\\n        for(int i=0;i<Math.min(a.length , b.length);i++){\\n            if(a[i] == b[i])\\n                continue;\\n            else if(a[i]<b[i])\\n                return -1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxNumber(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        int m = b.length;\\n        \\n        int x[][] = new int[n][];\\n        int y[][] = new int[m][];\\n        for(int i=0;i<n;i++)\\n            x[i] = new int[i+1];\\n        for(int i=0;i<m;i++)\\n            y[i] = new int[i+1];\\n        \\n        build(a , x);\\n        build(b , y);\\n        \\n        int ans[] = new int[k];\\n        \\n        for(int i=0;i<=k;i++){\\n            int count1 = i;\\n            int count2 = k-i;\\n            if(count1<=n && count2<=m){\\n                int left[] = new int[0];\\n                int right[] = new int[0];\\n                if(count1>0)\\n                    left = x[count1-1];\\n                if(count2>0)\\n                    right = y[count2-1];\\n                int now[] = max(left , right);\\n                if(less(ans , now)<0){\\n                    ans = now;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int[] max(int a[] , int b[]){\\n        int c[] = new int[a.length+b.length];\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                int x = check(a , b , i , j);\\n                if(x == 0)\\n                    c[k++] = a[i++];\\n                else\\n                    c[k++] = b[j++];\\n            }\\n            else if(a[i]>b[j])\\n                c[k++] = a[i++];\\n            else\\n                c[k++] = b[j++];\\n        }\\n        while(i<a.length)\\n            c[k++] = a[i++];\\n        while(j<b.length)\\n            c[k++] = b[j++];\\n        return c;\\n    }\\n    \\n    public int check(int a[] , int b[] , int s1 , int s2){\\n        // 0 -> a 1 -> b\\n        int i=s1;\\n        int j=s2;\\n        while(i<a.length && j<b.length){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            if(a[i]<b[j])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(i == a.length)\\n            return 1;\\n        return 0;\\n    }\\n    \\n    public void build(int a[] , int x[][]){\\n        for(int i=0;i<a.length;i++){\\n            int num = a[i];\\n            if(i == 0){\\n                x[i][0] = num;\\n                continue;\\n            }\\n            for(int j=i;j>0;j--){\\n                int res = less(x[j] , x[j-1]);\\n                if(res>0);\\n                else if(res == 0){\\n                    if(x[j][j]<num){\\n                        x[j][j] = num;\\n                    }\\n                }\\n                else{\\n                    copy(x[j-1] , x[j]);\\n                    x[j][j] = num;\\n                }\\n            }\\n            if(x[0][0]<num)\\n                x[0][0] = num;\\n        }\\n    }\\n    \\n    public void copy(int a[] , int b[]){\\n        for(int i=0;i<a.length;i++)\\n            b[i] = a[i];\\n    }\\n    \\n    public int less(int a[] , int b[]){\\n        // 0 -> equal -1 -> less 1 -> more\\n        for(int i=0;i<Math.min(a.length , b.length);i++){\\n            if(a[i] == b[i])\\n                continue;\\n            else if(a[i]<b[i])\\n                return -1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946759,
                "title": "why-this-question-tagged-with-dynamic-programming",
                "content": "TLE since 88th test case\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef recursion(i: int, j: int, left: int) -> int:\\n\\t\\t\\t\\tif left == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif len(nums1) - i + len(nums2) - j < left:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tval1 = val2 = val3 = 0\\n\\t\\t\\t\\tif i < len(nums1):\\n\\t\\t\\t\\t\\tval1 += nums1[i] * 10**(left - 1) + recursion(i + 1, j, left - 1)\\n\\t\\t\\t\\t\\tval1 = max(val1, recursion(i + 1, j, left))\\n\\t\\t\\t\\tif j < len(nums2):\\n\\t\\t\\t\\t\\tval2 += nums2[j] * 10**(left - 1) + recursion(i, j + 1, left - 1)\\n\\t\\t\\t\\t\\tval2 = max(val2, recursion(i, j + 1, left))\\n\\t\\t\\t\\tif i < len(nums1) and j < len(nums2):\\n\\t\\t\\t\\t\\tval3 = recursion(i + 1, j + 1, left)\\n\\t\\t\\t\\treturn max(val1, max(val2, val3))\\n\\n\\t\\t\\tres = recursion(0, 0, k)\\n\\n\\t\\t\\toutput = []\\n\\t\\t\\twhile res != 0:\\n\\t\\t\\t\\toutput.append(res % 10)\\n\\t\\t\\t\\tres //= 10\\n\\t\\t\\toutput.reverse()\\n\\t\\t\\treturn output",
                "solutionTags": [],
                "code": "TLE since 88th test case\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef recursion(i: int, j: int, left: int) -> int:\\n\\t\\t\\t\\tif left == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif len(nums1) - i + len(nums2) - j < left:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tval1 = val2 = val3 = 0\\n\\t\\t\\t\\tif i < len(nums1):\\n\\t\\t\\t\\t\\tval1 += nums1[i] * 10**(left - 1) + recursion(i + 1, j, left - 1)\\n\\t\\t\\t\\t\\tval1 = max(val1, recursion(i + 1, j, left))\\n\\t\\t\\t\\tif j < len(nums2):\\n\\t\\t\\t\\t\\tval2 += nums2[j] * 10**(left - 1) + recursion(i, j + 1, left - 1)\\n\\t\\t\\t\\t\\tval2 = max(val2, recursion(i, j + 1, left))\\n\\t\\t\\t\\tif i < len(nums1) and j < len(nums2):\\n\\t\\t\\t\\t\\tval3 = recursion(i + 1, j + 1, left)\\n\\t\\t\\t\\treturn max(val1, max(val2, val3))\\n\\n\\t\\t\\tres = recursion(0, 0, k)\\n\\n\\t\\t\\toutput = []\\n\\t\\t\\twhile res != 0:\\n\\t\\t\\t\\toutput.append(res % 10)\\n\\t\\t\\t\\tres //= 10\\n\\t\\t\\toutput.reverse()\\n\\t\\t\\treturn output",
                "codeTag": "Java"
            },
            {
                "id": 865383,
                "title": "c-simplest-solution-break-into-two-problem-and-enjoy",
                "content": "class Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n      int n=a.size();int m=b.size();\\n        vector<int> ans;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n || k-i>m)continue;\\n            ans=max(ans,merge(findmax(a,i),findmax(b,k-i)));\\n        }\\n        return ans;\\n    }\\n    vector<int> findmax(vector<int> &a,int k)\\n    {\\n        vector<int> res;\\n        int to_pop=a.size()-k;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           while(!res.empty() && to_pop && *res.rbegin()<a[i])\\n               res.pop_back(),to_pop--;\\n           res.push_back(a[i]);\\n       }\\n        res.resize(k);\\n        return res;\\n    }\\n    vector<int> merge(vector<int> a,vector<int> b)\\n    {\\n        vector<int> ans;\\n        auto s1=a.begin();\\n        auto e1=a.end();\\n        auto s2=b.begin();\\n        auto e2=b.end();\\n        while(s1!=e1 || s2!=e2)\\n            ans.push_back(lexicographical_compare(s1,e1,s2,e2)?*s2++:*s1++);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& a, vector<int>& b, int k) {\\n      int n=a.size();int m=b.size();\\n        vector<int> ans;\\n        for(int i=0;i<=k;i++)\\n        {\\n            if(i>n || k-i>m)continue;\\n            ans=max(ans,merge(findmax(a,i),findmax(b,k-i)));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732222,
                "title": "sharing-my-dp-solution",
                "content": "If you are going to calculate max in both array simultaneously, it is going to be order of  (m*n*k) where m = arr1.length, n=arr2.length;\\nIdea is calculate max in first array (m*k), calculate max in second array(n*k), then merge both max array to get final answer. complexity would be (m+n+k)*k;\\n\\n```\\n// get max of two string\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n    \\n    // calculate max in one array\\n    public String[] helper1(int[] A, int k) {\\n        int m = A.length;\\n        String[][] dp = new String[m+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int l = 0; l <= k; l++) {\\n                String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i - 1][l - 1] + A[i - 1];\\n                String ignoreAi = (i == 0) ? \"\" : dp[i - 1][l];\\n                dp[i][l] = max(chooseAi, ignoreAi);\\n            }\\n        }\\n        return dp[m];\\n    }\\n\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        String[] max1= helper1(nums1, Math.min(nums1.length,k));  // calculate max for num1\\n        String[] max2= helper1(nums2, Math.min(nums2.length,k)); // calculate max for num2\\n        \\n        // merge two max array \\n        String ans = \"\";\\n        for(int t=0;t<=k;t++) { // k*k*k\\n            int len1 = Math.min(nums1.length, t);\\n            int len2 = Math.min(nums2.length, k-t);\\n            if(len1+len2 != k) continue;\\n            String ans1 = max1[len1];\\n            String ans2 = max2[len2];\\n            StringBuilder tmp = new StringBuilder();\\n            while (tmp.length() < k) {\\n                char ch;\\n                if(ans1.compareTo(ans2)>=0){\\n                    ch=ans1.charAt(0);\\n                    ans1=ans1.substring(1);\\n                }\\n                else {\\n                    ch=ans2.charAt(0);\\n                    ans2=ans2.substring(1);\\n                }\\n                tmp.append(ch);\\n            }\\n            ans=max(ans,tmp.toString());\\n\\n        }\\n\\n        int[] tmp = new int[ans.length()];\\n        for(int i=0;i<tmp.length;i++){\\n            tmp[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return tmp;\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// get max of two string\\n    private String max(String s1, String s2) {\\n        return (s1.compareTo(s2) < 0) ? s2 : s1;\\n    }\\n    \\n    // calculate max in one array\\n    public String[] helper1(int[] A, int k) {\\n        int m = A.length;\\n        String[][] dp = new String[m+1][k+1];\\n        for (int i = 0; i <= m; i++) {\\n            for (int l = 0; l <= k; l++) {\\n                String chooseAi = (i == 0 || l == 0) ? \"\" : dp[i - 1][l - 1] + A[i - 1];\\n                String ignoreAi = (i == 0) ? \"\" : dp[i - 1][l];\\n                dp[i][l] = max(chooseAi, ignoreAi);\\n            }\\n        }\\n        return dp[m];\\n    }\\n\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n\\n        String[] max1= helper1(nums1, Math.min(nums1.length,k));  // calculate max for num1\\n        String[] max2= helper1(nums2, Math.min(nums2.length,k)); // calculate max for num2\\n        \\n        // merge two max array \\n        String ans = \"\";\\n        for(int t=0;t<=k;t++) { // k*k*k\\n            int len1 = Math.min(nums1.length, t);\\n            int len2 = Math.min(nums2.length, k-t);\\n            if(len1+len2 != k) continue;\\n            String ans1 = max1[len1];\\n            String ans2 = max2[len2];\\n            StringBuilder tmp = new StringBuilder();\\n            while (tmp.length() < k) {\\n                char ch;\\n                if(ans1.compareTo(ans2)>=0){\\n                    ch=ans1.charAt(0);\\n                    ans1=ans1.substring(1);\\n                }\\n                else {\\n                    ch=ans2.charAt(0);\\n                    ans2=ans2.substring(1);\\n                }\\n                tmp.append(ch);\\n            }\\n            ans=max(ans,tmp.toString());\\n\\n        }\\n\\n        int[] tmp = new int[ans.length()];\\n        for(int i=0;i<tmp.length;i++){\\n            tmp[i]=ans.charAt(i)-\\'0\\';\\n        }\\n        return tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709875,
                "title": "c-greedy",
                "content": "I have used too much memory to make this code working great. Please keep in mind that while merging we are not merging two sorted arrays so do not use traditional approach for merging.\\n```C++\\n#define ll int\\n#define pb push_back\\nvoid genMax(ll arr[],ll n, vector<ll> nos[]){\\n        ll i=1;\\n        for(ll len=n;len>=1;len--)\\n        {\\n            if(len==n){\\n                for(ll i=1;i<=n;i++)\\n                    nos[len].pb(arr[i]);\\n            }\\n            else\\n            {\\n                i=1;\\n               while(i+1<=n and arr[i]>=arr[i+1])i++;\\n               n-=1;\\n               for(ll j=i;j<=n;j++)arr[j]=arr[j+1];\\n               for(ll j=1;j<=n;j++)nos[len].pb(arr[j]);\\n            }\\n        }\\n    }\\n    bool greater1(vector<ll> v1,int i,vector<ll> v2,int j)\\n    {\\n        while (i < v1.size() && j < v2.size() && v1[i] == v2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == v2.size() || (i < v1.size() && v1[i] > v2[j]);\\n    }\\n    vector<int> merge(vector<int>& v1,vector<int> &v2){\\n        int n=v1.size(),m=v2.size();\\n        int k=n+m;\\n        vector<int> ans(k);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n        ans[r] = greater1(v1, i, v2, j) ? v1[i++] : v2[j++];\\n            return ans;\\n    }\\n    bool great(vector<int> &result,vector<int> &temp){\\n        int k=result.size();\\n        int i=0;\\n        while(i<k and result[i]==temp[i])i++;\\n        if(i<k and result[i] < temp[i])return true;\\n        return false;\\n    }\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        int arr1[n+1],arr2[m+1];\\n        for(int i=0;i<n;i++)\\n            arr1[i+1]=nums1[i];\\n        for(int i=0;i<m;i++)\\n            arr2[i+1]=nums2[i];\\n        vector<int> v1[n+1];\\n        vector<int> v2[m+1];\\n        genMax(arr1,n,v1);\\n        genMax(arr2,m,v2);\\n        // for(ll i=n;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v1[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        // for(ll i=m;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v2[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        vector<int> result(k,-1);\\n        for(int i=0;i<=k;i++)\\n        {\\n            // cout<<\"i_start= \"<<i<<endl;\\n            // cout<<\"result= \";\\n            // for(auto it:result)cout<<it<<\" \";cout<<endl;\\n            int first=i,second=k-i;\\n            // cout<<\"first= \"<<first<<\" second= \"<<second<<endl;\\n            if(first>n or second>m)continue;\\n            if(first==0)\\n            {\\n                if(great(result,v2[second]))\\n                    result=v2[second];\\n                continue;\\n            }\\n            if(second==0)\\n            {\\n                if(great(result,v1[first]))\\n                    result=v1[first];\\n                continue;\\n            }\\n            // cout<<\"i_end= \"<<i<<endl;\\n            vector<int> temp=merge(v1[first],v2[second]);\\n            if(great(result,temp))\\n                result=temp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n#define ll int\\n#define pb push_back\\nvoid genMax(ll arr[],ll n, vector<ll> nos[]){\\n        ll i=1;\\n        for(ll len=n;len>=1;len--)\\n        {\\n            if(len==n){\\n                for(ll i=1;i<=n;i++)\\n                    nos[len].pb(arr[i]);\\n            }\\n            else\\n            {\\n                i=1;\\n               while(i+1<=n and arr[i]>=arr[i+1])i++;\\n               n-=1;\\n               for(ll j=i;j<=n;j++)arr[j]=arr[j+1];\\n               for(ll j=1;j<=n;j++)nos[len].pb(arr[j]);\\n            }\\n        }\\n    }\\n    bool greater1(vector<ll> v1,int i,vector<ll> v2,int j)\\n    {\\n        while (i < v1.size() && j < v2.size() && v1[i] == v2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == v2.size() || (i < v1.size() && v1[i] > v2[j]);\\n    }\\n    vector<int> merge(vector<int>& v1,vector<int> &v2){\\n        int n=v1.size(),m=v2.size();\\n        int k=n+m;\\n        vector<int> ans(k);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n        ans[r] = greater1(v1, i, v2, j) ? v1[i++] : v2[j++];\\n            return ans;\\n    }\\n    bool great(vector<int> &result,vector<int> &temp){\\n        int k=result.size();\\n        int i=0;\\n        while(i<k and result[i]==temp[i])i++;\\n        if(i<k and result[i] < temp[i])return true;\\n        return false;\\n    }\\nclass Solution {\\npublic:\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size(),m=nums2.size();\\n        int arr1[n+1],arr2[m+1];\\n        for(int i=0;i<n;i++)\\n            arr1[i+1]=nums1[i];\\n        for(int i=0;i<m;i++)\\n            arr2[i+1]=nums2[i];\\n        vector<int> v1[n+1];\\n        vector<int> v2[m+1];\\n        genMax(arr1,n,v1);\\n        genMax(arr2,m,v2);\\n        // for(ll i=n;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v1[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        // for(ll i=m;i>=1;i--)\\n        // {\\n        //     cout<<\"len= \"<<i<<\" : \";\\n        //     for(auto it:v2[i])\\n        //         cout<<it<<\" \";cout<<endl;\\n        // }\\n        vector<int> result(k,-1);\\n        for(int i=0;i<=k;i++)\\n        {\\n            // cout<<\"i_start= \"<<i<<endl;\\n            // cout<<\"result= \";\\n            // for(auto it:result)cout<<it<<\" \";cout<<endl;\\n            int first=i,second=k-i;\\n            // cout<<\"first= \"<<first<<\" second= \"<<second<<endl;\\n            if(first>n or second>m)continue;\\n            if(first==0)\\n            {\\n                if(great(result,v2[second]))\\n                    result=v2[second];\\n                continue;\\n            }\\n            if(second==0)\\n            {\\n                if(great(result,v1[first]))\\n                    result=v1[first];\\n                continue;\\n            }\\n            // cout<<\"i_end= \"<<i<<endl;\\n            vector<int> temp=merge(v1[first],v2[second]);\\n            if(great(result,temp))\\n                result=temp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 692570,
                "title": "tle-naive-dp-solution",
                "content": "Just sharing my pain with others who may have tried similar regular DP approaches instead of breaking it down into smaller sub-problems first.\\n\\nThis does pass 86/102 test cases so I hope it\\'s at least passable for an interview.\\n\\nI wonder if it would fare better if I didn\\'t make as heavy use of strings.\\n\\n```\\nclass Solution {\\n    \\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        Map<String, StringBuilder> memo = new HashMap<>();\\n        StringBuilder sb = helper(0, 0, k, memo);\\n        int[] output = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            output[i] = sb.charAt(i) - \\'0\\';\\n        }\\n        return output;\\n    }\\n    \\n    private String getKey(int i, int j, int k) {\\n        return i + \"_\" + j + \"_\" + k;\\n    }\\n    \\n    private StringBuilder helper(int i, int j, int k, Map<String, StringBuilder> memo) {\\n        if (k == 0) {\\n            return new StringBuilder();\\n        }\\n        String key = getKey(i, j, k);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int nLeft = nums1.length - i + nums2.length - j;\\n        // Take digit\\n        if (i >= nums1.length) {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        } else if (j >= nums2.length) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else if (nums1[i] == nums2[j]) {\\n            sb.append(nums2[j]);\\n            String left = helper(i + 1, j, k - 1, memo).toString();\\n            String right = helper(i, j + 1, k - 1, memo).toString();\\n            if (left.compareTo(right) >= 0) {\\n                sb.append(left);\\n            } else {\\n                sb.append(right);\\n            }\\n        } else if (nums1[i] > nums2[j]) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        }\\n        \\n        if (nLeft > k) {\\n            // can choose not to take anything\\n            StringBuilder sb1 = helper(i + 1, j, k, memo);\\n            StringBuilder sb2 = helper(i, j + 1, k, memo);\\n                    // return the biggest one\\n            String s1 = sb.toString();\\n            String s2 = sb1.toString();\\n            String s3 = sb2.toString();\\n\\n            if (s1.compareTo(s2) >= 0 && s1.compareTo(s3) >= 0) {\\n                memo.put(key, sb);\\n                return sb;\\n            } \\n\\n            if (s2.compareTo(s3) >= 0 && s2.compareTo(s1) >= 0) {\\n                memo.put(key, sb1);\\n                return sb1;\\n            } \\n            memo.put(key, sb2);\\n            return sb2;\\n        }\\n        \\n        memo.put(key, sb);\\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        Map<String, StringBuilder> memo = new HashMap<>();\\n        StringBuilder sb = helper(0, 0, k, memo);\\n        int[] output = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            output[i] = sb.charAt(i) - \\'0\\';\\n        }\\n        return output;\\n    }\\n    \\n    private String getKey(int i, int j, int k) {\\n        return i + \"_\" + j + \"_\" + k;\\n    }\\n    \\n    private StringBuilder helper(int i, int j, int k, Map<String, StringBuilder> memo) {\\n        if (k == 0) {\\n            return new StringBuilder();\\n        }\\n        String key = getKey(i, j, k);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int nLeft = nums1.length - i + nums2.length - j;\\n        // Take digit\\n        if (i >= nums1.length) {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        } else if (j >= nums2.length) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else if (nums1[i] == nums2[j]) {\\n            sb.append(nums2[j]);\\n            String left = helper(i + 1, j, k - 1, memo).toString();\\n            String right = helper(i, j + 1, k - 1, memo).toString();\\n            if (left.compareTo(right) >= 0) {\\n                sb.append(left);\\n            } else {\\n                sb.append(right);\\n            }\\n        } else if (nums1[i] > nums2[j]) {\\n            sb.append(nums1[i]);\\n            sb.append(helper(i + 1, j, k - 1, memo));\\n        } else {\\n            sb.append(nums2[j]);\\n            sb.append(helper(i, j + 1, k - 1, memo));\\n        }\\n        \\n        if (nLeft > k) {\\n            // can choose not to take anything\\n            StringBuilder sb1 = helper(i + 1, j, k, memo);\\n            StringBuilder sb2 = helper(i, j + 1, k, memo);\\n                    // return the biggest one\\n            String s1 = sb.toString();\\n            String s2 = sb1.toString();\\n            String s3 = sb2.toString();\\n\\n            if (s1.compareTo(s2) >= 0 && s1.compareTo(s3) >= 0) {\\n                memo.put(key, sb);\\n                return sb;\\n            } \\n\\n            if (s2.compareTo(s3) >= 0 && s2.compareTo(s1) >= 0) {\\n                memo.put(key, sb1);\\n                return sb1;\\n            } \\n            memo.put(key, sb2);\\n            return sb2;\\n        }\\n        \\n        memo.put(key, sb);\\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651565,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j){\\n        int loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n        for (int i = 0; i < loop_size; i++){\\n            if (nums1[i + start_i] < nums2[i + start_j])\\n                return true;\\n            else if (nums1[i + start_i] > nums2[i + start_j])\\n                return false;\\n        }\\n        return nums1.size() - start_i < nums2.size() - start_j;\\n    }\\n\\n    vector<vector<int>> largetsNum(vector<int>& nums){\\n        vector<vector<int>> res;\\n        res.resize(nums.size() + 1);\\n        res.back() = nums;\\n\\n        for (int i = res.size() - 2; i >= 0; i--){\\t\\n            int idx = 0;\\n            while (idx + 1 < res[i + 1].size()){\\n                if (res[i + 1][idx] < res[i + 1][idx + 1])\\n                    break;\\n                idx++;\\n            }\\n\\n            for (int j = 0; j < res[i + 1].size(); j++){\\n                if (idx != j)\\n                    res[i].push_back(res[i + 1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        while (i < nums1.size() || j < nums2.size()){\\n                if (compare(nums1, nums2, i, j))\\n                    res.push_back(nums2[j++]);\\n                else\\n                    res.push_back(nums1[i++]);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) {\\n        vector<vector<int>> largest_num1 = largetsNum(nums1);\\n        vector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n        vector<int> res;\\n        int start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n        for (int i = start; i < largest_num1.size() && i <= k; i++){\\n            vector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n            if (res.empty() || compare(res, tmp, 0, 0)) res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& nums1, vector<int>& nums2, int start_i, int start_j){\\n        int loop_size = min(nums1.size() - start_i, nums2.size() - start_j);\\n\\n        for (int i = 0; i < loop_size; i++){\\n            if (nums1[i + start_i] < nums2[i + start_j])\\n                return true;\\n            else if (nums1[i + start_i] > nums2[i + start_j])\\n                return false;\\n        }\\n        return nums1.size() - start_i < nums2.size() - start_j;\\n    }\\n\\n    vector<vector<int>> largetsNum(vector<int>& nums){\\n        vector<vector<int>> res;\\n        res.resize(nums.size() + 1);\\n        res.back() = nums;\\n\\n        for (int i = res.size() - 2; i >= 0; i--){\\t\\n            int idx = 0;\\n            while (idx + 1 < res[i + 1].size()){\\n                if (res[i + 1][idx] < res[i + 1][idx + 1])\\n                    break;\\n                idx++;\\n            }\\n\\n            for (int j = 0; j < res[i + 1].size(); j++){\\n                if (idx != j)\\n                    res[i].push_back(res[i + 1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2){\\n        vector<int> res;\\n        int i = 0, j = 0;\\n        while (i < nums1.size() || j < nums2.size()){\\n                if (compare(nums1, nums2, i, j))\\n                    res.push_back(nums2[j++]);\\n                else\\n                    res.push_back(nums1[i++]);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, size_t k) {\\n        vector<vector<int>> largest_num1 = largetsNum(nums1);\\n        vector<vector<int>> largest_num2 = largetsNum(nums2);\\n\\n        vector<int> res;\\n        int start = k > nums2.size() ? k - nums2.size() : 0;\\n\\n        for (int i = start; i < largest_num1.size() && i <= k; i++){\\n            vector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);\\n            if (res.empty() || compare(res, tmp, 0, 0)) res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575872,
                "title": "python-solution",
                "content": "```\\nimport functools\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n1,n2 = len(nums1),len(nums2)\\n        @functools.lru_cache(maxsize=2048)\\n        def recursive(i,j,k):\\n            if k == 0:\\n                return []\\n\\n            m1 = -1\\n            if i < n1:\\n                m1 = max(nums1[i:min(n1,n1+n2-j-k+1)])\\n\\n            m2 = -1\\n            if j < n2:\\n                m2 = max(nums2[j:min(n2,n1+n2-i-k+1)])\\n\\n            if m1 > m2:\\n                ii = i + nums1[i:].index(m1) + 1\\n                return [m1] + recursive(ii,j,k-1)\\n            elif m2 > m1:\\n                jj = j + nums2[j:].index(m2) + 1\\n                return [m2] + recursive(i,jj,k-1)\\n            else:\\n                ii = i + nums1[i:].index(m1) + 1\\n                jj = j + nums2[j:].index(m2) + 1\\n                ans1 = [m1] + recursive(ii,j,k-1)\\n                ans2 = [m2] + recursive(i,jj,k-1)\\n\\n                for a1,a2 in zip(ans1,ans2):\\n                    if a1 > a2:\\n                        return ans1\\n                    elif a2 > a1:\\n                        return ans2\\n\\n                return ans1\\n        \\n        return recursive(0,0,k)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n1,n2 = len(nums1),len(nums2)\\n        @functools.lru_cache(maxsize=2048)\\n        def recursive(i,j,k):\\n            if k == 0:\\n                return []\\n\\n            m1 = -1\\n            if i < n1:\\n                m1 = max(nums1[i:min(n1,n1+n2-j-k+1)])\\n\\n            m2 = -1\\n            if j < n2:\\n                m2 = max(nums2[j:min(n2,n1+n2-i-k+1)])\\n\\n            if m1 > m2:\\n                ii = i + nums1[i:].index(m1) + 1\\n                return [m1] + recursive(ii,j,k-1)\\n            elif m2 > m1:\\n                jj = j + nums2[j:].index(m2) + 1\\n                return [m2] + recursive(i,jj,k-1)\\n            else:\\n                ii = i + nums1[i:].index(m1) + 1\\n                jj = j + nums2[j:].index(m2) + 1\\n                ans1 = [m1] + recursive(ii,j,k-1)\\n                ans2 = [m2] + recursive(i,jj,k-1)\\n\\n                for a1,a2 in zip(ans1,ans2):\\n                    if a1 > a2:\\n                        return ans1\\n                    elif a2 > a1:\\n                        return ans2\\n\\n                return ans1\\n        \\n        return recursive(0,0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573843,
                "title": "my-three-solutions-dp-recursive-greedy-not-totally-correct-solution-all-not-ac",
                "content": "Divide and Conquer, Recursive solution (will trigger time limit exceed, 88 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    int k, h = 0;\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        this.k = k;\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String resultValue = getMaxNumber(nums1, nums2, 0);\\n        \\n        int i = 0;\\n        while(i < this.k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n\\n    }\\n\\n    public String getMaxNumber(int[] nums1, int[] nums2, int h){\\n        StringBuilder result = new StringBuilder();\\n        if(h >= this.k){\\n            return result.toString();\\n        }\\n        Map<String, Integer> map1 = findMax(nums1, nums1.length, nums2.length, h);\\n        Map<String, Integer> map2 = findMax(nums2, nums2.length, nums1.length, h);\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\") && map1.get(\"maxIndex\") == -1){\\n            return result.toString();\\n        }\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n            String tmp1 = getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, 1 + h);\\n            String tmp2 = getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), 1 + h);\\n            //get max of tmp1 and tmp2\\n            for(int i = 0; i < tmp1.length(); i++){\\n                if(tmp1.charAt(i) > tmp2.charAt(i)){\\n                    return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n                } else if(tmp1.charAt(i) < tmp2.charAt(i)) {\\n                    return result.append(map1.get(\"maxValue\")).append(tmp2).toString();\\n                }\\n            }\\n            return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n        } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n            return result.append(map1.get(\"maxValue\")).append(getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, ++h)).toString();\\n        } else {\\n            return result.append(map2.get(\"maxValue\")).append(getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), ++h)).toString();\\n        }\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int h){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - this.k + h + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n\\nDynamic Programming solution (will trigger time limit exceed, 85 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String [][][] resultValues = getMaxNumber(nums1, nums2, k);\\n        String resultValue = resultValues[nums1.length][nums2.length][k];\\n        int i = 0;\\n        while(i < k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n    }\\n\\n    public String[][][] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        String [][][] result = new String[nums1.length + 1][nums2.length + 1][k + 1];\\n        int m = nums1.length, n = nums2.length;\\n\\n        //init\\n        Map<String, Integer> map1, map2;\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                if(h == 0 || h > i){\\n                    result[i][0][h] = \"\";\\n                    continue;\\n                }\\n                map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, 0, h);\\n                result[i][0][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][0][h - 1];\\n            }\\n            for(int j = 1; j < n + 1; j++){\\n                if(h == 0 || h > j){\\n                    result[0][j][h] = \"\";\\n                    continue;\\n                }\\n                map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, 0, h);\\n                result[0][j][h] = map2.get(\"maxValue\") + result[0][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n            }\\n            result[0][0][h] = \"\";\\n        }\\n\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                for(int j = 1; j < n + 1; j++){\\n                    if(h > i + j || h == 0){\\n                        result[i][j][h] = \"\";\\n                        continue;\\n                    }\\n                    map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, j, h);\\n                    map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, i, h);\\n                    if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                        String tmp1 = result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                        String tmp2 = result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                        //get max of tmp1 and tmp2\\n                        for(int l = 0; l < tmp1.length(); l++){\\n                            if(tmp1.charAt(l) > tmp2.charAt(l)){\\n                                result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                                break;\\n                            } else if(tmp1.charAt(l) < tmp2.charAt(l)) {\\n                                result[i][j][h] = map2.get(\"maxValue\") + tmp2;\\n                                break;\\n                            }\\n                        }\\n                        if(result[i][j][h] == null) result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                    } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                        result[i][j][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                    } else {\\n                        result[i][j][h] = map2.get(\"maxValue\") + result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n\\nGreedy solution (not completely correct, 91 / 102 test cases passed.)\\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length || k <= 0){\\n            return null;\\n        }\\n        result = getMaxNumber(nums1, nums2, k);\\n        return result;\\n    }\\n\\n    public int[] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        int [] result = new int[k];\\n        int m = nums1.length, n = nums2.length;\\n        Map<String, Integer> map1, map2, tmpMapi1, tmpMapj1, tmpMapi2, tmpMapj2;\\n        int i = 0, j = 0, tmpi = 0, tmpj = 0;\\n        \\n        for(int h = 0; h < k; h++){\\n            map1 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - j, k - h);\\n            map2 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - i, k - h);\\n            if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                tmpMapi1 = map1;\\n                tmpMapj1 = map2;\\n                tmpMapi2 = map1;\\n                tmpMapj2 = map2;\\n                tmpi = i;\\n                tmpj = j;\\n                //9\\uFF0C10 \\uFF1B 9\\uFF0C10  \\u600E\\u4E48\\u5904\\u7406\\u3002\\n                while(h < k && Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) == Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))\\n                        && tmpMapi1.get(\"maxValue\") >= tmpMapj1.get(\"maxValue\") \\n                        && tmpMapj2.get(\"maxValue\") >= tmpMapi2.get(\"maxValue\")){\\n                    result[h++] = Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\"));\\n                    //always choose nums1\\n                    tmpi = tmpi + tmpMapi1.get(\"maxIndex\") + 1;\\n                    tmpMapi1 = findMax(Arrays.copyOfRange(nums1, tmpi, m), m - tmpi, n - j, k - h);\\n                    tmpMapj1 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - tmpi, k - h);\\n                    //always choose nums2\\n                    tmpj = tmpj + tmpMapj2.get(\"maxIndex\") + 1;\\n                    tmpMapi2 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - tmpj, k - h);\\n                    tmpMapj2 = findMax(Arrays.copyOfRange(nums2, tmpj, n), n - tmpj, m - i, k - h);\\n                    if(tmpMapi1.get(\"maxIndex\") == -1 || tmpMapj2.get(\"maxIndex\") == -1){\\n                        break;\\n                    }\\n                }\\n                if(Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) > Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))){\\n                    i = tmpi;\\n                    h--;\\n                } else {\\n                    j = tmpj;\\n                    h--;\\n                }\\n            } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                i = i + map1.get(\"maxIndex\") + 1;\\n                result[h] = map1.get(\"maxValue\");\\n            } else {\\n                j = j + map2.get(\"maxIndex\") + 1;\\n                result[h] = map2.get(\"maxValue\");\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    int k, h = 0;\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        this.k = k;\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String resultValue = getMaxNumber(nums1, nums2, 0);\\n        \\n        int i = 0;\\n        while(i < this.k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n\\n    }\\n\\n    public String getMaxNumber(int[] nums1, int[] nums2, int h){\\n        StringBuilder result = new StringBuilder();\\n        if(h >= this.k){\\n            return result.toString();\\n        }\\n        Map<String, Integer> map1 = findMax(nums1, nums1.length, nums2.length, h);\\n        Map<String, Integer> map2 = findMax(nums2, nums2.length, nums1.length, h);\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\") && map1.get(\"maxIndex\") == -1){\\n            return result.toString();\\n        }\\n        if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n            String tmp1 = getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, 1 + h);\\n            String tmp2 = getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), 1 + h);\\n            //get max of tmp1 and tmp2\\n            for(int i = 0; i < tmp1.length(); i++){\\n                if(tmp1.charAt(i) > tmp2.charAt(i)){\\n                    return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n                } else if(tmp1.charAt(i) < tmp2.charAt(i)) {\\n                    return result.append(map1.get(\"maxValue\")).append(tmp2).toString();\\n                }\\n            }\\n            return result.append(map1.get(\"maxValue\")).append(tmp1).toString();\\n        } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n            return result.append(map1.get(\"maxValue\")).append(getMaxNumber(Arrays.copyOfRange(nums1, map1.get(\"maxIndex\") + 1, nums1.length), nums2, ++h)).toString();\\n        } else {\\n            return result.append(map2.get(\"maxValue\")).append(getMaxNumber(nums1, Arrays.copyOfRange(nums2, map2.get(\"maxIndex\") + 1, nums2.length), ++h)).toString();\\n        }\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int h){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - this.k + h + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length){\\n            return null;\\n        }\\n        String [][][] resultValues = getMaxNumber(nums1, nums2, k);\\n        String resultValue = resultValues[nums1.length][nums2.length][k];\\n        int i = 0;\\n        while(i < k){\\n            result[i] = resultValue.charAt(i++) - \\'0\\';\\n        }\\n        return result;\\n    }\\n\\n    public String[][][] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        String [][][] result = new String[nums1.length + 1][nums2.length + 1][k + 1];\\n        int m = nums1.length, n = nums2.length;\\n\\n        //init\\n        Map<String, Integer> map1, map2;\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                if(h == 0 || h > i){\\n                    result[i][0][h] = \"\";\\n                    continue;\\n                }\\n                map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, 0, h);\\n                result[i][0][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][0][h - 1];\\n            }\\n            for(int j = 1; j < n + 1; j++){\\n                if(h == 0 || h > j){\\n                    result[0][j][h] = \"\";\\n                    continue;\\n                }\\n                map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, 0, h);\\n                result[0][j][h] = map2.get(\"maxValue\") + result[0][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n            }\\n            result[0][0][h] = \"\";\\n        }\\n\\n        for(int h = 0; h < k + 1; h++){\\n            for(int i = 1; i < m + 1; i++){\\n                for(int j = 1; j < n + 1; j++){\\n                    if(h > i + j || h == 0){\\n                        result[i][j][h] = \"\";\\n                        continue;\\n                    }\\n                    map1 = findMax(Arrays.copyOfRange(nums1, m - i, m), i, j, h);\\n                    map2 = findMax(Arrays.copyOfRange(nums2, n - j, n), j, i, h);\\n                    if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                        String tmp1 = result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                        String tmp2 = result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                        //get max of tmp1 and tmp2\\n                        for(int l = 0; l < tmp1.length(); l++){\\n                            if(tmp1.charAt(l) > tmp2.charAt(l)){\\n                                result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                                break;\\n                            } else if(tmp1.charAt(l) < tmp2.charAt(l)) {\\n                                result[i][j][h] = map2.get(\"maxValue\") + tmp2;\\n                                break;\\n                            }\\n                        }\\n                        if(result[i][j][h] == null) result[i][j][h] = map1.get(\"maxValue\") + tmp1;\\n                    } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                        result[i][j][h] = map1.get(\"maxValue\") + result[i - (map1.get(\"maxIndex\") + 1)][j][h - 1];\\n                    } else {\\n                        result[i][j][h] = map2.get(\"maxValue\") + result[i][j - (map2.get(\"maxIndex\") + 1)][h - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int [] result = new int[k];\\n        if(k > nums1.length + nums2.length || k <= 0){\\n            return null;\\n        }\\n        result = getMaxNumber(nums1, nums2, k);\\n        return result;\\n    }\\n\\n    public int[] getMaxNumber(int[] nums1, int[] nums2, int k){\\n        int [] result = new int[k];\\n        int m = nums1.length, n = nums2.length;\\n        Map<String, Integer> map1, map2, tmpMapi1, tmpMapj1, tmpMapi2, tmpMapj2;\\n        int i = 0, j = 0, tmpi = 0, tmpj = 0;\\n        \\n        for(int h = 0; h < k; h++){\\n            map1 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - j, k - h);\\n            map2 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - i, k - h);\\n            if(map1.get(\"maxValue\") == map2.get(\"maxValue\")){\\n                tmpMapi1 = map1;\\n                tmpMapj1 = map2;\\n                tmpMapi2 = map1;\\n                tmpMapj2 = map2;\\n                tmpi = i;\\n                tmpj = j;\\n                //9\\uFF0C10 \\uFF1B 9\\uFF0C10  \\u600E\\u4E48\\u5904\\u7406\\u3002\\n                while(h < k && Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) == Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))\\n                        && tmpMapi1.get(\"maxValue\") >= tmpMapj1.get(\"maxValue\") \\n                        && tmpMapj2.get(\"maxValue\") >= tmpMapi2.get(\"maxValue\")){\\n                    result[h++] = Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\"));\\n                    //always choose nums1\\n                    tmpi = tmpi + tmpMapi1.get(\"maxIndex\") + 1;\\n                    tmpMapi1 = findMax(Arrays.copyOfRange(nums1, tmpi, m), m - tmpi, n - j, k - h);\\n                    tmpMapj1 = findMax(Arrays.copyOfRange(nums2, j, n), n - j, m - tmpi, k - h);\\n                    //always choose nums2\\n                    tmpj = tmpj + tmpMapj2.get(\"maxIndex\") + 1;\\n                    tmpMapi2 = findMax(Arrays.copyOfRange(nums1, i, m), m - i, n - tmpj, k - h);\\n                    tmpMapj2 = findMax(Arrays.copyOfRange(nums2, tmpj, n), n - tmpj, m - i, k - h);\\n                    if(tmpMapi1.get(\"maxIndex\") == -1 || tmpMapj2.get(\"maxIndex\") == -1){\\n                        break;\\n                    }\\n                }\\n                if(Math.max(tmpMapi1.get(\"maxValue\"), tmpMapj1.get(\"maxValue\")) > Math.max(tmpMapi2.get(\"maxValue\"), tmpMapj2.get(\"maxValue\"))){\\n                    i = tmpi;\\n                    h--;\\n                } else {\\n                    j = tmpj;\\n                    h--;\\n                }\\n            } else if (map1.get(\"maxValue\") > map2.get(\"maxValue\")){\\n                i = i + map1.get(\"maxIndex\") + 1;\\n                result[h] = map1.get(\"maxValue\");\\n            } else {\\n                j = j + map2.get(\"maxIndex\") + 1;\\n                result[h] = map2.get(\"maxValue\");\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Map<String, Integer> findMax(int[] nums, int m, int n, int k){\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"maxIndex\", -1);\\n        map.put(\"maxValue\", -1);\\n        if(m == 0){\\n            return map;\\n        }\\n        int maxIndex = 0;\\n        int maxValue = nums[maxIndex];\\n        for(int i = maxIndex + 1; i < Math.min(m, m + n - k + 1); i++){\\n            if(nums[i] > maxValue){\\n                maxIndex = i;\\n                maxValue = nums[i];\\n            }\\n        }\\n        map.put(\"maxIndex\", maxIndex);\\n        map.put(\"maxValue\", maxValue);\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567690,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1569073,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567248,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1814460,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1575654,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1574818,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1573634,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1570516,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1571577,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 2045990,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567690,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1569073,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1567248,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1814460,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1575654,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1574818,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1573634,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1570516,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 1571577,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            },
            {
                "id": 2045990,
                "content": [
                    {
                        "username": "CrackItSean",
                        "content": "\"Create the maximum number of length k <= m + n from digits of the two numbers.\"\\n\\nDon\\'t know it\\'s a coding test or a language test."
                    },
                    {
                        "username": "CristianoJason",
                        "content": "I`m sorry for my poor English first.\\nDoes this problem aim at finding the max sum of length k?\\nIf so, for [3,4,6,5] & [9,1,2,5,8,3] with k = 5, why not choose [9,8,4,6,5] instead of [9,8,6,5,3]?\\nI have many assumptions but I cannot link them to this problem with a proper explaination.\\nCould anyone can explain this problem to me especially in Chinese?\\nThanks a lot!"
                    },
                    {
                        "username": "CPWithAkshay",
                        "content": "[9,8,4,6,5]  evaluates to 98,465 and [9,8,6,5,3] evaluates to 98,653 which is greater than 98465. Hence the solution\\n"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Apologize if the question is too naive, but will the example 3 shall return [8,9,3,9]?\\nThe only requirement is 4<=2+2 in length and digits in initial order.\\n\\nWhy the result should be 3 digits, not 4?\\n\"\\nExample 3:\\n\\nnums1 = [3, 9]\\nnums2 = [8, 9]\\nk = 3\\nreturn [9, 8, 9] \\n\"\\n\\nWish some clarification.\\n\\nThanks!"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "20je0321",
                        "content": "[@av9514843](/av9514843) if u pick 9 first then ans is of length 2 possible because there is no remaining digit 9 is end point\\n"
                    },
                    {
                        "username": "krazyhair",
                        "content": "[@av9514843](/av9514843) The reason why is because the relative order of the elements must remain the same. Remember that `nums1 = [3,9]` and `num2 = [8,9]`. `[9,9,8]` would violate this principle since it would take the second number of nums2 (`9`) before the first (`8`). Let me know if you are still confused and feel free to check out my solution [here](https://leetcode.com/problems/create-maximum-number/solutions/2881277/c-easy-to-understand-with-in-depth-explanation-o-k-n-k-2/)!"
                    },
                    {
                        "username": "av9514843",
                        "content": "[@krazyhair](/krazyhair)  why the answer is [9,8,9] instead of [9,9,8] ?"
                    },
                    {
                        "username": "krazyhair",
                        "content": "The reason why is because k refers to the maximum number of digits that you can use to create the largest number possible. The answer you provided would be correct if `k = 4`"
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of the hardest problems within the 88 hard problems I've solved so far! \n\nTip 1: `k = k1 + k2` where `k1` is the number of elements taken from `nums1`, and `k2` is the number of elements taken from `nums2`. Try all the possible `k1` values.\n\nTip 2: for each `k1`, combine solutions for these problems: [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/) and [1754. Largest Merge Of Two Strings](https://leetcode.com/problems/largest-merge-of-two-strings/)."
                    },
                    {
                        "username": "bytheby",
                        "content": "That was really helpful! \\nIf anyone is looking for the code for this approach, here you go.\\n\\n```\\nclass comp{\\n    public:\\n    bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        else return p1.first < p2.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        priority_queue <pair<int, int>, vector<pair<int, int>>, comp> pq;\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            pq.push({nums[i], i});\\n            if(i >= nums.size() - k){\\n                auto f = pq.top();\\n                pq.pop();\\n\\n                int ind = f.second;\\n                ans.push_back(f.first);\\n\\n                while(!pq.empty() && pq.top().second < ind) pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> largestMerge(vector<int>& w1, vector<int>& w2) {\\n        int n1 = w1.size();\\n        int n2 = w2.size();\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n\\n        while(i < n1 && j < n2){\\n            if(w1[i] - w2[j]> 0){\\n                ans.push_back(w1[i++]);\\n            }\\n            else if(w1[i] - w2[j]< 0){\\n                ans.push_back(w2[j++]);\\n            }\\n            else{\\n                string s1(begin(w1) + i, end(w1));\\n                string s2(begin(w2) + j, end(w2));\\n                if(s1 > s2) ans.push_back(w1[i++]);\\n                else ans.push_back(w2[j++]);\\n                }\\n            }\\n            \\n\\n        while(i < n1) ans.push_back(w1[i++]);\\n        while(j < n2) ans.push_back(w2[j++]);\\n\\n        return ans;\\n    }\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        vector<int> ans(k, 0);\\n        for(int i = 0; i <= k; i++){\\n            int first = i;\\n            int second = k - i;\\n\\n\\n            if(first > nums1.size()) break;\\n            if(second > nums2.size()) continue;\\n            vector<int> v1 = mostCompetitive(nums1, first);\\n            vector<int> v2 = mostCompetitive(nums2, second);\\n            \\n            vector<int> v3 = largestMerge(v1, v2);\\n\\n            string s1(begin(v3), end(v3));\\n\\n            string s2(begin(ans), end(ans));\\n\\n            if(s1 > s2) ans = v3;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anil_danu",
                        "content": "this question will help\\n https://leetcode.com/problems/find-the-most-competitive-subsequence/\\n try to map to this question"
                    },
                    {
                        "username": "Finesse",
                        "content": "That medium question is very easy to me, but I still can't solve this hard question.\n\nThis problem looks very similar too: https://leetcode.com/problems/largest-merge-of-two-strings/"
                    },
                    {
                        "username": "navneetkchy",
                        "content": "I have seen in many problem in leetcode where they don\\'t give any constrains which can be cumbersome\\nto figure out which kind of solution you should approch even if you have idea for a solution you don\\'t know whether you will get  time limit exceded error"
                    },
                    {
                        "username": "dp_1620",
                        "content": "Thank you :)"
                    },
                    {
                        "username": "kotasc_18",
                        "content": "hi\\nra ela unnav i am good"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Hmmm... Telugu \\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "rangerbottle",
                        "content": "nums1 = [3, 4, 6, 5]\\nnums2 = [9, 1, 2, 5, 8, 3]\\nk = 5\\nreturn [9, 8, 6, 5, 3]\\n\\nThe answer could be  [9, 8, 3, 6, 5], / [9,5,8,6,3], am I right?"
                    },
                    {
                        "username": "vnaticzhock",
                        "content": "The author puts the constraint \"k <= m + n\" into the question lines, how ridiculous:)\\nWe can just ignore it, because the question only wants us to make a k-digits number, that\\'s all!"
                    }
                ]
            }
        ]
    }
]