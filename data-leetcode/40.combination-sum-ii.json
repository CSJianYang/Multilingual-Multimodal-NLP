[
    {
        "title": "Combination Sum II",
        "question_content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates&nbsp;where the candidate numbers sum to target.\nEach number in candidates&nbsp;may only be used once in the combination.\nNote:&nbsp;The solution set must not contain duplicate combinations.\n&nbsp;\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;candidates.length <= 100\n\t1 <=&nbsp;candidates[i] <= 50\n\t1 <= target <= 30",
        "solutions": [
            {
                "id": 16878,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16861,
                "title": "java-solution-using-dfs-easy-understand",
                "content": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277764,
                "title": "combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions",
                "content": "**SUBSETS** \\nhttps://leetcode.com/problems/subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\\n\\n**SUBSETS II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\\n----------------------------------------------------------------------------------\\n**PERMUTATIONS**\\nhttps://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\\n**PERMUTATIONS II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\\n-------------------------------------------------------------------------------------------\\n**COMBINATION SUM**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM III**\\nhttps://leetcode.com/problems/combination-sum-iii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16944,
                "title": "beating-98-python-solution-using-recursion-with-comments",
                "content": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "codeTag": "Python3"
            },
            {
                "id": 750378,
                "title": "python3-dfs-solutions-templates-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16862,
                "title": "c-backtracking-solution-with-detailed-explanation",
                "content": "At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a  iterative component and a resursive component so I'd like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }\\n        void findCombination(vector<vector<int>>& res, const int order, const int target, vector<int>& local, const vector<int>& num)\\n        {\\n            if(target==0)\\n            {\\n                res.push_back(local);\\n                return;\\n            }\\n            else\\n            {\\n                for(int i = order;i<num.size();i++) // iterative component\\n                {\\n                    if(num[i]>target) return;\\n                    if(i&&num[i]==num[i-1]&&i>order) continue; // check duplicate combination\\n                    local.push_back(num[i]),\\n                    findCombination(res,i+1,target-num[i],local,num); // recursive componenet\\n                    local.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17020,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16870,
                "title": "dp-solution-in-python",
                "content": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "solutionTags": [
                    "Python"
                ],
                "code": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "codeTag": "Python3"
            },
            {
                "id": 1350766,
                "title": "100-faster-c-solution-with-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16884,
                "title": "a-smaller-trick-to-improve-a-lot-beat-92-35",
                "content": "Most people who use recursive backtrack to solve this question have code like:\\n\\n```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\\n\\nThis is absolutely correct. However, we can do much more pruning by breaking much earlier. \\n\\nFor example: the list is [1, 1,  2, 5, 6, 7, 10], target is 8 and the current list is [1, 1, 2]. Now we are at 5, and we know that [1, 1, 2, 5] will be greater than 8. The next to check is [1, 1, 2, 6]. However, we should already know that [1, 1, 2, 6] cannot work since [1, 1, 2, 5] already has a sum larger than 8. There is no need to check for [1, 1,  2, 6] or [1, 1, 2, 7] and so no.\\n\\nThus, when we find a match or the current sum is already larger than the target, we should not continue with the current list.\\n\\nThe code is something like:\\n\\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213780,
                "title": "3-backtracking-variations-java-beats-100",
                "content": "**Backtracking With Visited Array (using space)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**Backtracking With Prev Variable (space efficient)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**BackTracking Subsequence method**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16916,
                "title": "understanding-the-differences-between-the-dp-solution-and-simple-recursive-which-one-is-really-better",
                "content": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "solutionTags": [],
                "code": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "codeTag": "Unknown"
            },
            {
                "id": 1656844,
                "title": "solution-swift-combination-sum-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815837,
                "title": "backtracking-recursion-python-solution-with-illustration",
                "content": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3441047,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546439,
                "title": "java-backtracking-optimized-for-duplicate-candidates-detailed-tc-explanation-added",
                "content": "**Backtracking**\\n```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Optimized Backtracking by using a Count Map and Unique Num List**\\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17035,
                "title": "my-concise-14ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }\\n        \\n        void combHelper(vector<int>& a, int start, int n, int target, \\n        vector<int> cur_vec, vector<vector<int> >& result) {\\n            \\n            if (target == 0) {\\n                result.push_back(cur_vec);\\n                return;\\n            }\\n            int i = start;\\n            while(i < n  && target-a[i] >= 0) {\\n                // NOTE : this condition helps neglecting making identical sets\\n                //  this is the catch of this question\\n                if (i == start || a[i] != a[i-1]) {\\n                    cur_vec.push_back(a[i]);\\n                    combHelper(a, i+1, n, target-a[i], cur_vec, result);\\n                    cur_vec.pop_back();\\n                }\\n                i++;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 883077,
                "title": "very-easy-python-solution-beats-98-related-problems-to-solve",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```\\n\\nOther related Qs to solve that will help:\\n#77 Combinations\\n#permutations LC 76\\n#permutations II \\n#subsets\\n#subsets II\\n#combinations sum LC 39",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889492,
                "title": "simple-java-solution-with-comments-beats-98-2ms",
                "content": "**Algorithm:**\\n- Sort the array to ensure we have duplicate elements together.\\n- For every element in the array\\n\\t- include the element and see if we can achieve target\\n\\t- exclude the element and see if we can achieve target\\n\\t\\t- while exclusion skip all the duplicate entries\\n\\n```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211544,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934668,
                "title": "backtracking-solution-with-time-complexity-explanations-in-c",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- As we have to return all the unique combinations, so we\\u2019ll sort the array to skip duplicates.\\n- The base case for our helper function is when the target will be 0 then we\\u2019ll push our temp to ans.\\n- So here for every recursion, we\\u2019ll take a loop to check which could be our next possible element. Here we can have 2 cases:\\n    - `if(i>index && candidates[i]==candidates[i-1])` we\\u2019ve already taken an element with the same value of current element, so simply skip it.\\n    - `if(candidates[i] > target)` as current element is greater than target & the array is in sorted order, so no chance to get any possible solution from the next elements, so break the loop.\\n- We\\u2019ll push the current element to our temp vector & call recursion for the next index, also reducing the target value.\\n- After the call, we\\u2019ve to pop the current element from temp as we already used this element.\\n- **Time complexity:** O(2^n * k), where 2^n is the total number of subsequences & k is the average of every combination.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16871,
                "title": "time-complexity-analysis-of-recursive-approach",
                "content": "On the first thought, the time complexity analysis of this brute force approach looks difficult. We are going through each element and calling recursively on each of those elements. Is it n ^ n ? \\n\\nThe fact that we are doing brute force gives us the answer of complexity. If you think, we are essentially selecting all possible subsets of  of set.\\n\\n{1,2,3} -> {1} {2} {3} {1,2} {1,3} {2,3} {1,2,3}\\n\\nThere are **2 ^n** such elements and hence the time complexity is **O(2^n)**\\n\\n**Example:**\\nIt is easy to see this with example also. We select input that will explore all the paths such as {1,2,3,4,5,6,7} and the target is big enough so it will not prune any path. It will call the iteration  128 times.\\n```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16958,
                "title": "8ms-c-backtracking-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 738352,
                "title": "javascript-fast-solution-avoid-duplication",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16933,
                "title": "my-84ms-python-recursive-solution",
                "content": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "solutionTags": [],
                "code": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3866692,
                "title": "easy-explanation-using-images-and-dry-run-using-set-without-set",
                "content": "# Understanding the Question\\nHELLO! Lets analyze how to solve this problem. well if you are solving this problem then i am assuming that you already solved **Combination Sum 1 problem** , Where we could pick any value multiple times. \\nThis problem is a little different. Here we cant choose a single value multiple times, also here is one more thing. if we get ans=[[1,7],[7,1]] then our final ans will be [[1,7]] as duplicate combinations are not allowed.\\n\\n# Approach\\nIn combination sum 1 problem we had two choices--\\n- Either pick the current element and again pick the same element.\\n**OR**\\n- dont pick the current element, move 1 step ahead and repeat the same process\\n\\nBut in combination sum 2 problem we cant choose one value multiple times. so what options do we have?\\n- Either choose the value and move ahead\\n**OR**\\n- Dont pick the value and move ahead\\n\\nso how will our recurrence relations will look?\\n\\n- f(i+1,sum-arr[i],arr)  ***Pick the value and move on to next index***\\n**OR**\\n- f(i+1,sum,arr)  ***dont pick the value but move onto next index***\\n\\nnow take a simple example to understand recursive calls:\\nlets take **arr=[1,1,7]** and **target=8**\\nhere i have attached a picture where pick and not_pick calls happens\\n*(pardon my drawing, i draw using trackpad)*\\n\\n![Screenshot (11).png](https://assets.leetcode.com/users/images/295b4fbd-00f7-46ce-83d0-06d0942eec33_1691228467.687165.png)\\n\\nhere as you can see at last we are getting 2 answers [[1,7],[1,7]]\\nbut as we know duplicate combinations are not allowed so we have to find a way to only get one set of combination.\\n\\n***There are Two ways-***\\n1. Using Set Data Structure\\n2. Using Brain\\n\\n*i will not talk about how to use set as it is very easy.Although i will share the code using set ds.*\\n\\n**Lets talk about the second approach--**\\n1. if you carefully observe the answer of test cases in this problem you can notice that all the combination set are sorted. means [1,7] then [2,6] this way.\\nso to achive combinations in sorted order we need to sort our arr as well.\\n2. our main reason why we are getting [1,7] twice is because there is two 1 in our arr.\\nif u see previous image which i attached u will see that when i picked the 1 **[0th index]** i got [1,7] as an answer combination. \\nand when i **didn\\'t picked** the 1 **[0th index]** i had another 1 **[1st index]** which is going in the next recursive call and giving me an extra [1,7] combination.\\n\\n3. so if i can manipulate my code in a way that at the time of not picking the element, which i already picked **1** **[0th index]** ,will not go to the not pick call with the same value then we can avoid getting the duplicate.\\n\\n![Screenshot (12).png](https://assets.leetcode.com/users/images/7ba37cfd-eb6c-4b35-9068-4fa510c92856_1691230268.4377675.png)\\n\\n4. see here i picked 1**[0th index]**  which is okay.\\n5. but when i am not picking 1[0th index], i am not letting any 1 value pass to the not pick call.\\n6. i have picked 1 so at the time of not pick i\\'ll avoid all the 1 present in the array.\\n7. to skip all the 1, i have used a loop. \\n8. pick 1 and go to next index. \\nbut if dont pick 1 then dont pick any 1 value and go directly to the next unique element which is 7.\\n\\nI am not explaning about the base case here. if you r having hard time finding how i got the base case then plz comment down below. I will reply.\\n\\n***now see the above 2 picture again. spot the difference.***\\n# PLZ UPVOTE IF YOU UNDERSTOOD THE APPROACH (\\u25CF\\'\\u25E1\\'\\u25CF)\\n\\n# Time Complexity:\\nTime complexity will be $O(2^n*n)$\\n$2^n$ because every element have two choices either pick or not pick.\\nand n extra because we are using a while loop inside the recursive function which will add n time complexity.\\n\\n# Code using SET\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\\n\\n# Code Using Brain\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057690,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905802,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16877,
                "title": "java-short-and-recursive-clean-code",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 708266,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451893,
                "title": "small-difference-between-combination-sum-1-and-2-c-backtracking",
                "content": "**Combination Sum I**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\n**Combination Sum II**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\nAs you can see the only **difference** in the above two codes is the ith parameter we pass in our recursive function.\\nIn Combination Sum I, we may want to add the current element again so we don\\'t increment i while passing it to the recursive function.\\nIn Combination Sum II, each number may be used only once hence once we include an element we move on to the next element by incrementing i by 1.\\n\\nTime complexity is O(2^n) because for every number we have two choices.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934838,
                "title": "two-dp-solutions-in-java-with-explanation",
                "content": "# Method 1: With Hash Table\\nConsider a 2D dp array, where `dp[i][j]` is all combinations using `candidates[0]` to `candidates[i]` that sum to `j`. Our goal is `dp[n - 1][target]`, where `n` is the number of candidates.\\n\\nThe transition function is `dp[i][j] = d[i - 1][j] + d[i - 1][j - candidates[i]].add(candidates[i])`. \\n\\nThe first term on right hand side, `d[i - 1][j]`, is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j`. This is part of `d[i][j]`, when we don\\'t include `candidates[i]` in the combination (because the sum is already `j`). \\n\\nThe second term on right hand side, `d[i - 1][j - candidates[i]]` is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j - candidates[i]`. This is other parts of `d[i][j]` when we include `candidates[i]` in the combination (because `j - candidates[i] + candidates[i] = j`. \\n\\n`.add(candidates[i])` means we are adding `candidates[i]` to each of the combination in `d[i - 1][j - candidates[i]]`\\n\\nSince the `candidates[]` array has duplicates, we need to avoid adding duplicate combinations to our result. We can use hash table to accomplish this, the dp array can be defined as:\\n```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\\n\\nWe also need to sort the `candidates` array to avoid duplicates. Consider candidates being `[1,6,1,1]`, and target is `7`. If we don\\'t sort, we would have `[1,6],[6,1],[6,1]` as the combination. The hash table will only screen the two `[6,1]`, but not `[1,6],[6,1]`, because they are considered different `List<Integer>`. If we sort the candidate so it becomes `[1,1,1,6]`, and the three combinations sum to `7` is `[1,6],[1,6],[1,6]`, hash table can screen off duplicates, only one `[1,6]` will be present in the result.\\n\\n\\nBelow is the java code:\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\\n\\n# Method 2: Without Hash Table\\nThis method has the same time and space complexity as method 1, so there is no advantage with respect to time/space. Just another way of thinking. \\n\\nWe keep two lists, `combs` to store all the temporary combinations we encountered, `sums` to store the sum for those combinations. When adding `candidates[i]` to our current collection of combinations, we check if its been encountered before. If so, we will not add it to earlier combinations (because those combinations already contain this number). For any combinations that sum to `target`, we add it to the final result.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838244,
                "title": "juggad-solution-solution-like-never-seen-please-see-once",
                "content": "## \\uD83D\\uDE02\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118021,
                "title": "brute-force-to-optimal-solution-beats-99-89",
                "content": "brutforce to optimal solution:-\\n\\n*Brutforce*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\\nit`s give the TLE\\n\\n*optimal:-*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840482,
                "title": "python-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16985,
                "title": "java-solutions-beats-99-87",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }\\n        \\n        private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List<List<Integer>> results) {\\n            if (target == 0) {\\n                List<Integer> result = new ArrayList<>();\\n                for (int i = 0; i < lindex; i++) {\\n                    result.add(list[i]);\\n                }\\n                results.add(result);\\n                return;\\n            }\\n            \\n            int prev = 0;\\n            for (int i = cindex; i < candidates.length; i++) {\\n                if (candidates[i] != prev) {\\n                    if (target - candidates[i] < 0) {\\n                        break;\\n                    }\\n                    \\n                    list[lindex] = candidates[i];\\n                    calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results);\\n                    prev = candidates[i];\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3696443,
                "title": "backtracking-concept",
                "content": "# Backtracking Logic\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774415,
                "title": "combinations-sum-2-java-solution-2-line-adding-in-combinations-sum-1",
                "content": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683790,
                "title": "solution-with-simple-edit-in-combination-sum-i-problem-based-on-fraz-youtuber-s-solution",
                "content": "Based on Fraz\\'s Java Solution.\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```\\n\\nHope this helps.\\nPlease upvote if this helped you :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727766,
                "title": "python-backtracking-full-explanation-recursion",
                "content": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```\\n\\n**Time Complexity - 2^n * k\\nSpace complexity - k * x**\\n\\nk: average length of every combinations\\nx: total combinations\\n\\n![image](https://assets.leetcode.com/users/images/05dd7a00-0907-49c8-805b-31d17eb21f3e_1643432927.4891348.jpeg)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1671782,
                "title": "c-100-backtrack",
                "content": "**Runtime:** 0 ms, faster than 100.00% of C++ online submissions for Combination Sum II.\\n**Memory Usage:** 10.6 MB, less than 71.06% of C++ online submissions for Combination Sum II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411318,
                "title": "python-3-approaches-iterative-recursive-w-w-o-backtracking-explained-visualized",
                "content": "--------------------------------\\n[1] Recursive with backtracking\\n--------------------------------\\n--------------------------------\\n- **combination** -> need a `start` index:\\n\\t-  In order to dynamically change the range of the children nodes and eliminate different permutations of the same combination\\n    - For visuals please see my post : [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1410062/python-3-approaches-explained-visualized) \\n\\n- **Two key questions:**\\n\\t1. Are we allowed to use the same integer twice? `(i vs. i+1)` in the recursive call\\n\\t2. Are we allowed to have duplicate combos? \\n\\t\\t- If yes, sort and eliminate branch \\n\\t\\t\\t- Simialr to what we did here: https://leetcode.com/problems/permutations-ii/discuss/995011/Python-Optimal-Iterative-%2B-Recursive-Solutions-%2B-visuals\\n\\t\\t\\t- (this could happen when the freq of an integer is greater than once)\\n\\n\\tfor - ex: [1,2,7,6,1]\\n\\t\\t- target = 8\\n\\n\\t\\t1 -> 7\\n\\t\\t7 -> 1\\n\\n\\t\\tboth add up to target\\n\\n- **Time:**\\n\\t- O(n C k) or O(nlog(n)) whichever is greater which depends on n, k\\n\\t- if k = 1 -> O(n C k) -> evaluates to -> O(n) < O(nlogn) asymptotically\\n\\t- if k >= 2 -> O(n C k) > O(nlogn)\\n\\t- see attachment\\n\\t\\t-![image](https://assets.leetcode.com/users/images/4ad4372a-7929-4a15-b764-4f5a9a57c981_1629291386.2069864.png)\\n\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```        \\n\\n----------------------------------\\n[2] Recursive without backtracking\\n----------------------------------\\n----------------------------------\\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\\n-------------\\n[3] Iterative\\n-------------\\n-------------\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1311156,
                "title": "c-simple-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nEither we can use ``` set<vector<int>> s``` instead of global 2-D vector and store all possible combination and then return them after storing in 2-D vector but that increases the space as well as time complexity . Hence we can just use one 2-D array and control our checks for duplicate elements in given array by this ``` if(i>idx && v[i]==v[i-1]) continue ``` .\\n\\nHope you liked the solution !!!",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\n``` set<vector<int>> s```\n``` if(i>idx && v[i]==v[i-1]) continue ```",
                "codeTag": "Java"
            },
            {
                "id": 586217,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/59bd115a-85b7-40fe-b8be-a4a54d4280bc_1623909837.0499973.png)\\n```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308045,
                "title": "heavily-commented-backtracking-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307734,
                "title": "c-dp",
                "content": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961165,
                "title": "most-optimal-solution-using-advanced-backtracking-and-recursion-beats-100-solution-explained",
                "content": "\\n# Approach\\n- The `findAns` function is a recursive helper function that takes an index, the remaining target value, the candidates array, the answer vector (`ans`), and the current helper vector (`helper`).\\n\\n- The base case of the recursion is when the target value becomes 0. This means a valid combination has been found, so the current helper vector is added to the answer vector.\\n\\n- Within the recursive function, a loop iterates through the candidates starting from the current index. For each candidate, the following conditions are checked:\\n    - If the current candidate is the same as the previous candidate, it\\'s skipped to avoid duplicate combinations.\\n    - If the current candidate is greater than the remaining target, it\\'s not feasible to include it, so the loop breaks.\\n    - Otherwise, the current candidate is included in the helper vector, and the recursive call is made with the next index and the updated target value.\\n\\n- After the loop, the current candidate is removed from the helper vector (backtracking).\\n\\n- The `combinationSum2` function first sorts the candidates array. This sorting helps in efficiently avoiding duplicate combinations and breaking out of the loop early when candidates exceed the target.\\n\\n- The `ans`vector containing all valid unique combinations is returned.\\n\\n# Complexity\\n- Time complexity:\\nO((2^n)*k)\\n\\n- Space complexity:\\nO(k*x)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478784,
                "title": "c-recursive-backtracking-solution-easy-to-understand-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO( 2^n *k )\\n\\n- Space complexity:\\nO( k*X )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458185,
                "title": "100-faster-java-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2^N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/710511bf-1194-487d-b905-ad6599403eb4_1682528664.190133.png)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092296,
                "title": "99-fast-javascript-solution-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/9AYldOQFJfk\\n\\n![image.png](https://assets.leetcode.com/users/images/cfa25008-9a12-4b79-ac71-ba7810d76d0b_1674525474.7510023.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703414,
                "title": "c-backtrack-easy-and-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808881,
                "title": "in-depth-explaination-with-comments",
                "content": "Explaination with comments\\n\\nclass Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = ind;i<n;i++)\\n        {\\n            // here i > ind and not i-1>=0 ? because we could chose the same no. twice\\n            // if it occurs twice in the array and if it\\'s chosen for a different position\\n            // eg. {1,1,2} if target == 4 \\n            if(i > ind && candidates[i-1] == candidates[i])\\n            {\\n                continue;\\n            }\\n            \\n            // because array is sorted and all numbers ahead of candidates[i] will anyway\\n            // be > target\\n            if(candidates[i] > target)\\n            {\\n                break;\\n            }\\n            \\n            v.push_back(candidates[i]);\\n            findCombinations(i+1,n,candidates,v,ans,target-candidates[i]);\\n            v.pop_back();\\n\\t\\t\\t// v.pop_back() is necessary because of ?\\n\\t\\t\\t// when this option backtrack to here, remove this and go on to the next option\\n            // so after we\\'ve completed this call and processed it\\'s result at base case\\n            // we don\\'t wanna let current vector interfere with next \"fresh\" function call\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        \\n        sort(candidates.begin(),candidates.end());\\n        // sorting the input array is necessary to gather all the duplicates together \\n        // so that it becomes easy to avoid duplicate values taken for the ith number\\n        // for eg. 1st no. is chosen as 1 then it can\\'t be chosen as 1st no. again,\\n        \\n        // though it can be chosen as 2nd no. explained at line 17\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        findCombinations(0,n,candidates,v,ans,target);\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1769816,
                "title": "without-loop-combination-sum-2-easy-c-similar-to-combination-1-subset-2-problems",
                "content": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680167,
                "title": "c-simple-recursive-solution-for-beginners",
                "content": "A simple C++ approach using recursion for beginners:\\n\\n```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```\\n\\nAnd if you still want to improve this solution, read [this improvement.](https://leetcode.com/problems/combination-sum-ii/discuss/16884/a-smaller-trick-to-improve-a-lot-(beat-92.35))",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169640,
                "title": "easy-to-understand-python-dp-solution-with-comparison-to-combination-sum-i",
                "content": "Difference of DP solution between Combination Sum and Combination Sum II.\\n1. `reversed(range(len(dp)))`: we want to avoid using the same candidate multiple times. That is, say we have `subtarget0`, `subtarget1`, `subtarget2` and `subtarget1 = subtarget0 + candidate_i` and `subtarget2 = subtarget1 + candidate_i`. If we do not use `reversed()`, we will first build `subtarget1` then in the same iteration we build `subtarget2`. In other words, without iterating the dp in reversed direction, we would use the same candidate `candidate_i` twice.\\n2. `set` to store the sub-results. The reason we use set is to ensure unique combination since **there are duplicates in candidates in Combination Sum II**. \\n\\nCombination Sum I solution:\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\\n\\nCombination Sum II solution:\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16955,
                "title": "javascript-solution-with-dfs",
                "content": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17023,
                "title": "my-solution-without-using-set",
                "content": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "solutionTags": [],
                "code": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4013220,
                "title": "cpp-solution-with-explanation-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599114,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310668,
                "title": "c-fast-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first things that came to mid seeing this problem was a recursive approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go to every possible candiates check its credibility and check again from the next candiate by deleting the duplicate elemnts after a same element has been visited.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2) because we have to store the answer for final submission.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125993,
                "title": "simple-back-tracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103327,
                "title": "c-easy-backtraking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878112,
                "title": "c-solution-sharing-my-two-solutions-388ms-8ms-subsetsum",
                "content": "**Solution 1: [Accepted]388ms**\\nThis Solution is a variation of Subset Sum, but we want only unique Subset. Therefore, to keep track of that, I use a set of vector type and store them in sorted only. *[Reason for storing  them in sorted only, is beacuse if I have a target=7, and Array=[2,3,2,1,2,2,1] and let\\'s say we got two subset [1,2,2,2] && [2,1,2,2] which is equal to our target, but in this case they are not unique subset. {Unique is when we have the frequencies of any value in a subset , is different from another subset.} But, in this case Frequencies of every value in both subset are same. Therefore, they must be treated as a single subset not two different subset].*  So, if I find a duplicate one, I will not going to push it into  my answer.\\nBelow, is the Code which is just a subset Sum variaton.\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\\nNow, in above Code we are taking extra space and we always sorting it to so that we can keep only unique subsets in our final answer.\\nWe can modify the above solution, by sorting the candidates at first. Now the duplicates ones are adjacent to each other and we can easily skip that ones which are Duplicates.\\n\\n**Solution #2: [Accepted] 8ms**\\nSort the candidates vector. And Now, when you have encounter a duplicate value, skip that value, because they may form same subset as previous one has formed. So, run a while loop and skip until you find a unique value.\\nNow, we don\\'t need extra space and we don\\'t have to sort again and again. Just a little bit of change, and everything is same as above code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```\\n*And yes, this Q\\'s can also be solved using Backtracking. Many users has posted brilliant backtracking solutions, you can check that also.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620712,
                "title": "bottom-up-python-solution-beats-98-simple-and-clean",
                "content": "\\n```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434253,
                "title": "javascript-easy",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16879,
                "title": "golang-solution-6ms",
                "content": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16946,
                "title": "c-solution-with-comments-8ms",
                "content": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "solutionTags": [],
                "code": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 16880,
                "title": "python-dfs-easy-to-understand",
                "content": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 16988,
                "title": "5ms-java-solution",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17056,
                "title": "my-solution-in-java",
                "content": "Generally speaking it is a DFS solution\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }\\n            return results;\\n        }\\n        //Use DFS\\n        private void combinationSumHelper(int[] candidates,int index, int target,LinkedList<Integer> work,List<List<Integer>> results){\\n            //Compare candidates[index] and target;\\n            //If equals, terminate the search,return result \\n            //If candidates[index] > target, terminate the search, no result\\n            //Otherwise, study rest of elements.\\n            if (candidates[index]>target){\\n                return;\\n            }else if (candidates[index]==target){//Update the \\n                work.addLast(candidates[index]);\\n                results.add(new ArrayList<Integer>(work));\\n                work.removeLast();\\n                return;\\n            }\\n            work.addLast(candidates[index]);\\n            for (int i=index+1,len=candidates.length;i<len;i++){\\n                if (i>index+1&&candidates[i]==candidates[i-1]) continue;//Avoid dulipcates\\n                if (candidates[i]<=target-candidates[index]){\\n                    combinationSumHelper(candidates,i,target-candidates[index],work,results);\\n                }\\n            }\\n            work.removeLast();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3812563,
                "title": "c-backtracking-considering-multiplicities-vs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 different kinds of solutions are provided! One is backtracking; the other is dynamic programming solution. The backtracking solution is faster.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe backtracking solution considers the numbers with multiplicities. Using a container to store the pairs $(x_i, m_i)$ where $x_i$ is the number in candidates with its frequency $m_i$. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\prod_i(m_i+1))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\sum_i m_i)$$\\n\\n# Code for  backtracking\\n```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\\n# Code for DP\\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631115,
                "title": "optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263257,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243195,
                "title": "c-recursion-backtracking-array-easy-66-time-43-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844056,
                "title": "easy-c-solution-striver-better-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494877,
                "title": "c-not-fastest-but-easy-to-understand-recursive-solution-unique-solution",
                "content": "Please let me know if you need an explanation. I will try to explain in detail.\\n\\n```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383036,
                "title": "c-solution-backtracking-comments-better-than-89",
                "content": "Here, we can\\'t perform normal backtracking as it would lead to 2^n cases(where n<=100 given). So we tweak the code a bit so that we don\\'t have to produce the same combinations again and again.\\n\\nSteps used:\\n-> After sorting the initial array, follow the below steps\\n-> add the curr element from target and backtrack for the leftover part of array.\\n-> don\\'t add the curr element from the target and backtrack for the leftover part of the array.\\n-> if this we keep track of if the previous element is same as current element, we skip to the next distinct number, and then apply the same steps as above.\\n\\n```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318566,
                "title": "c-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260963,
                "title": "combination-of-subsets-ii-90-and-combination-sum-39",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }\\n     public void solve(int[] candidates,int i,List<List<Integer>>ans,List<Integer> output, int target){\\n\\t //base case\\n        if(i==candidates.length){\\n            if(target==0){\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        //include the element and since each candidate can be used one send i+1 to the function\\n         if(candidates[i]<=target){\\n            output.add(candidates[i]);\\n            solve(candidates,i+1,ans,output,target-candidates[i]);\\n            output.remove(output.size()-1);\\n         }\\n        //exclude if the number is similar to the previous as it will result in same path\\n        while(i+1<candidates.length && candidates[i]==candidates[i+1]){\\n            i++;\\n        }\\n        solve(candidates,i+1,ans,output,target);\\n    }\\n}\\nTried after following striver\\'s and neetcode\\'s approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1689307,
                "title": "c-solution-set-recursion",
                "content": "*Please upvote if you find it helpful :)*\\n```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311783,
                "title": "elegant-python-recursion",
                "content": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788413,
                "title": "8ms-c-backtracking-simple-code",
                "content": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650590,
                "title": "java-iterative-dp-no-recursion-straightforward",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561957,
                "title": "python-6-line-dp-without-using-hashset-to-check-duplicate-explained",
                "content": "I see a lot of posts using HashSet to check duplicates. There is no need for that.\\nThe only difference with question [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/) is that, this questions limits the repetition count for each item in \"candidates\" array. \\nCode is almost the same code as [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/), just adding an extra \"if\" to exclude those repeating too many times.\\n**dp[i]** is a list of all combinations that sums up to \"i\". We put \"candidates\" in outer loop and \"target\" iteration in inner loop, so that when one candidate number is used, it won\\'t be picked again later. This automatically avoids duplicates. No need to use hash for duplicate check.\\n```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\\nWe can use arr[-cnt]!=c to check repeating count because in arr, same number must all be side-by-side.\\n\\nFor comparison, here is the code for [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/). The only difference is, it doesn\\'t have the \"if\" statement in the end of \"dp[i].extend\" line.\\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543016,
                "title": "c-4-ms-short-fast-backtracking-solution-99-100",
                "content": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429543,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146416,
                "title": "11ms-java-solution-with-no-loop-inside-recursion",
                "content": "A simple way to look at the problem is that for each element in the array, we have two options: **include it or not** in the combination.\\nSay we\\'re at array index ```i``` with target ```t```. \\n*Possibility 1:* If we do include ```array[i]```, the problem becomes \"**Find combinations of sum (t - array[i]) in the array starting at i+1**\". \\n*Possibility 2:* If we do **not** include ```array[i]```, the problem is to \"**Find combinations of sum t in the array starting at i+1**\".\\nThe only headache left now is to exclude duplicate answers. Duplicate answers exist because we have duplicate elements in the array. \\nSay we have *k* ```1```\\'s. Using the above algorithm, we get *2^k* possiblites. But among them only *(k+1)* possiblities are useful: *0 ... k* of the k ```1```\\'s are chosen. Thus, we only include the first *n* consecutive ```1```\\'s. That means **once we decide to uninclude a ```1```, we uninclude all the following ```1```\\'s**.\\nSince we consider two possibilities at each index, the execution forms a binary tree with level *n*. The execution time will thus be O(2^n).\\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "solutionTags": [],
                "code": "```i```\n```t```\n```array[i]```\n```array[i]```\n```1```\n```1```\n```1```\n```1```\n```1```\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16882,
                "title": "python-dfs-solution",
                "content": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```\\n\\nDFS idea is borrowed from @caikehe's Combination Sum [solution](https://discuss.leetcode.com/topic/23142/python-dfs-solution). Here, when recursively calling dfs in for loop, we increment the index by 1 (unlike combination sum problem where we don't increment i). That's because we don't want the same number to be considered twice. Also, the line `if i != idx and c == candidates[i-1]: continue`, is needed to eliminate duplicate combinations.",
                "solutionTags": [],
                "code": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17006,
                "title": "short-and-easy-to-understand-recursive-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }\\n        private void combine(int[] nums, int start, int target, List<List<Integer>> res, List<Integer> path){\\n            if (target < 0) return;\\n            if (target == 0){\\n                res.add(path);\\n                return;\\n            }\\n            for (int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) continue;\\n                List<Integer> currentPath = new ArrayList<Integer>(path);\\n                currentPath.add(nums[i]);\\n                combine(nums, i + 1, target - nums[i], res, currentPath);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3581319,
                "title": "python3-backtracking-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265075,
                "title": "python-accepted-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071587,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826015,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/ugly-number.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774199,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314706,
                "title": "c-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }\\n        if(target<0||idx>=nums.size())\\n        {\\n            return ;\\n        }\\n        \\n        v.push_back(nums[idx]);\\n        backtrack(nums,target-nums[idx],idx+1,v);\\n        v.pop_back();\\n        \\n        int temp=nums[idx];\\n        while(idx<nums.size()&&temp==nums[idx])\\n            idx++;\\n        \\n        backtrack(nums,target,idx,v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> v;\\n        backtrack(candidates,target,0,v);\\n        return res;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270683,
                "title": "c-easy-simple-solution-combination-sum-ii",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }\\n        for(int j=i;j<c.size();j++)\\n        {\\n            if(j>i && c[j]==c[i])\\n                continue;\\n            sum+=c[j];\\n            a.push_back(c[j]);\\n            util(c,a,sum,j+1);\\n            a.pop_back();\\n            sum-=c[j];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        target=t;\\n        vector<int> a;\\n        sort(c.begin(),c.end());\\n        util(c,a,0,0);\\n        set<vector<int>> s;\\n        for(auto t: ans)\\n        {\\n            if(s.find(t)==s.end())\\n            {\\n                s.insert(t);\\n                k.push_back(t);\\n            }\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786651,
                "title": "using-java-recursion-with-set",
                "content": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }\\n            return;\\n        }\\n        \\n        if(array[index]<=target)\\n        {\\n            ds.add(array[index]);\\n            \\n            findCombinations(index+1,array,target-array[index],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n        findCombinations(index+1,array,target,ans,ds);\\n    }\\n    \\n    \\n    \\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n         \\n        \\n        List<List<Integer>> op = new ArrayList<>();\\n        for(List a:ans)\\n        {\\n            op.add(a);\\n        }\\n       return op;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778007,
                "title": "c-simpelst-backtracking-solution-faster-than-100",
                "content": "* The solution is same as that of **Combination Sum**.\\n* But here, since there are repated elements & each element can be used only once, we\\'ll not be looping as : solve(candidates, i, curr, ans, target-C[i]) - this will lead to using an element more than once.\\n* We also add an additional condition in ```solve()``` i.e; when we\\'re traversing the array using ```j```, if ```j != i```, we\\'ll not be adding an element that\\'s repeated (Because we can use elements that\\'re repeated as many no. of times they\\'re repeated, but we cannot have the same combinations forming again and again)\\n\\n* **Eg :** In ```candidates = [1, 1, ,2 ,5 ,6, 7, 10]``` ---> Once we form a combination [1, 2, 5] if we use the 2nd one we\\'ll be again forming the same combination [1, 2, 5] since it satisfies the condition -- Add to the array if it\\'s less than the remaining target. So we avoid using such elements.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**Time Complexity :** O(k *x* 2^k) - k = avg length of the combinations arrays\\n\\n\\n**Do upvote if you\\'ve found my solution & explanation helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```solve()```\n```j```\n```j != i```\n```candidates = [1, 1, ,2 ,5 ,6, 7, 10]```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713508,
                "title": "easy-to-understand-forgive-me-drawing-ugly-trees",
                "content": "![image](https://assets.leetcode.com/users/images/00b770e0-5782-458a-92f2-7348e78ce975_1642956700.9327555.png)\\n\\n<br>\\nsome cases you must pay attention to:\\n\\n\\n\\n1. n < 0\\n\\n```java\\nif (n < 0) skip all later ones\\n```\\n\\n2. n == 0\\n\\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\\n\\n3. after backtrack recursion calling in loop, skip duplicates\\n\\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\\n\\n\\n\\nsome code:\\n\\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nif (n < 0) skip all later ones\\n```\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673313,
                "title": "easy-java-solution-and-explaination-with-time-and-space-complexity",
                "content": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```\\n\\nTC - O(2^n) * K - where k is the average list size\\nSC - K * X - where X is no. of combinations\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568727,
                "title": "solution-using-backtracking-with-given-input-in-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369209,
                "title": "template-same-structure-codes-for-combination-subset-and-permutations",
                "content": "In this post:\\n\\nthese codes may not the fast solution or solution with least lines, but:\\n**If you understand one question, you can fix all others.**\\n\\nAll of them used the same structure.\\n--- Bot Up DFS, so we can use memorization to save inmediate results to speed up the algorithm.\\n\\n**All memorization part are not mandatory** , if you remove these codes, the algorithm still works.\\n\\nPart 1: Permutations\\nWhen order is matter,  we use boolean[] visited to avoid duplicate values.\\nPart 2: Combination\\nWhen order is not necessary,  for (int i = start; i < n; i++)  and dfs(i + 1) to avlid duplicate combination.\\nPart 3: Set\\nWhen the order is not necessary and the size of combination can be different, use a for loop to check the size from 0 to k.\\n\\n------------------------------------------------------------------------------------------------\\n\\n# Part one: Permutations\\nleetcode 46 https://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 47 https://leetcode.com/problems/permutations-ii/\\n\\njust one line different to fix the duplication\\n\\n*if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;*\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 131\\nhttps://leetcode.com/problems/palindrome-partitioning/\\nThere is memorization function.\\n\\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n# Part 2: Combination\\nleetcode 77 \\nhttps://leetcode.com/problems/combinations/\\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nLeetcode 39. https://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\\n\\nleetcode 40 https://leetcode.com/problems/combination-sum-ii/\\n\\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPart 3: Set\\n\\nleetcode 78 https://leetcode.com/problems/subsets/\\n\\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 90\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\nRelated posts before:\\n\\n\\nPython:\\nhttps://leetcode.com/problems/permutation-sequence/discuss/22554/Backtrack-Summary%3A-General-Solution-for-10-Questions!!!!!!!!-Python-(Combination-Sum-Subsets-Permutation-Palindrome)\\n\\nJava:\\nhttps://leetcode.com/problems/permutations/discuss/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning\\n\\n---------------------------\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208963,
                "title": "python-knapsack-solution",
                "content": "This problem sounds very similar to a [well known knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\\nIt can be solved here in `O(N^2*target)` time and memory.\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\\n\\nOf course, we can save some memory because we use only previous row (`O(target*N)`). Smth like following:\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204663,
                "title": "lessons-learned",
                "content": "How this differs from Combination Sum 1 is this has **duplicate** elements and shouldn\\'t use the number at same index multiple times.\\n\\n**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n\\n**Code**:\\n```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197125,
                "title": "backtracking-with-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906626,
                "title": "java-backtracking-sorting-to-avoid-duplicates-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843631,
                "title": "simple-12ms-c-backtrack-explain-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737513,
                "title": "c-easy-solution-easytounderstand",
                "content": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632658,
                "title": "java-2-ms-faster-than-98-12-recursive-backtrack",
                "content": "same as [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/632645/Java-2-ms-faster-than-99.46) and [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/632691/Java-0-ms-faster-than-100.00-RecursiveandBacktrack).\\n```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631916,
                "title": "c-easy-solution-pattern-in-combination-sum-1-2-and-3",
                "content": "Try to think of it as a graph with `n` nodes and `O(n^2)` edges. Then, all we need to do is do dfs and see what branches are satisfying the condition that question is asking for. \\nIf you are facing problem in following the dfs approach (_recursion fear_), try creating a graph for the the `candidates` array and write a bfs to find the sum. Once you get the hang of how the branches of graph are playing out, try writing the recursive dfs for it.\\n\\n**Combination Sum 1:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n\\n**Combination Sum 2:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n**Combination Sum 3:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615729,
                "title": "java-dfs-solution-beat-98-with-clear-explanations",
                "content": "We illustrate the depth first search (DFS) method to enumerate all possible combinations that satisfy the sum requirement using the example:\\ncandidates =\\xA0[2,5,2,1,2], target =\\xA05\\n1. We first sort the array and it becomes candidates =\\xA0[1, 2, 2, 2, 5]. This is needed because one can easily get rid of redundant answers while searching.\\n2.   Generate the search tree by adding one element at a time to the current list (in the order dictated by the order of the array candidates). Also, to avoid duplicates, each distinct number is allowed to be used only once for each level. In our example, this means the left graph is correct, not the right one.\\n<img src=\"https://assets.leetcode.com/users/jzhao0105/image_1589212751.png\" width=\"600\"/>\\n3. To implement the DFS recursive solution,  we need to traverse all nodes of the tree above and check if the sum of the elements in the list is equal to target. Once a solution is found (e.g. curList = [1, 2, 2]), we (deep) copy it and add it to the answer list. Also, we backtrack (i.e. remove the last element from curList [1, 2, 2] -> [1, 2] so that in the next step of recursion [1, 2, 5] will be considered too.)\\n4. Time complexity: O(S*N), where S = the number of answers (= length of ans array = 2 in our example) and N = the (average) time that is needed to construct each answer. (e.g. time to traverse the tree and find the list [1, 2, 2]).\\t\\n\\t\\n\\t\\n\\t\\t// Key observation: To eliminate all possible duplicate answers, we only need to\\n\\t\\t// remove all the duplicate candidates at the same level of the search tree\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate void dfs(int[] candidates, int target, int index, \\n\\t\\t\\t\\t\\t\\t\\t List<Integer> curList, List<List<Integer>> ans) {\\n\\t\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\t\\t// Deep copy curList to ans\\n\\t\\t\\t\\t\\tans.add(new ArrayList<Integer>(curList));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int i = index; i < candidates.length; i++) {\\n\\t\\t\\t\\t\\tif (candidates[i] > target) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Remove duplicate candidates at the same level of the tree\\n\\t\\t\\t\\t\\tif (i > index && candidates[i] == candidates[i - 1]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurList.add(candidates[i]);\\n\\t\\t\\t\\t\\tdfs(candidates, target - candidates[i], i + 1, curList, ans);\\n\\t\\t\\t\\t\\tcurList.remove(curList.size() - 1); // Backtrack\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 543026,
                "title": "go-backtrack",
                "content": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511148,
                "title": "javascript-es6-without-push-pop",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481687,
                "title": "python3-backtracking-dp",
                "content": "**Approach 1 -- backtracking**\\nKeep track of a list of existing numbers and residual. When residual drops to 0, add list to answer. Similar to this [thread](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-use-a-stack-to-traverse-the-solution-space-through-backtracking). \\n\\nImplementation :\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\\nAnalysis:\\nTime complexity `O(2^N)`\\nSpace complexity `O(2^N)`\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```\\n\\nComment: \\nNote the similarity to that of [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-A-concise-implementation-of-backtracking-algo).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415202,
                "title": "java-2ms-99-99-faster-100-less-memory",
                "content": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350011,
                "title": "python-generator-solution",
                "content": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338279,
                "title": "java-backtracking-without-for-loop-bounded-knapsack-pattern",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310039,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 302616,
                "title": "swift-70-beat-intuitive-solution-using-modified-dfs-smarty-logix",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```\\n\\nThe trick is to skip the dupes in such a way where you will still get the first \"run\" of the dupes...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302609,
                "title": "c-95-beat-modified-dfs-requires-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170901,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\\nRecursion with memoization:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16863,
                "title": "java-18-lines-solution",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16893,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Combination Sum II** https://leetcode.com/problems/combination-sum-ii/\\n\\n**Algorithm**\\n* Recursion tree will help you solve this problem. https://goo.gl/photos/vEDezZoWctf7CgfM8\\n* Combination Sum I allowed duplicates. To avoid those, in the recursive call, use i + 1.\\n* Now other duplicates are also possible. Imagine [1,2,5, 7, 1] and target as 8. If we use DFS we will get [1,7] and then [7,1]. How do we avoid this?\\n* Sort candidates: [1,1,2,5,7]. Now when you start with index 0, your first element will be 1. It will allow you to pick the second element as 1 too. You will be able to pick [1,7]. But during recursion, when you reach the next start index as 1, your recursion tree will again start from 1. This will lead to a duplicate [1,7]. You want to avoid this.\\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\\n\\n**Another Implementation**\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16976,
                "title": "19-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& candidates, vector<int> tmp, int index, int target){\\n            if(target < 0 )return;\\n            if(target == 0){\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                if(i == index || candidates[i] != candidates[i - 1]){\\n                    tmp.push_back(candidates[i]);\\n                    backtracking(res, candidates, tmp, i + 1, target - candidates[i]);\\n                    tmp.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17060,
                "title": "my-thoughts-and-solution-to-the-problem-java",
                "content": "Hello, I've solve the problem and I am here to give back to the community. Basically the question is pretty straight forward. I've approached the problem with sorting the array first, and keeping the current value and make recursive call to check for target - current value. Any suggestion on how I can make this code better is much appreciated. Thank you.\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }\\n        public List<List<Integer>> helper(int[] num, int target, int index)\\n        {\\n            if(index>=num.length||num[index]>target) return null; //return null if you hit the end\\n            ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            Set<List<Integer>> s = new HashSet<List<Integer>>(); //check if there is no duplicates\\n            for(int i = index;i<num.length;i++)\\n            {\\n                 //if num[i]> target you dont need to check the rest. \\n                 //but it's break here because you still want to keep the rest of the result.\\n                if(num[i]>target) break; \\n                temp = new ArrayList<Integer>();\\n                //if it's found the rest of the numbers can be trimed, save some time on complexity\\n                if(num[i]==target) \\n                {\\n                    temp.add(num[i]);\\n                    result.add(temp);\\n                    return result;\\n                }\\n                ArrayList<List<Integer>> t = (ArrayList)helper(num,target-num[i],i+1);\\n                //t is the temporary ArrayList of the result of your recursion call\\n                // you want to add the value of your current num[i] in the beginning of each\\n                // returned List<Integer> and add it to result if it's not duplicated.\\n                if(t!=null)\\n                {\\n                    for(List<Integer> a:t)\\n                    {\\n                        a.add(0,num[i]);\\n                        if(!s.contains(a)) //make sure there is no duplicates\\n                        {\\n                            s.add(a);\\n                            result.add(a);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4029177,
                "title": "java-easy-100-backtracking-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998318,
                "title": "c-recursion-backtracking-two-approaches",
                "content": "# Approach 1: Extended Solution to [Combination Sum 1 ](https://leetcode.com/problems/combination-sum/discuss/3994292/C%2B%2B-or-Cpp-or-Cpp-Solution-or-Recursion-%2B-Backtracking) but will give TLE\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Most Optimized Solution \\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966330,
                "title": "cpp-solution-easy-to-understand",
                "content": "# Intuition\\nThe problem requires finding all unique combinations of numbers from the \\'candidates\\' array that sum up to the \\'target\\' value. However, each number in the \\'candidates\\' array can only be used once in each combination. To solve this efficiently and avoid duplicates, we can use a depth-first search (DFS) algorithm. We will also sort the \\'candidates\\' array to group identical elements together.\\n\\n# Approach\\n1. Initialize an empty vector of vectors \\'res\\' to store the combinations.\\n2. Initialize an empty vector \\'curr\\' to store the current combination being constructed.\\n3. Sort the \\'candidates\\' vector to group identical elements together.\\n4. Call the DFS function \\'dfs\\' with the following parameters: \\'candidates\\', \\'0\\' as the starting index, \\'target\\', \\'0\\' as the initial sum, \\'curr\\', and \\'res\\'.\\n5. In the \\'dfs\\' function:\\n   a. Check if \\'sum\\' is equal to \\'target\\'. If they are equal, it means the current combination in \\'curr\\' is a valid combination that sums up to the \\'target\\'. Therefore, add \\'curr\\' to \\'res\\'.\\n   b. Check if \\'sum\\' is greater than \\'target\\'. If it is, return to avoid further exploration of this branch.\\n   c. Start a loop from the \\'start\\' index to the end of the \\'candidates\\' vector.\\n   d. Inside the loop:\\n      i. Check if \\'i\\' is greater than \\'start\\' and if the current element \\'candidates[i]\\' is the same as the previous element \\'candidates[i-1]\\'. If both conditions are true, skip the current iteration to avoid duplicate combinations.\\n      ii. Add the current element \\'candidates[i]\\' to \\'curr\\'.\\n      iii. Recursively call \\'dfs\\' with the updated \\'candidates\\', \\'i+1\\' as the new starting index to avoid reusing the same element, \\'target\\', \\'sum+candidates[i]\\' as the new sum, \\'curr\\', and \\'res\\'.\\n      iv. Remove the last element from \\'curr\\' to backtrack and explore other possibilities.\\n6. After the DFS is complete, \\'res\\' will contain all unique combinations.\\n7. Return \\'res\\' as the final result.\\n\\n# Complexity\\n- Time complexity: O(2^n * n), where \\'n\\' is the number of elements in \\'candidates\\'. In the worst case, there can be 2^n combinations to generate, and for each combination, we perform sorting with a maximum of \\'n\\' elements.\\n- Space complexity: O(2^n * n) for the \\'res\\' vector to store all combinations and O(n) for the \\'curr\\' vector. The overall space complexity is dominated by the \\'res\\' vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853451,
                "title": "easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The combinationSum2 method first sorts the candidates array in ascending order. Sorting helps in avoiding duplicates and optimizing the combination generation process.\\n\\n2. It initializes an empty vector ans to store the resulting combinations and an empty vector v to temporarily store a combination during the generation process.\\n\\n3. It calls the combinationSum_helper function with the sorted candidates array, the target value, the empty v vector, ans, and an initial index of 0.\\n\\n4. The combinationSum_helper function is a recursive function that generates combinations. It takes the current index, candidates, the remaining target, the temporary vector v, and the ans vector as parameters.\\n\\n5. In the combinationSum_helper function, the base cases are:\\n\\n   If target becomes 0, it means a valid combination is found. The current v vector is added to the ans vector.\\n   If target becomes negative, it means the current combination is not valid, so it returns.\\n\\n6. The function then iterates through the candidates array, starting from the given index. It avoids duplicates by checking if the current element is the same as the previous element and the current index is greater than the starting index. If this condition is met, the loop continues to the next iteration.\\n\\n7. For each valid candidate, it adds the candidate to the temporary vector v, subtracts the candidate from the remaining target, and makes a recursive call to combinationSum_helper with the updated parameters.\\n\\n8. After the recursive call returns, the last added candidate is removed from the temporary vector v (backtracking).\\n\\n9. The process continues until all combinations are generated.\\n\\n10. The sorted nature of the candidates array helps in avoiding duplicates and optimizing the combination generation process.\\n\\n11. The combinationSum2 method returns the ans vector containing all unique combinations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851424,
                "title": "c-easy-killer-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> refer combination sum solution and combination and subset for more clearity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847301,
                "title": "python-99-53-faster-backtracking-easy",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718563,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473396,
                "title": "easy-java-solution-2ms-beats-99-69",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373591,
                "title": "pyhton3-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346744,
                "title": "efficient-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make combination we need to use the \"Pick\" and \"Not pick\" method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Combination I.\\nBut, to ignore duplicate combination -->\\n- First we need to sort the given vector, so that all the duplicate elements of the given vector will be consecutively placed.\\n- Then, When we are about to \"Not pick\" an element we need to ignore all the similar consecutive elements. Which job is done by this block of code -->\\n```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n\\nMy Combination I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294871,
                "title": "recursion-java-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248311,
                "title": "java-simple-powerfull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224015,
                "title": "optimized-solution-2ms-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2n*k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:k*x\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185178,
                "title": "python-backtracking-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182108,
                "title": "java-sol-2ms-beats-99-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177752,
                "title": "go-solution-recursive-dfs",
                "content": "#### Recursive DFS\\n\\n```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3158498,
                "title": "runtime-beats-97-33-combination-sum-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the candidates list in ascending order.\\nDefine a backtracking function that takes in 3 parameters: start index, a list path to store each combination, and the target value.\\nIf the target value is 0, append the path list to the result res list.\\nLoop through the candidates list starting from the given start index.\\nIf the current index i is greater than start and the current candidate is the same as the previous candidate, continue to the next iteration.\\nIf the current candidate is greater than the target value, break the loop.\\nAdd the current candidate to the path list and call the backtracking function with i + 1 as the start index, the updated path list, and the target minus the current candidate.\\nReturn the result res list after the backtracking function is finished.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124204,
                "title": "2k-views-easy-to-understand-concise-and-precise-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105204,
                "title": "java-backtracking-explained",
                "content": "# Intuition\\n- Before starting the recursive call make sure to sort the elements because the ans should contain the combinations in sorted order and should not be repeated.\\n\\n- Initially, We start with the index 0, At index 0 we have n \\u2013 1 way to pick the first element of our subsequence.\\n\\n- Check if the current index value can be added to our ds. If yes add it to the ds and move the index by 1. while moving the index skip the consecutive repeated elements because they will form duplicate sequences.\\n\\n- Reduce the target by arr[i],call the recursive call for f(idx + 1,target \\u2013 1,ds,ans) after the call make sure to pop the element from the ds.\\n\\n- - if(arr[i] > target) then terminate the recursive call because there is no use to check as the array is sorted in the next recursive call the index will be moving by 1 all the elements to its right will be in increasing order.\\n\\n# Base Condition:\\n\\n- Whenever the target value is zero add the ds to the ans return.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n*k)$$ \\n- - Assume if all the elements in the array are unique then the no. of subsequence you will get will be O(2^n). we also add the ds to our ans when we reach the base case that will take \\u201Ck\\u201D//average space for the ds.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100921,
                "title": "super-easily-understandable-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://www.youtube.com/watch?v=G1fRTGRxXU8&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088912,
                "title": "c-striver-approach-easy-explained",
                "content": "# Approach\\n- So Here Sort The Vector , Because We Are Having A Logic Of Not Using Extra Space\\n- Lets Deep Dive Into Our Recursive Code And I Will Explain It Line By Line\\n- So First Of All We Have Our Base Case , That Is If(target == 0) , we push the vector in our ans , which is vector<vector<int>> and we return\\n- After That As We Know The Question States We Need Lexicographical Answers Only , Means We Cannot Pick [1,2,1] , We Can Only Pick Answers Which Are Sorted In I.e [1,1,2] or [2,2]\\n- So Inorder To Avoid The Same Sequences We Keep A Check , That Is If We Are Picking The Element For First Time We Allow It , If The Same Number Comes Again , That Will Generate Same Answer\\n- So We Keep A Check By Using This  if(i > index && arr[i] == arr[i-1]) , If This Satisfies We Skip And Move To Next Index\\n- After That We Keep A Check If The arr[i] > Target that means we cannot have any combination , as after this all values will be high as we have the vector sorted\\n- After That We Add The ith Element In Our Temp Vector And We Again Call Recursion\\n- We Have To Also Do Backtracking For Removing The ith Element , So We Also Pop Back The Element\\n- Check Given Recursion Tree , And You Will Get What I am Trying To Explain\\n\\n# Recursion Tree \\n\\n```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\\n\\n![WhatsApp Image 2023-01-23 at 11.28.03 AM.jpeg](https://assets.leetcode.com/users/images/42c631cb-fb47-4a1a-b6ba-1a7a98c486ae_1674453532.080475.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074701,
                "title": "c-backtracking",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u9700\\u8981\\u526A\\u679D\\uFF0C\\u5982\\u679C\\u4E00\\u4E2A\\u8282\\u70B9\\u6709\\u591A\\u6761\\u503C\\u76F8\\u540C\\u7684\\u6811\\u679D\\u76F8\\u90BB\\uFF0C\\u5219\\u53EA\\u904D\\u5386\\u7B2C\\u4E00\\u6761\\uFF0C\\u5269\\u4E0B\\u7684\\u90FD\\u526A\\u6389\\uFF0C\\u4E0D\\u8981\\u53BB\\u904D\\u5386.\\u4F53\\u73B0\\u5728\\u4EE3\\u7801\\u4E0A\\uFF0C\\u9700\\u8981\\u5148\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u8BA9\\u76F8\\u540C\\u7684\\u5143\\u7D20\\u9760\\u5728\\u4E00\\u8D77\\uFF0C\\u5982\\u679C\\u53D1\\u73B0candidates[i] == candidates[i-1]\\uFF0C\\u5219\\u8DF3\\u8FC7.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040453,
                "title": "c-java-python-easiest-solution-detailed-explanation-code",
                "content": "\\n# Approach\\nThe code is a solution to the problem of finding all combinations of a given set of candidates that add up to a given target. The solution uses a recursive function Solve() that takes the candidates, target, current sum, an array to store the combinations, an array to store the current combination, and the current index being processed as input. The function checks if the current sum is equal to the target, if so it adds the current combination to the output. If the current sum is greater than the target, it returns.\\nIf the current index is equal to the size of the candidates, it returns.\\n\\nOne difference from the previous code is that it also skips any duplicates candidates by using a while loop after a recursive call using the current candidate. This will prevent the function from generating duplicate subsets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O((2^n)*k)**, where 2^n is distribution of n elements, k is average length of every combination(mainly k for this -> ans.push_back(ds);)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(x)**, where x is length of longest combinations \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```\\n**Note 0 : Also Recommend to see \"Combination Sum\" which is available in leetcode.** https://leetcode.com/problems/combination-sum/solutions/3027804/c-java-python-detailed-explanation-recursive-solution/\\n\\n**Note 1: Code for Java and Python might be wrong due to syntax error bcz Java and Python Solution is just the exact coversion of C++ code but logic is 100 % correct.**\\n\\n***Note 2: with the help of hashset we will get time limit exceeded error with this test case.**\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget = 30\\nclass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, set<vector<int>>& s, vector<int>& ans, int index){\\n        if(target == sum){\\n            s.insert(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        if(sum + candidates[index] > target) \\n            return;\\n        ans.push_back(candidates[index]); \\n        Solve(candidates, target, sum + candidates[index], s, ans, index + 1);\\n        ans.pop_back();\\n        Solve(candidates, target, sum, s, ans, index + 1);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, s, ans, 0);\\n        for(auto vec : s)\\n            output.push_back(vec);\\n        return output;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010879,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860265,
                "title": "c-faster-than-100-concept-of-pick-subsequence",
                "content": "# Complexity\\n- Time complexity:\\nO(2^n)+k\\n\\n- Space complexity:\\nk*x (ignoring auxilary space used by recursion)\\n\\npls upvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1773550,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1708453,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1572711,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2052618,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2049804,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2046354,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027816,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027069,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2014335,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2011007,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2004828,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1997800,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1984747,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1957769,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1948099,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1937812,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1930902,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1925393,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1922337,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1818568,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1808121,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1806997,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1800119,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1788823,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1777795,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1775087,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1767902,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1752615,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1740987,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1735773,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            }
        ]
    }
]