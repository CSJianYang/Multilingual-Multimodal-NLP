[
    {
        "title": "Number of People Aware of a Secret",
        "question_content": "On day 1, one person discovers a secret.\nYou are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.\nGiven an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 6, delay = 2, forget = 4\nOutput: 5\nExplanation:\nDay 1: Suppose the first person is named A. (1 person)\nDay 2: A is the only person who knows the secret. (1 person)\nDay 3: A shares the secret with a new person, B. (2 people)\nDay 4: A shares the secret with a new person, C. (3 people)\nDay 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\nDay 6: B shares the secret with E, and C shares the secret with F. (5 people)\n\nExample 2:\n\nInput: n = 4, delay = 1, forget = 3\nOutput: 6\nExplanation:\nDay 1: The first person is named A. (1 person)\nDay 2: A shares the secret with B. (2 people)\nDay 3: A and B share the secret with 2 new people, C and D. (4 people)\nDay 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 1000\n\t1 <= delay < forget <= n",
        "solutions": [
            {
                "id": 2229982,
                "title": "java-c-python-sliding-window-o-n-time-o-forget-space",
                "content": "# **Intuition**\\nSliding window, calculatint the number of people who will share the secrets.\\n<br>\\n\\n# **Explanation**\\n`dp[i]` means the number of people who found the secret on `i`th day.\\n`share` is the number of people who are going to share the secrets.\\nOn the `i`th day,\\n`dp[i - delay]` people found the secret `delay` days before,\\nstarting to share the secret.\\nso `share += dp[i - delay]`\\n\\n`dp[i - forget]` people found the secret `forget` days before,\\nand forgot the secret today.\\nso `share -= dp[i - forget]`\\nand we assign `dp[i] = share`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n + 1], mod = (long)1e9 + 7, share = 0, res = 0;\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = share = (share + dp[Math.max(i - delay, 0)] - dp[Math.max(i - forget, 0)] + mod) % mod;\\n        for (int i = n - forget + 1; i <= n; ++i)\\n            res = (res + dp[i]) % mod;\\n        return (int)res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(n + 1);\\n        dp[1] = 1;\\n        int share = 0, mod = 1e9 + 7, res = 0 ;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = share = (share + dp[max(i - delay, 0)] - dp[max(i - forget, 0)] + mod) % mod;\\n        for (int i = n - forget + 1; i <= n; ++i)\\n            res = (res + dp[i]) % mod;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp = [1] + [0] * (n - 1)\\n        mod = 10 ** 9 + 7\\n        share = 0\\n        for i in range(1, n):\\n            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % mod\\n        return sum(dp[-forget:]) % mod\\n```\\n<br>\\n\\n## **Solution2**\\nTime `O(n)`\\nSpace `O(forget)`\\n\\n**C++**\\n```cpp\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(forget);\\n        dp[0] = 1;\\n        long mod = 1e9 + 7, share = 0;\\n        for (int i = 1; i < n; ++i)\\n            dp[i % forget] = share = (share + dp[(i - delay + forget) % forget] - dp[i % forget] + mod) % mod;\\n        return accumulate(dp.begin(), dp.end(), 0L) % mod;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp = [1] + [0] * forget\\n        mod = 10 ** 9 + 7\\n        share = 0\\n        for i in range(1, n):\\n            dp[i % forget] = share = (share + dp[(i - delay) % forget] - dp[i % forget]) % mod\\n        return sum(dp) % mod\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n + 1], mod = (long)1e9 + 7, share = 0, res = 0;\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = share = (share + dp[Math.max(i - delay, 0)] - dp[Math.max(i - forget, 0)] + mod) % mod;\\n        for (int i = n - forget + 1; i <= n; ++i)\\n            res = (res + dp[i]) % mod;\\n        return (int)res;\\n    }\\n```\n```cpp\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(n + 1);\\n        dp[1] = 1;\\n        int share = 0, mod = 1e9 + 7, res = 0 ;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = share = (share + dp[max(i - delay, 0)] - dp[max(i - forget, 0)] + mod) % mod;\\n        for (int i = n - forget + 1; i <= n; ++i)\\n            res = (res + dp[i]) % mod;\\n        return res;\\n    }\\n```\n```py\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp = [1] + [0] * (n - 1)\\n        mod = 10 ** 9 + 7\\n        share = 0\\n        for i in range(1, n):\\n            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % mod\\n        return sum(dp[-forget:]) % mod\\n```\n```cpp\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(forget);\\n        dp[0] = 1;\\n        long mod = 1e9 + 7, share = 0;\\n        for (int i = 1; i < n; ++i)\\n            dp[i % forget] = share = (share + dp[(i - delay + forget) % forget] - dp[i % forget] + mod) % mod;\\n        return accumulate(dp.begin(), dp.end(), 0L) % mod;\\n    }\\n```\n```py\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp = [1] + [0] * forget\\n        mod = 10 ** 9 + 7\\n        share = 0\\n        for i in range(1, n):\\n            dp[i % forget] = share = (share + dp[(i - delay) % forget] - dp[i % forget]) % mod\\n        return sum(dp) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2229805,
                "title": "c-dp-from-o-n-2-to-o-n",
                "content": "## Observation\\n\\nLet\\'s forget about the constraint to find the number of people who found out and **remember** the secret after `n` days and only concentrate on finding the total number of people who found out about the secret in `n` days regardless of if they remember it or not.\\n\\nThis is a little simpler problem, we can use DP here with the following recursion.\\n\\n`$\\\\sum_{i=delay}^{i=forget-1} f(n-i)$` which is `f(n) = f(n-delay) + f(n-(delay+1)) +f(n-(delay+2)) ....f(n-(forget-1)) where n-i >=0`. What this means is that each person tells the secret to `forget-delay-1` people and they would do the same and so on.\\n\\nOnce we have this result for each day it easy easy to calculate what\\'s asked in the question (the number of people who know and remember the secret by the nth day). This will be `f(n)-f(n-forget)` which basically means that all the people who found out the secret by the end of the `n-forget` day will forget the secret by the `nth` day and the remaining will remember it.\\n\\n\\n## Solution 1 - Top Down\\n\\nWe use top-down DP. As you can see, the result of each state `n` is required multiple times and we can cache the results for bringing the time complexity down.\\n\\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int delay,forget;\\n    vector<long> memo;\\n    // Total number of people who would have found out about the secret by the nth day.\\n    long dp(int n) {\\n        if(!n)\\n            return 0;\\n        if(memo[n]!=-1)  // Return cached result if exists.\\n            return memo[n];\\n\\t\\t// Current contribution of 1 person who knows the secret\\n        long result=1;\\n        for(int i=delay;i<forget;i++)       // Number of people that the secret will be forwarded to\\n            if(n-i>=0)\\n                result=(result+dp(n-i))%MOD;\\n        return memo[n]=result;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        this->delay=delay;\\n        this->forget=forget;\\n        memo.resize(n+1,-1);\\n        return (dp(n)-dp(n-forget)+MOD)%MOD;    // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\\n\\n## Complexity\\n**Space:** `O(n)`. Due to memoization.\\n**Time** `O(n^2)`. Each state requires `O(n)` work at max to get the result and there are `n` states.\\n\\n## Solution 2 - Bottom Up\\n\\nTo optimize the solution\\'s time complexity we will first have to understand the bottom-up approach which is straight forward, instead of running a memoized DP from `n` we start tabulating our results from `0` to `n`.\\n\\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> memo(n+1,1);    // Each day contributes at least to 1 person kowing the secret.\\n        memo[0]=0;  // End case\\n        for(int i=1;i<=n;i++)\\n            for(int j=delay;j<forget;j++) // Number of people that the secret will be forwarded to\\n                if(i-j>=0)\\n                    memo[i]=(memo[i]+memo[i-j])%MOD;    // Same as our recursion relation.\\n        return (memo[n]-memo[n-forget]+MOD)%MOD;  // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\\n\\n## Complexity\\n**Space:** `O(n)`. Due to storing results of each dp till `n`.\\n**Time** `O(n^2)`. Each state requires `O(n)` work at max to get the result and there are `n` states. The `O(n)` work comes from the summation of `memo[i-forget+1] + memo[i-forget+2] .... memo[i-delay]` where these may be `O(n)` elements.\\n\\n## Solution 3 - Optimized Time Complexity.\\n\\nThe advantage with bottom up approach is that we fill the memo table and find our answers for each day sequentially, we can use this to our advantage to optimize the solution further.\\n\\nYou may notice that at each state `dp(i)` what we are calculating is the sum `dp(i-delay) + dp(i-delay-1) +dp(i-delay-2) ....dp(i-forget+1)` as mentioned earlier. This is nothing but the sum from `dp(i-forget+1) to dp(i-delay)` since `forget > delay`. \\nNow since in the previous bottom up approach we are calculating the results sequentially, at index `i` we have the results of `dp(i-forget+1)` to `dp(i-delay)` stored in `memo` table in `memo[i-forget+1]` to `memo[i-delay]`.\\n\\nHow can we get the sum of these in `O(1)` instead of `O(n)` ?\\n\\nWe can use prefix sum approach i.e. `dp(i-forget+1) + dp(i-forget+2) ... dp(i-delay) = memo[i-forget+1] + memo[i-forget+2] ... memo[i-delay] = PrefixSum[i-delay] - PrefixSum[i-forget]`. Where `PrefixSum[i-delay] = memo[0] + memo[1] .... memo[i-delay]`. This is a common pattern that you can learn in questions like:\\n* [303. Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)\\n\\nNow that we know how to calculate the sum in `O(1)` all we need to do is calculate and store the prefix sum at index `i` as we calculate the result of `dp(i)`. Which brings us to the following optimization.\\n\\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> memo(n+1,1),prefixSum(n+1,0); // New array to store prefix sum.\\n        memo[0]=0; // Base case\\n        for(int i=1;i<=n;i++) {\\n            // The optimization, we avoid going to negative index by max(0,i-x).\\n            // We are using prefix sum to get the sum of all dps from i-forget+1 to i-delay.\\n            memo[i]=(memo[i]+prefixSum[max(0,i-delay)]-prefixSum[max(0,i-forget)]+MOD)%MOD;\\n            prefixSum[i]=(prefixSum[i-1]+memo[i])%MOD; // Store the prefixSum for ith state of dp.\\n        }\\n        return (memo[n]-memo[n-forget]+MOD)%MOD; // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\\n## Complexity\\n**Space:** `O(2n) = O(n)`. Due to storing results of each dp till `n` and their prefix sums.\\n**Time** `O(n)`. Each state requires `O(1)` work at max. This is due to the prefix sum optimization.\\n\\n## Solution 4 - Optimized Space Complexity.\\n\\nOn observing further you may notice that we never need the values before  `dp(i-forget)` i.e. the values `dp(i-forget-1), dp(i-forget-2) ... dp(0)` as we move forward in our algorithm at index `i+1` we only need results after `dp(i-forget+1)` i.e. `dp(i-forget+2), dp(i-forget+3 ... dp(i-delay+1)` and so on. Thus with this information we can optimize the space further by discarding all the results we don\\'t need. We can use a double ended queue for implementing this.\\n\\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        deque<long> memo={0},prefixSum={0}; // Dynamic lists to help discard values in the front (optimizations).\\n        for(int i=1;i<=n;i++) {\\n            // Same as previous section prefix sum optimization.\\n\\t\\t\\t// Here we add 1 as the contribution of ith day as we don\\'t iniatilize memo with 1s\\n            memo.push_back((1+prefixSum[max(0,(int)prefixSum.size()-delay)]-prefixSum[max(0,(int)prefixSum.size()-forget)]+MOD)%MOD);\\n            prefixSum.push_back((prefixSum.back()+memo.back())%MOD); // Store the prefixSum for ith state of dp.\\n            if(memo.size()>forget+1)    // Optimization to discard non-required values\\n                memo.pop_front(),prefixSum.pop_front();\\n        }\\n        return (memo.back()-memo.front()+MOD)%MOD; // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\\n## Complexity\\n**Space:** `O(2*forget) = O(forget)`. Due to storing of at max `forget` dp results and their prefix sums.\\n**Time** `O(n)`. Each state requires `O(1)` work at max. This is due to the prefix sum optimization.\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int delay,forget;\\n    vector<long> memo;\\n    // Total number of people who would have found out about the secret by the nth day.\\n    long dp(int n) {\\n        if(!n)\\n            return 0;\\n        if(memo[n]!=-1)  // Return cached result if exists.\\n            return memo[n];\\n\\t\\t// Current contribution of 1 person who knows the secret\\n        long result=1;\\n        for(int i=delay;i<forget;i++)       // Number of people that the secret will be forwarded to\\n            if(n-i>=0)\\n                result=(result+dp(n-i))%MOD;\\n        return memo[n]=result;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        this->delay=delay;\\n        this->forget=forget;\\n        memo.resize(n+1,-1);\\n        return (dp(n)-dp(n-forget)+MOD)%MOD;    // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> memo(n+1,1);    // Each day contributes at least to 1 person kowing the secret.\\n        memo[0]=0;  // End case\\n        for(int i=1;i<=n;i++)\\n            for(int j=delay;j<forget;j++) // Number of people that the secret will be forwarded to\\n                if(i-j>=0)\\n                    memo[i]=(memo[i]+memo[i-j])%MOD;    // Same as our recursion relation.\\n        return (memo[n]-memo[n-forget]+MOD)%MOD;  // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> memo(n+1,1),prefixSum(n+1,0); // New array to store prefix sum.\\n        memo[0]=0; // Base case\\n        for(int i=1;i<=n;i++) {\\n            // The optimization, we avoid going to negative index by max(0,i-x).\\n            // We are using prefix sum to get the sum of all dps from i-forget+1 to i-delay.\\n            memo[i]=(memo[i]+prefixSum[max(0,i-delay)]-prefixSum[max(0,i-forget)]+MOD)%MOD;\\n            prefixSum[i]=(prefixSum[i-1]+memo[i])%MOD; // Store the prefixSum for ith state of dp.\\n        }\\n        return (memo[n]-memo[n-forget]+MOD)%MOD; // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```\n```c++\\nstatic int MOD=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        deque<long> memo={0},prefixSum={0}; // Dynamic lists to help discard values in the front (optimizations).\\n        for(int i=1;i<=n;i++) {\\n            // Same as previous section prefix sum optimization.\\n\\t\\t\\t// Here we add 1 as the contribution of ith day as we don\\'t iniatilize memo with 1s\\n            memo.push_back((1+prefixSum[max(0,(int)prefixSum.size()-delay)]-prefixSum[max(0,(int)prefixSum.size()-forget)]+MOD)%MOD);\\n            prefixSum.push_back((prefixSum.back()+memo.back())%MOD); // Store the prefixSum for ith state of dp.\\n            if(memo.size()>forget+1)    // Optimization to discard non-required values\\n                memo.pop_front(),prefixSum.pop_front();\\n        }\\n        return (memo.back()-memo.front()+MOD)%MOD; // Subtract the people who found out by the `n-forget` day as observed.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229808,
                "title": "two-queues-or-rolling-array",
                "content": "The second solution below is the optimized version of the first one, though it could be hard to debug.\\n\\nTherefore, we will start with the two queues solution, which should be easier to code and build an intuition.\\n\\n#### Two Queues\\n\\nWe use separate queues to track how many people are ready to tell the secret each day (`d`), and how many people are going to forget the secret (`f`).\\n\\nWe track the current number of people who can share the secret in `sharing`.\\n\\nEach day, three things happen:\\n1. We add people in the front of the `d` queue to `sharing` (if `d.size() >= delay`).\\n2. We subtract people in the front of `f` queue from `sharing` (if `f.size() >= forget`).\\n3. The resulting `sharing` people tell the secret to the same number of new people.\\n\\t- We add these new people to the back of the `d` and `f` queues.\\n\\n**C++**\\n```cpp\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n    long long sharing = 0, mod = 1000000007;\\n    deque<int> d{1}, f{1};\\n    while (--n > 0) {\\n        if (d.size() >= delay) {\\n            sharing = (sharing + d.front()) % mod;\\n            d.pop_front();\\n        }\\n        if (f.size() >= forget) {\\n            sharing = (mod + sharing - f.front()) % mod;\\n            f.pop_front();\\n        }\\n        d.push_back(sharing);\\n        f.push_back(sharing);\\n    }\\n    return accumulate(begin(f), end(f), 0LL) % mod;\\n} \\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(delay + forget)\\n\\n#### Rolling Array\\nThis solution does exactly the same as the one above, using one rolling array instead of two queues.\\n**Python 3**\\n```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, d: int, f: int) -> int:\\n        dp, md = [1] + [0] * (f - 1), 10**9 + 7\\n        for i in range(1, n):\\n            dp[i % f] = (md + dp[(i + f - d) % f] - dp[i % f] + (0 if i == 1 else dp[(i - 1) % f])) % md\\n        return sum(dp) % md\\n```\\n**C++**\\n```cpp\\nint peopleAwareOfSecret(int n, int d, int f) {\\n    vector<long long> dp(f);\\n    dp[0] = 1;\\n    int mod = 1000000007;\\n    for (int i = 1; i < n; ++i)\\n        dp[i % f] = (mod + (i - 1 ? dp[(i - 1) % f] : 0) + dp[(i + f - d) % f] - dp[i % f]) % mod;\\n    return accumulate(begin(dp), end(dp), 0LL) % mod;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(forget)",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n    long long sharing = 0, mod = 1000000007;\\n    deque<int> d{1}, f{1};\\n    while (--n > 0) {\\n        if (d.size() >= delay) {\\n            sharing = (sharing + d.front()) % mod;\\n            d.pop_front();\\n        }\\n        if (f.size() >= forget) {\\n            sharing = (mod + sharing - f.front()) % mod;\\n            f.pop_front();\\n        }\\n        d.push_back(sharing);\\n        f.push_back(sharing);\\n    }\\n    return accumulate(begin(f), end(f), 0LL) % mod;\\n} \\n```\n```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, d: int, f: int) -> int:\\n        dp, md = [1] + [0] * (f - 1), 10**9 + 7\\n        for i in range(1, n):\\n            dp[i % f] = (md + dp[(i + f - d) % f] - dp[i % f] + (0 if i == 1 else dp[(i - 1) % f])) % md\\n        return sum(dp) % md\\n```\n```cpp\\nint peopleAwareOfSecret(int n, int d, int f) {\\n    vector<long long> dp(f);\\n    dp[0] = 1;\\n    int mod = 1000000007;\\n    for (int i = 1; i < n; ++i)\\n        dp[i % f] = (mod + (i - 1 ? dp[(i - 1) % f] : 0) + dp[(i + f - d) % f] - dp[i % f]) % mod;\\n    return accumulate(begin(dp), end(dp), 0LL) % mod;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229807,
                "title": "with-explanation-dp-c",
                "content": "**Explanation:-**\\n1. We have to do ```Dp on days```.\\n2. ```Dp[curDay]``` = if some person knows the secret on ```curDay``` then to how many people he call the secret + to how many people those people can tell and so on.\\n\\n**TC:- O(n^2)\\nSc:- O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    long dp[1001];\\n    long m=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(1,n,delay,forget);\\n    }\\n    long helper(int day,int &n,int &delay,int &forget){\\n        // some people know the secret on this day\\n        if(dp[day]!=-1)\\n            return dp[day];\\n        long ans=0;\\n        // he is the one who knows the secret so do ans++\\n        ans++;\\n        // but if till the end of nth day he forgets the secret then do we have to add this to answer?  No\\n        if(day+forget<=n)\\n            ans--;\\n        // now on what days he can tell the secret?   that is from day+delay to min(day+forget,n+1)-1\\n        for(int start=day+delay;start<(min(day+forget,n+1));start++){\\n            ans+=helper(start,n,delay,forget);\\n            ans%=m;\\n        }\\n        // store it in dp\\n        dp[day]=ans;\\n        return ans;\\n        \\n    }\\n};\\n```\\nDo **UPVOTE** if  it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```Dp on days```\n```Dp[curDay]```\n```curDay```\n```\\nclass Solution {\\npublic:\\n    long dp[1001];\\n    long m=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(1,n,delay,forget);\\n    }\\n    long helper(int day,int &n,int &delay,int &forget){\\n        // some people know the secret on this day\\n        if(dp[day]!=-1)\\n            return dp[day];\\n        long ans=0;\\n        // he is the one who knows the secret so do ans++\\n        ans++;\\n        // but if till the end of nth day he forgets the secret then do we have to add this to answer?  No\\n        if(day+forget<=n)\\n            ans--;\\n        // now on what days he can tell the secret?   that is from day+delay to min(day+forget,n+1)-1\\n        for(int start=day+delay;start<(min(day+forget,n+1));start++){\\n            ans+=helper(start,n,delay,forget);\\n            ans%=m;\\n        }\\n        // store it in dp\\n        dp[day]=ans;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229904,
                "title": "simple-c-commented",
                "content": "```\\n#define ll long long\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<ll> v(n+1,0);//v[i] will store how many person knows the secret on ith day\\n        \\n        \\n        \\n        v[0] = 1; //only 1 person knows the secret on day 1\\n        int mod = 1000000007;\\n        for(int i =0 ;i < n;i ++)// for each day (i) the persons who knows the secret on that day will start spreading it from (i+delay)th day\\n        {\\n            if(v[i] == 0)//no one knows a secret\\n                continue;\\n            for(int j = i + delay;j < n && (j-i)  < forget;j++) // it start spreading the secret on  (i+delay)th day til it forgets after (i+forget)th day\\n            {\\n                v[j] += v[i];\\n                v[j] = v[j]%mod;\\n            }\\n        }\\n        \\n        ll ans = 0;\\n     \\n        for(int i = n-1;i >= n-forget;i--)// taking last (forget-1) persons becaause the persons before that would have forgotten till nth day\\n        {\\n            ans += v[i];\\n            ans = ans%mod;\\n        }\\n        \\n        return ans;\\n    }```\\n\\t\\n\\tUpvote if it helped!!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<ll> v(n+1,0);//v[i] will store how many person knows the secret on ith day\\n        \\n        \\n        \\n        v[0] = 1; //only 1 person knows the secret on day 1\\n        int mod = 1000000007;\\n        for(int i =0 ;i < n;i ++)// for each day (i) the persons who knows the secret on that day will start spreading it from (i+delay)th day\\n        {\\n            if(v[i] == 0)//no one knows a secret\\n                continue;\\n            for(int j = i + delay;j < n && (j-i)  < forget;j++) // it start spreading the secret on  (i+delay)th day til it forgets after (i+forget)th day\\n            {\\n                v[j] += v[i];\\n                v[j] = v[j]%mod;\\n            }\\n        }\\n        \\n        ll ans = 0;\\n     \\n        for(int i = n-1;i >= n-forget;i--)// taking last (forget-1) persons becaause the persons before that would have forgotten till nth day\\n        {\\n            ans += v[i];\\n            ans = ans%mod;\\n        }\\n        \\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229834,
                "title": "bottom-up-dp-simple-explanation-c",
                "content": "\\nThis problem can be divided into smaller sub problems. As we can see, if a person knows the secret and he tells the seret to someone else then the other person acts independently.\\nFor.e.g.\\nn = 6, delay = 2, forget = 4\\n\\nHere Person A knows on day 1,\\nThen he tells B on day 3 ( now from day 3 to day 6 B will act independently)\\nThen he tells C on day 4( now C acts on its own)\\n\\nTherefore , we can approach this problem in a bottom up manner where for each n we will store what will happen if there were n days and 1 person knows the secret initially.\\n\\n```\\n  vector<long long> vec(n+1);           \\n        vec[0] = 0;\\n        vec[1] = 1;\\n        int mod = 1e9+7;\\n        for(int i =1;i<=delay;i++)vec[i] = 1;   // only 1 person knows secret till delay\\n        \\n        for(int i = delay+1;i<=n;i++){\\n             for(int j = delay;j<forget ;j++){     // he tells secret from delay till forget \\n                 if(i-j<=0)break;\\n                 vec[i] =(vec[i]%mod + vec[i-j]%mod)%mod;\\n             }\\n               vec[i]+=1;\\n            \\n            if(i-forget>=1)vec[i]--;          // the person forgot the secret \\n        \\n        }\\n        \\n        return vec[n];\\n```\\n\\n\\n# Time Complexity : O(n x n)\\n# Space Complexity : O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  vector<long long> vec(n+1);           \\n        vec[0] = 0;\\n        vec[1] = 1;\\n        int mod = 1e9+7;\\n        for(int i =1;i<=delay;i++)vec[i] = 1;   // only 1 person knows secret till delay\\n        \\n        for(int i = delay+1;i<=n;i++){\\n             for(int j = delay;j<forget ;j++){     // he tells secret from delay till forget \\n                 if(i-j<=0)break;\\n                 vec[i] =(vec[i]%mod + vec[i-j]%mod)%mod;\\n             }\\n               vec[i]+=1;\\n            \\n            if(i-forget>=1)vec[i]--;          // the person forgot the secret \\n        \\n        }\\n        \\n        return vec[n];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229977,
                "title": "python-3-explanation-with-pictures-o-n",
                "content": "For each day `d`, we only focus on the number of people who first know the secret from day `d`.\\n### Solution 1. O(N^2)\\n\\nFor each day `d`, update the people knowing the secret accordingly, as shown in the picture.\\n\\n![image](https://assets.leetcode.com/users/images/70d080d1-068c-4032-9ad9-7026e6748d33_1656821055.9810927.png)\\n\\nThen iterate over all the days, if the people at day `d` still know the secret at day `n`, add their number to answer.\\n\\n```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, dd: int, ff: int) -> int:\\n        dp, mod, ans = [0] * 1001, 1000000007, 0\\n        dp[1] = 1\\n        for d in range(1, n + 1):\\n            if dp[d] > 0:\\n                for nxt in range(d + dd, min(d + ff, 1001)):\\n                    dp[nxt] += dp[d]\\n        for d in range(1, n + 1):\\n            if d + ff > n:\\n                ans += dp[d]\\n        return ans % mod\\n```\\n\\n### Solution 2. O(N)\\n\\nNotice that we can update `dp` and calculate the sum of valid people in a single iteration, use prefix method to store the number of people who first know the secret at each day.\\n\\n![image](https://assets.leetcode.com/users/images/89af8769-9fc3-4578-9f67-419324021ce6_1656821059.8699133.png)\\n\\n```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, dd: int, ff: int) -> int:\\n        dp, mod = [0] * 1002, 1000000007\\n        dp[1], dp[2] = 1, -1\\n        cur, ans = 0, 0\\n        \\n        for d in range(1, n + 1):\\n            cur += dp[d]\\n            if d + ff > n:\\n                ans += cur\\n            if cur > 0:\\n                dp[min(d + dd, 1001)] += cur\\n                dp[min(d + ff, 1001)] -= cur\\n\\n        return ans % mod\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, dd: int, ff: int) -> int:\\n        dp, mod, ans = [0] * 1001, 1000000007, 0\\n        dp[1] = 1\\n        for d in range(1, n + 1):\\n            if dp[d] > 0:\\n                for nxt in range(d + dd, min(d + ff, 1001)):\\n                    dp[nxt] += dp[d]\\n        for d in range(1, n + 1):\\n            if d + ff > n:\\n                ans += dp[d]\\n        return ans % mod\\n```\n```python\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, dd: int, ff: int) -> int:\\n        dp, mod = [0] * 1002, 1000000007\\n        dp[1], dp[2] = 1, -1\\n        cur, ans = 0, 0\\n        \\n        for d in range(1, n + 1):\\n            cur += dp[d]\\n            if d + ff > n:\\n                ans += cur\\n            if cur > 0:\\n                dp[min(d + dd, 1001)] += cur\\n                dp[min(d + ff, 1001)] -= cur\\n\\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229835,
                "title": "java-o-n-solution",
                "content": "The idea is to calculate the number of people that are going to share the secret each day.\\n\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }\\n        if (forget < n) {\\n            forgets[forget + 1] = 1;\\n        }\\n        \\n        long shareToday = 0;\\n        long peopleKnow = 1;\\n        for (int i = delay; i <= n; i++) {\\n            shareToday += shares[i] % mod;\\n            shareToday -= forgets[i] % mod;\\n\\t\\t\\t\\n            peopleKnow -= forgets[i] % mod;\\n            peopleKnow += shareToday % mod;\\n            \\n            if (i + delay < n + 1) {\\n                shares[i + delay] += shareToday % mod;\\n            }\\n            if (i + forget < n + 1) {    \\n                forgets[i + forget] += shareToday % mod;\\n            }\\n        }\\n        \\n        return (int) (peopleKnow % mod);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }\\n        if (forget < n) {\\n            forgets[forget + 1] = 1;\\n        }\\n        \\n        long shareToday = 0;\\n        long peopleKnow = 1;\\n        for (int i = delay; i <= n; i++) {\\n            shareToday += shares[i] % mod;\\n            shareToday -= forgets[i] % mod;\\n\\t\\t\\t\\n            peopleKnow -= forgets[i] % mod;\\n            peopleKnow += shareToday % mod;\\n            \\n            if (i + delay < n + 1) {\\n                shares[i + delay] += shareToday % mod;\\n            }\\n            if (i + forget < n + 1) {    \\n                forgets[i + forget] += shareToday % mod;\\n            }\\n        }\\n        \\n        return (int) (peopleKnow % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229832,
                "title": "python-dp-with-explanation-easy-to-understand",
                "content": "**Explanation:**\\n1. The dp array stores the number of people who start to know the secret at ith day.\\n2. We are interested in the number of people who satisfy the following conditions (they will inform a new person the secret at ith day):\\nA. know the secret\\nB. at least \\'delay\\' time away from the current ith day ([:i-delay+1])\\nC. not too far away from the current ith day, so that they still remember the secret ([i-forget+1:])\\n3. Take the sum of the number of people who meet those conditions, we get the state transition relation:\\ndp[i] = sum(dp[i-forget+1:i-delay+1])\\n4. The final result equals to the number of people who still remember the secret.\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0] * n\\n        dp[0] = 1\\n        \\n        for i in range(delay, n):\\n            if i < forget - 1:\\n                dp[i] = sum(dp[:i-delay+1])\\n            else:\\n                dp[i] = sum(dp[i-forget+1:i-delay+1])\\n\\n        return sum(dp[n-forget:]) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0] * n\\n        dp[0] = 1\\n        \\n        for i in range(delay, n):\\n            if i < forget - 1:\\n                dp[i] = sum(dp[:i-delay+1])\\n            else:\\n                dp[i] = sum(dp[i-forget+1:i-delay+1])\\n\\n        return sum(dp[n-forget:]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229864,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nll m=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<ll> vec(n,0);\\n        vec[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+delay;j<i+forget && j<n ;j++)\\n            {\\n                vec[j]=(vec[j]%m+vec[i]%m)%m;\\n            }\\n        }\\n        ll ans=0;\\n        for(int i=n-forget;i<n;i++)\\n        {\\n            ans=(ans%m+vec[i]%m)%m;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll m=1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<ll> vec(n,0);\\n        vec[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+delay;j<i+forget && j<n ;j++)\\n            {\\n                vec[j]=(vec[j]%m+vec[i]%m)%m;\\n            }\\n        }\\n        ll ans=0;\\n        for(int i=n-forget;i<n;i++)\\n        {\\n            ans=(ans%m+vec[i]%m)%m;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230025,
                "title": "simple-python-dynamic-program-with-explaination",
                "content": "1.dp[i] represent people who knows the secret at the day i\\n 2. people who knows the news from day i - forgot + 1 to i - dealy can share the news on day i. \\n\\n```\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0] * n\\n        dp[0] = 1\\n        for i in range(0, n):\\n            for j in range(i - forget + 1, i-delay + 1):\\n\\t\\t# people who knows the news from day i - forgot + 1 to i - dealy can share the news on day i. \\n                if j >= 0:\\n                    dp[i] += dp[j]\\n\\n        return sum(dp[-1 - forget + 1:]) % (10**9 + 7)\\n\\t\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0] * n\\n        dp[0] = 1\\n        for i in range(0, n):\\n            for j in range(i - forget + 1, i-delay + 1):\\n\\t\\t# people who knows the news from day i - forgot + 1 to i - dealy can share the news on day i. \\n                if j >= 0:\\n                    dp[i] += dp[j]\\n\\n        return sum(dp[-1 - forget + 1:]) % (10**9 + 7)\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2231158,
                "title": "c-simple-dp-intuitive",
                "content": "This question was nothing but a simple dp problem. The relation we will form in this problem is just like we do in other dp problems. We will stand at a position, and see how many people before this position will reveal the secret today and store the answer at that index in an array. \\n\\nWe loop for every position, and for each position, we see all the valid people in past, who will reveal the secret today. Those people are those who have not forgotten yet, and who has passed the delay period. Therefore, we run another loop `j` from `i-forget+1` to `i-delay`. For all these people, we add their `dp[j]` to `dp[i]`. \\nWe have another two conditions, \\n```\\nif(i-delay>=1) dp[i]++\\nand\\nif(i-forget>=1) dp[i]--\\n```\\nThe first one is for the case when the delay period is over for some person. This person will now reveal the secret to a person. \\nThen there comes the loop that will accumulate all the people who knows the secret on ith day. \\nThen the last condition makes sure to remove the person who will forget the secret today. \\n**Note** Since people are knowing secret one by one, therefore they will forget it one by one. That for loop will actually add the count of all people who can reveal the secret today. It omits the one who has already forgotten. \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int count = 1;\\n        vector <int> dp(n+1,0);\\n        \\n        // The first person knows the secret.\\n        dp[1] = 1;\\n        for(int i = 2; i<=n; i++){\\n            // If the delay period is over, the secret will be told to someone. \\n            if(i-delay>=1) dp[i]++;\\n            \\n            // This loop determines the total number of people who knows the secret. \\n            for(int j = max(1,i-forget+1); j<=max(1,i-delay); j++)\\n                dp[i] = (dp[i]%mod + dp[j]%mod)%mod;\\n            \\n            // If there is someone who will forget today, make him forget :)\\n            if(i-forget>=1) dp[i]--;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif(i-delay>=1) dp[i]++\\nand\\nif(i-forget>=1) dp[i]--\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int count = 1;\\n        vector <int> dp(n+1,0);\\n        \\n        // The first person knows the secret.\\n        dp[1] = 1;\\n        for(int i = 2; i<=n; i++){\\n            // If the delay period is over, the secret will be told to someone. \\n            if(i-delay>=1) dp[i]++;\\n            \\n            // This loop determines the total number of people who knows the secret. \\n            for(int j = max(1,i-forget+1); j<=max(1,i-delay); j++)\\n                dp[i] = (dp[i]%mod + dp[j]%mod)%mod;\\n            \\n            // If there is someone who will forget today, make him forget :)\\n            if(i-forget>=1) dp[i]--;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230135,
                "title": "easy-dp-solution-c",
                "content": "Idea:  For each time t, store how many new persons know the secret at time t. For doing this, we will go from time[t-forget+1] to time[t-delay] and add them to time[t]. At last we will find sum of time[n-forget+1] to time[n].\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int i=2;\\n        long long time[n+1];\\n        memset(time,0,sizeof(time));\\n        int mod=1e9+7;\\n        long long ans=0;\\n        time[1]=1;\\n        while(i<=n){\\n            for(int j=1;j<i;j++){\\n                if(i-j>=delay && i-j<forget){\\n                    time[i]=(time[j]+time[i])%mod;\\n                }\\n            }\\n            i++;\\n        }\\n        for(int j=max(1,n-forget+1);j<=n;j++){\\n            ans=(ans+time[j])%mod;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int i=2;\\n        long long time[n+1];\\n        memset(time,0,sizeof(time));\\n        int mod=1e9+7;\\n        long long ans=0;\\n        time[1]=1;\\n        while(i<=n){\\n            for(int j=1;j<i;j++){\\n                if(i-j>=delay && i-j<forget){\\n                    time[i]=(time[j]+time[i])%mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2229942,
                "title": "c-recursion-with-memoization",
                "content": "**Explanation**: \\n\\n`dp[i]` states if a person knows the secret message  on the `ith` days, then how many total person, will remember the secret message at the end of `n`th days.\\n\\nSo if a person knows the message at `start`  day, he will forget the message on `start + forget`th days. So if `start+forget` is greater than `n` then only he can remember the message at the end of `n`th days.\\n\\nTherefore if `start+forget > n` then that person will be counted in answer (initialize ans = 1).\\nelse that person will forget the message and will not be counted in (initialize ans = 0).\\n\\nAfter then total ans will be, sum of count contributed by the person whom current person shared the message.\\nSince he will start sharing `delay` days after he will get to know (means from `start+delay`)  till he doesn\\'t forget(`start+forget`).\\n\\nSince there will be many overlapping cases, we can memoize the result to get result in `O(n)` time complexity.\\n\\n**C++ Code:**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mod= 1e9 + 7;\\n    int solve(int start, int delay, int forget, int n, vector<int> &dp)\\n    {\\n        if(delay==forget) return 1;\\n        if(dp[start] != -1) return dp[start];\\n        \\n\\t\\t// to check current person will forget before n days or not\\n        int mul = (start+forget) > n;\\n        int ans = 1*mul;\\n        for(int day=start+delay; day < min(start+forget, n+1); day++)\\n            ans = ( ans + solve(day, delay, forget, n, dp) ) % mod;\\n        \\n        return dp[start] = ans;\\n    }\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        vector<int> dp(n+1, -1);\\n        return solve(1, d, f, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mod= 1e9 + 7;\\n    int solve(int start, int delay, int forget, int n, vector<int> &dp)\\n    {\\n        if(delay==forget) return 1;\\n        if(dp[start] != -1) return dp[start];\\n        \\n\\t\\t// to check current person will forget before n days or not\\n        int mul = (start+forget) > n;\\n        int ans = 1*mul;\\n        for(int day=start+delay; day < min(start+forget, n+1); day++)\\n            ans = ( ans + solve(day, delay, forget, n, dp) ) % mod;\\n        \\n        return dp[start] = ans;\\n    }\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        vector<int> dp(n+1, -1);\\n        return solve(1, d, f, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229941,
                "title": "easy-simulation-with-explanation",
                "content": "##### Explanation\\n* We could simulate the given requriements with an Array\\n* Let\\'s maintain an Array, `people`, where every index, `idx`, tracks the delay and forget timeline for everybody. Note that we do not care about people who forget about the secret, so the size could be `forget` for the Array \\n* Initially, only 1 person will know the secret\\n* Next, for the days between `(1, n - 1)`:\\n\\t* Everybody will move forward in their timeline. They will go closer to \"the forgetting deadline\". To simulate, let\\'s shift the people to their next day\\n\\t* Everybody who is past their delay and present in the Array will share secrets with somebody new. To simulate, update the first day count by checking how many people may now share the secret (whether they\\'ve passed the delay time)\\t\\n\\n##### Complexities\\n* Time: `O(n * forget)`\\n* Space: `O(forget)`\\n\\n```\\ndef mod_add(a: int, b: int) -> int:\\n\\tMOD = 1000000007\\n\\treturn ((a % MOD) + (b % MOD)) % MOD \\n\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        people = [0] * forget\\n        people[0] = 1\\n        \\n        for _ in range(1, n):\\n            for idx in range(forget - 1, 0, -1):\\n                people[idx] = people[idx - 1] \\n            \\n            new = 0\\n            for idx in range(forget):\\n                if idx >= delay:\\n                    new = mod_add(new, people[idx])\\n                    \\n            people[0] = new\\n            \\n        total = 0\\n        for p in people:\\n            total = mod_add(total, p)\\n            \\n        return total      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef mod_add(a: int, b: int) -> int:\\n\\tMOD = 1000000007\\n\\treturn ((a % MOD) + (b % MOD)) % MOD \\n\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        people = [0] * forget\\n        people[0] = 1\\n        \\n        for _ in range(1, n):\\n            for idx in range(forget - 1, 0, -1):\\n                people[idx] = people[idx - 1] \\n            \\n            new = 0\\n            for idx in range(forget):\\n                if idx >= delay:\\n                    new = mod_add(new, people[idx])\\n                    \\n            people[0] = new\\n            \\n        total = 0\\n        for p in people:\\n            total = mod_add(total, p)\\n            \\n        return total      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234193,
                "title": "c-properly-annotated-optimized-bottom-up-dp-solution-4ms-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n, 0); // for storing the number of people knowing the secret on the ith day\\n        int mod = 1e9+7;\\n        for(int i = 0;i<n;i++){\\n            if(i<delay) dp[i] = 1; // only a single person knows about the secret\\n            else if(i>=delay and i<forget){// nobody has forgotten the secret till now\\n\\t\\t\\t\\t// dp[i - delay] = people who were told the secret (= those people who will be able to share the secret at the ith day)\\n\\t\\t\\t\\t// dp[i-1] = people who knew the secret already\\n                dp[i] = (dp[i-delay] + dp[i-1] + mod)%mod;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t// dp[i - delay] = those people who will be able to share the secret on the ith day\\n\\t\\t\\t// dp[i - forget] = those people who\\'ll forget the secret on the ith day\\n\\t\\t\\t// dp[i - delay] - dp[i-forget] = those new people who were told the secret\\n\\t\\t\\t// (dp[i - delay] - dp[i - forget]) + dp[i-1] = people who were told the secret + people who knew the secret\\n                dp[i] = ((dp[i-delay] - dp[i-forget]) + dp[i-1] + mod)%mod;\\n            }\\n        }\\n        int lastForget = n-1 - forget; //people who knew the secret up until this day will forget it on the nth day\\n\\t\\t// dp[n-1] - dp[lastForget] = the actual number of people who know the secret on the nth day\\n        return (lastForget>=0) ? (dp[n-1] - dp[lastForget] + mod)%mod : dp[n-1]%mod;\\n    }\\n};\\n```\\n\\n* Time Complexity: O(n)\\n* Space Complexity: O(n)\\n\\n**Clean Code:**\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n, 0);\\n        int mod = 1e9+7;\\n        for(int i = 0;i<n;i++){\\n            if(i<delay) dp[i] = 1;\\n            else if(i>=delay and i<forget){\\n                dp[i] = (dp[i-delay] + dp[i-1] + mod)%mod;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t    dp[i] = ((dp[i-delay] - dp[i-forget]) + dp[i-1] + mod)%mod;\\n            }  \\n        }\\n        int lastForget = n-1 - forget;\\n        return (lastForget>=0) ? (dp[n-1] - dp[lastForget] + mod)%mod : dp[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n, 0); // for storing the number of people knowing the secret on the ith day\\n        int mod = 1e9+7;\\n        for(int i = 0;i<n;i++){\\n            if(i<delay) dp[i] = 1; // only a single person knows about the secret\\n            else if(i>=delay and i<forget){// nobody has forgotten the secret till now\\n\\t\\t\\t\\t// dp[i - delay] = people who were told the secret (= those people who will be able to share the secret at the ith day)\\n\\t\\t\\t\\t// dp[i-1] = people who knew the secret already\\n                dp[i] = (dp[i-delay] + dp[i-1] + mod)%mod;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t// dp[i - delay] = those people who will be able to share the secret on the ith day\\n\\t\\t\\t// dp[i - forget] = those people who\\'ll forget the secret on the ith day\\n\\t\\t\\t// dp[i - delay] - dp[i-forget] = those new people who were told the secret\\n\\t\\t\\t// (dp[i - delay] - dp[i - forget]) + dp[i-1] = people who were told the secret + people who knew the secret\\n                dp[i] = ((dp[i-delay] - dp[i-forget]) + dp[i-1] + mod)%mod;\\n            }\\n        }\\n        int lastForget = n-1 - forget; //people who knew the secret up until this day will forget it on the nth day\\n\\t\\t// dp[n-1] - dp[lastForget] = the actual number of people who know the secret on the nth day\\n        return (lastForget>=0) ? (dp[n-1] - dp[lastForget] + mod)%mod : dp[n-1]%mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n, 0);\\n        int mod = 1e9+7;\\n        for(int i = 0;i<n;i++){\\n            if(i<delay) dp[i] = 1;\\n            else if(i>=delay and i<forget){\\n                dp[i] = (dp[i-delay] + dp[i-1] + mod)%mod;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t    dp[i] = ((dp[i-delay] - dp[i-forget]) + dp[i-1] + mod)%mod;\\n            }  \\n        }\\n        int lastForget = n-1 - forget;\\n        return (lastForget>=0) ? (dp[n-1] - dp[lastForget] + mod)%mod : dp[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230292,
                "title": "c-greedy-100-faster-o-n-time-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        queue<pair<int,ll>> d,f;\\n        ll ans=1;                   // persons currently who knows the secret\\n        ll cnt=0;                   // persons currently  who can share the secret \\n        d.push({1+delay,1});\\n        f.push({1+forget,1});\\n        int i=2;\\n        while(i<=n){\\n            if(!f.empty() && f.front().first==i){                   // forget time\\n                auto it= f.front();\\n                cnt=(cnt-(it.second)+mod)%mod;\\n                ans=(ans-(it.second)+mod)%mod;\\n                f.pop();\\n            }\\n            if(!d.empty() && d.front().first==i){                  // after their delay time completed, more people can start sharing secret \\n                auto it= d.front();\\n                cnt+=it.second;\\n                cnt%=mod;\\n                d.pop();\\n            }\\n            ans+=cnt;                 // secret shared\\n            ans%=mod;\\n            if(cnt!=0) d.push({i+delay,cnt});                  // adding new persons delay\\n            if(cnt!=0) f.push({i+forget,cnt});                 // and forget time to queues\\n            i++;\\n        }\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n};\\n\\n    \\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        queue<pair<int,ll>> d,f;\\n        ll ans=1;                   // persons currently who knows the secret\\n        ll cnt=0;                   // persons currently  who can share the secret \\n        d.push({1+delay,1}",
                "codeTag": "Java"
            },
            {
                "id": 2233478,
                "title": "1d-dp-complete-explaination-time-o-n-faster-then-100",
                "content": "~  Key Idea is we are going to use dp to solve this preoblem\\nwhere dp[i] represent number people get know the secret on ith day.\\n##### numOfPeopleGoingToKnow = numOfPeopleKnowBefore + numOfNewPeopleKnow - numOfPeopleForget;\\nwhere :-\\n\\t- numOfNewPeoleKnow = dp[i - delay];\\n\\t- numOfPeopleForget = dp[i - forget];\\n\\n```\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>dp(n+1);\\n        int mod = 1e9 + 7;\\n        dp[1] = 1;  //on day-1 only 1 people know\\n        long long peopleKnowingSecreat = 0;\\n        for(int day = 2; day <= n; day++){\\n            peopleKnowingSecreat = (peopleKnowingSecreat + dp[max(day-delay,0)] - dp[max(day-forget, 0)] + mod)%mod;\\n            dp[day] = peopleKnowingSecreat;\\n        }\\n        int numOfPeoples = 0; \\n\\t\\t/* total num of peoples know the secret on nth day = sum of all peoples get to know the secret on (n - forget + 1)th day to nth day,\\n\\t\\tbecause the peoples who get secret on forget day before nth day will forgot the secret on nth day.  */\\n        for(int day = n - forget + 1; day <= n; day++){\\n            numOfPeoples = (numOfPeoples + dp[day])%mod;\\n        }\\n        return numOfPeoples;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "~  Key Idea is we are going to use dp to solve this preoblem\\nwhere dp[i] represent number people get know the secret on ith day.\\n##### numOfPeopleGoingToKnow = numOfPeopleKnowBefore + numOfNewPeopleKnow - numOfPeopleForget;\\nwhere :-\\n\\t- numOfNewPeoleKnow = dp[i - delay];\\n\\t- numOfPeopleForget = dp[i - forget];\\n\\n```\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>dp(n+1);\\n        int mod = 1e9 + 7;\\n        dp[1] = 1;  //on day-1 only 1 people know\\n        long long peopleKnowingSecreat = 0;\\n        for(int day = 2; day <= n; day++){\\n            peopleKnowingSecreat = (peopleKnowingSecreat + dp[max(day-delay,0)] - dp[max(day-forget, 0)] + mod)%mod;\\n            dp[day] = peopleKnowingSecreat;\\n        }\\n        int numOfPeoples = 0; \\n\\t\\t/* total num of peoples know the secret on nth day = sum of all peoples get to know the secret on (n - forget + 1)th day to nth day,\\n\\t\\tbecause the peoples who get secret on forget day before nth day will forgot the secret on nth day.  */\\n        for(int day = n - forget + 1; day <= n; day++){\\n            numOfPeoples = (numOfPeoples + dp[day])%mod;\\n        }\\n        return numOfPeoples;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230299,
                "title": "python-using-dictionary",
                "content": "```\\n\\n```class Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        table = [0]*(forget+1)\\n        table[1] = 1\\n        days = 1\\n        while days<=n-1:\\n            count = 0\\n            for k in range(forget-1,-1,-1):\\n                if k+1>delay:\\n                    table[k+1] = table[k]\\n                    count+=table[k]\\n                elif k+1<=delay:\\n                    table[k+1] = table[k]\\n            table[1] = count\\n            days+=1\\n        count = 0\\n        for k in range(1,forget+1):\\n            count+=table[k]\\n        return count%(pow(10,9)+7)\\n\\t\\t\\nTC---O(forget*n)\\nsc---O(forget)\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230263,
                "title": "python-tabulation-with-visual-explanation",
                "content": "The main idea is that on each i\\'th day, every person who knows the secret, can tell one new person on every day within the range (lower, upper-1). where - \\n\\t1. Lower is calculated based on current day + delay\\n\\t2. Upper is the day before the person forgets which is i + forget (not inclusive)\\n\\nthus the main tabulation formula is dp[j] += dp[i] with some conditions. \\n\\nNote: The second dp[i] in the table below is the updated value. This is based on whether the specific `i` contributes to the final answer or not. This depends on whether people who knew the secret on the `i`th day will remember or forget on the `n`th day. \\n![image](https://assets.leetcode.com/users/images/e7a464fe-3b2c-49cd-a001-d032d8eb9a26_1656822570.2243476.png)\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        dp = [0] * (n + 1)\\n        dp[0] = 0\\n        dp[1] = 1\\n        \\n        for i in range(1, n+1):\\n            if dp[i] > 0:\\n                lower = i + delay # 3\\n                upper = i + forget\\n                upper_bound = min(upper, n+1)\\n                for j in range(lower, upper_bound):\\n                    dp[j] += dp[i]\\n\\n                if upper <= n:\\n                    dp[i] = 0\\n        \\n        print(dp)\\n        return sum(dp) % (10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "The main idea is that on each i\\'th day, every person who knows the secret, can tell one new person on every day within the range (lower, upper-1). where - \\n\\t1. Lower is calculated based on current day + delay\\n\\t2. Upper is the day before the person forgets which is i + forget (not inclusive)\\n\\nthus the main tabulation formula is dp[j] += dp[i] with some conditions. \\n\\nNote: The second dp[i] in the table below is the updated value. This is based on whether the specific `i` contributes to the final answer or not. This depends on whether people who knew the secret on the `i`th day will remember or forget on the `n`th day. \\n![image](https://assets.leetcode.com/users/images/e7a464fe-3b2c-49cd-a001-d032d8eb9a26_1656822570.2243476.png)\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        dp = [0] * (n + 1)\\n        dp[0] = 0\\n        dp[1] = 1\\n        \\n        for i in range(1, n+1):\\n            if dp[i] > 0:\\n                lower = i + delay # 3\\n                upper = i + forget\\n                upper_bound = min(upper, n+1)\\n                for j in range(lower, upper_bound):\\n                    dp[j] += dp[i]\\n\\n                if upper <= n:\\n                    dp[i] = 0\\n        \\n        print(dp)\\n        return sum(dp) % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2229948,
                "title": "python-dp-top-down-easy-solution",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0]*n\\n        dp[0] = 1\\n        s = 0\\n        for i in range(delay,n):\\n            s += dp[i-delay]\\n            dp[i] = s\\n            if i-forget+1 >= 0:\\n                s -= dp[i-forget+1]\\n        #print(dp[-forget:])\\n        return(sum(dp[-forget:]))%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        dp = [0]*n\\n        dp[0] = 1\\n        s = 0\\n        for i in range(delay,n):\\n            s += dp[i-delay]\\n            dp[i] = s\\n            if i-forget+1 >= 0:\\n                s -= dp[i-forget+1]\\n        #print(dp[-forget:])\\n        return(sum(dp[-forget:]))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250957,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) similar to kadane\\'s algorithm, we find the \"best ending here\" at each `i`<sup>th</sup> index, ie. let `dp[i]` denote the amount of people who know the secret on the `i`<sup>th</sup> day from `i = 1..N` inclusive.\\n\\n**Base case:** the first person knows the secret from `i = [1..forget]`, ie. from `1` inclusive to `forget` inclusive.\\n\\n**Recurrence relation:** all `i`<sup>th</sup> day people who know the secret tell it to new `j`<sup>th</sup> day people from `j = [i + delay..i + forget)`, ie. from `i + delay` inclusive to `i + forget` non-inclusive.\\n\\nSo we build the future `j`<sup>th</sup> solutions upon the past `i`<sup>th</sup> solutions, ie. we use the past to formulate the future.\\n\\nNote: `dp[0]` is *not* used, its a sentinel for 1-based indexing alignment\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun peopleAwareOfSecret(N: Int, delay: Int, forget: Int): Int {\\n        var dp = IntArray(N + 1) { 0 }\\n        for (i in 1..forget)\\n            dp[i] = 1\\n        for (i in 1 until N)\\n            for (j in i + delay..Math.min(i + forget - 1, N))\\n                dp[j] = (dp[j] + dp[i]) % (1e9 + 7).toInt()\\n        return dp[N]\\n    }\\n}\\n```\\n\\n*Java*\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int N, int delay, int forget) {\\n        int[] dp = new int[N + 1];\\n        for (int i = 1; i <= forget; ++i)\\n            dp[i] = 1;\\n        for (int i = 1; i < N; ++i)\\n            for (int j = i + delay; j <= Math.min(i + forget - 1, N); ++j)\\n                dp[j] = (dp[j] + dp[i]) % 1000000007;\\n        return dp[N];\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet peopleAwareOfSecret = (N, delay, forget) => {\\n    let dp = Array(N + 1).fill(0);\\n    for (let i = 1; i <= forget; ++i)\\n        dp[i] = 1;\\n    for (let i = 1; i < N; ++i)\\n        for (let j = i + delay; j <= Math.min(i + forget - 1, N); ++j)\\n            dp[j] = (dp[j] + dp[i]) % Number(1e9 + 7);\\n    return dp[N];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, N: int, delay: int, forget) -> int:\\n        dp = [0] * (N + 1)\\n        for i in range(1, forget + 1):\\n            dp[i] = 1\\n        for i in range(1, N):\\n            for j in range(i + delay, min(i + forget - 1, N) + 1):\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7)\\n        return dp[N]\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn people_aware_of_secret(N: i32, delay: i32, forget: i32) -> i32 {\\n        let N = N as usize;\\n        let delay = delay as usize;\\n        let forget = forget as usize;\\n        let mut dp = vec![0; N + 1];\\n        for i in 1..=forget {\\n            dp[i] = 1;\\n        }\\n        for i in 1..N {\\n            for j in i + delay..=min(i + forget - 1, N) {\\n                dp[j] = (dp[j] + dp[i]) % (1e9 as i32 + 7);\\n            }\\n        }\\n        dp[N]\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int peopleAwareOfSecret(int N, int delay, int forget) {\\n        VI dp(N + 1);\\n        for (auto i{ 1 }; i <= forget; ++i)\\n            dp[i] = 1;\\n        for (auto i{ 1 }; i < N; ++i)\\n            for (auto j{ i + delay }; j <= min(i + forget - 1, N); ++j)\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7);\\n        return dp[N];\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental:** This is the \"path\" I took to figure this one out...\\n\\n```\\n# Q3 we have ~25 minutes remaining in the contest\\n\\n# offhand this looks like DP, ie we remember the past to formulate the future,\\n# and kadane\\'s algorithm may be a candidate, ie. best-ending-here at each i-th day up till n\\n\\n# Input: n = 6, delay = 2, forget = 4\\n# Output: 5\\n# Explanation:\\n# Day 1: Suppose the first person is named A. (1 person)\\n# Day 2: A is the only person who knows the secret. (1 person)\\n# Day 3: A shares the secret with a new person, B. (2 people)\\n# Day 4: A shares the secret with a new person, C. (3 people)\\n# Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\\n# Day 6: B shares the secret with E, and C shares the secret with F. (5 people)\\n\\n# let dp[i] denote the # of people who know the secret on the i-th day (we don\\'t need to use index 0)\\n# and we want to fill in from i = 1..n inclusive\\n# then we start with dp[1] = 1\\n# and we return dp[n]\\n\\n# note: don\\'t forget the mod by 1e9 + 7\\n\\n#                 -1\\n#        |--------|    <---- forget = 4\\n#        ok      ng\\n#         V       V\\n# dp = [0 1 0 0 0 0 0]\\n#  i =  0 1 2 3 4 5 6 7\\n#\\n\\n#             +1\\n#         |---|    <---- delay = 2\\n#        ok   next\\n#         V   V\\n# dp = [0 1 0 0 0 0 0]\\n#  i =  0 1 2 3 4 5 6 7\\n#\\n\\n\\n# add = 2\\n# sub = 4\\n\\n# dp = [0 1 0 0 0 0 0]\\n#       0 1 2 3 4 5 6 7\\n\\n# dp = [0 1 0 1 0 -1 0]\\n#       0 1 2 3 4  5 6 7\\n#         i\\n\\n# dp = [0 1 1 1 1 -1 -1]\\n#       0 1 2 3 4  5  6 7\\n#           i\\n\\n# dp = [0 1 1 2 1  0 -1]\\n#       0 1 2 3 4  5  6 7\\n#             i\\n\\n# dp = [0 1 1 2 3  0  0]\\n#       0 1 2 3 4  5  6 7\\n#               i\\n\\n\\n# this solution works ok for example 1, but fails for example 2, so something\\'s not quite right here...\\n\\n#     Example 2:\\n\\n# Input: n = 4, delay = 1, forget = 3\\n# Output: 6\\n# Explanation:\\n# Day 1: The first person is named A. (1 person)\\n# Day 2: A shares the secret with B. (2 people)\\n# Day 3: A and B share the secret with 2 new people, C and D. (4 people)\\n# Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\\n\\n# dp = [0 1 1 0 0]\\n#       0 1 2 3 4 5\\n#         i\\n\\n# dp = [0 1 2 1 0]\\n#       0 1 2 3 4 5\\n#           i\\n\\n# dp = [0 1 2 3 4]\\n#       0 1 2 3 4 5\\n#             i\\n\\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += 1\\n#             if i + sub <= N: dp[i + sub] = max(0, -1 + dp[i + sub])\\n#         return dp[N]\\n    \\n# example1\\n# Input: n = 6, delay = 2, forget = 4\\n# Output: 5\\n# Explanation:\\n# Day 1: Suppose the first person is named A. (1 person)\\n# Day 2: A is the only person who knows the secret. (1 person)\\n# Day 3: A shares the secret with a new person, B. (2 people)\\n# Day 4: A shares the secret with a new person, C. (3 people)\\n# Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\\n# Day 6: B shares the secret with E, and C shares the secret with F. (5 people)\\n  \\n#     A---->B\\n#        A---->C\\n#           A---->D <-- cannot occur because A forgets\\n#           B---->D <-- is ok\\n#              A---->E <-- cannot occurs because A forgets\\n#              B---->E <-- is ok\\n#              C---->F <-- is ok\\n# [0, 1, 1, 2, 3, 4, 6]\\n#  0  1  2  3  4  5  6  7\\n#     A  A  A  A   \\n#           B  B  B  B\\n#              C  C  C\\n#                 D  D\\n#                    E\\n#                    F\\n\\n# [0, 1, 2, 4, 7]\\n    \\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += dp[i]\\n#             if i + sub <= N: dp[i + sub] -= 1\\n#         print(dp)\\n#         return dp[N]\\n    \\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += dp[i]\\n#             if i + sub <= N: dp[i + sub] -= 1\\n#         print(dp)\\n#         return dp[N]    \\n    \\n\\n# ----------------------------------------------------------------------\\n    \\n# ok remember to KISS == keep it super simple\\n\\n# let\\'s start with a correct solution, then optimize it\\n# so what does brute-force solution look like?\\n\\n#     A---->B\\n#        A---->C\\n#           A---->D <-- cannot occur because A forgets\\n#           B---->D <-- is ok\\n#              A---->E <-- cannot occurs because A forgets\\n#              B---->E <-- is ok\\n#              C---->F <-- is ok\\n# [0, 1, 1, 2, 3, 4, 6]\\n#  0  1  2  3  4  5  6  7\\n#     A  A  A  A   \\n#           B  B  B  B\\n#              C  C  C\\n#                 D  D\\n#                    E\\n#                    F\\n\\n\\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, delay: int, forget: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         for i in range(1, forget + 1):\\n#             dp[i] = 1\\n#         for i in range(1, N):\\n#             for j in range(i + delay, min(i + forget - 1, N) + 1):\\n#                 dp[j] += dp[i] # i-th persons tells secret to new persons\\n#         return dp[N]\\n                    \\n# Submission Detail\\n# 54 / 82 test cases passed.\\n# Status: Wrong Answer\\n# Submitted: 0 minutes ago\\n# Input:\\n# 684\\n# 18\\n# 496\\n# Output:\\n# 225561137641781117625839396954739207\\n# Expected:\\n# 653668527\\n\\n\\n# oops, ok I missed MOD 1e9 + 7\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, N: int, delay: int, forget) -> int:\\n        dp = [0] * (N + 1)\\n        for i in range(1, forget + 1):\\n            dp[i] = 1\\n        for i in range(1, N):\\n            for j in range(i + delay, min(i + forget - 1, N) + 1):\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7)\\n        return dp[N]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun peopleAwareOfSecret(N: Int, delay: Int, forget: Int): Int {\\n        var dp = IntArray(N + 1) { 0 }\\n        for (i in 1..forget)\\n            dp[i] = 1\\n        for (i in 1 until N)\\n            for (j in i + delay..Math.min(i + forget - 1, N))\\n                dp[j] = (dp[j] + dp[i]) % (1e9 + 7).toInt()\\n        return dp[N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int N, int delay, int forget) {\\n        int[] dp = new int[N + 1];\\n        for (int i = 1; i <= forget; ++i)\\n            dp[i] = 1;\\n        for (int i = 1; i < N; ++i)\\n            for (int j = i + delay; j <= Math.min(i + forget - 1, N); ++j)\\n                dp[j] = (dp[j] + dp[i]) % 1000000007;\\n        return dp[N];\\n    }\\n}\\n```\n```\\nlet peopleAwareOfSecret = (N, delay, forget) => {\\n    let dp = Array(N + 1).fill(0);\\n    for (let i = 1; i <= forget; ++i)\\n        dp[i] = 1;\\n    for (let i = 1; i < N; ++i)\\n        for (let j = i + delay; j <= Math.min(i + forget - 1, N); ++j)\\n            dp[j] = (dp[j] + dp[i]) % Number(1e9 + 7);\\n    return dp[N];\\n};\\n```\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, N: int, delay: int, forget) -> int:\\n        dp = [0] * (N + 1)\\n        for i in range(1, forget + 1):\\n            dp[i] = 1\\n        for i in range(1, N):\\n            for j in range(i + delay, min(i + forget - 1, N) + 1):\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7)\\n        return dp[N]\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn people_aware_of_secret(N: i32, delay: i32, forget: i32) -> i32 {\\n        let N = N as usize;\\n        let delay = delay as usize;\\n        let forget = forget as usize;\\n        let mut dp = vec![0; N + 1];\\n        for i in 1..=forget {\\n            dp[i] = 1;\\n        }\\n        for i in 1..N {\\n            for j in i + delay..=min(i + forget - 1, N) {\\n                dp[j] = (dp[j] + dp[i]) % (1e9 as i32 + 7);\\n            }\\n        }\\n        dp[N]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int peopleAwareOfSecret(int N, int delay, int forget) {\\n        VI dp(N + 1);\\n        for (auto i{ 1 }; i <= forget; ++i)\\n            dp[i] = 1;\\n        for (auto i{ 1 }; i < N; ++i)\\n            for (auto j{ i + delay }; j <= min(i + forget - 1, N); ++j)\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7);\\n        return dp[N];\\n    }\\n};\\n```\n```\\n# Q3 we have ~25 minutes remaining in the contest\\n\\n# offhand this looks like DP, ie we remember the past to formulate the future,\\n# and kadane\\'s algorithm may be a candidate, ie. best-ending-here at each i-th day up till n\\n\\n# Input: n = 6, delay = 2, forget = 4\\n# Output: 5\\n# Explanation:\\n# Day 1: Suppose the first person is named A. (1 person)\\n# Day 2: A is the only person who knows the secret. (1 person)\\n# Day 3: A shares the secret with a new person, B. (2 people)\\n# Day 4: A shares the secret with a new person, C. (3 people)\\n# Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\\n# Day 6: B shares the secret with E, and C shares the secret with F. (5 people)\\n\\n# let dp[i] denote the # of people who know the secret on the i-th day (we don\\'t need to use index 0)\\n# and we want to fill in from i = 1..n inclusive\\n# then we start with dp[1] = 1\\n# and we return dp[n]\\n\\n# note: don\\'t forget the mod by 1e9 + 7\\n\\n#                 -1\\n#        |--------|    <---- forget = 4\\n#        ok      ng\\n#         V       V\\n# dp = [0 1 0 0 0 0 0]\\n#  i =  0 1 2 3 4 5 6 7\\n#\\n\\n#             +1\\n#         |---|    <---- delay = 2\\n#        ok   next\\n#         V   V\\n# dp = [0 1 0 0 0 0 0]\\n#  i =  0 1 2 3 4 5 6 7\\n#\\n\\n\\n# add = 2\\n# sub = 4\\n\\n# dp = [0 1 0 0 0 0 0]\\n#       0 1 2 3 4 5 6 7\\n\\n# dp = [0 1 0 1 0 -1 0]\\n#       0 1 2 3 4  5 6 7\\n#         i\\n\\n# dp = [0 1 1 1 1 -1 -1]\\n#       0 1 2 3 4  5  6 7\\n#           i\\n\\n# dp = [0 1 1 2 1  0 -1]\\n#       0 1 2 3 4  5  6 7\\n#             i\\n\\n# dp = [0 1 1 2 3  0  0]\\n#       0 1 2 3 4  5  6 7\\n#               i\\n\\n\\n# this solution works ok for example 1, but fails for example 2, so something\\'s not quite right here...\\n\\n#     Example 2:\\n\\n# Input: n = 4, delay = 1, forget = 3\\n# Output: 6\\n# Explanation:\\n# Day 1: The first person is named A. (1 person)\\n# Day 2: A shares the secret with B. (2 people)\\n# Day 3: A and B share the secret with 2 new people, C and D. (4 people)\\n# Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\\n\\n# dp = [0 1 1 0 0]\\n#       0 1 2 3 4 5\\n#         i\\n\\n# dp = [0 1 2 1 0]\\n#       0 1 2 3 4 5\\n#           i\\n\\n# dp = [0 1 2 3 4]\\n#       0 1 2 3 4 5\\n#             i\\n\\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += 1\\n#             if i + sub <= N: dp[i + sub] = max(0, -1 + dp[i + sub])\\n#         return dp[N]\\n    \\n# example1\\n# Input: n = 6, delay = 2, forget = 4\\n# Output: 5\\n# Explanation:\\n# Day 1: Suppose the first person is named A. (1 person)\\n# Day 2: A is the only person who knows the secret. (1 person)\\n# Day 3: A shares the secret with a new person, B. (2 people)\\n# Day 4: A shares the secret with a new person, C. (3 people)\\n# Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\\n# Day 6: B shares the secret with E, and C shares the secret with F. (5 people)\\n  \\n#     A---->B\\n#        A---->C\\n#           A---->D <-- cannot occur because A forgets\\n#           B---->D <-- is ok\\n#              A---->E <-- cannot occurs because A forgets\\n#              B---->E <-- is ok\\n#              C---->F <-- is ok\\n# [0, 1, 1, 2, 3, 4, 6]\\n#  0  1  2  3  4  5  6  7\\n#     A  A  A  A   \\n#           B  B  B  B\\n#              C  C  C\\n#                 D  D\\n#                    E\\n#                    F\\n\\n# [0, 1, 2, 4, 7]\\n    \\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += dp[i]\\n#             if i + sub <= N: dp[i + sub] -= 1\\n#         print(dp)\\n#         return dp[N]\\n    \\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, add: int, sub: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         dp[1] = 1\\n#         for i in range(1, N + 1):\\n#             dp[i] = (dp[i] + dp[i - 1]) % (MOD)\\n#             if i + add <= N: dp[i + add] += dp[i]\\n#             if i + sub <= N: dp[i + sub] -= 1\\n#         print(dp)\\n#         return dp[N]    \\n    \\n\\n# ----------------------------------------------------------------------\\n    \\n# ok remember to KISS == keep it super simple\\n\\n# let\\'s start with a correct solution, then optimize it\\n# so what does brute-force solution look like?\\n\\n#     A---->B\\n#        A---->C\\n#           A---->D <-- cannot occur because A forgets\\n#           B---->D <-- is ok\\n#              A---->E <-- cannot occurs because A forgets\\n#              B---->E <-- is ok\\n#              C---->F <-- is ok\\n# [0, 1, 1, 2, 3, 4, 6]\\n#  0  1  2  3  4  5  6  7\\n#     A  A  A  A   \\n#           B  B  B  B\\n#              C  C  C\\n#                 D  D\\n#                    E\\n#                    F\\n\\n\\n# class Solution:\\n#     def peopleAwareOfSecret(self, N: int, delay: int, forget: int, MOD = int(1e9 + 7)) -> int:\\n#         dp = [0] * (N + 1)\\n#         for i in range(1, forget + 1):\\n#             dp[i] = 1\\n#         for i in range(1, N):\\n#             for j in range(i + delay, min(i + forget - 1, N) + 1):\\n#                 dp[j] += dp[i] # i-th persons tells secret to new persons\\n#         return dp[N]\\n                    \\n# Submission Detail\\n# 54 / 82 test cases passed.\\n# Status: Wrong Answer\\n# Submitted: 0 minutes ago\\n# Input:\\n# 684\\n# 18\\n# 496\\n# Output:\\n# 225561137641781117625839396954739207\\n# Expected:\\n# 653668527\\n\\n\\n# oops, ok I missed MOD 1e9 + 7\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, N: int, delay: int, forget) -> int:\\n        dp = [0] * (N + 1)\\n        for i in range(1, forget + 1):\\n            dp[i] = 1\\n        for i in range(1, N):\\n            for j in range(i + delay, min(i + forget - 1, N) + 1):\\n                dp[j] = (dp[j] + dp[i]) % int(1e9 + 7)\\n        return dp[N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026304,
                "title": "java-dp-o-n-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake 3 one dimentional arrays as fresh , active and total.\\n**fresh[i]**-> number of people who are knowing the secret on ith day.\\n**active[i]** -> number of people who are actively spreading the secret.\\n**total[i]** -> total number of people know the secret on ith day.\\n\\nAt first fresh[1] = 1 and total[1] = 1 , because on day one only 1 person know the secret.\\n\\nsteps :\\n1. Already active people will stay active today \\n   => active[i] += active[i - 1]\\n\\n2. People who knew the secret \"**forget**\" days before will forget the    secret so they will not share the secret \\n   => active[i] -= fresh[i - forget]\\n\\n3. People who knew the secret \"**delay**\" days before will start sharing the secret \\n   => active[i] += fresh[i - delay]\\n\\n4. Each active people will share the  secret with one person so \\n   active[i] number of people will know the secret today\\n   => fresh[i] += active[i];\\n   these people will increase the total of today\\n   => total[i] = total[i - 1] + fresh[i]\\n\\n5. People who knew the secret \"**forget**\" days before will forget the    secret so they will not be included in todays total\\n   => total[i] -= fresh[i - forget]\\n\\n// if you can understand the logic please give upvote.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long fresh [] = new long[n + 1];\\n        long active [] = new long[n + 1];\\n        long total [] = new long[n + 1];\\n        long mod = 1000000007;\\n\\n        fresh[1] = 1;\\n        total[1] = 1;\\n        for(int i = 2; i <= n ; i++) {\\n            active[i] = (active[i] % mod + active[i-1] % mod) % mod;\\n\\nif(i - forget >= 0) active[i] = (active[i] - fresh[i-forget] + mod) % mod;\\n\\nif(i - delay >= 0) active[i] = (active[i] + fresh[i-delay]) % mod ;\\n\\n            fresh[i] = (fresh[i] + active[i]) % mod;\\n            total[i] = (total[i-1] + fresh[i] )% mod ;\\n\\nif(i - forget >= 0) total[i] = (total[i] - fresh[i-forget] + mod) %  mod;\\n        }\\n        return (int)(total[n] % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long fresh [] = new long[n + 1];\\n        long active [] = new long[n + 1];\\n        long total [] = new long[n + 1];\\n        long mod = 1000000007;\\n\\n        fresh[1] = 1;\\n        total[1] = 1;\\n        for(int i = 2; i <= n ; i++) {\\n            active[i] = (active[i] % mod + active[i-1] % mod) % mod;\\n\\nif(i - forget >= 0) active[i] = (active[i] - fresh[i-forget] + mod) % mod;\\n\\nif(i - delay >= 0) active[i] = (active[i] + fresh[i-delay]) % mod ;\\n\\n            fresh[i] = (fresh[i] + active[i]) % mod;\\n            total[i] = (total[i-1] + fresh[i] )% mod ;\\n\\nif(i - forget >= 0) total[i] = (total[i] - fresh[i-forget] + mod) %  mod;\\n        }\\n        return (int)(total[n] % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250312,
                "title": "c-simple-intuitive-o-n-time-o-n-space-with-explanation",
                "content": "**Simple Intuition:**\\nA person starts telling the secret on (day of getting to know secret) + delay, and stops telling the secret on  (day of getting to know secret) + forget.\\n\\nLet us define the following terms:\\n```cur``` - number of people currently telling the secret \\n```know```- number of people currently knowing the secret (`cur` + number of people who haven\\'t started telling the secret yet)\\n\\nNow, for any particular day ```i```, we have:\\n\\n`cur` = `cur` - (people who forgot secret on day i) + (people who start telling the secret on day i)\\n\\nAs `cur` people tell secret to `cur` more people:\\n\\n`know `= `know` - (people who forgot secret on day i) + `cur` \\n\\nNow, we just need to find out how many people will start telling the secret and forget the secret on a particular day. We can store this in two arrays - start_secret[n] and forget_secret[n].\\n\\nIf `cur` new people know the secret on a day `i`:\\n`start_secret[i + delay] = cur`\\n\\n`cur` people will forget the secret on day `i+forget`:\\n`forget_secret[i + forget]=cur`\\n\\nTherefore, for a day `i`, we get:\\n```\\ncur = cur +  start_secret[i] - forget_secret[i]\\nknow = know + cur - forget_secret[i]\\nif(i + delay <= n)\\n\\tstart_secret[i + delay] = cur;\\nif(i + forget <= n)\\n    forget_secret[i + forget] = cur;\\n```\\n\\nThe number of people who know the secret on day `n` will thus be `know`.\\n\\n**Code (C++):**\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int start_secret[n+1];\\n        int forget_secret[n+1];\\n        \\n        memset(start_secret,0,sizeof(start_secret));\\n        memset(forget_secret,0,sizeof(forget_secret));\\n        \\n        int cur = 0;\\n        int mod = 1e9+7;\\n        int know = 1;\\n        \\n        //setting the day the first person will start sharing the secret\\n        if(1 + delay <= n)\\n            start_secret[1 + delay] = 1;\\n        //setting the day the first person will forget the secret\\n        if(1 + forget <= n)\\n            forget_secret[1 + forget] = 1;\\n        \\n        for(int i=2;i<=n;i++){\\n            //cur is the number of people who will tell the secret to cur more people\\n            cur = (cur + start_secret[i]) % mod;\\n            cur = (cur + mod - forget_secret[i]) % mod;\\n            \\n            //know is the number of people who currently know the secret\\n            know = (know + cur) % mod;\\n            know = (know + mod - forget_secret[i]) % mod;\\n            \\n            \\n            if(i + delay <= n)\\n                start_secret[i + delay] = cur;\\n            \\n            if(i + forget <= n)\\n                forget_secret[i + forget] = cur;\\n        }\\n        return know;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cur```\n```know```\n```i```\n```\\ncur = cur +  start_secret[i] - forget_secret[i]\\nknow = know + cur - forget_secret[i]\\nif(i + delay <= n)\\n\\tstart_secret[i + delay] = cur;\\nif(i + forget <= n)\\n    forget_secret[i + forget] = cur;\\n```\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int start_secret[n+1];\\n        int forget_secret[n+1];\\n        \\n        memset(start_secret,0,sizeof(start_secret));\\n        memset(forget_secret,0,sizeof(forget_secret));\\n        \\n        int cur = 0;\\n        int mod = 1e9+7;\\n        int know = 1;\\n        \\n        //setting the day the first person will start sharing the secret\\n        if(1 + delay <= n)\\n            start_secret[1 + delay] = 1;\\n        //setting the day the first person will forget the secret\\n        if(1 + forget <= n)\\n            forget_secret[1 + forget] = 1;\\n        \\n        for(int i=2;i<=n;i++){\\n            //cur is the number of people who will tell the secret to cur more people\\n            cur = (cur + start_secret[i]) % mod;\\n            cur = (cur + mod - forget_secret[i]) % mod;\\n            \\n            //know is the number of people who currently know the secret\\n            know = (know + cur) % mod;\\n            know = (know + mod - forget_secret[i]) % mod;\\n            \\n            \\n            if(i + delay <= n)\\n                start_secret[i + delay] = cur;\\n            \\n            if(i + forget <= n)\\n                forget_secret[i + forget] = cur;\\n        }\\n        return know;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232270,
                "title": "c-o-n-solution-easy-to-understand-commented",
                "content": "So here we take two arrays, capable and f.\\ncapable[i] represents the number of people who can share secret on i\\'th day. \\nf[i] reprensents the number of people who will forget the secret on i\\'th day. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long> capable(2002, 0);\\n        vector<long long> f(2002,0);\\n        \\n        long long ans = 1;  //Person who knows the secret on ith day.\\n        f[1+forget]=1;      //1st person will forget the secret on \"day1+forget\"\\n        capable[1+delay]=1;     //1st person would be capable of sharing secret on \"day1 + delay\"\\n        for(int i = 1; i <= n; i++){\\n            capable[i] += capable[i-1]-f[i];    //this equation states the person who were able to share secret on previous day would be still capable of sharing the secret on next day unless and until they forget (that is why we subtract f[i])  \\n            ans = (ans+capable[i]-f[i])%1000000007; //we add the person who would be able to share secret on that day(that is capable[i]) and we subtract \"f[i] from ans\" and not from \"capable[i]\" \\n            capable[i+delay] = (capable[i+delay]+capable[i])%1000000007;    //capable[i] have generated new \"capable[i]\" persons on the ith day, hence they would become capable on \"i+delay\" day\\n            f[i+forget] = (f[i+forget]+capable[i])%1000000007;\\n        }\\n        \\n        return ans;     //easy peasy lemon squeezy\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long> capable(2002, 0);\\n        vector<long long> f(2002,0);\\n        \\n        long long ans = 1;  //Person who knows the secret on ith day.\\n        f[1+forget]=1;      //1st person will forget the secret on \"day1+forget\"\\n        capable[1+delay]=1;     //1st person would be capable of sharing secret on \"day1 + delay\"\\n        for(int i = 1; i <= n; i++){\\n            capable[i] += capable[i-1]-f[i];    //this equation states the person who were able to share secret on previous day would be still capable of sharing the secret on next day unless and until they forget (that is why we subtract f[i])  \\n            ans = (ans+capable[i]-f[i])%1000000007; //we add the person who would be able to share secret on that day(that is capable[i]) and we subtract \"f[i] from ans\" and not from \"capable[i]\" \\n            capable[i+delay] = (capable[i+delay]+capable[i])%1000000007;    //capable[i] have generated new \"capable[i]\" persons on the ith day, hence they would become capable on \"i+delay\" day\\n            f[i+forget] = (f[i+forget]+capable[i])%1000000007;\\n        }\\n        \\n        return ans;     //easy peasy lemon squeezy\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230851,
                "title": "clean-and-readable-java-code",
                "content": "Based on lee215s idea : https://leetcode.com/problems/number-of-people-aware-of-a-secret/discuss/2229982/JavaC%2B%2BPython-Sliding-window-O(n)-Time-O(forget)-Space\\n\\n```\\n// TC : O(n)\\n// SC : O(n)\\n\\n// dp[day] -> number of people who got to know about secret on this day \\n// dp[day-delay] people will start sharing secret on this day\\n// so people+=dp[day-delay]\\n// dp[day-forget] people will forget secret on this day\\n// so people-=dp[day-forget]\\n// dp[day] = people\\n// ans = summation of dp from day = n-forget+1 to n\\n\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n+1];\\n        dp[1] = 1;\\n        long people = 0;\\n        long mod = (long)1e9+7;\\n        long ans = 0;\\n        \\n        for(int day=1;day<=n;day++){\\n            if(day>1){\\n                dp[day] = (people+dp[Math.max(day-delay,0)]-dp[Math.max(day-forget,0)])%mod;\\n                people = dp[day];\\n            }\\n            \\n            if(day>=n-forget+1){\\n                ans = (ans + dp[day])%mod;\\n            }\\n        }\\n        \\n        int finalAns = (int)ans;\\n        if(finalAns<0) finalAns+=(int)mod;\\n        return finalAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// TC : O(n)\\n// SC : O(n)\\n\\n// dp[day] -> number of people who got to know about secret on this day \\n// dp[day-delay] people will start sharing secret on this day\\n// so people+=dp[day-delay]\\n// dp[day-forget] people will forget secret on this day\\n// so people-=dp[day-forget]\\n// dp[day] = people\\n// ans = summation of dp from day = n-forget+1 to n\\n\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n+1];\\n        dp[1] = 1;\\n        long people = 0;\\n        long mod = (long)1e9+7;\\n        long ans = 0;\\n        \\n        for(int day=1;day<=n;day++){\\n            if(day>1){\\n                dp[day] = (people+dp[Math.max(day-delay,0)]-dp[Math.max(day-forget,0)])%mod;\\n                people = dp[day];\\n            }\\n            \\n            if(day>=n-forget+1){\\n                ans = (ans + dp[day])%mod;\\n            }\\n        }\\n        \\n        int finalAns = (int)ans;\\n        if(finalAns<0) finalAns+=(int)mod;\\n        return finalAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230720,
                "title": "dp-begineer-friendly-self-explanatory-commented-code",
                "content": "```\\n//here  x denotes the day a particular person got to know truth\\n//and pd denotes the present day\\n\\n  int mod=1e9+7;\\n    int dp[1004][1004];\\n    \\n    int solve(int x,int pd,int n,int d,int f)\\n    {\\n        if(pd>n) return 1;\\n        //if he doesn\\'t forget  till n\\n\\t\\t\\n        if(pd-x==f) return 0;\\n        //if he forgets then return\\n\\t\\t\\n\\t\\t\\n       if(dp[x][pd]!=-1) return dp[x][pd];\\n        \\n        long long int ans=0;\\n        \\n         \\n       //if time lapse between  the day he got to know truth and present day is less tahn delay time \\n\\t   //he can\\'t spread it\\n        if(pd-x<d)\\n        {\\n            ans=solve(x,pd+1,n,d,f);\\n        }\\n        else{\\n            \\n        ans=(solve(pd,pd+1,n,d,f)%mod+solve(x,pd+1,n,d,f)%mod)%mod;\\n            \\n            }\\n\\t\\t\\t//else he is spreading here and to a differnt person and also keep spreading until he forgets \\n        \\n        return dp[x][pd]=ans;\\n        \\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(1,1,n,delay,forget) ;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n//here  x denotes the day a particular person got to know truth\\n//and pd denotes the present day\\n\\n  int mod=1e9+7;\\n    int dp[1004][1004];\\n    \\n    int solve(int x,int pd,int n,int d,int f)\\n    {\\n        if(pd>n) return 1;\\n        //if he doesn\\'t forget  till n\\n\\t\\t\\n        if(pd-x==f) return 0;\\n        //if he forgets then return\\n\\t\\t\\n\\t\\t\\n       if(dp[x][pd]!=-1) return dp[x][pd];\\n        \\n        long long int ans=0;\\n        \\n         \\n       //if time lapse between  the day he got to know truth and present day is less tahn delay time \\n\\t   //he can\\'t spread it\\n        if(pd-x<d)\\n        {\\n            ans=solve(x,pd+1,n,d,f);\\n        }\\n        else{\\n            \\n        ans=(solve(pd,pd+1,n,d,f)%mod+solve(x,pd+1,n,d,f)%mod)%mod;\\n            \\n            }\\n\\t\\t\\t//else he is spreading here and to a differnt person and also keep spreading until he forgets \\n        \\n        return dp[x][pd]=ans;\\n        \\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(1,1,n,delay,forget) ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230349,
                "title": "java-dp-fast-easy-to-understand",
                "content": "dp[i] means the number of people who know the secret at the first time.\\n\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        long mod = 1000000007;\\n        long[] dp = new long[n + 1];\\n        dp[1] = 1;\\n\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i + delay; j < i + forget && j <= n; ++j) {\\n                dp[j] = (dp[j] + dp[i]) % mod;\\n            }\\n        }\\n\\n        long res = 0;\\n        for (int i = n; i > n - forget; --i) {\\n            res = (res + dp[i]) % mod;\\n        }\\n\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        long mod = 1000000007;\\n        long[] dp = new long[n + 1];\\n        dp[1] = 1;\\n\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i + delay; j < i + forget && j <= n; ++j) {\\n                dp[j] = (dp[j] + dp[i]) % mod;\\n            }\\n        }\\n\\n        long res = 0;\\n        for (int i = n; i > n - forget; --i) {\\n            res = (res + dp[i]) % mod;\\n        }\\n\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230048,
                "title": "python-dp-dynamic-programming",
                "content": "Iterate from delay->forget for each time, increment one count, in addition to the current people who remember. For the day a user forgets, decrement one count\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        dp = [0]*(n+1)\\n        \\n        for i in range(1, n+1):\\n            dp[i] += 1\\n            for k in range(i+delay, i+forget):\\n                if k < n+ 1:\\n                    dp[k] += dp[i]\\n            if i+forget < n+1:\\n                dp[i+forget] -= 1\\n                \\n        return dp[-1] % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        dp = [0]*(n+1)\\n        \\n        for i in range(1, n+1):\\n            dp[i] += 1\\n            for k in range(i+delay, i+forget):\\n                if k < n+ 1:\\n                    dp[k] += dp[i]\\n            if i+forget < n+1:\\n                dp[i+forget] -= 1\\n                \\n        return dp[-1] % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229829,
                "title": "very-simple-java-solution",
                "content": "**Intuition**\\nWe need to keep a track of discovery day for each person and who ever have passed the delay should share the messag.\\n\\nSo we\\'ll use the array of size forget (where each block represents people having idx+1 discovery day) and we don\\'t need to keep a track of person who has frgottent the secret so array of size forget.\\n\\nAt each day\\n1. Increase the discovery day by move all the people in array forwad in the arr.\\n2. People after the delay day will share the secrest with people by adding 1 at 0th idx \\n\\nThen at the end sum all the people in the array as they are the pople who know the secret. \\n\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int m = 1000000007;\\n        long ans = 0;\\n        \\n        // It represnts the timelime\\n        // i.e. for how many days a person will remeber the \\n        // secret and then forget\\n        int[] dayTracker = new int[forget];\\n        \\n        // Initialze (at 1st day 1 person knows)\\n        dayTracker[0] = 1;\\n        \\n        for(int day = 2; day <= n ; day++){\\n            \\n            // Increase discovery day for everyone\\n            // \\n            for(int i = forget -1; i > 0 ; i--){\\n                dayTracker[i] = dayTracker[i-1]; \\n            }\\n            dayTracker[0] = 0;\\n            \\n            // Share secret\\n            for(int i = delay; i < forget ; i++){\\n                dayTracker[0] = (dayTracker[0]+dayTracker[i]) % m;\\n            }\\n        }\\n        \\n        // Find total peoples\\n        for(int i  = 0; i < forget ; i++){\\n            ans+= dayTracker[i];\\n        }\\n        \\n        return (int)(ans % m);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int m = 1000000007;\\n        long ans = 0;\\n        \\n        // It represnts the timelime\\n        // i.e. for how many days a person will remeber the \\n        // secret and then forget\\n        int[] dayTracker = new int[forget];\\n        \\n        // Initialze (at 1st day 1 person knows)\\n        dayTracker[0] = 1;\\n        \\n        for(int day = 2; day <= n ; day++){\\n            \\n            // Increase discovery day for everyone\\n            // \\n            for(int i = forget -1; i > 0 ; i--){\\n                dayTracker[i] = dayTracker[i-1]; \\n            }\\n            dayTracker[0] = 0;\\n            \\n            // Share secret\\n            for(int i = delay; i < forget ; i++){\\n                dayTracker[0] = (dayTracker[0]+dayTracker[i]) % m;\\n            }\\n        }\\n        \\n        // Find total peoples\\n        for(int i  = 0; i < forget ; i++){\\n            ans+= dayTracker[i];\\n        }\\n        \\n        return (int)(ans % m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035749,
                "title": "easiest-soln-goldman-sachs-adobe-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nChallenge Company 2 : Goldman Sachs\\nQ10. Number of People Aware of a Secret\\nQ14. People aware of secret**\\n\\n### Approach\\n\\n![10.jpg](https://assets.leetcode.com/users/images/5307e5f7-08aa-4879-b644-2e86220e2ff0_1673445344.685206.jpeg)\\n\\n\\n### Complexity\\n- **Time complexity** of this code is O(n*(d+f)), where n is the total number of days, d is the delay, and f is the forget.\\n- **The Space complexity** is O(n), where n is the total number of days\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int totalDays, int delay, int forget) {\\n        // vector to store the number of people who know the secret at a certain day\\n        vector<long long> peopleAware(totalDays, 0);\\n        // variable to store the total number of people who know the secret\\n        long long totalPeopleAware = 0;\\n        // constant used for taking modulo operation\\n        int mod = 1e9 + 7;\\n        // initially, only one person knows the secret\\n        peopleAware[0] = 1;\\n        for(auto i = 0; i < totalDays; i++){\\n            // loop through the days the person can tell the secret to another person\\n            for(auto k = delay; k < forget && i + k < totalDays; k++){\\n                // calculate the number of people who know the secret at day i + k\\n                peopleAware[i + k] = (peopleAware[i + k] + peopleAware[i]) % mod;\\n            }\\n            // update the total number of people who know the secret\\n            totalPeopleAware = (totalPeopleAware + peopleAware[i]) % mod;\\n            // if a person has forgotten the secret after day i, remove them from the total\\n            if(i >= forget){\\n                totalPeopleAware = (totalPeopleAware - peopleAware[i - forget] + mod) % mod;\\n        }\\n    }\\n\\n    return totalPeopleAware;\\n}\\n};\\n```\\n- This code finds the total number of people who know a secret after a certain number of days, given the number of days it takes before a person can tell the secret to another person and the number of days it takes for a person to forget the secret.\\n- It uses a vector \"peopleAware\" to store the number of people who know the secret at each day.\\n- It uses nested loops to iterate through each day, and for each day, the inner loop iterates through the days that a person can tell the secret to another person and increases the number of people who know the secret at that day.\\n- It also uses a variable \"totalPeopleAware\" to keep track of the total number of people who know the secret and a constant \"mod\" for modulo operation",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int totalDays, int delay, int forget) {\\n        // vector to store the number of people who know the secret at a certain day\\n        vector<long long> peopleAware(totalDays, 0);\\n        // variable to store the total number of people who know the secret\\n        long long totalPeopleAware = 0;\\n        // constant used for taking modulo operation\\n        int mod = 1e9 + 7;\\n        // initially, only one person knows the secret\\n        peopleAware[0] = 1;\\n        for(auto i = 0; i < totalDays; i++){\\n            // loop through the days the person can tell the secret to another person\\n            for(auto k = delay; k < forget && i + k < totalDays; k++){\\n                // calculate the number of people who know the secret at day i + k\\n                peopleAware[i + k] = (peopleAware[i + k] + peopleAware[i]) % mod;\\n            }\\n            // update the total number of people who know the secret\\n            totalPeopleAware = (totalPeopleAware + peopleAware[i]) % mod;\\n            // if a person has forgotten the secret after day i, remove them from the total\\n            if(i >= forget){\\n                totalPeopleAware = (totalPeopleAware - peopleAware[i - forget] + mod) % mod;\\n        }\\n    }\\n\\n    return totalPeopleAware;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719386,
                "title": "python-3-6-lines-dp-t-m-100-00-44",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n\\n        dp, ct = [0] * n, 0\\n        dp[0] = 1\\n\\n        for i in range(1, n):\\n\\n            dp[i] = ct + dp[i-delay] - dp[i-forget]\\n            ct = dp[i]\\n\\n        return sum(dp[n-forget:]) % 1000000007\\n```\\n\\n[https://leetcode.com/submissions/detail/825365833/](http://)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n\\n        dp, ct = [0] * n, 0\\n        dp[0] = 1\\n\\n        for i in range(1, n):\\n\\n            dp[i] = ct + dp[i-delay] - dp[i-forget]\\n            ct = dp[i]\\n\\n        return sum(dp[n-forget:]) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360099,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dynamic-programming",
                "content": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n\\n        for (int i = delay; i < n; i++)\\n        {\\n            for (int j = Math.Max(0, i - forget + 1); j <= i - delay; j++)\\n                dp[i] = (dp[i] + dp[j]) % _mod;\\n        }\\n\\n        int ans = 0;\\n        for (int i = Math.Max(0, n - forget); i < n; i++)\\n            ans = (ans + dp[i]) % _mod;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n\\n        for (int i = delay; i < n; i++)\\n        {\\n            for (int j = Math.Max(0, i - forget + 1); j <= i - delay; j++)\\n                dp[i] = (dp[i] + dp[j]) % _mod;\\n        }\\n\\n        int ans = 0;\\n        for (int i = Math.Max(0, n - forget); i < n; i++)\\n            ans = (ans + dp[i]) % _mod;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232706,
                "title": "c-dp-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        // d->Delay\\n        //f->Forget\\n        vector<long long> ans(n+1,0);\\n        const int mod = 1e9+7;\\n        ans[1] = 1; // At day one only one person know the secret\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i]) // At day i if any one know the secret just check to how many new person these a[i] person can tell the secret\\n            {\\n                for(int j=i+d;j<=n&&j<=(i+f-1);j++)\\n                {\\n                    ans[j] = ((ans[j])%mod+(ans[i])%mod)%mod; // So after the delay period every jth day a[i] new people will know the secret\\n                }\\n            }\\n        }\\n        long long temp = 0;\\n        for(int i=n;i>=(n-f+1)&&i>=1;i--) // At the end only last f days people will remeber the secret rest all will forget\\n            temp = ((temp)%mod+(ans[i])%mod)%mod;\\n        return temp%mod;//return ans\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        // d->Delay\\n        //f->Forget\\n        vector<long long> ans(n+1,0);\\n        const int mod = 1e9+7;\\n        ans[1] = 1; // At day one only one person know the secret\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i]) // At day i if any one know the secret just check to how many new person these a[i] person can tell the secret\\n            {\\n                for(int j=i+d;j<=n&&j<=(i+f-1);j++)\\n                {\\n                    ans[j] = ((ans[j])%mod+(ans[i])%mod)%mod; // So after the delay period every jth day a[i] new people will know the secret\\n                }\\n            }\\n        }\\n        long long temp = 0;\\n        for(int i=n;i>=(n-f+1)&&i>=1;i--) // At the end only last f days people will remeber the secret rest all will forget\\n            temp = ((temp)%mod+(ans[i])%mod)%mod;\\n        return temp%mod;//return ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231997,
                "title": "c-using-single-queue",
                "content": "Here, we simulate the process each day at a time, removing the people who forgot the secret and adding new people who learn the secret. We push the number of people learning the secret on the day and the day number as a pair in the queue and loop for n days. The process is O(n^2), but I feel it is more intuitive than the DP solution.\\n```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    const int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        ll day=1;\\n        queue<pair<ll,ll>> q;\\n        q.push({1,1});\\n        day++;\\n        while(day<=n)\\n        {\\n            ll len=q.size(), aware=0;\\n            while(len>0)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.second+forget>day)\\n                {\\n                    q.push(p);\\n                    if(p.second+delay<=day)\\n                        aware=(aware+p.first)%mod;                   \\n                }\\n                len--;\\n            }\\n            if(aware!=0)\\n                q.push({aware,day});\\n            day++;\\n        }\\n        ll ans=0;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            ans=(ans+p.first)%mod;\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    const int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        ll day=1;\\n        queue<pair<ll,ll>> q;\\n        q.push({1,1});\\n        day++;\\n        while(day<=n)\\n        {\\n            ll len=q.size(), aware=0;\\n            while(len>0)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.second+forget>day)\\n                {\\n                    q.push(p);\\n                    if(p.second+delay<=day)\\n                        aware=(aware+p.first)%mod;                   \\n                }\\n                len--;\\n            }\\n            if(aware!=0)\\n                q.push({aware,day});\\n            day++;\\n        }\\n        ll ans=0;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            ans=(ans+p.first)%mod;\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230657,
                "title": "java-mod-tricks-need-help-resolved",
                "content": "# Mod tricks Solution\\nAdding one more `MOD` value before you do `% MOD` can fix everything.\\n```java\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = (todayShare - forgets[i] + MOD) % MOD;\\n            todayShare = (todayShare + delays[i] + MOD) % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare;\\n            forgets[i+forget] = todayShare;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res = (res + delays[i] + MOD) % MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n# Original Question\\nWhy solution 1 works but solution 2 fails for test case \"289,7,23\"?\\nI don\\'t understand, seems like solution1 is more correct, `delays` and `forgets` are already MODed, why calculate first then MOD will cause wrong answer?\\nThe only difference is here:\\n```java\\n//works\\ntodayShare = todayShare - forgets[i] % MOD;\\ntodayShare = todayShare + delays[i] % MOD;\\n```\\nand\\n```java\\n//fails\\ntodayShare = (todayShare - forgets[i]) % MOD;\\ntodayShare = (todayShare + delays[i]) % MOD;\\n```\\n## Solution 1 Work\\n```java\\nclass Solution1 {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = todayShare - forgets[i] % MOD;\\n            todayShare = todayShare + delays[i] % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare % MOD;\\n            forgets[i+forget] = todayShare % MOD;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res += delays[i];\\n            res %= MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```\\n## Solution 2 Fail\\n```java\\nclass Solution2 {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = (todayShare - forgets[i]) % MOD;\\n            todayShare = (todayShare + delays[i]) % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare % MOD;\\n            forgets[i+forget] = todayShare % MOD;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res += delays[i];\\n            res %= MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = (todayShare - forgets[i] + MOD) % MOD;\\n            todayShare = (todayShare + delays[i] + MOD) % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare;\\n            forgets[i+forget] = todayShare;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res = (res + delays[i] + MOD) % MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\n```java\\n//works\\ntodayShare = todayShare - forgets[i] % MOD;\\ntodayShare = todayShare + delays[i] % MOD;\\n```\n```java\\n//fails\\ntodayShare = (todayShare - forgets[i]) % MOD;\\ntodayShare = (todayShare + delays[i]) % MOD;\\n```\n```java\\nclass Solution1 {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = todayShare - forgets[i] % MOD;\\n            todayShare = todayShare + delays[i] % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare % MOD;\\n            forgets[i+forget] = todayShare % MOD;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res += delays[i];\\n            res %= MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```\n```java\\nclass Solution2 {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long MOD = 1_000_000_000+7;\\n        long res = 1;\\n        long[] delays = new long[n+1+delay];\\n        long[] forgets = new long[n+1+forget];\\n        long[] people = new long[n+1];\\n        people[1] = 0;\\n        delays[1+delay] = 1;\\n        forgets[1+forget] = 1;\\n        for(int i = 2; i <= n; i++){\\n            long todayShare = people[i-1];\\n            todayShare = (todayShare - forgets[i]) % MOD;\\n            todayShare = (todayShare + delays[i]) % MOD;\\n            people[i] = todayShare;\\n            delays[i+delay] = todayShare % MOD;\\n            forgets[i+forget] = todayShare % MOD;\\n        }\\n        res = people[n];\\n        for(int i = n+1; i < n+1+delay; i++){\\n            res += delays[i];\\n            res %= MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230455,
                "title": "python-super-easy-to-understand",
                "content": "(1) only need track the most recent forget daily added new people\\n(2) for i-th day, the newly added people should be:\\n i-forget+1,  i-forget+2,..., i-delay,\\n (3) now the total people at the n-th day:\\n  simply the sum of daily added ppl starting from n-forget+1, ,,,, n.\\n  because the days on and before n-forget, ppl already forget!\\n  \\n```\\ndef peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        ## each day newly added ppl\\n        add=[0 for i in range(1+n)]\\n        #day 1\\n        add[1]=1\\n        mod=10**9+7\\n        for i in range(2,n+1):\\n            newadd=sum(add[max(0,(i-forget+1)):max(0,(i-delay+1))])\\n            add[i]=newadd%mod\\n        res=sum(add[(n-forget+1):(n+1)])%mod\\n        return res",
                "solutionTags": [],
                "code": "(1) only need track the most recent forget daily added new people\\n(2) for i-th day, the newly added people should be:\\n i-forget+1,  i-forget+2,..., i-delay,\\n (3) now the total people at the n-th day:\\n  simply the sum of daily added ppl starting from n-forget+1, ,,,, n.\\n  because the days on and before n-forget, ppl already forget!\\n  \\n```\\ndef peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        ## each day newly added ppl\\n        add=[0 for i in range(1+n)]\\n        #day 1\\n        add[1]=1\\n        mod=10**9+7\\n        for i in range(2,n+1):\\n            newadd=sum(add[max(0,(i-forget+1)):max(0,(i-delay+1))])\\n            add[i]=newadd%mod\\n        res=sum(add[(n-forget+1):(n+1)])%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3022723,
                "title": "typescript-javascript-recursion-runtime-71ms-beats-100",
                "content": "# Code\\n```\\nfunction peopleAwareOfSecret(n: number, delay: number, forget: number): number {\\n    const MOD = 10 ** 9 + 7;\\n    let peopleKnowSecret : number[] = [];\\n\\n    for (let i=0;i<forget-1;i++){\\n        peopleKnowSecret.push(0);\\n    }\\n    peopleKnowSecret.push(1);\\n\\n    let range: number = peopleKnowSecret.length - delay;\\n\\n    const result: number[] = peoplesKnowSecret(n-1, peopleKnowSecret, range);\\n\\n    const sumWithInitial: number = result.reduce(\\n        (accumulator, currentValue) => accumulator + currentValue,\\n        0    \\n    );\\n\\n    return sumWithInitial % MOD;\\n};  \\n\\n\\nfunction peoplesKnowSecret (n:number, peoples: number[], range): number[]{\\n\\n    if(n === 0)\\n        return peoples;\\n\\n    const MOD = 10 ** 9 + 7;\\n\\n    peoples.shift();\\n    let newPeopleKnowSecrect: number = 0;\\n    for(let i = 0; i<range; i++){\\n        newPeopleKnowSecrect += peoples[i]\\n    }\\n    peoples.push(newPeopleKnowSecrect % MOD ); \\n\\n    return peoplesKnowSecret(n-1,peoples, range);\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction peopleAwareOfSecret(n: number, delay: number, forget: number): number {\\n    const MOD = 10 ** 9 + 7;\\n    let peopleKnowSecret : number[] = [];\\n\\n    for (let i=0;i<forget-1;i++){\\n        peopleKnowSecret.push(0);\\n    }\\n    peopleKnowSecret.push(1);\\n\\n    let range: number = peopleKnowSecret.length - delay;\\n\\n    const result: number[] = peoplesKnowSecret(n-1, peopleKnowSecret, range);\\n\\n    const sumWithInitial: number = result.reduce(\\n        (accumulator, currentValue) => accumulator + currentValue,\\n        0    \\n    );\\n\\n    return sumWithInitial % MOD;\\n};  \\n\\n\\nfunction peoplesKnowSecret (n:number, peoples: number[], range): number[]{\\n\\n    if(n === 0)\\n        return peoples;\\n\\n    const MOD = 10 ** 9 + 7;\\n\\n    peoples.shift();\\n    let newPeopleKnowSecrect: number = 0;\\n    for(let i = 0; i<range; i++){\\n        newPeopleKnowSecrect += peoples[i]\\n    }\\n    peoples.push(newPeopleKnowSecrect % MOD ); \\n\\n    return peoplesKnowSecret(n-1,peoples, range);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021438,
                "title": "c-solution-dp-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n//https://www.youtube.com/watch?v=V7QVZY84KQ8&ab_channel=CodingDecoded\\n    int mod = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long>persons(n+1,0);\\n        persons[1] = 1; //persons[i] => persons sharing the secret at day i\\n        long long numberOfPeopleSharingSecret = 0;\\n        for(int i=2;i<=n;i++){\\n            if(i - delay >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret + persons[i-delay])%mod;\\n            if(i - forget >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret - persons[i- forget] + mod)%mod;\\n            \\n            persons[i] = numberOfPeopleSharingSecret;\\n        }\\n\\n        long long ans = 0;//add all persons who are not forgotten the secret\\n        for(int i=n-forget+1;i<=n;i++){\\n            ans = (ans + persons[i]) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n//https://www.youtube.com/watch?v=V7QVZY84KQ8&ab_channel=CodingDecoded\\n    int mod = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long>persons(n+1,0);\\n        persons[1] = 1; //persons[i] => persons sharing the secret at day i\\n        long long numberOfPeopleSharingSecret = 0;\\n        for(int i=2;i<=n;i++){\\n            if(i - delay >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret + persons[i-delay])%mod;\\n            if(i - forget >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret - persons[i- forget] + mod)%mod;\\n            \\n            persons[i] = numberOfPeopleSharingSecret;\\n        }\\n\\n        long long ans = 0;//add all persons who are not forgotten the secret\\n        for(int i=n-forget+1;i<=n;i++){\\n            ans = (ans + persons[i]) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233684,
                "title": "simple-kotlin-solution-fast-understandable",
                "content": "**Runtime: 329 ms, faster than 100.00% of Kotlin online submissions for Number of People Aware of a Secret.\\nMemory Usage: 38.3 MB, less than 100.00% of Kotlin online submissions for Number of People Aware of a Secret.**\\n\\n```\\n    fun peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int {\\n        val mod = 1000000007\\n        val peopleSecret = HashMap<Int, Int>()\\n        peopleSecret[0] = 1\\n        var active = 0L\\n        for (i in 1 until n) {\\n            var num = 0\\n            if (peopleSecret.containsKey(i - delay)) num = peopleSecret[i - delay]!!\\n            active = (num.toLong()+active)\\n            var f = 0\\n            if (peopleSecret.containsKey(i - forget)) f = peopleSecret[i - forget]!!%mod\\n            active -= f\\n            peopleSecret[i] = (active%mod).toInt()\\n        }\\n\\n        var count = 0L\\n        for (i in 0 until n) {\\n            count += peopleSecret[i]!!\\n            var f = 0\\n            if (peopleSecret.containsKey(i - forget)) f = peopleSecret[i - forget]!!\\n            count -= f\\n        }\\n\\n        return (count%mod).toInt()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int {\\n        val mod = 1000000007\\n        val peopleSecret = HashMap<Int, Int>()\\n        peopleSecret[0] = 1\\n        var active = 0L\\n        for (i in 1 until n) {\\n            var num = 0\\n            if (peopleSecret.containsKey(i - delay)) num = peopleSecret[i - delay]!!\\n            active = (num.toLong()+active)\\n            var f = 0\\n            if (peopleSecret.containsKey(i - forget)) f = peopleSecret[i - forget]!!%mod\\n            active -= f\\n            peopleSecret[i] = (active%mod).toInt()\\n        }\\n\\n        var count = 0L\\n        for (i in 0 until n) {\\n            count += peopleSecret[i]!!\\n            var f = 0\\n            if (peopleSecret.containsKey(i - forget)) f = peopleSecret[i - forget]!!\\n            count -= f\\n        }\\n\\n        return (count%mod).toInt()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233621,
                "title": "java-2d-dp-array-easy-to-understand-o-n-time-and-space",
                "content": "We can use a 2D dp array to track the three status:\\n* 0: total number of people who know the secret on this day - this is also the final answer we need, \\n* 1: people who can secret on this day (they start knowing this secret since i - delay day)\\n* 2: people who forget on this day. \\n\\nThen for each day, we just need to update the current day\\'s dp[i][1] first, since this will impact all the other info for future days and also the current total number of people who know the secret.\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[][] dp = new long[n + forget][3];\\n        // 0: people who currently know the secret (includes [1] below)\\n        // 1: people who start sharing the secret on this day\\n        // 2: people who forget on this day\\n        long mod = (long)1e9 + 7;\\n        dp[0][0] = dp[delay][1] = dp[forget][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = (dp[i][1] + dp[i - 1][1] - dp[i][2] + mod) % mod; // dp[i][1] was originally just the i - delay newcomers\\n            dp[i + forget][2] = dp[i][1]; // these people forget on i + forget day\\n            dp[i + delay][1] = dp[i][1]; // these people start sharing on i + delay day\\n            dp[i][0] = (dp[i - 1][0] + dp[i][1] - dp[i][2] + mod) % mod; //today\\'s total people who know the secret\\n        }\\n        return (int) dp[n - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[][] dp = new long[n + forget][3];\\n        // 0: people who currently know the secret (includes [1] below)\\n        // 1: people who start sharing the secret on this day\\n        // 2: people who forget on this day\\n        long mod = (long)1e9 + 7;\\n        dp[0][0] = dp[delay][1] = dp[forget][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = (dp[i][1] + dp[i - 1][1] - dp[i][2] + mod) % mod; // dp[i][1] was originally just the i - delay newcomers\\n            dp[i + forget][2] = dp[i][1]; // these people forget on i + forget day\\n            dp[i + delay][1] = dp[i][1]; // these people start sharing on i + delay day\\n            dp[i][0] = (dp[i - 1][0] + dp[i][1] - dp[i][2] + mod) % mod; //today\\'s total people who know the secret\\n        }\\n        return (int) dp[n - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232332,
                "title": "c-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll mod = 1000000007;\\n\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        ll ans = 0;\\n        vector<ll> active(n+1);\\n        vector<ll> infected(n+1);\\n        infected[1] = 1;\\n        for(ll i = 1 ; i<=n; i++){\\n            active[i]+=active[i-1]%mod;\\n            active[i]%=mod;\\n            if(active[i]>0){\\n                infected[i]+=active[i]%mod;\\n                infected[i]%=mod;\\n            }\\n            if(i+delay<=n){\\n                active[i+delay]+=infected[i]%mod;\\n                active[i+delay]%=mod;\\n            }\\n            if(i+forget<=n){\\n                active[i+forget]= (active[i+forget]%mod + mod - infected[i])%mod;\\n            }\\n        }\\n        for(int i = n; i>n-forget; i--){\\n            ans+= infected[i]%mod;\\n            ans%=mod;\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll mod = 1000000007;\\n\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        ll ans = 0;\\n        vector<ll> active(n+1);\\n        vector<ll> infected(n+1);\\n        infected[1] = 1;\\n        for(ll i = 1 ; i<=n; i++){\\n            active[i]+=active[i-1]%mod;\\n            active[i]%=mod;\\n            if(active[i]>0){\\n                infected[i]+=active[i]%mod;\\n                infected[i]%=mod;\\n            }\\n            if(i+delay<=n){\\n                active[i+delay]+=infected[i]%mod;\\n                active[i+delay]%=mod;\\n            }\\n            if(i+forget<=n){\\n                active[i+forget]= (active[i+forget]%mod + mod - infected[i])%mod;\\n            }\\n        }\\n        for(int i = n; i>n-forget; i--){\\n            ans+= infected[i]%mod;\\n            ans%=mod;\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231626,
                "title": "c-easy-dynamic-programming-solution",
                "content": "We traverse from [n+delay,n+forget) for each day (note that we include the day with delay but not the day to forget because people cannot share the secret at the day they forget it.).\\n\\n\\n```\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n        const int mod = 1e9+7;\\n        vector<int> dp(n+1);\\n        dp[0] = 1;\\n        for(int i = 1;i<n;i++){\\n            for(int j = max(0,i-forget+1);j+delay<=i;j++){\\n                dp[i]+=dp[j];\\n                if (dp[i] >= mod) {\\n                    dp[i] -= mod;\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(i+forget>=n) ans += dp[i];\\n            ans %= mod;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "We traverse from [n+delay,n+forget) for each day (note that we include the day with delay but not the day to forget because people cannot share the secret at the day they forget it.).\\n\\n\\n```\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n        const int mod = 1e9+7;\\n        vector<int> dp(n+1);\\n        dp[0] = 1;\\n        for(int i = 1;i<n;i++){\\n            for(int j = max(0,i-forget+1);j+delay<=i;j++){\\n                dp[i]+=dp[j];\\n                if (dp[i] >= mod) {\\n                    dp[i] -= mod;\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(i+forget>=n) ans += dp[i];\\n            ans %= mod;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230948,
                "title": "python-2-solutions-o-n-and-o-n-2-dynamic-programming",
                "content": "# O(N^2)\\nWe can store `dp[i]` as the number of people that know the secret from day 0, to day i. Starting with 1 person that knows the secret in `day <= forget` (because he didn\\'t forget it yet)\\n\\nAll people that knew the secret in days `[day-forget+1..day-delay (included)]` can tell the secret today.\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10**9+7\\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        for day in range(2, n+1):\\n            # Stil remember the secret if day is <= forget\\n            if day <= forget:\\n                dp[day] = 1\\n            \\n            # Add the result from all the people that can tell\\n            for remember_day in range(day-forget+1, day-delay+1):\\n                if remember_day < 0: continue\\n                    \\n                dp[day] += dp[remember_day] % mod\\n        \\n        return dp[n] % mod\\n```\\n\\n\\n# O(n)\\nInstead of having dp[i] represent the people that know the secret, we can let `dp[i]` represent the people that figured out the secret on day `i`\\n\\nPeople on day `dp[day-delay]` start sharing the secret today\\nAnd people from `dp[day-forget]` forgot the secret\\n\\nWe add the number of people that shared the secret today, to day `i`.\\n\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10**9+7\\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        share = 0\\n        \\n        for day in range(2, n+1):\\n            share += dp[day-delay] # starting to share\\n            share -= dp[day-forget] # forgot the secret\\n            dp[day] = share\\n        \\n        return sum(dp[n-forget+1:]) % mod\\n```\\n\\nThanks to @lee125 [answer](https://leetcode.com/problems/number-of-people-aware-of-a-secret/discuss/2229982/JavaC%2B%2BPython-Sliding-window-O(n)-Time-O(forget)-Space)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10**9+7\\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        for day in range(2, n+1):\\n            # Stil remember the secret if day is <= forget\\n            if day <= forget:\\n                dp[day] = 1\\n            \\n            # Add the result from all the people that can tell\\n            for remember_day in range(day-forget+1, day-delay+1):\\n                if remember_day < 0: continue\\n                    \\n                dp[day] += dp[remember_day] % mod\\n        \\n        return dp[n] % mod\\n```\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10**9+7\\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        share = 0\\n        \\n        for day in range(2, n+1):\\n            share += dp[day-delay] # starting to share\\n            share -= dp[day-forget] # forgot the secret\\n            dp[day] = share\\n        \\n        return sum(dp[n-forget+1:]) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230798,
                "title": "c-80-80-test-cases-passed-runtime-48-ms-memory-usage-6-5-mb-easy-to-understand",
                "content": "// NOTE: arr[i] denotes the number of people got aware of secret at that particular day (ith day)\\n\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) \\n    {\\n        vector<int>arr(n,0);\\n        int mod=1e9+7;\\n        if(n==0)return 0;\\n        \\n        arr[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i])\\n            {\\n                for(int j=i+d;j<i+f && j<n;j++)\\n                {\\n                    arr[j]=(arr[j]+arr[i])%mod;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=n-1;i>=0 && i>=n-f;i--)\\n        {\\n            ans=(ans+arr[i])%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) \\n    {\\n        vector<int>arr(n,0);\\n        int mod=1e9+7;\\n        if(n==0)return 0;\\n        \\n        arr[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i])\\n            {\\n                for(int j=i+d;j<i+f && j<n;j++)\\n                {\\n                    arr[j]=(arr[j]+arr[i])%mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2230334,
                "title": "easy-c-solution",
                "content": "```\\n// Let d be the delay and f be the time to forget message .\\n// The work to share the message to further people will be done by \\'active peoples\\' between this time period i.e (f-d).\\n//at each time we will be finding the number of \\'active peoples\\'.\\n\\nint peopleAwareOfSecret(int n, int d, int f) {\\n        vector<long long> dp(n,0);dp[0]=1; // at first the number of active people is 1\\n        for(int i=1;i<n;i++){\\n            for(int j=i-d;j>i-f;j--){\\n                if(j>=0){\\n                    dp[i]=(dp[i]+dp[j])%1000000007; //step to find number of  \\'active peoples\\' .\\n\\t\\t\\t\\t // between some period of \\'i-f to i-d\\' and this will share message to other people .\\n                }\\n            }\\n        }\\n        long long ans=0;\\n\\t\\t//at last finding the people which has the current message.\\n        for(int i=n-1;i>=n-f && i>=0;i--){\\n            ans=(ans+dp[i])%1000000007;\\n        }\\n        return (int)ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n// Let d be the delay and f be the time to forget message .\\n// The work to share the message to further people will be done by \\'active peoples\\' between this time period i.e (f-d).\\n//at each time we will be finding the number of \\'active peoples\\'.\\n\\nint peopleAwareOfSecret(int n, int d, int f) {\\n        vector<long long> dp(n,0);dp[0]=1; // at first the number of active people is 1\\n        for(int i=1;i<n;i++){\\n            for(int j=i-d;j>i-f;j--){\\n                if(j>=0){\\n                    dp[i]=(dp[i]+dp[j])%1000000007; //step to find number of  \\'active peoples\\' .\\n\\t\\t\\t\\t // between some period of \\'i-f to i-d\\' and this will share message to other people .\\n                }\\n            }\\n        }\\n        long long ans=0;\\n\\t\\t//at last finding the people which has the current message.\\n        for(int i=n-1;i>=n-f && i>=0;i--){\\n            ans=(ans+dp[i])%1000000007;\\n        }\\n        return (int)ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230244,
                "title": "c-simple-memo",
                "content": "```\\nclass Solution {\\npublic:\\n   int Mod=1e9+7;\\n    int dp[1001];\\n    // t is the time time when this person gets a secret\\n\\n   int helper(int t,int d,int f,int n){\\n       if(dp[t]!=-1) return dp[t];\\n      int ans=1;\\n     if(t==n) return 1;\\n     // it can share secret to other till he forget (x<t+f)\\n      for(int x=t+d;x<t+f && x<=n;x++){\\n         ans=((long long)ans+helper(x,d,f,n))%Mod;\\n      }\\n      return dp[t]=ans;\\n   }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) dp[i]=-1;\\n         // total new person who has known or currently know the secret till n\\n        int total=helper(1,delay,forget,n);\\n        if(n==forget)\\n        return total;\\n        for(int i=1;i<=n;i++) dp[i]=-1;\\n          // total new person who has known or currently know the secret till n-forget\\n     int rest=helper(1,delay,forget,n-forget);\\n\\n  // we want total person who currently know the secret till n=total-rest\\n     return ((long long)total-rest+Mod)%Mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int Mod=1e9+7;\\n    int dp[1001];\\n    // t is the time time when this person gets a secret\\n\\n   int helper(int t,int d,int f,int n){\\n       if(dp[t]!=-1) return dp[t];\\n      int ans=1;\\n     if(t==n) return 1;\\n     // it can share secret to other till he forget (x<t+f)\\n      for(int x=t+d;x<t+f && x<=n;x++){\\n         ans=((long long)ans+helper(x,d,f,n))%Mod;\\n      }\\n      return dp[t]=ans;\\n   }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) dp[i]=-1;\\n         // total new person who has known or currently know the secret till n\\n        int total=helper(1,delay,forget,n);\\n        if(n==forget)\\n        return total;\\n        for(int i=1;i<=n;i++) dp[i]=-1;\\n          // total new person who has known or currently know the secret till n-forget\\n     int rest=helper(1,delay,forget,n-forget);\\n\\n  // we want total person who currently know the secret till n=total-rest\\n     return ((long long)total-rest+Mod)%Mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230069,
                "title": "c-dp",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod=1000000007;\\n        long long a[n+1];\\n        memset(a,0,sizeof(a));\\n        long long res=0;\\n        a[1]=1; // 1 person at day 1\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(a[i])\\n            for(int j=i+delay;j<i+forget;j++)\\n            {\\n                if(j>n)\\n                    break;\\n                a[i]=a[i]%mod;\\n                a[j]+=a[i];\\n                a[j]=a[j]%mod;\\n            }\\n        }\\n        for(int i=n;i>n-forget;i--)\\n        {\\n            res+=a[i];\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod=1000000007;\\n        long long a[n+1];\\n        memset(a,0,sizeof(a));\\n        long long res=0;\\n        a[1]=1; // 1 person at day 1\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(a[i])\\n            for(int j=i+delay;j<i+forget;j++)\\n            {\\n                if(j>n)\\n                    break;\\n                a[i]=a[i]%mod;\\n                a[j]+=a[i];\\n                a[j]=a[j]%mod;\\n            }\\n        }\\n        for(int i=n;i>n-forget;i--)\\n        {\\n            res+=a[i];\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230045,
                "title": "dp-read-question-carefully-especially-the-forget-condition",
                "content": "Code:\\n```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    int mod = 1e9 + 7;\\n    int func(int d,int n,int D,int F){\\n        \\n        if(d > n) return 0;\\n        \\n        int ans = 0;\\n        if(dp[d] != -1) return dp[d];\\n        bool is = false;\\n        \\n        for(int x=d+D;x<d+F;x++){     //just create all the friends that can get the secret\\n            \\n            int tmp = func(x,n,D,F);\\n            ans += tmp;\\n            ans%=mod;\\n            \\n        }\\n        \\n        if(d+F <= n) return dp[d] = ans%mod;    //if it forget the secret then no need of +1\\n        return dp[d] = (1 + ans)%mod;   //otherwise do +1\\n        \\n    }\\n    \\n    int peopleAwareOfSecret(int n, int D, int F) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(1,n,D,F);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1001];\\n    int mod = 1e9 + 7;\\n    int func(int d,int n,int D,int F){\\n        \\n        if(d > n) return 0;\\n        \\n        int ans = 0;\\n        if(dp[d] != -1) return dp[d];\\n        bool is = false;\\n        \\n        for(int x=d+D;x<d+F;x++){     //just create all the friends that can get the secret\\n            \\n            int tmp = func(x,n,D,F);\\n            ans += tmp;\\n            ans%=mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2230029,
                "title": "very-simple-easy-approach",
                "content": "```\\nclass Solution {\\n    long MOD = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> day(1001, 0); // represents the number of people who know the secret on day i\\n        int d = 1;  \\n        day[d] = 1; // day 1 has 1 person who knows the secret\\n\\n        // iterate through days\\n        while(d <= n) {\\n            // as 1 person can tell secret to only 1 person per day\\n            // so persons on day i  can tell  secreat after delay days untill they forget it\\n            // so we simply add the number of people who know the secret on day d to all new days\\n            for(int j = d + delay; j <= min(d + forget - 1, n); j++) {\\n                day[j] = (day[j] + day[d]) % MOD;\\n            }\\n            d++;\\n        }\\n        long res = 0;\\n        // At last day only  last \\'\\'\\'forget\\'\\'\\' days persons can remember the secret\\n\\t\\t// so simply add them\\n        for(int i = max(n - forget + 1, 0); i <= n; i++) {\\n            res = (res + day[i]) % MOD;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    long MOD = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> day(1001, 0); // represents the number of people who know the secret on day i\\n        int d = 1;  \\n        day[d] = 1; // day 1 has 1 person who knows the secret\\n\\n        // iterate through days\\n        while(d <= n) {\\n            // as 1 person can tell secret to only 1 person per day\\n            // so persons on day i  can tell  secreat after delay days untill they forget it\\n            // so we simply add the number of people who know the secret on day d to all new days\\n            for(int j = d + delay; j <= min(d + forget - 1, n); j++) {\\n                day[j] = (day[j] + day[d]) % MOD;\\n            }\\n            d++;\\n        }\\n        long res = 0;\\n        // At last day only  last \\'\\'\\'forget\\'\\'\\' days persons can remember the secret\\n\\t\\t// so simply add them\\n        for(int i = max(n - forget + 1, 0); i <= n; i++) {\\n            res = (res + day[i]) % MOD;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229943,
                "title": "python-3-top-down-dp",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        MOD = 1_000_000_007\\n        \\n        @cache\\n        def dp(idx):\\n            if n < idx + delay:\\n                return 1\\n            ret = 1\\n            if n >= idx + forget:\\n                ret = 0\\n            for k in range(idx + delay, min(idx + forget, n + 1)):\\n                ret = (ret + dp(k)) % MOD\\n            return ret\\n        \\n        return dp(1)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        MOD = 1_000_000_007\\n        \\n        @cache\\n        def dp(idx):\\n            if n < idx + delay:\\n                return 1\\n            ret = 1\\n            if n >= idx + forget:\\n                ret = 0\\n            for k in range(idx + delay, min(idx + forget, n + 1)):\\n                ret = (ret + dp(k)) % MOD\\n            return ret\\n        \\n        return dp(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229916,
                "title": "simple-dp-o-n-2-time-o-n-space-detailed-explanation",
                "content": "```\\nPerson can deliver secret to new person only if day is in the range [day+delay,day+forget)\\n\\nfor eg:\\nif current day is 2\\n\\ndelay is 2\\nforget is 4\\n\\nthen current person can deliver from [2+2,2+4)\\n\\nand if the person has more days then that person will forget the secret.(Day+Forget<=Total no of days).\\n\\n\\n\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll t[1001];\\n    int mod=1e9+7;\\n    ll solve(int day,int delay,int forget,int n){\\n        \\n        if(t[day]!=-1) return t[day]%mod;\\n        \\n        int ans=1;\\n        \\n        // person can only deliver secret as delay period ends and deliver upto its forget period starts. \\n        for(int i=day+delay;i<day+forget && i<=n;i++){\\n            ans+=solve(i,delay,forget,n)%mod;\\n            ans%=mod;\\n        }\\n        \\n        // if current person has enough days to forget the secret\\n        if(day+forget<=n) ans=(ans-1+mod)%mod;\\n        \\n        return t[day] = ans%mod;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(t,-1,sizeof(t));\\n        ll ans = solve(1,delay,forget,n);\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nPerson can deliver secret to new person only if day is in the range [day+delay,day+forget)\\n\\nfor eg:\\nif current day is 2\\n\\ndelay is 2\\nforget is 4\\n\\nthen current person can deliver from [2+2,2+4)\\n\\nand if the person has more days then that person will forget the secret.(Day+Forget<=Total no of days).\\n\\n\\n\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll t[1001];\\n    int mod=1e9+7;\\n    ll solve(int day,int delay,int forget,int n){\\n        \\n        if(t[day]!=-1) return t[day]%mod;\\n        \\n        int ans=1;\\n        \\n        // person can only deliver secret as delay period ends and deliver upto its forget period starts. \\n        for(int i=day+delay;i<day+forget && i<=n;i++){\\n            ans+=solve(i,delay,forget,n)%mod;\\n            ans%=mod;\\n        }\\n        \\n        // if current person has enough days to forget the secret\\n        if(day+forget<=n) ans=(ans-1+mod)%mod;\\n        \\n        return t[day] = ans%mod;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(t,-1,sizeof(t));\\n        ll ans = solve(1,delay,forget,n);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229880,
                "title": "python-dp-for-beginners",
                "content": "Day 1 [0, 1, 0, 0, 0, 0, 0]\\nDay 2 [0, 1, 1, 0, 0, 0, 0]\\nDay 3 [0, 1, 1, 2, 0, 0, 0]\\nDay 4 [0, 1, 1, 2, 3, 0, 0]\\nDay 5 [0, 0, 0, 1, 2, 3, 0]\\nDay 6 [0, 0, 0, 1, 2, 3, 5]\\t\\n\\n\\tclass Solution:\\n\\t\\tdef peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n\\t\\t\\tdp = [0]*(n+1)\\n\\t\\t\\tdp[1] = 1 \\n\\t\\t\\tfor i in range(2,n+1):  \\n\\t\\t\\t\\tprev = max(0,i-forget)\\n\\t\\t\\t\\tsub = dp[prev]\\n\\t\\t\\t\\tfor j in range(prev,i): dp[j]-=sub\\n\\t\\t\\t\\tdp[i] = dp[max(0,i-delay)] + dp[i-1] \\n\\t\\t\\treturn dp[-1]%(10**9+7)\\n\\nTime: O(n*forget)\\nspace: O(n) \\n",
                "solutionTags": [],
                "code": "Day 1 [0, 1, 0, 0, 0, 0, 0]\\nDay 2 [0, 1, 1, 0, 0, 0, 0]\\nDay 3 [0, 1, 1, 2, 0, 0, 0]\\nDay 4 [0, 1, 1, 2, 3, 0, 0]\\nDay 5 [0, 0, 0, 1, 2, 3, 0]\\nDay 6 [0, 0, 0, 1, 2, 3, 5]\\t\\n\\n\\tclass Solution:\\n\\t\\tdef peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n\\t\\t\\tdp = [0]*(n+1)\\n\\t\\t\\tdp[1] = 1 \\n\\t\\t\\tfor i in range(2,n+1):  \\n\\t\\t\\t\\tprev = max(0,i-forget)\\n\\t\\t\\t\\tsub = dp[prev]\\n\\t\\t\\t\\tfor j in range(prev,i): dp[j]-=sub\\n\\t\\t\\t\\tdp[i] = dp[max(0,i-delay)] + dp[i-1] \\n\\t\\t\\treturn dp[-1]%(10**9+7)\\n\\nTime: O(n*forget)\\nspace: O(n) \\n",
                "codeTag": "Java"
            },
            {
                "id": 3042752,
                "title": "java-dp-solution-bottomup",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n #####  create a array of length n + 1  -->  [0,1,2,3,4,5,6]\\n*This array would signify the number of people who found the secret on ith day*\\n\\n##### i --> i  + delay  (Acting as Spreader)\\n\\n##### i --> i + forget  (Forgotting the Secret)\\n\\n##### i --> dp[i - delay] (noOfnewPeopleSharingSecretOnIthDay)\\n\\n##### i --> dp[i - forget] (noOfPeopleForgetSecretOnIthDay)\\n\\n##### noOfPeopleSharingSecret = (noOfPeopleSharingSecret + noOfnewPeopleSharingSecretOnIthDay - noOfPeopleForgetSecretOnIthDay)\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n       \\n    long dp[] = new long[n + 1];\\n    long mod  = (long)1e9 + 7;\\n    long noOfPeopleSharingSecret = 0;\\n    long ans = 0;\\n\\n    // day 1 only one person knows the secret\\n    dp[1] = 1;\\n\\n    // i stands for days\\n    // using Math.max to avoid negative scenarios when i - delay is negative (max is 0 in case of -ve) and (dp[0] = 0 is valid).\\n    for(int i = 2; i <= n; i++){\\n    long noOfnewPeopleSharingSecretOnIthDay = dp[Math.max(i - delay , 0)];\\n    long noOfPeopleForgetSecretOnIthDay = dp[Math.max(i - forget , 0)];\\n    noOfPeopleSharingSecret += (noOfnewPeopleSharingSecretOnIthDay - noOfPeopleForgetSecretOnIthDay + mod) % mod;\\n\\n    // dp[i] means the number of people who found the secret on ith day\\n    dp[i] = noOfPeopleSharingSecret;\\n    }\\n\\n    // once we build the dp array we start the iteration from (n - forget + 1 to n)\\n    // and sum up the elements and store it in ans variable and finally return it \\n    for(int i = n - forget + 1 ; i <= n; i++){\\n        ans = (ans + dp[i]) % mod;\\n    }\\n    return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n       \\n    long dp[] = new long[n + 1];\\n    long mod  = (long)1e9 + 7;\\n    long noOfPeopleSharingSecret = 0;\\n    long ans = 0;\\n\\n    // day 1 only one person knows the secret\\n    dp[1] = 1;\\n\\n    // i stands for days\\n    // using Math.max to avoid negative scenarios when i - delay is negative (max is 0 in case of -ve) and (dp[0] = 0 is valid).\\n    for(int i = 2; i <= n; i++){\\n    long noOfnewPeopleSharingSecretOnIthDay = dp[Math.max(i - delay , 0)];\\n    long noOfPeopleForgetSecretOnIthDay = dp[Math.max(i - forget , 0)];\\n    noOfPeopleSharingSecret += (noOfnewPeopleSharingSecretOnIthDay - noOfPeopleForgetSecretOnIthDay + mod) % mod;\\n\\n    // dp[i] means the number of people who found the secret on ith day\\n    dp[i] = noOfPeopleSharingSecret;\\n    }\\n\\n    // once we build the dp array we start the iteration from (n - forget + 1 to n)\\n    // and sum up the elements and store it in ans variable and finally return it \\n    for(int i = n - forget + 1 ; i <= n; i++){\\n        ans = (ans + dp[i]) % mod;\\n    }\\n    return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025006,
                "title": "c-easy-soln-explained",
                "content": "# Intuition\\n![IMG-5236 (1).jpg](https://assets.leetcode.com/users/images/52e9b4d4-e9e2-48a3-832b-aa6ece4e3800_1673271710.6536677.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int help(int delay,int forget,int n,vector<int> &dp){\\n        int mod=1e9+7;\\n        int a = forget;\\n        a -= delay;\\n        if(dp[n] != -1) return dp[n];\\n        int j=0;\\n        int sum=0;\\n        while(a>0 && n-delay-j>0){\\n            a--;\\n            sum += ((long)help(delay,forget,n-delay-j,dp)%mod);\\n            sum = sum%mod;\\n            j++;\\n        }\\n        if(n-forget>0){\\n            dp[n] = (sum%mod);\\n        }\\n        else{\\n            dp[n] = ((sum+1)%mod);\\n        }\\n        return dp[n];\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> dp(n+1,-1);\\n        return help(delay,forget,n,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int delay,int forget,int n,vector<int> &dp){\\n        int mod=1e9+7;\\n        int a = forget;\\n        a -= delay;\\n        if(dp[n] != -1) return dp[n];\\n        int j=0;\\n        int sum=0;\\n        while(a>0 && n-delay-j>0){\\n            a--;\\n            sum += ((long)help(delay,forget,n-delay-j,dp)%mod);\\n            sum = sum%mod;\\n            j++;\\n        }\\n        if(n-forget>0){\\n            dp[n] = (sum%mod);\\n        }\\n        else{\\n            dp[n] = ((sum+1)%mod);\\n        }\\n        return dp[n];\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> dp(n+1,-1);\\n        return help(delay,forget,n,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960037,
                "title": "99-python-solution-using-two-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn each iteration of the loop, the code checks if there are any elements in the delay or forget deques that correspond to the current day. If there are, it updates the canshare variable accordingly. If there are people who currently know the secret (i.e., if canshare is non-zero), it adds new elements to the delay and forget deques for each of those people.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, Delay: int, Forget: int) -> int:\\n\\n        canshare = 0\\n        delay = deque()\\n        forget = deque()\\n        day = 0\\n\\n        delay.append([1+Delay,1])\\n        forget.append([1+Forget,1])\\n        while day <= n:\\n            if delay and delay[0][0] == day:\\n                canshare += delay.popleft()[1]\\n            if forget and forget[0][0] == day:\\n                canshare -= forget.popleft()[1]\\n            if canshare:\\n                delay.append([day+Delay,canshare])\\n                forget.append([day+Forget,canshare])\\n\\n            day += 1\\n        \\n        while delay:\\n            canshare += delay.pop()[1]\\n        \\n        return canshare % (10**9+7)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, Delay: int, Forget: int) -> int:\\n\\n        canshare = 0\\n        delay = deque()\\n        forget = deque()\\n        day = 0\\n\\n        delay.append([1+Delay,1])\\n        forget.append([1+Forget,1])\\n        while day <= n:\\n            if delay and delay[0][0] == day:\\n                canshare += delay.popleft()[1]\\n            if forget and forget[0][0] == day:\\n                canshare -= forget.popleft()[1]\\n            if canshare:\\n                delay.append([day+Delay,canshare])\\n                forget.append([day+Forget,canshare])\\n\\n            day += 1\\n        \\n        while delay:\\n            canshare += delay.pop()[1]\\n        \\n        return canshare % (10**9+7)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544522,
                "title": "java-dp-o-n2",
                "content": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1000000007;\\n        long[] people = new long[n + 1];\\n        people[1] = 1;\\n        long total = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(people[i] > 0) {\\n                for(int j = delay; j < forget && i + j <=n; j++) {\\n\\t\\t\\t\\t   //all people who will know the secret at day i will share it to 1 person each on each day from delay until they forget\\n                    people[i + j] = (people[i + j] + people[i]) % mod;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        for(int i = 1; i <=n; i++) {\\n\\t\\t//people who will remember at day n are those whose forget day is after day n\\n            if(people[i] > 0 && i + forget > n)\\n                total= (total + people[i]) % mod;\\n        }\\n        \\n        return (int)total;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1000000007;\\n        long[] people = new long[n + 1];\\n        people[1] = 1;\\n        long total = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(people[i] > 0) {\\n                for(int j = delay; j < forget && i + j <=n; j++) {\\n\\t\\t\\t\\t   //all people who will know the secret at day i will share it to 1 person each on each day from delay until they forget\\n                    people[i + j] = (people[i + j] + people[i]) % mod;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        for(int i = 1; i <=n; i++) {\\n\\t\\t//people who will remember at day n are those whose forget day is after day n\\n            if(people[i] > 0 && i + forget > n)\\n                total= (total + people[i]) % mod;\\n        }\\n        \\n        return (int)total;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272291,
                "title": "c-short-and-crisp-o-n-to-o-n",
                "content": "\\nO(n\\xB2)\\n```\\nstruct Solution {\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        \\n        long long dp[n], M = 1\\'000\\'000\\'007;\\n        \\n        memset(dp, 0, sizeof dp);\\n        \\n        dp[0] = 1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // ith person will start sharing from (i+d)th day\\n            // until he/she forgets it i.e. (i+f)th day\\n            for (int j = i+d; j < i+f && j < n; ++j) {\\n                (dp[j] += dp[i]) %= M;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        \\n        // now just return the sum of last f days\\n        for (int i = n-f; i < n; ++i) {\\n            (ans += dp[i]) %= M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nO(n)\\n```\\nstruct Solution {\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        \\n        long long dp[n+1];\\n        dp[0] = 0, dp[1] = 1;\\n        long long cur = 0, M = 1\\'000\\'000\\'007;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            cur += dp[max(0, i-d)] - dp[max(0, i-f)];\\n            dp[i] = (cur += M) %= M;\\n        }\\n        \\n        cur = 0;\\n        \\n        for (int i = n-f+1; i <= n; ++i) {\\n            (cur += dp[i]) %= M;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Solution {\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        \\n        long long dp[n], M = 1\\'000\\'000\\'007;\\n        \\n        memset(dp, 0, sizeof dp);\\n        \\n        dp[0] = 1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // ith person will start sharing from (i+d)th day\\n            // until he/she forgets it i.e. (i+f)th day\\n            for (int j = i+d; j < i+f && j < n; ++j) {\\n                (dp[j] += dp[i]) %= M;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        \\n        // now just return the sum of last f days\\n        for (int i = n-f; i < n; ++i) {\\n            (ans += dp[i]) %= M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nstruct Solution {\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        \\n        long long dp[n+1];\\n        dp[0] = 0, dp[1] = 1;\\n        long long cur = 0, M = 1\\'000\\'000\\'007;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            cur += dp[max(0, i-d)] - dp[max(0, i-f)];\\n            dp[i] = (cur += M) %= M;\\n        }\\n        \\n        cur = 0;\\n        \\n        for (int i = n-f+1; i <= n; ++i) {\\n            (cur += dp[i]) %= M;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267542,
                "title": "c-dynamic-programming-easy-solution",
                "content": "```\\n// dp[i] will store the entries at ith day\\n// for nth day total people will be (n - forget) days before n\\n\\nclass Solution\\n{\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget)\\n    {\\n        int M = 1000000007;\\n        vector<long long> dp(2005, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i + delay; j < i + forget; j++)\\n            {\\n                dp[j] = (dp[j]% M +  dp[i] % M)%M;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = max(0, n - forget); i < n; i++)\\n            ans = (ans % M + dp[i] % M) % M;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// dp[i] will store the entries at ith day\\n// for nth day total people will be (n - forget) days before n\\n\\nclass Solution\\n{\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget)\\n    {\\n        int M = 1000000007;\\n        vector<long long> dp(2005, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i + delay; j < i + forget; j++)\\n            {\\n                dp[j] = (dp[j]% M +  dp[i] % M)%M;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = max(0, n - forget); i < n; i++)\\n            ans = (ans % M + dp[i] % M) % M;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264367,
                "title": "dp-with-single-loop",
                "content": "We can keep track of a few things.\\n1. The number of people who are currently aware of the secret.\\n2. The number of people who came to know about the secret on the current day.\\n3. The number of people who cannot share the secret on the current day due to incomplete delay period.\\n\\n```\\n/*\\ntotalAware stores the number of people who are aware of the secret on the current day.\\nnewEntries[i] stores the number of people who came to know about the secret on ith day.\\npossibleShare stores how many people may share the secret\\ncantshare stores how many people cannot share the secret due to incomplete delay period\\nnewEntrants stores how many people came to know about the secret\\n*/\\n\\nclass Solution {\\n    private static final int m = (int)1e9+7;\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] newEntries = new int[n+1];\\n        int totalAware = 0, day;\\n        \\n        //for all days till the delay, only 1 person knows the secret\\n        totalAware = 1;\\n        newEntries[1] = 1; //new entries for the 1st day is 1 and for the rest is 0\\n        \\n        int possibleShare = 0, cantShare = 0, newEntrants = 0;\\n        for (day = delay+1; day <= n; ++day) //for each day starting from the next day of delay\\n        {\\n            possibleShare = totalAware; //get the number of people who may share\\n            possibleShare -= day-forget > 0 ? newEntries[day-forget] : 0; //subtract the number of people who will forget on the same day\\n            if (possibleShare < 0) possibleShare += m; //rebalancing due to mod operation\\n            newEntrants = possibleShare-cantShare; //store the number of new entrants, the people who cannot share due to incomplete delay period will be subtracted\\n            if (newEntrants < 0) newEntrants += m; //rebalancing due to mod operation\\n            newEntries[day] = newEntrants; //store the new entrants for current day\\n            totalAware = (possibleShare+newEntrants)%m; //store the total active people for current day\\n            cantShare -= newEntries[day-delay+1]; //slide the window for the people who cannot share the secret for the next day\\n            if (cantShare < 0) cantShare += m; //rebalancing due to mod operation\\n            cantShare = (cantShare+newEntries[day])%m; //slide the window for the people who cannot share the secret for the next day\\n        }\\n        \\n        return totalAware;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\ntotalAware stores the number of people who are aware of the secret on the current day.\\nnewEntries[i] stores the number of people who came to know about the secret on ith day.\\npossibleShare stores how many people may share the secret\\ncantshare stores how many people cannot share the secret due to incomplete delay period\\nnewEntrants stores how many people came to know about the secret\\n*/\\n\\nclass Solution {\\n    private static final int m = (int)1e9+7;\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] newEntries = new int[n+1];\\n        int totalAware = 0, day;\\n        \\n        //for all days till the delay, only 1 person knows the secret\\n        totalAware = 1;\\n        newEntries[1] = 1; //new entries for the 1st day is 1 and for the rest is 0\\n        \\n        int possibleShare = 0, cantShare = 0, newEntrants = 0;\\n        for (day = delay+1; day <= n; ++day) //for each day starting from the next day of delay\\n        {\\n            possibleShare = totalAware; //get the number of people who may share\\n            possibleShare -= day-forget > 0 ? newEntries[day-forget] : 0; //subtract the number of people who will forget on the same day\\n            if (possibleShare < 0) possibleShare += m; //rebalancing due to mod operation\\n            newEntrants = possibleShare-cantShare; //store the number of new entrants, the people who cannot share due to incomplete delay period will be subtracted\\n            if (newEntrants < 0) newEntrants += m; //rebalancing due to mod operation\\n            newEntries[day] = newEntrants; //store the new entrants for current day\\n            totalAware = (possibleShare+newEntrants)%m; //store the total active people for current day\\n            cantShare -= newEntries[day-delay+1]; //slide the window for the people who cannot share the secret for the next day\\n            if (cantShare < 0) cantShare += m; //rebalancing due to mod operation\\n            cantShare = (cantShare+newEntries[day])%m; //slide the window for the people who cannot share the secret for the next day\\n        }\\n        \\n        return totalAware;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258422,
                "title": "did-simple-simulation",
                "content": "I am bad at DP :| so thought of the idea where we have to update the array entry after the delay point till the forget point, once it is done sum up the last len(forget) elements as before that all the members must have forget the secrets   \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        \\n        vector<int> v(n,0);\\n        \\n        v[0] = 1;\\n        int mod = 1000000007;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i] ==  0)\\n                continue; \\n            int start = i+delay;\\n            int end = i+forget;\\n            for(int j = start;j<n && j<end;j++)\\n            {\\n                \\n                v[j]= (v[j]%mod + v[i]%mod)%mod;\\n                v[j]%=mod;\\n            }\\n        }\\n        \\n        long long int res = 0;\\n        int lim=n-forget;\\n        for(int i = n-1;i>=lim;i--)\\n        {\\n            res = res+v[i];\\n            res%=mod;\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    \\n        \\n           \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        \\n        vector<int> v(n,0);\\n        \\n        v[0] = 1;\\n        int mod = 1000000007;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i] ==  0)\\n                continue; \\n            int start = i+delay;\\n            int end = i+forget;\\n            for(int j = start;j<n && j<end;j++)\\n            {\\n                \\n                v[j]= (v[j]%mod + v[i]%mod)%mod;\\n                v[j]%=mod;\\n            }\\n        }\\n        \\n        long long int res = 0;\\n        int lim=n-forget;\\n        for(int i = n-1;i>=lim;i--)\\n        {\\n            res = res+v[i];\\n            res%=mod;\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    \\n        \\n           \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257351,
                "title": "c-easy-implementation-clear-approach",
                "content": "\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<tuple<int,int,int>>person; int m = 1e9+7;\\n        int target =1;vector<int>dp(n+1);\\n        dp[0] =0;dp[1] = 1;int day = 2;\\n        person.push_back({1+delay,1+forget,1});\\n        while(day<=n)\\n        {\\n            while(!person.empty()&&get<1>(person[0])== day)\\n            {\\n                person.erase(person.begin());\\n            }\\n            int cnt=0;\\n            for(auto x: person)\\n            {  auto [d,f,c] = x;\\n                if(d<=day)\\n                {\\n                    cnt=(cnt%m+c)%m;\\n                }\\n            }\\n            person.push_back({day+delay,day+forget,cnt});\\n            day++;\\n        }\\n        int ans=0;\\n        for(auto y:person)\\n        {  auto [d,f,c] = y;\\n            ans= (ans%m+c)%m;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\nint peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<tuple<int,int,int>>person; int m = 1e9+7;\\n        int target =1;vector<int>dp(n+1);\\n        dp[0] =0;dp[1] = 1;int day = 2;\\n        person.push_back({1+delay,1+forget,1});\\n        while(day<=n)\\n        {\\n            while(!person.empty()&&get<1>(person[0])== day)\\n            {\\n                person.erase(person.begin());\\n            }\\n            int cnt=0;\\n            for(auto x: person)\\n            {  auto [d,f,c] = x;\\n                if(d<=day)\\n                {\\n                    cnt=(cnt%m+c)%m;\\n                }\\n            }\\n            person.push_back({day+delay,day+forget,cnt});\\n            day++;\\n        }\\n        int ans=0;\\n        for(auto y:person)\\n        {  auto [d,f,c] = y;\\n            ans= (ans%m+c)%m;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2257248,
                "title": "dp-solving-diary",
                "content": "# Idea\\n\\nOh man, this problem reuqires comprehension.\\n\\nAt first glance, I didn\\'t even know how to do it .\\n\\nI just checked the code from others.\\n\\nAnd then I start to gradually understand what this problem means and how can we solve it.\\n\\nLet\\'s revise the problem first.\\n\\nAt start we have one person knowing a secret.\\nAnd we have a `delay` amd `forget` number.\\nOne person will spread the secret to another new person starting from\\n`delay` days, and he will forget this secret and stop spreading this secret after\\n`forget` days.\\n\\nWe have two ideas for this problem using dp.\\nCheck out the ideas below.\\n\\n# Two dimension dp \\nThe problem hints use this way.\\nThis is intuitive, but require some careful code writing and thought.\\nThe two dimension dp solution idea is that we have a `dp[n][forget]`\\narray.\\n`dp[i][j]` means  how many people remember the secret at day i for j+1 days.\\n\\nfor j > 0, which means people already know the secret for more than one day\\nwe have `dp[i][j] = dp[i-1][j-1]`\\n\\nj == 0 means the number of new people who get the secret. These new people \\ncomes from the `i-1` day who know the secret for [delay, forget-1] days .\\n\\nAnd after checking out the code I find that I actually we could save some space \\n`dp[i][j] ` only depends on `dp[i-1][j]`\\nso we could get rid of dp[n]\\nuse `dp1[forget] ` and `dp2[forget]` should be enough.\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n      // dp[i][j] means at day i, the number of people remember the secret for j days.\\n      // no one will remember the secret for forget days, at most forget -1 days.\\n      vector<vector<long>> dp(n+1, vector<long>(forget, 0));\\n\\n        \\n      dp[1][0] = 1;\\n\\n      int mod = 1000000007;\\n      // start from day2  until day n\\n      for(int day=2; day <= n; day++) {\\n        // notice that dp[i][j], j should not be larger than i\\n        // and this is why we get j < min(day, forget);\\n        for(int j=0; j < min(day, forget); j++) {\\n          // dp[i][0] and dp[i][j] j >0 is different\\n          // dp[i][0] means how many new people get the secret at day i.\\n          // dp[i][j] j > 0 means how many people from past know the secret for j+1 days.\\n          if(j==0) {\\n            long sum = 0;\\n            // notice the start condition and the terminate condition.\\n            // k = delay-1 \\n\\n            // we sum all the people who already know the secret from day delay to day forget-1 \\n            // remember dp[i][j] means the number of people know the secret fro day j+1;\\n            for(int k=delay-1; k <= forget-2; k++) {\\n              sum = (sum + dp[day-1][k]) % mod;\\n            }\\n            dp[day][j] = sum;\\n          } else {\\n            // an extra day pass.\\n            dp[day][j] = dp[day-1][j-1];\\n          }\\n        }\\n      }\\n\\n      long ans = 0;\\n      for(int i=0; i < forget; i++) {\\n        ans += dp[n][i];\\n        ans %= mod;\\n      }\\n      return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# One dimesion dp \\n\\nThis is copied from lee.\\n\\nI will try to do some explanation. \\nThe variable `share` stores how many new people get the secret at day i\\nand  `share` at day `i` comes from day `i-1` and `i-delay`, also we minus the \\npeople who will forget the secret from day` i-forget`.\\n\\nshould we do `day -delay +1 ` , this boundary case always confuses me .\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        // dp[i] =  number of new people that know the secret on day i\\n        // dp[i]= dp[i-1]  - dp[i-forget]  + dp[i-delay]\\n        \\n        // dp[i] means how many new people get the secret at day i\\n        vector<long> dp(n+1, 0);\\n        \\n        dp[1] = 1;\\n        int share = 0;\\n        int mod = 1000000007;\\n        for(int day=2; day <= n ;day++) {\\n            dp[day] = share = (share + dp[max(day - delay, 0 )] - dp[max(day - forget, 0) ] + mod) % mod;\\n        }\\n        \\n        int res = 0;\\n        for(int i=n-forget+1; i<=n ; i++) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Tags\\nDynamic programming. State transfer.\\nQueue is also \\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n      // dp[i][j] means at day i, the number of people remember the secret for j days.\\n      // no one will remember the secret for forget days, at most forget -1 days.\\n      vector<vector<long>> dp(n+1, vector<long>(forget, 0));\\n\\n        \\n      dp[1][0] = 1;\\n\\n      int mod = 1000000007;\\n      // start from day2  until day n\\n      for(int day=2; day <= n; day++) {\\n        // notice that dp[i][j], j should not be larger than i\\n        // and this is why we get j < min(day, forget);\\n        for(int j=0; j < min(day, forget); j++) {\\n          // dp[i][0] and dp[i][j] j >0 is different\\n          // dp[i][0] means how many new people get the secret at day i.\\n          // dp[i][j] j > 0 means how many people from past know the secret for j+1 days.\\n          if(j==0) {\\n            long sum = 0;\\n            // notice the start condition and the terminate condition.\\n            // k = delay-1 \\n\\n            // we sum all the people who already know the secret from day delay to day forget-1 \\n            // remember dp[i][j] means the number of people know the secret fro day j+1;\\n            for(int k=delay-1; k <= forget-2; k++) {\\n              sum = (sum + dp[day-1][k]) % mod;\\n            }\\n            dp[day][j] = sum;\\n          } else {\\n            // an extra day pass.\\n            dp[day][j] = dp[day-1][j-1];\\n          }\\n        }\\n      }\\n\\n      long ans = 0;\\n      for(int i=0; i < forget; i++) {\\n        ans += dp[n][i];\\n        ans %= mod;\\n      }\\n      return ans;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        // dp[i] =  number of new people that know the secret on day i\\n        // dp[i]= dp[i-1]  - dp[i-forget]  + dp[i-delay]\\n        \\n        // dp[i] means how many new people get the secret at day i\\n        vector<long> dp(n+1, 0);\\n        \\n        dp[1] = 1;\\n        int share = 0;\\n        int mod = 1000000007;\\n        for(int day=2; day <= n ;day++) {\\n            dp[day] = share = (share + dp[max(day - delay, 0 )] - dp[max(day - forget, 0) ] + mod) % mod;\\n        }\\n        \\n        int res = 0;\\n        for(int i=n-forget+1; i<=n ; i++) {\\n            res = (res + dp[i]) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254253,
                "title": "easy-recursion-and-memo",
                "content": "```\\nclass Solution {\\n    static const int mod = 1e9+7;\\n    int dp[1005];\\npublic:\\n    Solution(){\\n        memset(dp,-1,sizeof(dp));\\n        // for(int i=0;i<1005;i++) dp[i]=-1;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        if(n<=0) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        int realDays = n;\\n        int ans = 1;\\n        if(n>forget) ans = 0;\\n        n = n-delay;\\n        int x = forget-delay;\\n        while(x>0 && n>0){\\n            ans = (ans + peopleAwareOfSecret(n,delay,forget)%mod)%mod;\\n            n--;\\n            x--;\\n        }\\n        return dp[realDays]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static const int mod = 1e9+7;\\n    int dp[1005];\\npublic:\\n    Solution(){\\n        memset(dp,-1,sizeof(dp));\\n        // for(int i=0;i<1005;i++) dp[i]=-1;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        if(n<=0) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        int realDays = n;\\n        int ans = 1;\\n        if(n>forget) ans = 0;\\n        n = n-delay;\\n        int x = forget-delay;\\n        while(x>0 && n>0){\\n            ans = (ans + peopleAwareOfSecret(n,delay,forget)%mod)%mod;\\n            n--;\\n            x--;\\n        }\\n        return dp[realDays]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247785,
                "title": "easy-to-understand-c-memoization-code",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll t[1001];\\n    int mod = 1e9+7;\\n    ll solve(int day, int delay, int forget, int n){\\n        \\n        if(t[day] != -1) return t[day];\\n        \\n        int ans = 1;\\n        \\n        // person can only deliver secret as delay period ends and deliver upto its forget period starts. \\n        for(int i =day + delay; i < day + forget && i <= n; i++){\\n            ans = (ans + solve(i, delay, forget, n)) % mod;\\n        }\\n        \\n        // if current person has enough days to forget the secret\\n        if(day + forget <= n) ans--;\\n        \\n        return t[day] = ans;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(t, -1, sizeof(t));\\n        return solve(1, delay, forget, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll t[1001];\\n    int mod = 1e9+7;\\n    ll solve(int day, int delay, int forget, int n){\\n        \\n        if(t[day] != -1) return t[day];\\n        \\n        int ans = 1;\\n        \\n        // person can only deliver secret as delay period ends and deliver upto its forget period starts. \\n        for(int i =day + delay; i < day + forget && i <= n; i++){\\n            ans = (ans + solve(i, delay, forget, n)) % mod;\\n        }\\n        \\n        // if current person has enough days to forget the secret\\n        if(day + forget <= n) ans--;\\n        \\n        return t[day] = ans;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(t, -1, sizeof(t));\\n        return solve(1, delay, forget, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247683,
                "title": "python-o-n-time-o-forget-space",
                "content": "One person knows the secret on day 1. Every day thereafter:\\n1. Everyone who discovered the secret on day `day - delay` starts sharing it, and everyone who discovered it on day `day - forget` forgets it.\\n2. Everyone who is currently sharing the secret shares it with a new person.\\n3. The total number of people who know the secret increases by the number of people who just discovered it minus the number of people who just forgot.\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        modulus = 10 ** 9 + 7\\n        discovered = deque([0] * delay)\\n        know = discovered[0] = 1\\n        sharing = 0\\n\\n        for day in range(delay, forget):\\n            sharing += discovered[-delay]\\n            discovered.append(sharing)\\n            know += sharing\\n\\n        for day in range(forget, n):\\n            sharing += discovered[-delay] - discovered[0]\\n            discovered.append(sharing)\\n            know += sharing - discovered.popleft()\\n            \\n        return know % modulus\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        modulus = 10 ** 9 + 7\\n        discovered = deque([0] * delay)\\n        know = discovered[0] = 1\\n        sharing = 0\\n\\n        for day in range(delay, forget):\\n            sharing += discovered[-delay]\\n            discovered.append(sharing)\\n            know += sharing\\n\\n        for day in range(forget, n):\\n            sharing += discovered[-delay] - discovered[0]\\n            discovered.append(sharing)\\n            know += sharing - discovered.popleft()\\n            \\n        return know % modulus\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241015,
                "title": "java-dp-2-approaches",
                "content": "Approach 1: DP with SC: O(n^2)\\n\\n```\\nclass Solution {\\n    private final int MOD = 1000000007;\\n    \\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int dp[][] = new int[n+1][forget];\\n        int i,j,k;\\n        for(i=0;i<n+1;i++){\\n            for(j=0;j<forget;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        \\n        dp[1][0] = 1;\\n        for(i=2;i<n+1;i++){\\n            for(j=0;j<Math.min(i,forget);j++){\\n                if(j==0){\\n                    long sum = 0;\\n                    for(k=delay-1;k<=forget-2;k++){\\n                        sum = (sum + dp[i-1][k])%MOD;\\n                    }\\n                    dp[i][j] = (int)sum;\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        \\n        \\n        long ans = 0;\\n        for(j=0;j<forget;j++){\\n            ans = (ans + dp[n][j])%MOD;\\n        }\\n        \\n        // System.out.println();\\n        // for(i=0;i<n+1;i++){\\n        //     for(j=0;j<forget;j++){\\n        //         System.out.print(dp[i][j]);\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        return (int)ans;\\n    }\\n}\\n```\\n\\nApproach 2: SC: O(n)\\n\\n```\\nclass Solution {\\n    private final int MOD = 1000000007;\\n    \\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] numWhoKnowSecret = new int[n + forget];\\n        int i,j;\\n        \\n        numWhoKnowSecret[1] = 1;\\n        for(i=1;i<=n;i++){\\n            for(j=i+delay ; j<i+forget ; j++){\\n                numWhoKnowSecret[j] = (numWhoKnowSecret[j] + numWhoKnowSecret[i])%MOD;\\n            }\\n        }\\n        \\n        long ans  = 0;\\n        for(i=n;i>n-forget;i--){\\n            ans = (ans + numWhoKnowSecret[i])%MOD;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```\\n\\n\\nFew more test cases to try -\\n500\\n6\\n9\\n1000\\n456\\n567\\n678\\n45\\n89\\n1000\\n236\\n798\\n1000\\n999\\n1000\\n\\n\\n*Kindly upvote if this solution has helped you.\\nThanks for reading! :)*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private final int MOD = 1000000007;\\n    \\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int dp[][] = new int[n+1][forget];\\n        int i,j,k;\\n        for(i=0;i<n+1;i++){\\n            for(j=0;j<forget;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        \\n        dp[1][0] = 1;\\n        for(i=2;i<n+1;i++){\\n            for(j=0;j<Math.min(i,forget);j++){\\n                if(j==0){\\n                    long sum = 0;\\n                    for(k=delay-1;k<=forget-2;k++){\\n                        sum = (sum + dp[i-1][k])%MOD;\\n                    }\\n                    dp[i][j] = (int)sum;\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        \\n        \\n        long ans = 0;\\n        for(j=0;j<forget;j++){\\n            ans = (ans + dp[n][j])%MOD;\\n        }\\n        \\n        // System.out.println();\\n        // for(i=0;i<n+1;i++){\\n        //     for(j=0;j<forget;j++){\\n        //         System.out.print(dp[i][j]);\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        return (int)ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private final int MOD = 1000000007;\\n    \\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] numWhoKnowSecret = new int[n + forget];\\n        int i,j;\\n        \\n        numWhoKnowSecret[1] = 1;\\n        for(i=1;i<=n;i++){\\n            for(j=i+delay ; j<i+forget ; j++){\\n                numWhoKnowSecret[j] = (numWhoKnowSecret[j] + numWhoKnowSecret[i])%MOD;\\n            }\\n        }\\n        \\n        long ans  = 0;\\n        for(i=n;i>n-forget;i--){\\n            ans = (ans + numWhoKnowSecret[i])%MOD;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238664,
                "title": "python-one-queue-99-and-100",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10 ** 9  + 7\\n        # day 1\\n        q, sharing, pre = deque([1] + [0] * (forget - 1)), 0, delay - 1\\n        \\n        for _ in range(1, n):\\n            sharing += q[pre] - q.pop() \\n            q.appendleft(sharing % mod)\\n        \\n        return sum(q) % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        mod = 10 ** 9  + 7\\n        # day 1\\n        q, sharing, pre = deque([1] + [0] * (forget - 1)), 0, delay - 1\\n        \\n        for _ in range(1, n):\\n            sharing += q[pre] - q.pop() \\n            q.appendleft(sharing % mod)\\n        \\n        return sum(q) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238513,
                "title": "java-brute-force",
                "content": "```\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long count=1;\\n        long m = 1000000007;\\n        long[] arr = new long[n+1];\\n        int spread = forget-delay;\\n        arr[1]=1;  // On day 1, one person know the secret.\\n\\t\\t// Spreading the secret from day 1 till N\\n        for(int index=1;index<arr.length;index++){\\n            if(arr[index]>0){\\n                int start=index+delay;\\n                int spreading=spread;\\n                while(start<arr.length && spreading>0){\\n                    arr[start] = (arr[start] + arr[index])%m;\\n                    count = (count+arr[index])%m;\\n                    spreading--;\\n                    start++;\\n                }\\n            }\\n        }\\n        // Forgetting the known secret by every person\\n        for(int index=1;index<arr.length;index++){\\n            if(arr[index]>0){\\n                int forgetDate = index+forget;\\n                if(forgetDate<arr.length){\\n                    count = (count-arr[index]+m)%m;\\n                    arr[index]=0;\\n                }\\n            }\\n        } \\n        return (int)count;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long count=1;\\n        long m = 1000000007;\\n        long[] arr = new long[n+1];\\n        int spread = forget-delay;\\n        arr[1]=1;  // On day 1, one person know the secret.\\n\\t\\t// Spreading the secret from day 1 till N\\n        for(int index=1;index<arr.length;index++){\\n            if(arr[index]>0){\\n                int start=index+delay;\\n                int spreading=spread;\\n                while(start<arr.length && spreading>0){\\n                    arr[start] = (arr[start] + arr[index])%m;\\n                    count = (count+arr[index])%m;\\n                    spreading--;\\n                    start++;\\n                }\\n            }\\n        }\\n        // Forgetting the known secret by every person\\n        for(int index=1;index<arr.length;index++){\\n            if(arr[index]>0){\\n                int forgetDate = index+forget;\\n                if(forgetDate<arr.length){\\n                    count = (count-arr[index]+m)%m;\\n                    arr[index]=0;\\n                }\\n            }\\n        } \\n        return (int)count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2235720,
                "title": "memoization-solution-optimization-over-recursion-java",
                "content": "```\\nclass Solution {\\n    \\n    private long mod = 1000000007;\\n    \\n    private long process(int i,int delay, int end , int target,int[] dp){\\n        \\n        if(i>target)return 0;\\n        \\n        long crt = 0l;\\n        \\n        for(int j=i+delay;j<i+end;j++){\\n            \\n            \\n            if(j<=target && dp[j]!=-1l)\\n                crt = crt + dp[j];\\n            else\\n                crt  = crt + process(j,delay,end,target,dp);\\n            \\n            \\n            crt = crt%mod;\\n        }\\n            \\n        \\n        if(i+end>target) crt+= 1l;\\n        \\n        return dp[i]=(int)(crt % mod);\\n    }\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        //recursive solution \\n        int[] dp = new int[n+1];\\n        \\n        Arrays.fill(dp,-1);\\n        \\n        return (int)  process(1,delay,forget,n,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private long mod = 1000000007;\\n    \\n    private long process(int i,int delay, int end , int target,int[] dp){\\n        \\n        if(i>target)return 0;\\n        \\n        long crt = 0l;\\n        \\n        for(int j=i+delay;j<i+end;j++){\\n            \\n            \\n            if(j<=target && dp[j]!=-1l)\\n                crt = crt + dp[j];\\n            else\\n                crt  = crt + process(j,delay,end,target,dp);\\n            \\n            \\n            crt = crt%mod;\\n        }\\n            \\n        \\n        if(i+end>target) crt+= 1l;\\n        \\n        return dp[i]=(int)(crt % mod);\\n    }\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        //recursive solution \\n        int[] dp = new int[n+1];\\n        \\n        Arrays.fill(dp,-1);\\n        \\n        return (int)  process(1,delay,forget,n,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235689,
                "title": "beating-100-o-n-using-prefix-sum",
                "content": "O(N^2) also passes but can make it O(N) using prefix sum.\\n```\\nclass Solution {\\npublic:\\n    int add(int a,int b)\\n    {\\n        int MOD=1e9+7;\\n        long long int ans=a%MOD;\\n        b=((long long)b+MOD)%MOD;\\n        return (a%MOD +b%MOD)%MOD;\\n    }\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        int ans[n+2];//={};\\n        fill(ans,ans+n+1,0);\\n        ans[1]=1;\\n        ans[2]=-1;\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s=add(s,ans[i]);\\n            ans[i]=s;\\n            int st=i+d;\\n            int en=i+f;\\n            if(st>n)\\n                continue;\\n            en=min(en,n+1);\\n            ans[st]=add(ans[st],s);\\n            ans[en]=add(ans[en],-s);\\n        }\\n        int fans=0;\\n        for(int i=n-f+1;i<=n;i++)\\n            fans=add(fans,ans[i]);\\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int add(int a,int b)\\n    {\\n        int MOD=1e9+7;\\n        long long int ans=a%MOD;\\n        b=((long long)b+MOD)%MOD;\\n        return (a%MOD +b%MOD)%MOD;\\n    }\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        int ans[n+2];//={};\\n        fill(ans,ans+n+1,0);\\n        ans[1]=1;\\n        ans[2]=-1;\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s=add(s,ans[i]);\\n            ans[i]=s;\\n            int st=i+d;\\n            int en=i+f;\\n            if(st>n)\\n                continue;\\n            en=min(en,n+1);\\n            ans[st]=add(ans[st],s);\\n            ans[en]=add(ans[en],-s);\\n        }\\n        int fans=0;\\n        for(int i=n-f+1;i<=n;i++)\\n            fans=add(fans,ans[i]);\\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234140,
                "title": "no-dp-simple-vector-o-n-2-sliding-window-commented",
                "content": "int peopleAwareOfSecret(int n, int delay, int forget) {\\n   \\n   vector<pair<int,long>> v; //pair for (day,no of Aware People till that day)\\n        int c=1;\\n        v.push_back({1,1});\\n        \\n        int j=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            \\n         int m=v.size(); \\n\\n            while(j<m && v[j].first+forget<=i) // excluding the days which are forgoten.(Sliding WIndow)\\n                 j++;\\n          \\n            long  c=0;\\n              long mo=(1e9+7);\\n            for(int k=j;k<m;k++)\\n            {\\n               \\n                \\n             if(v[k].first+delay<=i)\\n              {\\n                  c+=v[k].second;\\n                 \\n                 c=c%mo;\\n              }\\n          }\\n            if(c>0)  // Taking all the count till that day\\n                v.push_back({i,c});\\n        }\\n        long ans=0;\\n        long m=(1e9+7);\\n        for(int i=j;i<v.size();i++)\\n        {\\n            ans+=(v[i].second);\\n            \\n            ans%=m;\\n        }\\n        return (int)ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "int peopleAwareOfSecret(int n, int delay, int forget) {\\n   \\n   vector<pair<int,long>> v; //pair for (day,no of Aware People till that day)\\n        int c=1;\\n        v.push_back({1,1});\\n        \\n        int j=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            \\n         int m=v.size(); \\n\\n            while(j<m && v[j].first+forget<=i) // excluding the days which are forgoten.(Sliding WIndow)\\n                 j++;\\n          \\n            long  c=0;\\n              long mo=(1e9+7);\\n            for(int k=j;k<m;k++)\\n            {\\n               \\n                \\n             if(v[k].first+delay<=i)\\n              {\\n                  c+=v[k].second;\\n                 \\n                 c=c%mo;\\n              }\\n          }\\n            if(c>0)  // Taking all the count till that day\\n                v.push_back({i,c});\\n        }\\n        long ans=0;\\n        long m=(1e9+7);\\n        for(int i=j;i<v.size();i++)\\n        {\\n            ans+=(v[i].second);\\n            \\n            ans%=m;\\n        }\\n        return (int)ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2233746,
                "title": "c-range-query-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> newP(n,0), tmp(n,0);\\n        long long m =1000000007;\\n        tmp[0]=newP[delay]=1;\\n        tmp[delay]=-1;\\n        if(forget<n) newP[forget]=-1;\\n        \\n        for(int i=1;i<n;i++){\\n            newP[i]= (newP[i] + newP[i-1])%m;\\n            tmp[i]=((tmp[i]+tmp[i-1])%m +newP[i])%m;\\n            \\n            if(i+delay<n){\\n                tmp[i+delay] = (tmp[i+delay] -newP[i] +m)%m;\\n                newP[i+delay]= (newP[i+delay] +newP[i])%m;\\n            }\\n            if(i+forget<n)\\n                newP[i+forget]=(newP[i+forget]-newP[i]+m)%m;\\n            \\n        }\\n        return (newP[n-1] +tmp[n-1])%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> newP(n,0), tmp(n,0);\\n        long long m =1000000007;\\n        tmp[0]=newP[delay]=1;\\n        tmp[delay]=-1;\\n        if(forget<n) newP[forget]=-1;\\n        \\n        for(int i=1;i<n;i++){\\n            newP[i]= (newP[i] + newP[i-1])%m;\\n            tmp[i]=((tmp[i]+tmp[i-1])%m +newP[i])%m;\\n            \\n            if(i+delay<n){\\n                tmp[i+delay] = (tmp[i+delay] -newP[i] +m)%m;\\n                newP[i+delay]= (newP[i+delay] +newP[i])%m;\\n            }\\n            if(i+forget<n)\\n                newP[i+forget]=(newP[i+forget]-newP[i]+m)%m;\\n            \\n        }\\n        return (newP[n-1] +tmp[n-1])%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233520,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int rec(int i, int n, int delay, int forget, vector<int>& dp){\\n        int mod = 1e9+7;\\n        if(i>=n) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int res = 0;\\n        for(int j = i+delay;j<i+forget;j++){\\n            res += rec(j,n,delay,forget,dp);     // call recursively\\n            res%=mod;\\n        }\\n        if(i+forget>=n) res++;    // check if the current person will not forget on nth day\\n        return dp[i] = res%mod;\\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> dp(n,-1);\\n        return rec(0,n,delay,forget,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int i, int n, int delay, int forget, vector<int>& dp){\\n        int mod = 1e9+7;\\n        if(i>=n) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int res = 0;\\n        for(int j = i+delay;j<i+forget;j++){\\n            res += rec(j,n,delay,forget,dp);     // call recursively\\n            res%=mod;\\n        }\\n        if(i+forget>=n) res++;    // check if the current person will not forget on nth day\\n        return dp[i] = res%mod;\\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> dp(n,-1);\\n        return rec(0,n,delay,forget,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233104,
                "title": "c-simulate-approach-easy-to-understand",
                "content": "\\n# Solution\\n```C++\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> a(n+forget,0);\\n        a[1]=1;\\n\\t\\t//(1) simulate how the a[i] can share to this range [i+delay,i+forget) \\n        for(int i = 1;i<=n;i++) \\n\\t\\t\\tfor(int j = delay; j<forget;j++) \\n                a[i+j] = mod_add(a[i+j], a[i]); \\n\\t\\t//(2) prefix sum figure total share number without forget\\n        for(int i=1;i<=n;i++) a[i] = mod_add(a[i], a[i-1]); \\n\\t\\t//(3) To minus the total forget number of a[n] by minus a[n-forget]\\n        return mod_add(a[n], -a[n-forget]); \\n    }\\n    int mod_add(int a, int b){\\n        const int MOD=1e9+7;\\n        (a+=MOD)%=MOD; //a= (a+MOD)%MOD \\n        (b+=MOD)%=MOD; //b= (b+MOD)%MOD\\n        return (a+b)%MOD;\\n    }\\n};\\n```\\n\\n# Complexity Analysis\\nTime Compelxity O(n)\\nSpace Complexity O(n)",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> a(n+forget,0);\\n        a[1]=1;\\n\\t\\t//(1) simulate how the a[i] can share to this range [i+delay,i+forget) \\n        for(int i = 1;i<=n;i++) \\n\\t\\t\\tfor(int j = delay; j<forget;j++) \\n                a[i+j] = mod_add(a[i+j], a[i]); \\n\\t\\t//(2) prefix sum figure total share number without forget\\n        for(int i=1;i<=n;i++) a[i] = mod_add(a[i], a[i-1]); \\n\\t\\t//(3) To minus the total forget number of a[n] by minus a[n-forget]\\n        return mod_add(a[n], -a[n-forget]); \\n    }\\n    int mod_add(int a, int b){\\n        const int MOD=1e9+7;\\n        (a+=MOD)%=MOD; //a= (a+MOD)%MOD \\n        (b+=MOD)%=MOD; //b= (b+MOD)%MOD\\n        return (a+b)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233012,
                "title": "using-two-1d-arrays-explanation-and-comments-c-o-n-delay-time-o-2n-space",
                "content": "Every time a person gets told a secret, starting *delay* days after that day and until *forget* days after that day, the person will keep telling the secret to another person.\\nAfter *forget* days after that day, the person will forget the secret themself.\\n\\nThat is, if on Day x the person came to know about the secret.\\n    From the Days [x + *delay*, x + *forget*], here (x + *delay*) is included and (x + *forget*) is not,\\n\\t\\tthe person will tell the secret to a new person.\\n    On the (x + *forget*) day, the person will forget the secret.\\n\\nSo, we can create two 1D arrays (indexed from 0 to (n + 1),) one to track the number of new people who find out about the secret on a particular day and the other to track the number of people who forget the secret on a particular day.\\n\\nLet us call these arrays *toIncrement* and *toDecrement*.\\nWe will track the current number of people in a variable called *currentlyKnownTo* and we will update it as we go through the n days. Whenever a new person finds out about the secret, we have to update the *toIncrement* and *toDecrement* arrays as well.\\n\\n```\\nclass Solution {\\n    #define ll long long int\\n    \\npublic:\\n    // mod for the answer\\n    ll mod = 1e9 + 7;\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        // Declare the two 1D arrays, each of size (n + 1)\\n        vector<ll> toIncrement (n + 1, 0); // the number of new people who find out about the secret on the (i)th day\\n        vector<ll> toDecrement (n + 1, 0); // the number of people who forget the secret on the (i)th day\\n        \\n        // As per the problem: the first person finds out about the secret on Day 1.\\n        toIncrement[1] = 1;\\n        \\n        // To store the number of people who know the secret right now.\\n        ll currentlyKnownTo = 0;\\n        \\n        // Iterate from Day 1 to Day n.\\n        for (int i = 1; i <= n; i++) {\\n            // If one or more new people find out about the secret on this day i.e. the (i)th day, \\n            // we have to update the toIncrement and the toDecrement arrays.\\n            if (toIncrement[i] > 0) { // if some new people find out on this day\\n                // Now, if x new people found out the secret on the (i)th day. Each of these x \\n                // people are gonna share the secret with somebody starting at Day (i + delay) \\n                // and until Day (i + forget).\\n                // So we add x to all the values in the toIncrement array in the above mentioned \\n                // range of days.\\n                // Here, x just means toIncrement[i]\\n                for (int j = i + delay; j < (i + forget) && j <= n; j++) { // (j <= n) is an out-of-bounds check\\n                    toIncrement[j] += toIncrement[i];\\n                    toIncrement[j] = toIncrement[j] % mod;\\n                }\\n                \\n                // Also, each of the people who found out the secret on the (i)th Day are gonna \\n                // forget it on Day (i + forget).\\n                // So we subtract x from toDecrement[i + forget]\\n                if ((i + forget) <= n) { // out-of-bounds check\\n                    toDecrement[i + forget] = toIncrement[i];\\n                    toDecrement[i + forget] = toDecrement[i + forget] % mod;\\n                }\\n            }\\n            \\n            // Increment the current count by the number of new people who found out today.\\n            currentlyKnownTo += toIncrement[i];\\n\\n            // Decrement the current count by the number of new people who forgot today.\\n            currentlyKnownTo -= toDecrement[i];\\n        }\\n        \\n        // return the current count\\n        return currentlyKnownTo % mod;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(n * delay)**\\nIn the worst case, for each Day, we may have to update the *toIncrement* values of *delay* days.\\n\\n**Space Complexity: O(2n)**\\nFor storing the two arrays.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long int\\n    \\npublic:\\n    // mod for the answer\\n    ll mod = 1e9 + 7;\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        // Declare the two 1D arrays, each of size (n + 1)\\n        vector<ll> toIncrement (n + 1, 0); // the number of new people who find out about the secret on the (i)th day\\n        vector<ll> toDecrement (n + 1, 0); // the number of people who forget the secret on the (i)th day\\n        \\n        // As per the problem: the first person finds out about the secret on Day 1.\\n        toIncrement[1] = 1;\\n        \\n        // To store the number of people who know the secret right now.\\n        ll currentlyKnownTo = 0;\\n        \\n        // Iterate from Day 1 to Day n.\\n        for (int i = 1; i <= n; i++) {\\n            // If one or more new people find out about the secret on this day i.e. the (i)th day, \\n            // we have to update the toIncrement and the toDecrement arrays.\\n            if (toIncrement[i] > 0) { // if some new people find out on this day\\n                // Now, if x new people found out the secret on the (i)th day. Each of these x \\n                // people are gonna share the secret with somebody starting at Day (i + delay) \\n                // and until Day (i + forget).\\n                // So we add x to all the values in the toIncrement array in the above mentioned \\n                // range of days.\\n                // Here, x just means toIncrement[i]\\n                for (int j = i + delay; j < (i + forget) && j <= n; j++) { // (j <= n) is an out-of-bounds check\\n                    toIncrement[j] += toIncrement[i];\\n                    toIncrement[j] = toIncrement[j] % mod;\\n                }\\n                \\n                // Also, each of the people who found out the secret on the (i)th Day are gonna \\n                // forget it on Day (i + forget).\\n                // So we subtract x from toDecrement[i + forget]\\n                if ((i + forget) <= n) { // out-of-bounds check\\n                    toDecrement[i + forget] = toIncrement[i];\\n                    toDecrement[i + forget] = toDecrement[i + forget] % mod;\\n                }\\n            }\\n            \\n            // Increment the current count by the number of new people who found out today.\\n            currentlyKnownTo += toIncrement[i];\\n\\n            // Decrement the current count by the number of new people who forgot today.\\n            currentlyKnownTo -= toDecrement[i];\\n        }\\n        \\n        // return the current count\\n        return currentlyKnownTo % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232563,
                "title": "c-easy-to-understand",
                "content": "```\\n#define mod 1000000007\\n    int peopleAwareOfSecret(int n, int dl, int fg) {\\n        vector<int>dp(n+1,0);\\n        dp[0]=0;dp[1]=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=i+dl;j<=n && j<i+fg;j++){\\n                dp[j]=(dp[j]%mod+dp[i]%mod)%mod;\\n            }\\n            if(i+fg<=n)dp[i]=0;\\n        }\\n        int su=0;\\n        for(int i=0;i<=n;i++)su=(su%mod+dp[i]%mod)%mod;\\n        return su;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define mod 1000000007\\n    int peopleAwareOfSecret(int n, int dl, int fg) {\\n        vector<int>dp(n+1,0);\\n        dp[0]=0;dp[1]=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=i+dl;j<=n && j<i+fg;j++){\\n                dp[j]=(dp[j]%mod+dp[i]%mod)%mod;\\n            }\\n            if(i+fg<=n)dp[i]=0;\\n        }\\n        int su=0;\\n        for(int i=0;i<=n;i++)su=(su%mod+dp[i]%mod)%mod;\\n        return su;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2232447,
                "title": "c-simple-solution",
                "content": "```\\n int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n            int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        arr[1]++;\\n        for(int i=1;i<=n;i++){\\n            \\n            if(i-forget>=1)arr[i-forget]=0;\\n            if(i-delay>0){\\n                for(int j=1;j<=i-delay;j++){\\n                    arr[i]=(arr[i]+arr[j])%1000000007;\\n                }\\n            }\\n            \\n        }\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            ans=(ans+arr[i])%1000000007;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n            int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        arr[1]++;\\n        for(int i=1;i<=n;i++){\\n            \\n            if(i-forget>=1)arr[i-forget]=0;\\n            if(i-delay>0){\\n                for(int j=1;j<=i-delay;j++){\\n                    arr[i]=(arr[i]+arr[j])%1000000007;\\n                }\\n            }\\n            \\n        }\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            ans=(ans+arr[i])%1000000007;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2232346,
                "title": "java-easy-to-understand-o-n-tabulated-bottom-up-dp",
                "content": "We build two arrays, waiting and expired.\\nwaiting[i] represents the number of people who are ready to share the secret the ith day onwards\\nexpired[i] represents the number of people who have forgotten the secret on the ith day.\\n\\nWe also have two variables,\\na and w representing total active people and total people waiting respectively.\\n\\nIterate through days 2 to n, and on every day,\\nwe adjust the values of waiting and active people\\n\\nfor active people a:\\nremove people expired on that day\\nadd people who have completed their waiting on that day\\n\\n\\nfor waiting w:\\nremove the people who have completed their waiting on that day\\nadd the new people who have been told the secret today and are going into their waiting period\\n\\nupdate the waiting and expired arrays for the given people\\n\\nThe final answer then is the sum of a and w i.e. total people who know the secret.\\n\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        long[] waiting = new long[n+1];\\n        long[] expired = new long[n+1];\\n        \\n        long mod = (long)1e9+7;\\n        \\n        long a = 0;\\n        long w = 1;\\n        \\n        if(1+delay<=n)\\n        waiting[1+delay]++;\\n        if(1+forget<=n)\\n        expired[1+forget]++;\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            // add new active people\\n            a+=waiting[i]%mod;\\n            a-=expired[i]%mod;\\n            \\n            \\n            \\n            // remove waiting people\\n   \\n            w-=waiting[i]%mod;\\n            \\n            \\n            \\n            // create new offsprings\\n            w+=a%mod;\\n            if(i+delay<=n){\\n                waiting[i+delay]+=a%mod;\\n                \\n            }\\n            // set their expiry date\\n            if(i+forget<=n){\\n                expired[i+forget]+=a%mod;\\n            }\\n        }\\n        \\n        return (int)((a%mod+w%mod)%mod);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        long[] waiting = new long[n+1];\\n        long[] expired = new long[n+1];\\n        \\n        long mod = (long)1e9+7;\\n        \\n        long a = 0;\\n        long w = 1;\\n        \\n        if(1+delay<=n)\\n        waiting[1+delay]++;\\n        if(1+forget<=n)\\n        expired[1+forget]++;\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            // add new active people\\n            a+=waiting[i]%mod;\\n            a-=expired[i]%mod;\\n            \\n            \\n            \\n            // remove waiting people\\n   \\n            w-=waiting[i]%mod;\\n            \\n            \\n            \\n            // create new offsprings\\n            w+=a%mod;\\n            if(i+delay<=n){\\n                waiting[i+delay]+=a%mod;\\n                \\n            }\\n            // set their expiry date\\n            if(i+forget<=n){\\n                expired[i+forget]+=a%mod;\\n            }\\n        }\\n        \\n        return (int)((a%mod+w%mod)%mod);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232264,
                "title": "easy-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\n\\nint peopleAwareOfSecret(int n, int d, int f) {\\n    vi(ll)dp(n);\\n    ++dp[0];\\n    for (ll i = 1;i < n;++i) {\\n        for (ll j = i - d;j > max(-1LL, i - f);--j)\\n            dp[i] = (dp[i] + dp[j]) % mod;\\n    }\\n    ll res=0;\\n    for(ll i=n-1;i>-1;--i){\\n        if(i+f>n-1)\\n            res=(res+dp[i])%mod;\\n        else\\n            break;\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\n\\nint peopleAwareOfSecret(int n, int d, int f) {\\n    vi(ll)dp(n);\\n    ++dp[0];\\n    for (ll i = 1;i < n;++i) {\\n        for (ll j = i - d;j > max(-1LL, i - f);--j)\\n            dp[i] = (dp[i] + dp[j]) % mod;\\n    }\\n    ll res=0;\\n    for(ll i=n-1;i>-1;--i){\\n        if(i+f>n-1)\\n            res=(res+dp[i])%mod;\\n        else\\n            break;\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232249,
                "title": "python-dp-easy-to-understand-o-n",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        New, Propagate, Know = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\\n        New[1], Propagate[1], Know[1] = 1, 0, 1\\n        \\n        for i in range(2, n + 1):\\n            \\n            delay_end = New[i-delay] if i-delay >= 1 else 0\\n            remember_end = New[i-forget] if i-forget >= 1 else 0\\n            \\n            Propagate[i] = Propagate[i-1] + delay_end - remember_end\\n            New[i] = Propagate[i]\\n            Know[i] = Know[i-1] + New[i] - remember_end\\n            \\n        return Know[n] % (10 ** 9 + 7)\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        New, Propagate, Know = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\\n        New[1], Propagate[1], Know[1] = 1, 0, 1\\n        \\n        for i in range(2, n + 1):\\n            \\n            delay_end = New[i-delay] if i-delay >= 1 else 0\\n            remember_end = New[i-forget] if i-forget >= 1 else 0\\n            \\n            Propagate[i] = Propagate[i-1] + delay_end - remember_end\\n            New[i] = Propagate[i]\\n            Know[i] = Know[i-1] + New[i] - remember_end\\n            \\n        return Know[n] % (10 ** 9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231367,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) \\n    {\\n        vector<long long> days(n+1);\\n        days[0]=0;\\n        days[1]=1;\\n        long long mod=1e9+7,cnt=0;\\n        bool f=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            days[i]=days[i-1];\\n            if(i-delay>=0)\\n                days[i]=(days[i]+days[i-delay])%mod;\\n            if(i-forget-1>=0)\\n            {\\n                if(f==0)\\n                {\\n                    days[i]-=days[i-forget]-days[i-forget-1];\\n                    f=1;\\n                }\\n                days[i]-=days[i-forget];\\n                if(days[i]<0)\\n                    days[i]+=mod;\\n            }\\n            \\n            \\n            //cout<<i<<\" \"<<days[i]<<endl;\\n        }\\n        return days[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) \\n    {\\n        vector<long long> days(n+1);\\n        days[0]=0;\\n        days[1]=1;\\n        long long mod=1e9+7,cnt=0;\\n        bool f=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            days[i]=days[i-1];\\n            if(i-delay>=0)\\n                days[i]=(days[i]+days[i-delay])%mod;\\n            if(i-forget-1>=0)\\n            {\\n                if(f==0)\\n                {\\n                    days[i]-=days[i-forget]-days[i-forget-1];\\n                    f=1;\\n                }\\n                days[i]-=days[i-forget];\\n                if(days[i]<0)\\n                    days[i]+=mod;\\n            }\\n            \\n            \\n            //cout<<i<<\" \"<<days[i]<<endl;\\n        }\\n        return days[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2231179,
                "title": "using-priority-queue",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n\\t\\t\\tlong long mod=1e9+7;\\n\\t\\t\\t// day, count\\n\\t\\t\\tpriority_queue<pair<int,long long>,vector<pair<int,long long>>,greater<pair<int,long long>>>readyToShare, readyToExpire;\\n        \\n        long long currentSharing=0;\\n        int i=1;\\n        readyToShare.push({delay+i, 1});\\n        readyToExpire.push({forget+i,1});\\n        for(int i=2;i<=n;i++){\\n            while(readyToExpire.size() && readyToExpire.top().first <= i){\\n                currentSharing=(currentSharing-readyToExpire.top().second+mod)%mod;\\n                readyToExpire.pop();\\n            }\\n            \\n            while(readyToShare.size() && readyToShare.top().first <= i ){\\n                currentSharing =(currentSharing%mod+readyToShare.top().second%mod)%mod;\\n                readyToShare.pop();\\n            }\\n            \\n        // currentSharing=currentSharing*2;    \\n        readyToShare.push({delay+i,currentSharing});\\n        readyToExpire.push({forget+i,currentSharing});\\n            \\n        }\\n        \\n        while(readyToShare.size()){\\n            currentSharing=(currentSharing%mod+readyToShare.top().second%mod)%mod;\\n            readyToShare.pop();\\n        }\\n        return currentSharing;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n\\t\\t\\tlong long mod=1e9+7;\\n\\t\\t\\t// day, count\\n\\t\\t\\tpriority_queue<pair<int,long long>,vector<pair<int,long long>>,greater<pair<int,long long>>>readyToShare, readyToExpire;\\n        \\n        long long currentSharing=0;\\n        int i=1;\\n        readyToShare.push({delay+i, 1}",
                "codeTag": "Java"
            },
            {
                "id": 2231034,
                "title": "easy-memo-recursion",
                "content": "```\\nclass Solution {\\n    int dp[1001];\\n    long long const mod = 1e9 + 7;\\n    \\n    int rec(int currDay,int lastDay,int delay,int forget){\\n        if(currDay > lastDay) return 0;\\n        if(dp[currDay] != -1) return dp[currDay];\\n        \\n        int i = currDay + delay; // just bypass days to know who knows secret\\n        int ans = 0;\\n        for(i ; i < currDay + forget; i++){\\n            int whoKnows = rec(i,lastDay,delay,forget);\\n            ans += whoKnows;\\n            ans %= mod;\\n        }\\n        \\n        //if currUser forgets\\n        if(currDay + forget <= lastDay) return dp[currDay] = ans % mod;\\n        \\n        return dp[currDay] = (1 + ans)%mod;\\n        \\n    }\\n    \\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(1,n,delay,forget);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001];\\n    long long const mod = 1e9 + 7;\\n    \\n    int rec(int currDay,int lastDay,int delay,int forget){\\n        if(currDay > lastDay) return 0;\\n        if(dp[currDay] != -1) return dp[currDay];\\n        \\n        int i = currDay + delay; // just bypass days to know who knows secret\\n        int ans = 0;\\n        for(i ; i < currDay + forget; i++){\\n            int whoKnows = rec(i,lastDay,delay,forget);\\n            ans += whoKnows;\\n            ans %= mod;\\n        }\\n        \\n        //if currUser forgets\\n        if(currDay + forget <= lastDay) return dp[currDay] = ans % mod;\\n        \\n        return dp[currDay] = (1 + ans)%mod;\\n        \\n    }\\n    \\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(1,n,delay,forget);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230973,
                "title": "c-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<ll> memo( n , -1 );\\n        return dfs( 0, n, delay, forget, memo );\\n    }\\nprivate:\\n    using ll = long long;\\n    int _mod{1000000007};\\n    int dfs( int index, int n, int delay, int forget, vector<ll> &memo ){\\n        if( index >= n ){\\n            return 0;\\n        }\\n        if( memo[index] != -1 ){\\n            return memo[index];\\n        }\\n        ll count = index+forget < n ? 0 : 1;\\n        for( int i = index+delay; i < index+forget; i++ ){\\n            count += dfs( i, n, delay, forget, memo )%_mod;\\n            count %= _mod;\\n        }\\n        memo[index] = count;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<ll> memo( n , -1 );\\n        return dfs( 0, n, delay, forget, memo );\\n    }\\nprivate:\\n    using ll = long long;\\n    int _mod{1000000007};\\n    int dfs( int index, int n, int delay, int forget, vector<ll> &memo ){\\n        if( index >= n ){\\n            return 0;\\n        }\\n        if( memo[index] != -1 ){\\n            return memo[index];\\n        }\\n        ll count = index+forget < n ? 0 : 1;\\n        for( int i = index+delay; i < index+forget; i++ ){\\n            count += dfs( i, n, delay, forget, memo )%_mod;\\n            count %= _mod;\\n        }\\n        memo[index] = count;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230770,
                "title": "using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int N = 1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<ll,ll>mp;\\n        mp[1]=1;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+delay;j<i+forget;j++)\\n                mp[j] = (mp[j]+mp[i])%N;\\n        ll ans =0;\\n        for(int i=n;i>n-forget;i--) ans = (ans + mp[i])%N;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int N = 1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<ll,ll>mp;\\n        mp[1]=1;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+delay;j<i+forget;j++)\\n                mp[j] = (mp[j]+mp[i])%N;\\n        ll ans =0;\\n        for(int i=n;i>n-forget;i--) ans = (ans + mp[i])%N;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230538,
                "title": "java-o-n-forget-delay-time-and-o-n-space",
                "content": "\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {        \\n        int[] dp = new int[1001];\\n        int ans =  helper(1,n,delay,forget,dp);\\n        return ans;\\n        \\n    }\\n    int mod = (int)1e9+7;\\n    public int helper(int day,int n,int delay,int forget,int[]dp){\\n        if(dp[day]!=0){\\n            return dp[day];\\n        }\\n        int ans = 0;\\n        int i = delay;\\n        for( ; i<forget && day+i<=n ; i++){\\n            ans = (ans + helper(day+i,n,delay,forget,dp))%mod;\\n        }\\n        dp[day]=ans+1;\\n        if(day+i<=n){\\n            dp[day]-=1;//// beacuse current person will forget \\n        }\\n        return dp[day];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {        \\n        int[] dp = new int[1001];\\n        int ans =  helper(1,n,delay,forget,dp);\\n        return ans;\\n        \\n    }\\n    int mod = (int)1e9+7;\\n    public int helper(int day,int n,int delay,int forget,int[]dp){\\n        if(dp[day]!=0){\\n            return dp[day];\\n        }\\n        int ans = 0;\\n        int i = delay;\\n        for( ; i<forget && day+i<=n ; i++){\\n            ans = (ans + helper(day+i,n,delay,forget,dp))%mod;\\n        }\\n        dp[day]=ans+1;\\n        if(day+i<=n){\\n            dp[day]-=1;//// beacuse current person will forget \\n        }\\n        return dp[day];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230494,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long int> dp(n+1, 0);\\n        int mod = 1e9 + 7;\\n        \\n        for(int i = 1; i<=delay; i++)\\n            dp[i] = 1;\\n        \\n        for(int i = delay+1; i<=n; i++) {\\n            if(i-forget >= 1) { //check if there is a possibility of few people forgetting\\n                int num_of_forgotten = dp[i-forget]; \\n                for(int j = i-forget; j<i; j++) {\\n                    dp[j] = (dp[j] - num_of_forgotten + mod)%mod; // reduce number of forgotten people from every day till i-1 days \\n                }\\n            }\\n            \\n            dp[i] = ((dp[i-delay])%mod + (dp[i-1])%mod)%mod; // At ith day , we will have people who knows at i-1 day + extra people who came to know by people at i-delay days. \\n\\n        }\\n        \\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long int> dp(n+1, 0);\\n        int mod = 1e9 + 7;\\n        \\n        for(int i = 1; i<=delay; i++)\\n            dp[i] = 1;\\n        \\n        for(int i = delay+1; i<=n; i++) {\\n            if(i-forget >= 1) { //check if there is a possibility of few people forgetting\\n                int num_of_forgotten = dp[i-forget]; \\n                for(int j = i-forget; j<i; j++) {\\n                    dp[j] = (dp[j] - num_of_forgotten + mod)%mod; // reduce number of forgotten people from every day till i-1 days \\n                }\\n            }\\n            \\n            dp[i] = ((dp[i-delay])%mod + (dp[i-1])%mod)%mod; // At ith day , we will have people who knows at i-1 day + extra people who came to know by people at i-delay days. \\n\\n        }\\n        \\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230452,
                "title": "c-9-lines-bottom-up-dp-o-n-forget-time-o-forget-space",
                "content": "```\\npublic class Solution \\n{\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) \\n    {\\n        const int MOD = 1_000_000_007;\\n        \\n        long[] dpLastRow = Enumerable.Repeat(0L, forget - 1).Prepend(1L).ToArray();\\n        for (int time = 2; time <= n; ++time) \\n        {\\n            var dpCurrentRow = dpLastRow.SkipLast(1).Prepend(0).ToArray();\\n            \\n            dpCurrentRow[0] = dpLastRow.Skip(delay - 1).SkipLast(1).Sum(x => x) % MOD;\\n            \\n            dpLastRow = dpCurrentRow;\\n        }\\n        return (int)(dpLastRow.Sum() % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) \\n    {\\n        const int MOD = 1_000_000_007;\\n        \\n        long[] dpLastRow = Enumerable.Repeat(0L, forget - 1).Prepend(1L).ToArray();\\n        for (int time = 2; time <= n; ++time) \\n        {\\n            var dpCurrentRow = dpLastRow.SkipLast(1).Prepend(0).ToArray();\\n            \\n            dpCurrentRow[0] = dpLastRow.Skip(delay - 1).SkipLast(1).Sum(x => x) % MOD;\\n            \\n            dpLastRow = dpCurrentRow;\\n        }\\n        return (int)(dpLastRow.Sum() % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230447,
                "title": "c-simple-solution-with-time-complexity-o-n-forget-delay-and-space-complexity-o-n",
                "content": "class Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        typedef long long ll;\\n        vector<ll>newPeopleOnDay(n+1,0);//List of number of NEW people who know the secret on a day\\n        //NEW people means newPeopleOnDay[i] didn\\'t knew secret before day i\\n        //Space complexity O(n)\\n        \\n        const ll m=(ll)(1e9)+7;\\n        newPeopleOnDay[1]=1;//On first day 1 person knows secret\\n        for(int i=2;i<=n;++i){ //from 2nd to nth day\\n            /*People who didn\\'t forget are from days greater than current day - forget\\n              so, loop from people who didn\\'t forget till previous day of current day\\n              current day = i\\n              As at start i-forget+1 can be negative so take max of (1,i-forget+1) as days start from 1\\n              \\n              so iterate from j=max(1,i-forget+1) to i-1\\n              \\n              Also,\\n              Only those people who satisfy the delay will say the secret to other people\\n              so other condition on loop is the difference between the current day and the day which the\\n              new person knew about the secret \\n              \\n              i-j >=delay\\n            */\\n            for(int j=max(1,i-forget+1);(i-j)>=delay;++j){\\n                newPeopleOnDay[i]+=newPeopleOnDay[j];\\n                //This loop runs from j=max(1,i-forget+1) to (i-j)>=delay\\n                // i-delay >= j >= i-forget+1\\n                // no of times the inner loop runs in worst case for one day is\\n                // i-delay -(i-forget+1) == forget - delay+1\\n                // so O(forget - delay)\\n                //so for n days O(n*(forget - delay))\\n            }\\n            newPeopleOnDay[i]%=m;\\n        }\\n        ll res=0;\\n        //Finally add those who didn\\'t forget till the last day\\n        for(int i=n-forget+1;i<=n;++i){\\n            res+=newPeopleOnDay[i];\\n        }\\n        return (int)(res%m);\\n        //Time complexity O(n*(forget - delay))\\n        //Space complexity O(n)\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        typedef long long ll;\\n        vector<ll>newPeopleOnDay(n+1,0);//List of number of NEW people who know the secret on a day\\n        //NEW people means newPeopleOnDay[i] didn\\'t knew secret before day i\\n        //Space complexity O(n)\\n        \\n        const ll m=(ll)(1e9)+7;\\n        newPeopleOnDay[1]=1;//On first day 1 person knows secret\\n        for(int i=2;i<=n;++i){ //from 2nd to nth day\\n            /*People who didn\\'t forget are from days greater than current day - forget\\n              so, loop from people who didn\\'t forget till previous day of current day\\n              current day = i\\n              As at start i-forget+1 can be negative so take max of (1,i-forget+1) as days start from 1\\n              \\n              so iterate from j=max(1,i-forget+1) to i-1\\n              \\n              Also,\\n              Only those people who satisfy the delay will say the secret to other people\\n              so other condition on loop is the difference between the current day and the day which the\\n              new person knew about the secret \\n              \\n              i-j >=delay\\n            */\\n            for(int j=max(1,i-forget+1);(i-j)>=delay;++j){\\n                newPeopleOnDay[i]+=newPeopleOnDay[j];\\n                //This loop runs from j=max(1,i-forget+1) to (i-j)>=delay\\n                // i-delay >= j >= i-forget+1\\n                // no of times the inner loop runs in worst case for one day is\\n                // i-delay -(i-forget+1) == forget - delay+1\\n                // so O(forget - delay)\\n                //so for n days O(n*(forget - delay))\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2230278,
                "title": "c-recursion-memoization-with-explanation",
                "content": "**Intution**\\n-> solve for the first guy and for next guy the function will calculate :)\\n->Iterate through given period and if the forget day comes e cant spread the secrete so come out of the loop\\n->If you are in the day which is after delay we can calculate for the next guy who now knows the secrete\\n\\n**The code**\\n```\\nclass Solution {\\npublic:\\n   int mod = 1000000007;\\n    int solve(int s,int f,int d,int n,vector<int>& dp){\\n        if(dp[s] != -1){\\n            return dp[s];\\n        }\\n        int ans =0;\\n        for(int i = s;i<= n;i++){\\n            if(i-s == f){\\n                ans = ans-1;\\n                break;\\n            }\\n            if(i-s>= d){\\n                ans = (ans+1)%mod;\\n                ans += solve(i,f,d,n,dp)%mod;\\n            }\\n        }\\n        \\n        return dp[s] = ans;\\n        \\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       vector<int> dp(n+1,-1);\\n        return (solve(1,forget,delay,n,dp)+1)%mod;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n   int mod = 1000000007;\\n    int solve(int s,int f,int d,int n,vector<int>& dp){\\n        if(dp[s] != -1){\\n            return dp[s];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2230239,
                "title": "c-easy-dynamic-programming-o-n-space-o-n-forget-time",
                "content": "**Intution**\\n\\nFor every day if we know how many peoples know the secret we can tell how many people will know next day.\\n\\n**Explanation**\\n\\n1. keep and array for count of people knowing secret at the end of ```i\\'th``` day.\\n2. for every ```i\\'th``` day count the number of people upto ```i-forget``` days.\\n3. each day there will be double the number of peoples who knows the secret.\\n4. at last count the number of peoples who knows the secret till ```n-forget``` days.\\n\\n```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int total_people;\\n        vector<long long> dp(n+1, 0);\\n        dp[1] = 1;\\n        for(int i=delay+1; i<=n; i++){\\n            total_people = 0;\\n            for(int j=i-delay; j>max(0, i-forget); j--) total_people = (total_people%mod + dp[j]%mod)%mod;\\n            dp[i] = total_people;\\n        }\\n        total_people = 0;\\n        for(int i=n; i>n-forget; i--) total_people = (total_people%mod + dp[i]%mod)%mod;\\n        return total_people;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```i\\'th```\n```i\\'th```\n```i-forget```\n```n-forget```\n```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int total_people;\\n        vector<long long> dp(n+1, 0);\\n        dp[1] = 1;\\n        for(int i=delay+1; i<=n; i++){\\n            total_people = 0;\\n            for(int j=i-delay; j>max(0, i-forget); j--) total_people = (total_people%mod + dp[j]%mod)%mod;\\n            dp[i] = total_people;\\n        }\\n        total_people = 0;\\n        for(int i=n; i>n-forget; i--) total_people = (total_people%mod + dp[i]%mod)%mod;\\n        return total_people;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230233,
                "title": "c-with-explanation-easy-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        for example:\\n        10 days   -   forget: 5 days,   delay: 2 days\\n        \\n        start after \\'|\\' all of people can share the secret, \\n        they will forget the secret when they are out of the vector.\\n        \\n        every day all of the elements in the vector move to right 1,\\n        then add the number of people that just got the secret into the most left side of the vector\\n        \\n        [1 0 | 0 0 0]  total number of people can share: 0\\n        [0 1 | 0 0 0]  total number of people can share: 0\\n        [1 0 | 1 0 0]  total number of people can share: 1\\n        [1 1 | 0 1 0]  total number of people can share: 1\\n        [2 1 | 1 0 1]  total number of people can share: 2\\n        \\n        [2 2 | 1 1 0]  total number of people can share: 2\\n        [4 2 | 2 1 1]  total number of people can share: 4\\n        [5 4 | 2 2 1]  total number of people can share: 5\\n        [8 5 | 4 2 2]  total number of people can share: 8\\n        [11 8| 5 4 2]  total number of people can share: 11\\n        \\n        after 10 days;\\n        there are totally 30 people know the secret\\n    */\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1e9 + 7;\\n        \\n        vector<long long> days(forget, 0);\\n        days[0] = 1;\\n        long long share = 0;    // totol number of people that can share\\n        \\n        \\n        // [1 0 1 | 0 0]\\n        for (int day = 1; day < n; ++day) {\\n            // add mod, to make sure the share is positive\\n            // total people - people who forget + people who can share\\n            share = (share - days[forget - 1] + days[delay - 1] + mod) % mod;\\n            days.insert(days.begin(), share);\\n            days.pop_back();\\n        }\\n        \\n        long long res = 0;\\n        for (int i : days) {\\n            res = (res + i) % mod;\\n        }\\n        \\n        return (int)res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        for example:\\n        10 days   -   forget: 5 days,   delay: 2 days\\n        \\n        start after \\'|\\' all of people can share the secret, \\n        they will forget the secret when they are out of the vector.\\n        \\n        every day all of the elements in the vector move to right 1,\\n        then add the number of people that just got the secret into the most left side of the vector\\n        \\n        [1 0 | 0 0 0]  total number of people can share: 0\\n        [0 1 | 0 0 0]  total number of people can share: 0\\n        [1 0 | 1 0 0]  total number of people can share: 1\\n        [1 1 | 0 1 0]  total number of people can share: 1\\n        [2 1 | 1 0 1]  total number of people can share: 2\\n        \\n        [2 2 | 1 1 0]  total number of people can share: 2\\n        [4 2 | 2 1 1]  total number of people can share: 4\\n        [5 4 | 2 2 1]  total number of people can share: 5\\n        [8 5 | 4 2 2]  total number of people can share: 8\\n        [11 8| 5 4 2]  total number of people can share: 11\\n        \\n        after 10 days;\\n        there are totally 30 people know the secret\\n    */\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1e9 + 7;\\n        \\n        vector<long long> days(forget, 0);\\n        days[0] = 1;\\n        long long share = 0;    // totol number of people that can share\\n        \\n        \\n        // [1 0 1 | 0 0]\\n        for (int day = 1; day < n; ++day) {\\n            // add mod, to make sure the share is positive\\n            // total people - people who forget + people who can share\\n            share = (share - days[forget - 1] + days[delay - 1] + mod) % mod;\\n            days.insert(days.begin(), share);\\n            days.pop_back();\\n        }\\n        \\n        long long res = 0;\\n        for (int i : days) {\\n            res = (res + i) % mod;\\n        }\\n        \\n        return (int)res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230193,
                "title": "bottom-up-dp-solution-with-explanation-c",
                "content": "For each person we have delay and forget time. Between which the person will share it with others.\\nLets call it gossip time. And we have to fund number of people that knows the secret on the nth day.\\n\\nNow, we can write a function for a person and it\\'s known time and find what other people will get the information from this secret.  And when we reach the nth day, that will be our base case.\\n\\nThis solution will be exponential. We can convert it into dp.\\n\\nSo for each person, we will have it\\'s current time. \\n\\nUse 2D dp where dp[i][j] will represent the number of persons on ith day that knows the secret for j days till now.\\nThen for next day we know that for all persons with current j < forget time on prev day, they will know the secret on current day also but with j + 1 knowing time.\\n-> dp[i][j] = dp[i - 1][j - 1]\\nAlso each person from delay to forget time will tell one other person.\\n-> dp[i][1] += dp[i][j] for all j -> delay to forget - 1\\n\\n```\\nclass Solution {\\npublic:\\n\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n\\t\\tvector<vector<int>> dp(n + 1, vector<int> (n + 1));\\n\\t\\tdp[1][1] = 1;\\n\\t\\tint mod = 1000000007;\\n\\t\\tfor(int i = 2; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 1; j < min(forget, n); j++)\\n\\t\\t\\t\\tdp[i][j + 1] = dp[i - 1][j];\\n\\t\\t\\tfor(int j = delay; j < forget; j++)\\n\\t\\t\\t\\tdp[i][1] = (dp[i][1] + dp[i - 1][j]) % mod;\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\tans = (ans + dp[n][i]) % mod;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\nCan do space optimazition by storing just prev and cur array",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n\\t\\tvector<vector<int>> dp(n + 1, vector<int> (n + 1));\\n\\t\\tdp[1][1] = 1;\\n\\t\\tint mod = 1000000007;\\n\\t\\tfor(int i = 2; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 1; j < min(forget, n); j++)\\n\\t\\t\\t\\tdp[i][j + 1] = dp[i - 1][j];\\n\\t\\t\\tfor(int j = delay; j < forget; j++)\\n\\t\\t\\t\\tdp[i][1] = (dp[i][1] + dp[i - 1][j]) % mod;\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\tans = (ans + dp[n][i]) % mod;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230170,
                "title": "c-beats-100",
                "content": "**Similira to:** https://leetcode.com/problems/meeting-rooms-ii/discuss/2135429/four-cpp-methods\\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<long long int, long long int> tell;\\n        unordered_map<long long int, long long int> forg;\\n        \\n        tell[1+delay] = 1;\\n        forg[1+forget] = 1;\\n        \\n        long long int curr_spread = 0; \\n        long long int ans = 0;\\n        for(int i = 1 + delay; i <= n; ++ i){\\n\\t\\t\\t// curr_spread represents the number of people who are eligible to tell the secrets on day i\\n            curr_spread += tell[i] % (1000000000 + 7); // people who are able to **start** to tell secrets on day i\\n            curr_spread -= forg[i] % (1000000000 + 7); // people who will forget and **end** to tell secrete on day i\\n\\t\\t\\t\\n\\t\\t\\t// update the people who know the secret at day i\\n            tell[i + delay] += curr_spread; // these new people can tell others on day \"i + delay\"\\n            forg[i + forget] += curr_spread;   // these new people will forget secret on day \"i + forget\"\\n        }\\n        \\n\\t\\t// only need to calculate the number of people who forget the secret after day n\\n        for(auto& it: forg){\\n            if(it.first > n) ans += it.second;\\n        }\\n\\n        return ans % (1000000000 + 7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<long long int, long long int> tell;\\n        unordered_map<long long int, long long int> forg;\\n        \\n        tell[1+delay] = 1;\\n        forg[1+forget] = 1;\\n        \\n        long long int curr_spread = 0; \\n        long long int ans = 0;\\n        for(int i = 1 + delay; i <= n; ++ i){\\n\\t\\t\\t// curr_spread represents the number of people who are eligible to tell the secrets on day i\\n            curr_spread += tell[i] % (1000000000 + 7); // people who are able to **start** to tell secrets on day i\\n            curr_spread -= forg[i] % (1000000000 + 7); // people who will forget and **end** to tell secrete on day i\\n\\t\\t\\t\\n\\t\\t\\t// update the people who know the secret at day i\\n            tell[i + delay] += curr_spread; // these new people can tell others on day \"i + delay\"\\n            forg[i + forget] += curr_spread;   // these new people will forget secret on day \"i + forget\"\\n        }\\n        \\n\\t\\t// only need to calculate the number of people who forget the secret after day n\\n        for(auto& it: forg){\\n            if(it.first > n) ans += it.second;\\n        }\\n\\n        return ans % (1000000000 + 7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230106,
                "title": "java-no-dp-using-2-queues-with-explaination",
                "content": "This problem can easily be solved without using DP and just by using 2 queue data structures.\\n\\nFirstly, we can create a queue which will store the value of day on which new secret holders will be able to share the secret (d) and another queue which will store the day on which some people who know the secret will forget about it (f).\\nOn arriving on those days the queue will be updated as follows :-\\n1) on arriving on the day when new secret holders will be able to share the secret, we will increase the variable share.\\n2) on arriving on the day when some secret holders will forget about the secret, we will decrease share as well as know variables.\\n\\nWe will also create 2 variables which will store the number of people who are able to share the secret(share) and the number of people who know the secret (know).\\n\\n```\\nclass Solution {\\n    class Pair{\\n        int first;\\n        long second;\\n        Pair(int f,long s){\\n            first = f;\\n            second = s;\\n        }\\n    }\\n    private final int MOD = 1000000007;\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        Queue<Pair> d = new ArrayDeque<>();\\n        Queue<Pair> f = new ArrayDeque<>();\\n        long know=1,share=0;\\n        d.add(new Pair(1+delay,1));\\n        f.add(new Pair(1+forget,1));\\n        for(int i=2;i<=n;i++){\\n            if(!d.isEmpty()&&d.peek().first==i){\\n                share+=(d.poll().second%MOD);\\n            }\\n            if(!f.isEmpty()&&f.peek().first==i){\\n                share-=f.peek().second%MOD;\\n                know-=f.poll().second%MOD;\\n            }\\n            // System.out.println(share);\\n            know = (know+share)%MOD;\\n            know %= MOD;\\n            d.add(new Pair(i+delay,share));\\n            f.add(new Pair(i+forget,share));\\n        }\\n        // System.out.println(know);\\n        return (int)(know%MOD);\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int first;\\n        long second;\\n        Pair(int f,long s){\\n            first = f;\\n            second = s;\\n        }\\n    }\\n    private final int MOD = 1000000007;\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        Queue<Pair> d = new ArrayDeque<>();\\n        Queue<Pair> f = new ArrayDeque<>();\\n        long know=1,share=0;\\n        d.add(new Pair(1+delay,1));\\n        f.add(new Pair(1+forget,1));\\n        for(int i=2;i<=n;i++){\\n            if(!d.isEmpty()&&d.peek().first==i){\\n                share+=(d.poll().second%MOD);\\n            }\\n            if(!f.isEmpty()&&f.peek().first==i){\\n                share-=f.peek().second%MOD;\\n                know-=f.poll().second%MOD;\\n            }\\n            // System.out.println(share);\\n            know = (know+share)%MOD;\\n            know %= MOD;\\n            d.add(new Pair(i+delay,share));\\n            f.add(new Pair(i+forget,share));\\n        }\\n        // System.out.println(know);\\n        return (int)(know%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230099,
                "title": "most-straightforward-thinking-but-overflow",
                "content": "Is there a fault with my base logic or is it just failing due to incorrect mod operations?\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[] day = new long[n];\\n        long mod = 1000000007L;\\n        for(int i=0; i<delay; i++) day[i] = 1;\\n        for(int i=delay; i<n; i++) {\\n            if(i-forget>=0){\\n                for(int j=i-1; j>=i-forget; j--){\\n                   day[j] = day[j]-day[i-forget]; // forgetting\\n                }\\n            }\\n            day[i] = ((day[i-1]%mod) + (day[i-delay]%mod))%mod; //sharing\\n        }\\n        \\n        return (int)(day[n-1]%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[] day = new long[n];\\n        long mod = 1000000007L;\\n        for(int i=0; i<delay; i++) day[i] = 1;\\n        for(int i=delay; i<n; i++) {\\n            if(i-forget>=0){\\n                for(int j=i-1; j>=i-forget; j--){\\n                   day[j] = day[j]-day[i-forget]; // forgetting\\n                }\\n            }\\n            day[i] = ((day[i-1]%mod) + (day[i-delay]%mod))%mod; //sharing\\n        }\\n        \\n        return (int)(day[n-1]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230023,
                "title": "c-easy-dp-soln",
                "content": "Here we have to do what is said... ie simulate the process using dp\\nFor example the first person can told the secret after delay time and tell the secrets until he forgets so we can simply simulate this...\\ndp[i] represent the i th day how many people know our secrets \\nso we the dp[i] people can tell more dp[i] people to the j th day where i<j \\n\\nTime Complexity :- O(n\\\\*n) \\n\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>dp(n+1,0);\\n        int mod=1e9+7;\\n\\t\\t\\n\\t\\t// first day only one people know the secret\\n        dp[1]=1;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=i+delay;j<i+forget&&j<=n;j++)\\n            {\\n                dp[j]+=dp[i];\\n                dp[j]%=mod;\\n            }\\n        }\\n        long long ans=0;\\n\\t\\t\\n        for(int i=n-forget+1;i<=n;i++)\\n        {\\n\\t\\t\\n            ans+=dp[i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>dp(n+1,0);\\n        int mod=1e9+7;\\n\\t\\t\\n\\t\\t// first day only one people know the secret\\n        dp[1]=1;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=i+delay;j<i+forget&&j<=n;j++)\\n            {\\n                dp[j]+=dp[i];\\n                dp[j]%=mod;\\n            }\\n        }\\n        long long ans=0;\\n\\t\\t\\n        for(int i=n-forget+1;i<=n;i++)\\n        {\\n\\t\\t\\n            ans+=dp[i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229990,
                "title": "dynamic-programming",
                "content": "class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[]=new long[n];\\n        dp[0]=1;\\n        long sum=0,f=0;\\n        // dp array tell number of new people who know the secret\\n        for(int i=0;i<n;i++){\\n            for(int j=i+delay;j<i+forget;j++){\\n                if(j<n)\\n                    dp[j]=(dp[j]+dp[i])%1000000007;\\n            }\\n            // if its forget index is present within the range then remember to forget the new people\\n            if(dp[i]!=0 && i+forget<n){\\n                dp[i]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            sum+=dp[i];\\n        \\n        return (int)((sum)%1000000007);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[]=new long[n];\\n        dp[0]=1;\\n        long sum=0,f=0;\\n        // dp array tell number of new people who know the secret\\n        for(int i=0;i<n;i++){\\n            for(int j=i+delay;j<i+forget;j++){\\n                if(j<n)\\n                    dp[j]=(dp[j]+dp[i])%1000000007;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2229974,
                "title": "very-intutive-cpp-recursive-solution",
                "content": "Do **upvote** if you find it helpful :)\\n\\nVisualize this question as: Given a **binary** tree which is increasing every day and nodes have certain life. You have to find the **number of leaves present at nth day**.\\n\\nI will use dp to solve this using 2 states:\\n\\t1. Current day\\n\\t2. Remaining life of current node.\\n\\n**Base case:**\\n\\t1. If current day is **more** than nth day and remaining time of current node is greater than or equal to 0, that means that node **was present on nth day**. Hence we return 1.\\n\\t2. Otherwise if remaining time is less than or equal to 0 it means that particular node is **destroyed before nth day**, Hence we return 0. \\n\\nRecursive Call:\\nint ans=dfs(curr+delay,forget-delay,n) // New node from current node.\\nans+=dfs(curr+1,remaining-1,n) // current node on next level\\n\\nLet\\'s say **generation** day of any node is **d** so we are skipping days from **d to d+delay** as It **can\\'t produce any further nodes** in this duration So we don\\'t need to consider those days. Also this will make our solution faster and will also reduce dp state.\\n\\nCode-\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll mod=1000000007;\\n    ll forg;ll del;\\n    ll dp[1001][1001];\\n    ll dfs(ll curr,ll rem,ll n){\\n        if(curr>n){\\n            if(rem<0)return 0;\\n            return 1;\\n        }\\n        if(rem<=0)return 0;\\n        if(dp[curr][rem]!=-1)return dp[curr][rem];\\n        ll ans=0;\\n        ans=(ans+dfs(curr+del,forg-del,n))%mod;\\n        ans=(ans+dfs(curr+1,rem-1,n))%mod;\\n        ans%=mod;\\n        return dp[curr][rem]=ans;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        forg=forget;del=delay;\\n        memset(dp,-1,sizeof(dp));\\n        ll ans=dfs(1+delay,forget-(delay),n);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll mod=1000000007;\\n    ll forg;ll del;\\n    ll dp[1001][1001];\\n    ll dfs(ll curr,ll rem,ll n){\\n        if(curr>n){\\n            if(rem<0)return 0;\\n            return 1;\\n        }\\n        if(rem<=0)return 0;\\n        if(dp[curr][rem]!=-1)return dp[curr][rem];\\n        ll ans=0;\\n        ans=(ans+dfs(curr+del,forg-del,n))%mod;\\n        ans=(ans+dfs(curr+1,rem-1,n))%mod;\\n        ans%=mod;\\n        return dp[curr][rem]=ans;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        forg=forget;del=delay;\\n        memset(dp,-1,sizeof(dp));\\n        ll ans=dfs(1+delay,forget-(delay),n);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229946,
                "title": "c-dp-window-sum",
                "content": "**Algorithm**\\nLet dp[i] be the number of people who learn the secret on day i. Then, \\ndp[1] = 1\\ndp[i] = sum(dp[i-forget+1...dp[i-delay]])\\nReturn sum(dp[n-forget+1...])\\nThe calculation can be carried out via a rolling sum which constantly remove dp[i-forget] and add dp[i-delay] in each operation. \\n\\n**Complexity**\\n* O(N) time \\n* O(N) space \\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int MOD = 1\\'000\\'000\\'007; \\n        vector<long long> dp(n+1, 0); dp[1] = 1; \\n        long long prefix = 0; \\n        for (int i = 2; i <= n; ++i) {\\n            if (i >= delay) prefix = (prefix + dp[i-delay]) % MOD; \\n            if (i >= forget) prefix = (prefix - dp[i-forget]) % MOD; \\n            dp[i] = prefix; \\n        }\\n        long long ans = 0; \\n        for (int i = n-forget+1; i <= n; ++i) ans = (ans + dp[i]) % MOD; \\n        return (MOD + ans) % MOD; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int MOD = 1\\'000\\'000\\'007; \\n        vector<long long> dp(n+1, 0); dp[1] = 1; \\n        long long prefix = 0; \\n        for (int i = 2; i <= n; ++i) {\\n            if (i >= delay) prefix = (prefix + dp[i-delay]) % MOD; \\n            if (i >= forget) prefix = (prefix - dp[i-forget]) % MOD; \\n            dp[i] = prefix; \\n        }\\n        long long ans = 0; \\n        for (int i = n-forget+1; i <= n; ++i) ans = (ans + dp[i]) % MOD; \\n        return (MOD + ans) % MOD; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229909,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod=1e9+7;\\n        vector<long> v(n+1,0l);\\n        v[1]=1l;\\n        for(int i=2; i<=n; i++){\\n            if(i>forget)\\n                v[i-forget]=0;\\n            for(int j=1; j<=i-delay; j++){\\n                v[i]=(v[i]%mod+v[j]%mod)%mod;\\n            }\\n        }\\n        return accumulate(v.begin(),v.end(),0l)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod=1e9+7;\\n        vector<long> v(n+1,0l);\\n        v[1]=1l;\\n        for(int i=2; i<=n; i++){\\n            if(i>forget)\\n                v[i-forget]=0;\\n            for(int j=1; j<=i-delay; j++){\\n                v[i]=(v[i]%mod+v[j]%mod)%mod;\\n            }\\n        }\\n        return accumulate(v.begin(),v.end(),0l)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229878,
                "title": "c-queue-easy",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long mod = 1e9 + 7, know = 0, wait = 1;\\n        queue<pair<long long, long long>> delayq, forgetq;\\n        delayq.push({delay + 1, 1});\\n        forgetq.push({forget + 1, 1});\\n        for(int i = delay + 1; i <= n; i++) {\\n            if(!forgetq.empty() and forgetq.front().first == i) {\\n                auto [_, c] =  forgetq.front(); forgetq.pop();\\n                know = (know - c + mod) % mod;\\n            }\\n            if(!delayq.empty() and delayq.front().first == i) {\\n                auto [_, c] = delayq.front(); delayq.pop();\\n                wait = (wait - c + mod) % mod;\\n                know = (know + c) % mod;\\n            }\\n            if(know) {\\n                delayq.push({i + delay, know});\\n                forgetq.push({i + forget, know});\\n                wait = (wait + know) % mod;\\n            }\\n        }\\n        return (know + wait) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long mod = 1e9 + 7, know = 0, wait = 1;\\n        queue<pair<long long, long long>> delayq, forgetq;\\n        delayq.push({delay + 1, 1});\\n        forgetq.push({forget + 1, 1});\\n        for(int i = delay + 1; i <= n; i++) {\\n            if(!forgetq.empty() and forgetq.front().first == i) {\\n                auto [_, c] =  forgetq.front(); forgetq.pop();\\n                know = (know - c + mod) % mod;\\n            }\\n            if(!delayq.empty() and delayq.front().first == i) {\\n                auto [_, c] = delayq.front(); delayq.pop();\\n                wait = (wait - c + mod) % mod;\\n                know = (know + c) % mod;\\n            }\\n            if(know) {\\n                delayq.push({i + delay, know});\\n                forgetq.push({i + forget, know});\\n                wait = (wait + know) % mod;\\n            }\\n        }\\n        return (know + wait) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080861,
                "title": "annotated-rust-solution-8-lines",
                "content": "\\n\\n# Approach\\nKeep track of how many people learn the secret on each day using the results from previous days\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst MOD: u64 = 1_000_000_007; // 10^9 + 7\\n\\n\\nimpl Solution {\\n    pub fn people_aware_of_secret(n: i32, delay: i32, forget: i32) -> i32 {\\n   \\n        // First convert all parameters to `usize` because in this algorithm, they are all used as\\n        // slice indices. I Don\\'t know why leetcode problem authors insist on i32 interface\\n        let (n, delay, forget) = (n as usize, delay as usize, forget as usize);\\n\\n        // Use an array to keep track of how many people learn the secret on each day. log[x] is the\\n        // number of people who learned the secret on day x (staring from 0)\\n        let mut log = [0; 1000];\\n\\n        // on the first day, 1 person learns the secret; as per the problem statement\\n        log[0] = 1;\\n\\n        // for each subsequent day, calculate the number of people who learned the secret on that day\\n        // and store the result at the appropriate index of `log`\\n        for i in 1..n {\\n            // The number of people who learn the secret on day `i` is the sum of number of people who\\n            // learned the secret on days between `i - forget + 1` and `i - delay + 1`\\n            let window = i.saturating_sub(forget - 1)..i.saturating_sub(delay - 1);\\n            // Modular arithmetic is used to calculate this sum to avoid overflow.\\n            log[i] = log[window].iter().fold(0, |acc, x| acc + x % MOD);\\n        }\\n        // the total number of people who are aware of the secret on day n is sum of the people who\\n        // learned the secret on the last `forget` days\\n        (log[(n-forget)..].iter().sum::<u64>() % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD: u64 = 1_000_000_007; // 10^9 + 7\\n\\n\\nimpl Solution {\\n    pub fn people_aware_of_secret(n: i32, delay: i32, forget: i32) -> i32 {\\n   \\n        // First convert all parameters to `usize` because in this algorithm, they are all used as\\n        // slice indices. I Don\\'t know why leetcode problem authors insist on i32 interface\\n        let (n, delay, forget) = (n as usize, delay as usize, forget as usize);\\n\\n        // Use an array to keep track of how many people learn the secret on each day. log[x] is the\\n        // number of people who learned the secret on day x (staring from 0)\\n        let mut log = [0; 1000];\\n\\n        // on the first day, 1 person learns the secret; as per the problem statement\\n        log[0] = 1;\\n\\n        // for each subsequent day, calculate the number of people who learned the secret on that day\\n        // and store the result at the appropriate index of `log`\\n        for i in 1..n {\\n            // The number of people who learn the secret on day `i` is the sum of number of people who\\n            // learned the secret on days between `i - forget + 1` and `i - delay + 1`\\n            let window = i.saturating_sub(forget - 1)..i.saturating_sub(delay - 1);\\n            // Modular arithmetic is used to calculate this sum to avoid overflow.\\n            log[i] = log[window].iter().fold(0, |acc, x| acc + x % MOD);\\n        }\\n        // the total number of people who are aware of the secret on day n is sum of the people who\\n        // learned the secret on the last `forget` days\\n        (log[(n-forget)..].iter().sum::<u64>() % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034558,
                "title": "typescript-dp-solution-clean-and-fast-64ms-code-o-n",
                "content": "# Approach\\n1. How many people aware of a secret at the end of day $i$?\\nThis is the number of people who knew the secret on the previous day (e.g. $i-1$) **plus** those who aware of the secret on day $i$ **minus** those who forgot the secret on day $i$.\\n2. How many people forgot the secret on day $i$?\\nThis is the number that learned the secret $forget$ days ago.\\n$forget(i)=aware(i-forget)$\\n\\n$people(i)=people(i-1)+aware(i)-forget(i)=people(i-1)+aware(i)-aware(i-forget)$\\n\\n3. How many people learned the secret on day $i$?\\nThis is the number of people who learned the secret $delay$ days ago plus $delay+1$ day ago, and so on until they forget it.\\n$aware(i)=\\\\displaystyle\\\\sum_{j=i-forget+1}^{i-delay}aware(j)$\\nor, in other word, this is the number of people who learned the secret previous day **plus** those who learned it $delay$ days ago **minus** those who forget it.\\n\\n$aware(i)=aware(i-1)+aware(i-delay)-aware(i-forget)$\\n\\n\\n# Complexity\\n- Time complexity: $\\\\mathcal{O}(n)$\\n- Space complexity: ${mathcal{O}(n)}$\\n\\n# Code\\n```\\nfunction peopleAwareOfSecret(n: number, delay: number, forget: number): number {\\n    const MOD = 1e9 + 7, aware = Array(n + forget - delay).fill(0);\\n    aware[forget - delay] = 1; aware[forget] = 1;\\n    let r = 2;\\n    for (let i = forget + 1; i < n - delay + forget; i++)\\n        aware[i] = (MOD + aware[i - 1] + aware[i - delay] - aware[i - forget]) % MOD,\\n            r = (MOD + r + aware[i] - aware[i - forget]) % MOD;\\n    return r;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```\\nfunction peopleAwareOfSecret(n: number, delay: number, forget: number): number {\\n    const MOD = 1e9 + 7, aware = Array(n + forget - delay).fill(0);\\n    aware[forget - delay] = 1; aware[forget] = 1;\\n    let r = 2;\\n    for (let i = forget + 1; i < n - delay + forget; i++)\\n        aware[i] = (MOD + aware[i - 1] + aware[i - delay] - aware[i - forget]) % MOD,\\n            r = (MOD + r + aware[i] - aware[i - forget]) % MOD;\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004508,
                "title": "c-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long mod = 1e9+7;\\n        vector<long long> newman(n+1,0);\\n        vector<long long> active(n+1,0);\\n        newman[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            active[i]=((active[i-1]+(i-delay>0 ? newman[i-delay] : 0))%mod-(i-forget>0 ? newman[i-forget] : 0)+mod)%mod;\\n            newman[i]=active[i];\\n        }\\n        long long c=active[n],x=delay-1;\\n        while(x>=0)\\n        {\\n            c+=n-x ? newman[n-x] : 0;\\n            x--;\\n        }\\n        c%=mod;\\n        return int(c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long mod = 1e9+7;\\n        vector<long long> newman(n+1,0);\\n        vector<long long> active(n+1,0);\\n        newman[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            active[i]=((active[i-1]+(i-delay>0 ? newman[i-delay] : 0))%mod-(i-forget>0 ? newman[i-forget] : 0)+mod)%mod;\\n            newman[i]=active[i];\\n        }\\n        long long c=active[n],x=delay-1;\\n        while(x>=0)\\n        {\\n            c+=n-x ? newman[n-x] : 0;\\n            x--;\\n        }\\n        c%=mod;\\n        return int(c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952984,
                "title": "hashmap-solution",
                "content": "In classic leetcode fashion the hardest part was the modular arithmetic\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nconst MOD: i32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn people_aware_of_secret(n: i32, delay: i32, forget: i32) -> i32 {\\n        let mut people = 1;\\n        let mut growth = 0;\\n        let mut counts = HashMap::new();\\n        counts.insert(0, 1);\\n        for i in delay..n {\\n            if let Some(count) = counts.get(&(i - delay)) {\\n                growth += count;\\n                growth %= MOD;\\n            }\\n            if let Some(count) = counts.remove(&(i - forget)) {\\n                growth = (growth + MOD - count) % MOD;\\n                people = (people + MOD - count) % MOD;\\n            }\\n            counts.insert(i, growth);\\n            people += growth;\\n            people %= MOD;\\n        }\\n        people\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nconst MOD: i32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn people_aware_of_secret(n: i32, delay: i32, forget: i32) -> i32 {\\n        let mut people = 1;\\n        let mut growth = 0;\\n        let mut counts = HashMap::new();\\n        counts.insert(0, 1);\\n        for i in delay..n {\\n            if let Some(count) = counts.get(&(i - delay)) {\\n                growth += count;\\n                growth %= MOD;\\n            }\\n            if let Some(count) = counts.remove(&(i - forget)) {\\n                growth = (growth + MOD - count) % MOD;\\n                people = (people + MOD - count) % MOD;\\n            }\\n            counts.insert(i, growth);\\n            people += growth;\\n            people %= MOD;\\n        }\\n        people\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911644,
                "title": "simple-sliding-window-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n      long long mod=1e9+7;\\n        vector<long long>arr(n+1);\\n        arr[1]=1;\\n        long long r=1,s=0;\\n        for(int i=2;i<=n;i++){\\n           // s = arr[i - delay] + arr[i - delay - 1]... arr[i - forget + 1];\\n          if(i>delay){\\n            s=(s+arr[i-delay])%mod;\\n          }\\n          if(i>forget){\\n            s=(s-arr[i-forget]+mod)%mod;\\n            r=(r-arr[i-forget]+mod)%mod;\\n          }\\n          arr[i]=s%mod;\\n          r=(r+s)%mod;\\n        }\\n       \\n        return r%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n      long long mod=1e9+7;\\n        vector<long long>arr(n+1);\\n        arr[1]=1;\\n        long long r=1,s=0;\\n        for(int i=2;i<=n;i++){\\n           // s = arr[i - delay] + arr[i - delay - 1]... arr[i - forget + 1];\\n          if(i>delay){\\n            s=(s+arr[i-delay])%mod;\\n          }\\n          if(i>forget){\\n            s=(s-arr[i-forget]+mod)%mod;\\n            r=(r-arr[i-forget]+mod)%mod;\\n          }\\n          arr[i]=s%mod;\\n          r=(r+s)%mod;\\n        }\\n       \\n        return r%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885352,
                "title": "dynamic-programming-solution-iterative-well-explained",
                "content": "# Intuition\\nThe problem involves calculating the number of people who know the secret by the nth day.\\nEach person learns the secret after a delay and forgets it after a certain number of days.\\nWe need to find a solution that keeps track of people knowing the secret as time progresses.\\n\\n# Approach\\nWe use a dynamic programming approach to calculate the number of people knowing the secret.\\nWe initialize a DP array where dp[i] represents the number of people knowing the secret up to day i.\\nWe iterate through each day and calculate the contribution of each person who knew the secret.\\nFor each day, we iterate over the range of delay to forget, adding the contribution of people from previous days.\\nWe update the DP array with the current result for each day.\\n\\n# Complexity\\n- Time complexity: O(n * forget), where n is the number of days and forget is the forget duration.\\n- Space complexity: O(n), as we use a DP array of size n + 1 to store intermediate results.\\n\\n# Code\\n```\\nstatic const int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(n + 1, 0); // Stores the number of people aware of the secret up to day i\\n        \\n        dp[0] = 0; // No one is aware initially\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            long result = 1; // Current contribution of 1 person who knows the secret\\n            \\n            for (int j = delay; j < forget; ++j) {\\n                if (i - j >= 0) {\\n                    // Increment the result by the number of people who found out after forwarding\\n                    result = (result + dp[i - j]) % MOD;\\n                }\\n            }\\n            \\n            dp[i] = result;\\n        }\\n        \\n        // Subtract the number of people who found out before `n - forget` day as observed\\n        long answer = (dp[n] - dp[max(0, n - forget)] + MOD) % MOD;\\n        \\n        return static_cast<int>(answer);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nstatic const int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> dp(n + 1, 0); // Stores the number of people aware of the secret up to day i\\n        \\n        dp[0] = 0; // No one is aware initially\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            long result = 1; // Current contribution of 1 person who knows the secret\\n            \\n            for (int j = delay; j < forget; ++j) {\\n                if (i - j >= 0) {\\n                    // Increment the result by the number of people who found out after forwarding\\n                    result = (result + dp[i - j]) % MOD;\\n                }\\n            }\\n            \\n            dp[i] = result;\\n        }\\n        \\n        // Subtract the number of people who found out before `n - forget` day as observed\\n        long answer = (dp[n] - dp[max(0, n - forget)] + MOD) % MOD;\\n        \\n        return static_cast<int>(answer);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830720,
                "title": "easy-dynamic-programming-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe always have the search space at every i index between i+delay to \\ni+forgot  and within  these space we call for the recursive function \\nand to add the current index in the and depends upon  i+forgot should be greater than n \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long int >dp;\\nint mod =1e9+7;\\n\\n\\nlong long  fun( int i,int n ,int &delay ,int &forget){\\n    if(i+delay>n){\\n        return 0;\\n    }\\n          \\n          if(dp[i]!=INT_MIN){\\n              return dp[i];\\n          }\\n\\n       long long ans=0;\\n    for(int j=i+delay; j<=min(n,i+forget-1);j++){\\n           long long temp=fun(j,n,delay,forget);\\n\\n           \\n           if(j+forget>n){\\n              temp++;\\n           }\\n           \\n           temp%=mod;\\n           ans+=temp;\\n           ans%=mod;\\n    }\\n\\n    return dp[i]=ans;\\n}\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp=vector<long long int >(n+1,INT_MIN);\\n     int ans=fun(1,n,delay,forget);\\n   \\n     if(1+forget>n){\\n         ans++;\\n     }\\n\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long int >dp;\\nint mod =1e9+7;\\n\\n\\nlong long  fun( int i,int n ,int &delay ,int &forget){\\n    if(i+delay>n){\\n        return 0;\\n    }\\n          \\n          if(dp[i]!=INT_MIN){\\n              return dp[i];\\n          }\\n\\n       long long ans=0;\\n    for(int j=i+delay; j<=min(n,i+forget-1);j++){\\n           long long temp=fun(j,n,delay,forget);\\n\\n           \\n           if(j+forget>n){\\n              temp++;\\n           }\\n           \\n           temp%=mod;\\n           ans+=temp;\\n           ans%=mod;\\n    }\\n\\n    return dp[i]=ans;\\n}\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp=vector<long long int >(n+1,INT_MIN);\\n     int ans=fun(1,n,delay,forget);\\n   \\n     if(1+forget>n){\\n         ans++;\\n     }\\n\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811265,
                "title": "sliding-window",
                "content": "**time: `O(N)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/c2dff854-dfd3-46de-b2ae-66321a5fb586_1690315361.9931965.png)\\n\\n```\\nint peopleAwareOfSecret(int n, int d, int f)\\n{\\n\\tint x[1001]{1}, p{1000000007};\\n\\tfor(int i{}, s{}; i<n; ++i)\\n\\t{\\n\\t\\ts    = ((i-d>=0 ? x[i-d] : 0) + (s+p-(i-f>=0 ? x[i-f] : 0))%p)%p;\\n\\t\\tx[i] = (x[i]+s)%p;\\n\\t}\\n\\treturn accumulate(begin(x)+max(0,n-f), begin(x)+n, 0, [&](auto s, auto x){ return (s+x)%p; });\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint peopleAwareOfSecret(int n, int d, int f)\\n{\\n\\tint x[1001]{1}, p{1000000007};\\n\\tfor(int i{}, s{}; i<n; ++i)\\n\\t{\\n\\t\\ts    = ((i-d>=0 ? x[i-d] : 0) + (s+p-(i-f>=0 ? x[i-f] : 0))%p)%p;\\n\\t\\tx[i] = (x[i]+s)%p;\\n\\t}\\n\\treturn accumulate(begin(x)+max(0,n-f), begin(x)+n, 0, [&](auto s, auto x){ return (s+x)%p; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3712218,
                "title": "using-dynamic-programming-100-beats-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long >dp(n+1);\\n\\n        dp[1]=1;\\n        long noOfPeopleSharingSecret=0;\\n        long mod=pow(10,9)+7;\\n        long ans=0;\\n        for(int i=2;i<=n;i++){\\n           long noOfNewPeopleSharingSecret=dp[max(i-delay,0)];\\n           long noOfPeopleForgettingSecret=dp[max(i-forget,0)];\\n        noOfPeopleSharingSecret+=(noOfNewPeopleSharingSecret-noOfPeopleForgettingSecret+mod)%mod;\\n\\n\\n         dp[i]=noOfPeopleSharingSecret;\\n        }\\n\\n     for(int i=n-forget+1;i<=n;i++){\\n      ans=(ans+dp[i])%mod;\\n     }\\n     return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long >dp(n+1);\\n\\n        dp[1]=1;\\n        long noOfPeopleSharingSecret=0;\\n        long mod=pow(10,9)+7;\\n        long ans=0;\\n        for(int i=2;i<=n;i++){\\n           long noOfNewPeopleSharingSecret=dp[max(i-delay,0)];\\n           long noOfPeopleForgettingSecret=dp[max(i-forget,0)];\\n        noOfPeopleSharingSecret+=(noOfNewPeopleSharingSecret-noOfPeopleForgettingSecret+mod)%mod;\\n\\n\\n         dp[i]=noOfPeopleSharingSecret;\\n        }\\n\\n     for(int i=n-forget+1;i<=n;i++){\\n      ans=(ans+dp[i])%mod;\\n     }\\n     return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712051,
                "title": "simple-code-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>v(2001,0);\\n        int mod=pow(10,9)+7;\\n        v[1]=1;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=i+delay;j<i+forget;j++){\\n                v[j]=(v[j]+v[i])%mod;\\n            }\\n        }\\n        int i=0;\\n        long long int ans=0;\\n\\n        while(forget--){\\n            ans=(ans+v[n-i])%mod;\\n            i++;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>v(2001,0);\\n        int mod=pow(10,9)+7;\\n        v[1]=1;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=i+delay;j<i+forget;j++){\\n                v[j]=(v[j]+v[i])%mod;\\n            }\\n        }\\n        int i=0;\\n        long long int ans=0;\\n\\n        while(forget--){\\n            ans=(ans+v[n-i])%mod;\\n            i++;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711954,
                "title": "c-solution-using-dynamic-programming",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1; // day 1\\n        for(int i = 1;i < n;i++){  // fill array untill day n\\n            for(int j = i + delay;j < Math.Min(i + forget,n + 1);j++){\\n                dp[j] = (dp[i] + dp[j]) % mod;\\n            }\\n        }\\n        int res = 0;\\n        for(int i = n; i > n - forget;i--)\\n            res = (res + dp[i]) % mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1; // day 1\\n        for(int i = 1;i < n;i++){  // fill array untill day n\\n            for(int j = i + delay;j < Math.Min(i + forget,n + 1);j++){\\n                dp[j] = (dp[i] + dp[j]) % mod;\\n            }\\n        }\\n        int res = 0;\\n        for(int i = n; i > n - forget;i--)\\n            res = (res + dp[i]) % mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706387,
                "title": "easy-java-solution-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[] dp = new long[n+1];\\n        long mod  = 1000000000 + 7;\\n        long no_of_ppl_sharing = 0;\\n        long ans = 0;\\n\\n        dp[1] = 1;\\n\\n        for(int i = 2; i <= n; i++){\\n            long new_sharing = dp[Math.max(i-delay, 0)];\\n            long no_forgeting = dp[Math.max(i-forget, 0)];\\n\\n            no_of_ppl_sharing = (no_of_ppl_sharing + new_sharing - no_forgeting + mod)%mod;\\n            dp[i] = no_of_ppl_sharing;\\n        }\\n\\n        for(int i = n - forget + 1; i <= n; i++){\\n            ans = (ans + dp[i])%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[] dp = new long[n+1];\\n        long mod  = 1000000000 + 7;\\n        long no_of_ppl_sharing = 0;\\n        long ans = 0;\\n\\n        dp[1] = 1;\\n\\n        for(int i = 2; i <= n; i++){\\n            long new_sharing = dp[Math.max(i-delay, 0)];\\n            long no_forgeting = dp[Math.max(i-forget, 0)];\\n\\n            no_of_ppl_sharing = (no_of_ppl_sharing + new_sharing - no_forgeting + mod)%mod;\\n            dp[i] = no_of_ppl_sharing;\\n        }\\n\\n        for(int i = n - forget + 1; i <= n; i++){\\n            ans = (ans + dp[i])%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550389,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// TC : O(n)\\n// SC : O(n)\\n\\n// dp[day] -> number of people who got to know about secret on this day \\n// dp[day-delay] people will start sharing secret on this day\\n// so people+=dp[day-delay]\\n// dp[day-forget] people will forget secret on this day\\n// so people-=dp[day-forget]\\n// dp[day] = people\\n// ans = summation of dp from day = n-forget+1 to n\\n\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n+1];\\n        dp[1] = 1;\\n        long people = 0;\\n        long mod = (long)1e9+7;\\n        long ans = 0;\\n        \\n        for(int day=1;day<=n;day++){\\n            if(day>1){\\n                dp[day] = (people+dp[Math.max(day-delay,0)]-dp[Math.max(day-forget,0)])%mod;\\n                people = dp[day];\\n            }\\n            \\n            if(day>=n-forget+1){\\n                ans = (ans + dp[day])%mod;\\n            }\\n        }\\n        \\n        int finalAns = (int)ans;\\n        if(finalAns<0) finalAns+=(int)mod;\\n        return finalAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC : O(n)\\n// SC : O(n)\\n\\n// dp[day] -> number of people who got to know about secret on this day \\n// dp[day-delay] people will start sharing secret on this day\\n// so people+=dp[day-delay]\\n// dp[day-forget] people will forget secret on this day\\n// so people-=dp[day-forget]\\n// dp[day] = people\\n// ans = summation of dp from day = n-forget+1 to n\\n\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long dp[] = new long[n+1];\\n        dp[1] = 1;\\n        long people = 0;\\n        long mod = (long)1e9+7;\\n        long ans = 0;\\n        \\n        for(int day=1;day<=n;day++){\\n            if(day>1){\\n                dp[day] = (people+dp[Math.max(day-delay,0)]-dp[Math.max(day-forget,0)])%mod;\\n                people = dp[day];\\n            }\\n            \\n            if(day>=n-forget+1){\\n                ans = (ans + dp[day])%mod;\\n            }\\n        }\\n        \\n        int finalAns = (int)ans;\\n        if(finalAns<0) finalAns+=(int)mod;\\n        return finalAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548648,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int = {\\n    val mod = 1000000007\\n    val f = Array.fill(n + 1)(0)\\n    f(1) = 1\\n    for(i <- 2 to n){\\n      f(i) = f(i - 1)\\n      f(i) = (f(i) + (if(i >= delay) f(i - delay) else 0)) % mod\\n      f(i) = (f(i) - (if(i >= forget)  f(i - forget) else 0)) % mod\\n    }\\n    ((f(n) - f(n - forget)) % mod + mod) % mod\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int = {\\n    val mod = 1000000007\\n    val f = Array.fill(n + 1)(0)\\n    f(1) = 1\\n    for(i <- 2 to n){\\n      f(i) = f(i - 1)\\n      f(i) = (f(i) + (if(i >= delay) f(i - delay) else 0)) % mod\\n      f(i) = (f(i) - (if(i >= forget)  f(i - forget) else 0)) % mod\\n    }\\n    ((f(n) - f(n - forget)) % mod + mod) % mod\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3436672,
                "title": "c-four-lines-29-ms-couldn-t-be-shorter",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1000000007, dp[1001];\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        if (dp[n]) return dp[n];\\n        int ans=1;\\n        for (int i=d+1; i<=min(n,f); ++i) ans = (ans + peopleAwareOfSecret(n-i+1,d,f))%M;\\n        return dp[n] = n>f ? ans - 1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007, dp[1001];\\n\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        if (dp[n]) return dp[n];\\n        int ans=1;\\n        for (int i=d+1; i<=min(n,f); ++i) ans = (ans + peopleAwareOfSecret(n-i+1,d,f))%M;\\n        return dp[n] = n>f ? ans - 1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417640,
                "title": "java-29-ms-only-arrays-with-dp-23-lines-of-code-keeping-record-for-each-day",
                "content": "#     class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] arr=new int[n+1];\\n        arr[1]=1;\\n        int mod=(int)1e9+7;\\n        int sum=1; // starting person\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                int limit=i+forget;\\n                for(int j=i+delay;j<=n && j<limit;j++)\\n                {\\n                    sum=(sum+arr[i])%mod; // adding new persons to whom secret was told. \\n                    arr[j]=(arr[j]+arr[i])%mod;// new persons whose discovered secret on jth day.\\n                }\\n                if(limit<=n)\\n                    sum=((mod+sum)-arr[i])%mod;// subtracting those who forget secret.\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] arr=new int[n+1];\\n        arr[1]=1;\\n        int mod=(int)1e9+7;\\n        int sum=1; // starting person\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                int limit=i+forget;\\n                for(int j=i+delay;j<=n && j<limit;j++)\\n                {\\n                    sum=(sum+arr[i])%mod; // adding new persons to whom secret was told. \\n                    arr[j]=(arr[j]+arr[i])%mod;// new persons whose discovered secret on jth day.\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3337864,
                "title": "java-easy-solution-no-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }\\n        if (forget < n) {\\n            forgets[forget + 1] = 1;\\n        }\\n        \\n        long shareToday = 0;\\n        long peopleKnow = 1;\\n        for (int i = delay; i <= n; i++) {\\n            shareToday += shares[i] % mod;\\n            shareToday -= forgets[i] % mod;\\n\\t\\t\\t\\n            peopleKnow -= forgets[i] % mod;\\n            peopleKnow += shareToday % mod;\\n            \\n            if (i + delay < n + 1) {\\n                shares[i + delay] += shareToday % mod;\\n            }\\n            if (i + forget < n + 1) {    \\n                forgets[i + forget] += shareToday % mod;\\n            }\\n        }\\n        \\n        return (int) (peopleKnow % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }\\n        if (forget < n) {\\n            forgets[forget + 1] = 1;\\n        }\\n        \\n        long shareToday = 0;\\n        long peopleKnow = 1;\\n        for (int i = delay; i <= n; i++) {\\n            shareToday += shares[i] % mod;\\n            shareToday -= forgets[i] % mod;\\n\\t\\t\\t\\n            peopleKnow -= forgets[i] % mod;\\n            peopleKnow += shareToday % mod;\\n            \\n            if (i + delay < n + 1) {\\n                shares[i + delay] += shareToday % mod;\\n            }\\n            if (i + forget < n + 1) {    \\n                forgets[i + forget] += shareToday % mod;\\n            }\\n        }\\n        \\n        return (int) (peopleKnow % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312543,
                "title": "probably-the-most-inoptimal-prefix-sum-biginteger-saved-my-a",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int {\\n        val days = Array<BigInteger>(3*n) { BigInteger.ZERO }\\n        val active = Array<BigInteger>(3*n) { BigInteger.ZERO }\\n        var time = 1\\n        var prefixRunner = BigInteger.ZERO\\n        var activeRunner = BigInteger(\"1\")\\n        val addPersonAtTime = { x: Int, p: BigInteger ->\\n            days[x+delay] = days[x + delay].add(p)\\n            days[x+forget] = days[x+forget].subtract(p)\\n            active[x] = active[x].add(p)\\n            active[x+forget] = active[x+forget].subtract(p)\\n        }\\n        addPersonAtTime(1, BigInteger(\"1\"))\\n        while(time < n) {\\n            time++\\n            prefixRunner = prefixRunner.add(days[time])\\n            addPersonAtTime(time, prefixRunner)\\n            activeRunner = activeRunner.add(active[time])\\n        }\\n        return activeRunner.mod(BigInteger(\"1000000007\")).toString().toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    fun peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int {\\n        val days = Array<BigInteger>(3*n) { BigInteger.ZERO }\\n        val active = Array<BigInteger>(3*n) { BigInteger.ZERO }\\n        var time = 1\\n        var prefixRunner = BigInteger.ZERO\\n        var activeRunner = BigInteger(\"1\")\\n        val addPersonAtTime = { x: Int, p: BigInteger ->\\n            days[x+delay] = days[x + delay].add(p)\\n            days[x+forget] = days[x+forget].subtract(p)\\n            active[x] = active[x].add(p)\\n            active[x+forget] = active[x+forget].subtract(p)\\n        }\\n        addPersonAtTime(1, BigInteger(\"1\"))\\n        while(time < n) {\\n            time++\\n            prefixRunner = prefixRunner.add(days[time])\\n            addPersonAtTime(time, prefixRunner)\\n            activeRunner = activeRunner.add(active[time])\\n        }\\n        return activeRunner.mod(BigInteger(\"1000000007\")).toString().toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306440,
                "title": "easy-simplified-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int mod=1e9+7;\\n    vector<ll>dp;\\n    ll solve(int n, int delay, int forget){\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        ll cnt=0;\\n        for(int i=delay+1 ; i<=forget && i<=n ; i++){\\n            \\n            cnt=(cnt + 1+ solve( n-i+1, delay, forget))%mod;\\n        }\\n    \\n        if(n > forget) cnt-=1; // this person will forget the secret.\\n        \\n        return dp[n] = cnt;\\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp.resize(n+1,-1);\\n        return 1+solve(n,delay,forget);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int mod=1e9+7;\\n    vector<ll>dp;\\n    ll solve(int n, int delay, int forget){\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        ll cnt=0;\\n        for(int i=delay+1 ; i<=forget && i<=n ; i++){\\n            \\n            cnt=(cnt + 1+ solve( n-i+1, delay, forget))%mod;\\n        }\\n    \\n        if(n > forget) cnt-=1; // this person will forget the secret.\\n        \\n        return dp[n] = cnt;\\n    }\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        dp.resize(n+1,-1);\\n        return 1+solve(n,delay,forget);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264472,
                "title": "sliding-window-java-o-n-forget-delay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int dp[]=new int[n];\\n        dp[0]=1;\\n\\n        for(int i=delay;i<n;i++){\\n\\n            for(int j=i-delay;j>(i-forget);j--){\\n                if(j>=0)\\n                dp[i]=(dp[i]+dp[j])%1000000007;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=n-1;i>=n-forget;i--)\\n          ans=(ans+dp[i])%1000000007;\\n\\n          return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        int dp[]=new int[n];\\n        dp[0]=1;\\n\\n        for(int i=delay;i<n;i++){\\n\\n            for(int j=i-delay;j>(i-forget);j--){\\n                if(j>=0)\\n                dp[i]=(dp[i]+dp[j])%1000000007;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=n-1;i>=n-forget;i--)\\n          ans=(ans+dp[i])%1000000007;\\n\\n          return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253642,
                "title": "scala-dp-solution",
                "content": "DP, handle overflow with modulo along the way\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int = {\\n\\n        val rem = (math.pow(10, 9) + 7).toLong\\n        def iter(i: Int, prev: Long, dp: List[Long]): List[Long] = {\\n            if (i == n) dp\\n            else {\\n                val told = if (i - delay >= 0) dp(i - delay) else 0\\n                val forgot = if (i - forget >= 0) dp(i - forget) else 0\\n                val today = (prev + told - forgot + rem) % rem\\n                iter(i + 1, today, dp ++ List(today))\\n            }\\n        }\\n\\n        val dp = iter(1, 0, List(1))\\n        (dp.drop(n - forget).sum % rem).toInt\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int = {\\n\\n        val rem = (math.pow(10, 9) + 7).toLong\\n        def iter(i: Int, prev: Long, dp: List[Long]): List[Long] = {\\n            if (i == n) dp\\n            else {\\n                val told = if (i - delay >= 0) dp(i - delay) else 0\\n                val forgot = if (i - forget >= 0) dp(i - forget) else 0\\n                val today = (prev + told - forgot + rem) % rem\\n                iter(i + 1, today, dp ++ List(today))\\n            }\\n        }\\n\\n        val dp = iter(1, 0, List(1))\\n        (dp.drop(n - forget).sum % rem).toInt\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3239673,
                "title": "c-stimulation",
                "content": "```\\nclass Solution {\\npublic:\\n    // stimulation\\n    // store aheads in map of current day\\n    // take mod of stored\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int, long> m;\\n        m[1] = 1;\\n        int curDay = 1, ans = 0;\\n        queue<int> doubtfulBird;\\n        for (int i = 0; i < forget; ++i) doubtfulBird.push(0);\\n        while (curDay <= n){\\n            ans += m[curDay];\\n            ans -= doubtfulBird.front();\\n            doubtfulBird.pop();\\n            doubtfulBird.push(m[curDay] % 1000000007);\\n            int singingBird = m[curDay];\\n            for (int i = curDay + delay; i < curDay + forget; ++i){\\n                m[i] += singingBird;\\n                m[i] %= 1000000007;\\n            }\\n            ans %= 1000000007;\\n            ++curDay;\\n        }\\n        return ans < 0 ? ans + 1000000007 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // stimulation\\n    // store aheads in map of current day\\n    // take mod of stored\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int, long> m;\\n        m[1] = 1;\\n        int curDay = 1, ans = 0;\\n        queue<int> doubtfulBird;\\n        for (int i = 0; i < forget; ++i) doubtfulBird.push(0);\\n        while (curDay <= n){\\n            ans += m[curDay];\\n            ans -= doubtfulBird.front();\\n            doubtfulBird.pop();\\n            doubtfulBird.push(m[curDay] % 1000000007);\\n            int singingBird = m[curDay];\\n            for (int i = curDay + delay; i < curDay + forget; ++i){\\n                m[i] += singingBird;\\n                m[i] %= 1000000007;\\n            }\\n            ans %= 1000000007;\\n            ++curDay;\\n        }\\n        return ans < 0 ? ans + 1000000007 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231915,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-number-of-people-aware-of-a-secret",
                "content": "class Solution {\\n    private:\\n    \\n    int mod=1e9 +7;\\npublic:\\n    // int mod=1e9+7;\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n+1,0);//declaring of dp\\n        dp[1]=1;\\n        long long no_secret=0;\\n        \\n        for(int i =2;i<=n;i++){\\n            if(i-delay>=0){\\n                no_secret=(no_secret+dp[i-delay])%mod;//modulus of that number of people starting sharing\\n                                                        //  their idea\\n                \\n            }\\n            if(i-forget>=0){\\n                no_secret=(no_secret-dp[i-forget]+mod)%mod;//modulus of that number of people starting forget at \\n                                                        // at instance time their idea\\n            }\\n            dp[i]=no_secret;//stored that values\\n        }\\n        long long ans=0;\\n        for(int i =n-forget+1;i<=n;i++){\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\n    int mod=1e9 +7;\\npublic:\\n    // int mod=1e9+7;\\n    \\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long> dp(n+1,0);//declaring of dp\\n        dp[1]=1;\\n        long long no_secret=0;\\n        \\n        for(int i =2;i<=n;i++){\\n            if(i-delay>=0){\\n                no_secret=(no_secret+dp[i-delay])%mod;//modulus of that number of people starting sharing\\n                                                        //  their idea\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3177014,
                "title": "python-dp-with-explaination",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        learn_day = [0]*(n+delay) # number of people that learnt secret on day i\\n        sharers = [0]*(n+delay) # number of people that are ready to share secret on day i\\n        dp = [0] * n\\n        learn_day[0] = 1 # first person learns on day 0\\n        \\n        for day in range(n):\\n            # people ready to share today = people ready to share yesterday + people who learnt before delay days - people who forgot today\\n            sharers[day] += sharers[day-1] + learn_day[day-delay] - learn_day[day-forget] \\n            \\n            # people learnt today = people ready to share today\\n            learn_day[day] += sharers[day]\\n            \\n            # people that knows today = people that knew yesterday + people learnt today - people who forgot today\\n            dp[day] = dp[day-1] + learn_day[day] - learn_day[day-forget]\\n\\n        return dp[-1]%(1000000007)\\n\\n        \\n     ``",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        \\n        learn_day = [0]*(n+delay) # number of people that learnt secret on day i\\n        sharers = [0]*(n+delay) # number of people that are ready to share secret on day i\\n        dp = [0] * n\\n        learn_day[0] = 1 # first person learns on day 0\\n        \\n        for day in range(n):\\n            # people ready to share today = people ready to share yesterday + people who learnt before delay days - people who forgot today\\n            sharers[day] += sharers[day-1] + learn_day[day-delay] - learn_day[day-forget] \\n            \\n            # people learnt today = people ready to share today\\n            learn_day[day] += sharers[day]\\n            \\n            # people that knows today = people that knew yesterday + people learnt today - people who forgot today\\n            dp[day] = dp[day-1] + learn_day[day] - learn_day[day-forget]\\n\\n        return dp[-1]%(1000000007)\\n\\n        \\n     ``",
                "codeTag": "Java"
            },
            {
                "id": 3175391,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1000000007;\\n        var day = new long[n];\\n        day[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i - forget >= 0 && day[i - forget] > 0) {\\n                var temp = day[i - forget];\\n                for(int j = i - forget; j < i; j++)\\n                    day[j] = (day[j] - temp + mod)  % mod;\\n            }\\n            \\n            var tellPeople = i - delay >= 0 ? day[i - delay] : 0;\\n            day[i] = (day[i - 1] + tellPeople + mod)  % mod;\\n        }\\n\\n        return (int)(day[n - 1] % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PeopleAwareOfSecret(int n, int delay, int forget) {\\n        int mod = 1000000007;\\n        var day = new long[n];\\n        day[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i - forget >= 0 && day[i - forget] > 0) {\\n                var temp = day[i - forget];\\n                for(int j = i - forget; j < i; j++)\\n                    day[j] = (day[j] - temp + mod)  % mod;\\n            }\\n            \\n            var tellPeople = i - delay >= 0 ? day[i - delay] : 0;\\n            day[i] = (day[i - 1] + tellPeople + mod)  % mod;\\n        }\\n\\n        return (int)(day[n - 1] % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172115,
                "title": "dp-memoized-code-with-comments-added",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long count(int index,int &delay,int &forget,int &n, vector<int>&dp){\\n        //one person would be knowing the secrte on that particular index day\\n       if(dp[index]!=-1)return dp[index];\\n       //initial a variable for counting the number of person\\n       long long cnt=0;\\n       cnt++;\\n       //that person could share secret on till index+forget day\\n       if(index+forget<=n)cnt--;\\n       //counting numbers of people who could share secrets\\n       for(int i=index+delay;i<index+forget && i<=n;i++){\\n           cnt=cnt+count(i,delay,forget,n,dp);\\n           cnt=cnt%mod;\\n       }\\n       return dp[index]=cnt;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       vector<int>dp(1001,-1);\\n       return count(1,delay,forget,n,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long count(int index,int &delay,int &forget,int &n, vector<int>&dp){\\n        //one person would be knowing the secrte on that particular index day\\n       if(dp[index]!=-1)return dp[index];\\n       //initial a variable for counting the number of person\\n       long long cnt=0;\\n       cnt++;\\n       //that person could share secret on till index+forget day\\n       if(index+forget<=n)cnt--;\\n       //counting numbers of people who could share secrets\\n       for(int i=index+delay;i<index+forget && i<=n;i++){\\n           cnt=cnt+count(i,delay,forget,n,dp);\\n           cnt=cnt%mod;\\n       }\\n       return dp[index]=cnt;\\n    }\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       vector<int>dp(1001,-1);\\n       return count(1,delay,forget,n,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164962,
                "title": "0ms-hahahahhahah",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod(int n, int k)\\n    {\\n        int ans = n % k;\\n        if(n < 0) ans += k;\\n        return ans;\\n    }\\n\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>arr(n+1);\\n        arr[1] = 1;\\n        int knows = 0;  //number of new people got to know the secret from others\\n\\t\\t\\n\\t\\t//directly starting with the day at which person A start disclosing the secret\\n        for(int i=delay+1; i<=n; ++i) {\\n\\t\\t\\t//update number of people who know the secret\\n            if(i > forget) knows -= arr[i-forget]; \\n            knows += arr[i-delay];\\n\\t\\t\\t\\n            knows = mod(knows, 1000000007);\\n            arr[i] = knows;\\n        }\\n        int sum = 0;\\n\\t\\t//sum of all the people who knows the secret, \\n\\t\\t// from the day after which no one will forget the secret \\n\\t\\t// i.e. (n-forget+1)th day\\n        for(int i=n-forget+1; i<=n; ++i) sum = (sum + arr[i])%1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod(int n, int k)\\n    {\\n        int ans = n % k;\\n        if(n < 0) ans += k;\\n        return ans;\\n    }\\n\\tint peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int>arr(n+1);\\n        arr[1] = 1;\\n        int knows = 0;  //number of new people got to know the secret from others\\n\\t\\t\\n\\t\\t//directly starting with the day at which person A start disclosing the secret\\n        for(int i=delay+1; i<=n; ++i) {\\n\\t\\t\\t//update number of people who know the secret\\n            if(i > forget) knows -= arr[i-forget]; \\n            knows += arr[i-delay];\\n\\t\\t\\t\\n            knows = mod(knows, 1000000007);\\n            arr[i] = knows;\\n        }\\n        int sum = 0;\\n\\t\\t//sum of all the people who knows the secret, \\n\\t\\t// from the day after which no one will forget the secret \\n\\t\\t// i.e. (n-forget+1)th day\\n        for(int i=n-forget+1; i<=n; ++i) sum = (sum + arr[i])%1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118419,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2001)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       vector<int> curr(2001,0);\\n       curr[1]=1;\\n       for(int i=1;i<=n;i++)\\n       {\\n           for(int j=i+delay;j<i+forget;j++)\\n           {\\n               curr[j]=(curr[j]+curr[i])%mod;\\n           }\\n\\n       }\\n        long long  ans=0;\\n        for(int i=n;i>n-forget;i--)\\n        {\\n            ans=(ans+curr[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       vector<int> curr(2001,0);\\n       curr[1]=1;\\n       for(int i=1;i<=n;i++)\\n       {\\n           for(int j=i+delay;j<i+forget;j++)\\n           {\\n               curr[j]=(curr[j]+curr[i])%mod;\\n           }\\n\\n       }\\n        long long  ans=0;\\n        for(int i=n;i>n-forget;i--)\\n        {\\n            ans=(ans+curr[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110700,
                "title": "easy-to-understand-solution-using-greedy-approach-asked-in-goldman-sachs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     #define mod 1000000007\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<vector<long long>> v;\\n        v.push_back({delay + 1, forget+1, 1});\\n        long long day=2;\\n        long long ans=0;\\n        while(day<=n){\\n            while(v.size()>0 && v[0][1]<=day){\\n                 v.erase(v.begin());\\n            }\\n            long long cnt=0;\\n            for(auto& i : v){\\n                if(i[0]<=day){\\n                    cnt= ((cnt)%mod + (i[2])%mod)%mod;\\n                }\\n            }\\n            v.push_back({day+delay,day+forget,cnt});\\n            day++;\\n        }\\n        for(auto& i:v){\\n            ans=((ans)%mod + (i[2])%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     #define mod 1000000007\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<vector<long long>> v;\\n        v.push_back({delay + 1, forget+1, 1});\\n        long long day=2;\\n        long long ans=0;\\n        while(day<=n){\\n            while(v.size()>0 && v[0][1]<=day){\\n                 v.erase(v.begin());\\n            }\\n            long long cnt=0;\\n            for(auto& i : v){\\n                if(i[0]<=day){\\n                    cnt= ((cnt)%mod + (i[2])%mod)%mod;\\n                }\\n            }\\n            v.push_back({day+delay,day+forget,cnt});\\n            day++;\\n        }\\n        for(auto& i:v){\\n            ans=((ans)%mod + (i[2])%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105033,
                "title": "memoization-o-n-easy-and-fast-c-code",
                "content": "# Approach\\nlet\\'s discuss about how the recursion is working.\\n\\n**part1 - why using loop?**\\na guy can reveal the secret only between (initial day of discovering the secret + delay days) and (the day when he forgets the secret) where he will reveal the secret to one guy per day.\\nfor every guy to whom the secret is revealed they will also recursively reveal secrets in the same pattern.part1 in the code refers to the explanation which i just did.\\n\\n**part2 - the basecase**\\nwhen for a guy the secret reveal day(initial day+delay) is greater or equal to the total days ,the guy no longer can share secrets. so 1 needs to be returned because he is the only last guy who knows the secret.\\n\\n**part3 - what to return at last?**\\nby a recursive call , what are we trying to know over here? \\nlet\\'s say we are calling recursive functions for a guy named A and he reveals his secret to B and C between the secret revealing day and the forget day. the recursive function returns the total number of guys who were told the secret by B and who were told the secret by C. so i have summed up the results of all recursion calls in the loop in ***part1***. \\nso the biggest question is what we have to return?\\nlet\\'s say we get m from B\\'s call and n from C\\'s call , we have to return 1+m+n because A also knows the secret right? so for that we have to add an extra 1 with ans.\\nlet\\'s observe another scenario, where the forget day(initial day+f) of A is less than total num of days. in that case A will forget the secret at the end of n days right? so for that case , we will only return ans without adding a 1 with it.\\n\\n\\n                       \\n                        A(1+m+n)\\n                      /   \\\\\\n                    B(m)  c(n)\\n\\n    if we are getting m from B and n from C for A we will return 1+m+n \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int totdays,d,f,mod = 1e9+7;\\n    vector<int> dp;\\n    int rec(int day){\\n\\n        int forget_day = day+f,secret_reveal_day = day+d;\\n\\n        //part 2\\n        if(secret_reveal_day >= totdays)return 1;\\n\\n        if(dp[day] != -1)return dp[day];\\n        int ans = 0;\\n\\n        //part 1\\n        for(int i=secret_reveal_day;i<=min(forget_day-1,totdays-1);i++){\\n            ans = (ans + rec(i))%mod;\\n        }\\n\\n        //part 3\\n        return (day+f < totdays)?dp[day] = ans%mod:dp[day] = (1+ans)%mod;\\n    }\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        totdays = n;\\n        d = delay;\\n        f = forget;\\n        dp.resize(n,-1);\\n        int res = rec(0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int totdays,d,f,mod = 1e9+7;\\n    vector<int> dp;\\n    int rec(int day){\\n\\n        int forget_day = day+f,secret_reveal_day = day+d;\\n\\n        //part 2\\n        if(secret_reveal_day >= totdays)return 1;\\n\\n        if(dp[day] != -1)return dp[day];\\n        int ans = 0;\\n\\n        //part 1\\n        for(int i=secret_reveal_day;i<=min(forget_day-1,totdays-1);i++){\\n            ans = (ans + rec(i))%mod;\\n        }\\n\\n        //part 3\\n        return (day+f < totdays)?dp[day] = ans%mod:dp[day] = (1+ans)%mod;\\n    }\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        totdays = n;\\n        d = delay;\\n        f = forget;\\n        dp.resize(n,-1);\\n        int res = rec(0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065183,
                "title": "100-beat-rate-easiest-solution-goldman-sachs-well-explained",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\nReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ10. Number of People Aware of a Secret\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        long long mod=1e9+7,secret=0;\\n        vector<long long>dp(n+1,0);\\n       \\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            if(i-d>=0)\\n            {\\n                secret=(secret+dp[i-d])%mod;\\n            }\\n             if(i-f>=0)\\n         {   secret=(secret-dp[i-f]+mod)%mod;\\n        }\\n            dp[i]=secret;\\n        }\\n\\nlong long ans=0;\\n        //sum whole arr to return ans\\n        for(int i=n-f+1;i<=n;i++){\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int d, int f) {\\n        long long mod=1e9+7,secret=0;\\n        vector<long long>dp(n+1,0);\\n       \\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            if(i-d>=0)\\n            {\\n                secret=(secret+dp[i-d])%mod;\\n            }\\n             if(i-f>=0)\\n         {   secret=(secret-dp[i-f]+mod)%mod;\\n        }\\n            dp[i]=secret;\\n        }\\n\\nlong long ans=0;\\n        //sum whole arr to return ans\\n        for(int i=n-f+1;i<=n;i++){\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047275,
                "title": "dp-c-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i]->no of new people sharing the secret on ith day\\n        // i->i+delay(Acting as a spraeder)\\n        // i->i-forget(Forgetting the secret)\\n        // no of new people sharing secret on ith day->dp[i-delay]\\n        // no of people forgetting the secret on same day ith->dp[i-forget]\\n        // no of people sharing secret+=no of new people sharing secret-no of people forgetting secret\\n        // dp[i]=dp[i-1]+dp[i-delay]-dp[i-forget];\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long int mod=1e9+7;\\n        vector<long long int>dp(n,0);\\n       dp[0]=1;\\n       long long int no_of_people_sharing=0;\\n       for(int i=1;i<n;i++)\\n       {\\n           int a=i-delay;\\n           int b=i-forget;\\n           \\n           if(a>=0)\\n           no_of_people_sharing= (no_of_people_sharing+dp[a]);\\n           if(b>=0)\\n           no_of_people_sharing= (no_of_people_sharing-dp[b]);\\n           dp[i]=no_of_people_sharing%mod;\\n       }\\n       int secret=0;\\n       for(int i=n-forget;i<n;i++)\\n       secret=(secret+dp[i])%mod;\\n       return secret;\\n       \\n    }\\n    \\n};\\n // // dp[i]->no of new people sharing the secret on ith day\\n        // i->i+delay(Acting as a spraeder)\\n        // i->i-forget(Forgetting the secret)\\n        // no of new people sharing secret on ith day->dp[i-delay]\\n        // no of people forgetting the secret on same day ith->dp[i-forget]\\n        // no of people sharing secret+=no of new people sharing secret-no of people forgetting secret\\n        // dp[i]=dp[i-1]+dp[i-delay]-dp[i-forget];\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long long int mod=1e9+7;\\n        vector<long long int>dp(n,0);\\n       dp[0]=1;\\n       long long int no_of_people_sharing=0;\\n       for(int i=1;i<n;i++)\\n       {\\n           int a=i-delay;\\n           int b=i-forget;\\n           \\n           if(a>=0)\\n           no_of_people_sharing= (no_of_people_sharing+dp[a]);\\n           if(b>=0)\\n           no_of_people_sharing= (no_of_people_sharing-dp[b]);\\n           dp[i]=no_of_people_sharing%mod;\\n       }\\n       int secret=0;\\n       for(int i=n-forget;i<n;i++)\\n       secret=(secret+dp[i])%mod;\\n       return secret;\\n       \\n    }\\n    \\n};\\n // // dp[i]->no of new people sharing the secret on ith day\\n        // i->i+delay(Acting as a spraeder)\\n        // i->i-forget(Forgetting the secret)\\n        // no of new people sharing secret on ith day->dp[i-delay]\\n        // no of people forgetting the secret on same day ith->dp[i-forget]\\n        // no of people sharing secret+=no of new people sharing secret-no of people forgetting secret\\n        // dp[i]=dp[i-1]+dp[i-delay]-dp[i-forget];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040982,
                "title": "most-readable-and-self-explanatory-code-o-n-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        canTellToday = defaultdict(int)\\n        forgetsToday = defaultdict(int)\\n        \\n        peopleWithSecret = 1\\n        peopleWhoTellSecret = 0\\n\\n        canTellToday[1+delay] = 1\\n        forgetsToday[1+forget] = 1  \\n\\n        for day in range(1,n+1):\\n            peopleWhoTellSecret += canTellToday[day]\\n            \\n            peopleWithSecret -= forgetsToday[day]\\n            peopleWhoTellSecret -= forgetsToday[day]\\n\\n            peopleWithSecret += peopleWhoTellSecret\\n            canTellToday[day+delay] += peopleWhoTellSecret\\n            forgetsToday[day+forget] += peopleWhoTellSecret\\n\\n        return peopleWithSecret%(10**9+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        canTellToday = defaultdict(int)\\n        forgetsToday = defaultdict(int)\\n        \\n        peopleWithSecret = 1\\n        peopleWhoTellSecret = 0\\n\\n        canTellToday[1+delay] = 1\\n        forgetsToday[1+forget] = 1  \\n\\n        for day in range(1,n+1):\\n            peopleWhoTellSecret += canTellToday[day]\\n            \\n            peopleWithSecret -= forgetsToday[day]\\n            peopleWhoTellSecret -= forgetsToday[day]\\n\\n            peopleWithSecret += peopleWhoTellSecret\\n            canTellToday[day+delay] += peopleWhoTellSecret\\n            forgetsToday[day+forget] += peopleWhoTellSecret\\n\\n        return peopleWithSecret%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034180,
                "title": "c-o-n-runtime-beats-100-memory-beats-71-15",
                "content": "# Intuition \\nSliding Window\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep a vector in which the value at index i is the number of new people who got to know about the secret on the (i+1)th day, let\\'s say vector name is \"newBorn\". The value at index i will be the sum of all the newBorn values from index (i-forget+1) to (i-delay), this is nothing but saying the people who got to know the secret between (i-forget+1) and (i-delay) will be still remembering the secret and will be telling to new people.\\n\\nKeep a seperate variable to store the total number of people knowing the secret till date. Variable name \"totalTillDate\".\\n\\nLet \"window\" be the sliding window sum variable.\\n\\nAt every index i, to get the value of newBorn[i], the sliding window sum variable is added by the value newBorn[i-delay] and subtracted by the value newBorn[i-forget], and the at present value of sliding window sum will be the value of newBorn[i]. totalTillDate value is added by the number of new people who got to know about the secret that day and it is also subtracted by the number of people who forgets the secret that day(newBorn[i-forget] basically).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> newBorn(n,0);newBorn[0]=1;\\n        long long int totalTillNow=1,window=0,modu=1e9+7;\\n\\n        for(int i=1;i<n;i++){\\n            //updating the sliding window sum variable\\n            if(i>=delay){window+=newBorn[i-delay];}\\n            if(i>=forget)\\n            {   \\n                window-=newBorn[i-forget];\\n                //newBorn[i-forget] people will be forgetting the secret today\\n                totalTillNow-=newBorn[i-forget];\\n            }\\n\\n            //Just making sure the values of window and totalTillNow won\\'t become negative before updating newBorn.\\n            window+=modu;totalTillNow+=modu;\\n            window%=modu;totalTillNow%=modu;\\n\\n            newBorn[i]=window;totalTillNow+=window;\\n        }\\n        totalTillNow%=modu;\\n  \\n        return totalTillNow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<int> newBorn(n,0);newBorn[0]=1;\\n        long long int totalTillNow=1,window=0,modu=1e9+7;\\n\\n        for(int i=1;i<n;i++){\\n            //updating the sliding window sum variable\\n            if(i>=delay){window+=newBorn[i-delay];}\\n            if(i>=forget)\\n            {   \\n                window-=newBorn[i-forget];\\n                //newBorn[i-forget] people will be forgetting the secret today\\n                totalTillNow-=newBorn[i-forget];\\n            }\\n\\n            //Just making sure the values of window and totalTillNow won\\'t become negative before updating newBorn.\\n            window+=modu;totalTillNow+=modu;\\n            window%=modu;totalTillNow%=modu;\\n\\n            newBorn[i]=window;totalTillNow+=window;\\n        }\\n        totalTillNow%=modu;\\n  \\n        return totalTillNow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027030,
                "title": "6companies30days-challenge-by-arsh-goyal-goldmansachs-d4",
                "content": "```\\nclass Solution {\\nprivate:\\n\\n    int mod = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long>persons(n+1,0);\\n        persons[1] = 1; //persons[i] => persons sharing the secret at day i\\n        long long numberOfPeopleSharingSecret = 0;\\n        for(int i=2;i<=n;i++){\\n            if(i - delay >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret + persons[i-delay])%mod;\\n            if(i - forget >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret - persons[i- forget] + mod)%mod;\\n            \\n            persons[i] = numberOfPeopleSharingSecret;\\n        }\\n\\n        long long ans = 0;//add all persons who are not forgotten the secret\\n        for(int i=n-forget+1;i<=n;i++){\\n            ans = (ans + persons[i]) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\n    int mod = 1e9 + 7;\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long long>persons(n+1,0);\\n        persons[1] = 1; //persons[i] => persons sharing the secret at day i\\n        long long numberOfPeopleSharingSecret = 0;\\n        for(int i=2;i<=n;i++){\\n            if(i - delay >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret + persons[i-delay])%mod;\\n            if(i - forget >= 0) \\n                numberOfPeopleSharingSecret = (numberOfPeopleSharingSecret - persons[i- forget] + mod)%mod;\\n            \\n            persons[i] = numberOfPeopleSharingSecret;\\n        }\\n\\n        long long ans = 0;//add all persons who are not forgotten the secret\\n        for(int i=n-forget+1;i<=n;i++){\\n            ans = (ans + persons[i]) % mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022867,
                "title": "easy-c-solution-with-explanation-using-1d-dp",
                "content": "\\n# Approach\\n/*\\ni-> i+delay(Acting as aspreader)\\n\\ni-> i+forget(Forgetting the secret)\\n\\nnoofNewPeopleSharingSecret i-> dp[i-delay]\\nnoofPeopleForgetting the secret on ith day i-> dp[i-forget]\\n\\nnoofpeoplesharingsecret = noofpeoplesharingsecret + noofNewPeopleSharingSecret - noofPeopleForgetting\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\no(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n          \\n          vector<long> dp(n+1 , 0);\\n          long mod = 1e9+7;\\n          long PeopleSharingSecret = 0;\\n          long ans = 0;\\n          \\n          //day 1 only one person knows the secret\\n          dp[1] = 1;\\n\\n          //i -> days\\n          for(int i=2; i<=n; i++){\\n               long noofNewPeopleSharingSecret = 0;\\n              if(i-delay > 0){\\n                   noofNewPeopleSharingSecret = dp[i-delay];\\n              }\\n              long noofPeopleForgettingSecret = 0;\\n              if(i - forget > 0)    noofPeopleForgettingSecret = dp[i-forget];\\n              PeopleSharingSecret += (noofNewPeopleSharingSecret - noofPeopleForgettingSecret + mod)%mod;\\n              \\n              //dp[i] => no of peoples who found secret on ith day\\n              dp[i] = PeopleSharingSecret;\\n          }\\n        \\n          for(int i=n-forget+1; i<=n; i++){\\n              ans = (ans+dp[i])%mod;\\n          }\\n          return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n          \\n          vector<long> dp(n+1 , 0);\\n          long mod = 1e9+7;\\n          long PeopleSharingSecret = 0;\\n          long ans = 0;\\n          \\n          //day 1 only one person knows the secret\\n          dp[1] = 1;\\n\\n          //i -> days\\n          for(int i=2; i<=n; i++){\\n               long noofNewPeopleSharingSecret = 0;\\n              if(i-delay > 0){\\n                   noofNewPeopleSharingSecret = dp[i-delay];\\n              }\\n              long noofPeopleForgettingSecret = 0;\\n              if(i - forget > 0)    noofPeopleForgettingSecret = dp[i-forget];\\n              PeopleSharingSecret += (noofNewPeopleSharingSecret - noofPeopleForgettingSecret + mod)%mod;\\n              \\n              //dp[i] => no of peoples who found secret on ith day\\n              dp[i] = PeopleSharingSecret;\\n          }\\n        \\n          for(int i=n-forget+1; i<=n; i++){\\n              ans = (ans+dp[i])%mod;\\n          }\\n          return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957109,
                "title": "dp-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> secretAware(n+1, 0), firstDay(n+1, 0), canShare(n+1, 0);\\n        secretAware[1] = 1, firstDay[1] = 1; canShare[1] = 0;\\n        for(int d = 2; d <= n; ++d){\\n            secretAware[d] = secretAware[d-1];\\n            canShare[d] = canShare[d-1];\\n            if(d > forget){\\n                secretAware[d] = (secretAware[d] - firstDay[d-forget] + mod)%mod;\\n                canShare[d] = (canShare[d] - firstDay[d-forget] + mod)%mod;\\n            }\\n            if(d > delay){\\n                canShare[d] = (canShare[d] + firstDay[d-delay])%mod;\\n            }\\n            secretAware[d] = (secretAware[d] + canShare[d])%mod;\\n            firstDay[d] = canShare[d];\\n        }\\n        return secretAware[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        vector<long> secretAware(n+1, 0), firstDay(n+1, 0), canShare(n+1, 0);\\n        secretAware[1] = 1, firstDay[1] = 1; canShare[1] = 0;\\n        for(int d = 2; d <= n; ++d){\\n            secretAware[d] = secretAware[d-1];\\n            canShare[d] = canShare[d-1];\\n            if(d > forget){\\n                secretAware[d] = (secretAware[d] - firstDay[d-forget] + mod)%mod;\\n                canShare[d] = (canShare[d] - firstDay[d-forget] + mod)%mod;\\n            }\\n            if(d > delay){\\n                canShare[d] = (canShare[d] + firstDay[d-delay])%mod;\\n            }\\n            secretAware[d] = (secretAware[d] + canShare[d])%mod;\\n            firstDay[d] = canShare[d];\\n        }\\n        return secretAware[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933540,
                "title": "o-n-rak7et-w-nty-wa9th-a-zin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long> dp(n+forget,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==0) continue;\\n            for(int j=i+delay;j<i+forget;j++)\\n            {\\n                dp[j]  = (dp[j] + dp[i])%1000000007;\\n            }\\n        }\\n        \\n        \\n        long long ans = 0;\\n        for(int i=n-1;i>=n-forget;i--)\\n            ans += dp[i];\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long> dp(n+forget,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==0) continue;\\n            for(int j=i+delay;j<i+forget;j++)\\n            {\\n                dp[j]  = (dp[j] + dp[i])%1000000007;\\n            }\\n        }\\n        \\n        \\n        long long ans = 0;\\n        for(int i=n-1;i>=n-forget;i--)\\n            ans += dp[i];\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920907,
                "title": "python-tabulation-solution",
                "content": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        n+=1\\n        res = [0] * n\\n        spread = [0] * n\\n        minus = [0] * n\\n\\n        res[0] = 1\\n        spread[delay] = 1\\n        minus[forget] = 1\\n\\n        for i in range(1,n):\\n            spread[i] += (spread[i-1] - minus[i])\\n\\n            if i + delay < n:\\n                spread[i+delay] += spread[i]\\n                if i + forget < n:\\n                    minus[i+forget] += spread[i]\\n                    \\n\\n            res[i] = res[i-1] + spread[i] - minus[i]\\n        \\n        return res[-2] % 1000000007\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        n+=1\\n        res = [0] * n\\n        spread = [0] * n\\n        minus = [0] * n\\n\\n        res[0] = 1\\n        spread[delay] = 1\\n        minus[forget] = 1\\n\\n        for i in range(1,n):\\n            spread[i] += (spread[i-1] - minus[i])\\n\\n            if i + delay < n:\\n                spread[i+delay] += spread[i]\\n                if i + forget < n:\\n                    minus[i+forget] += spread[i]\\n                    \\n\\n            res[i] = res[i-1] + spread[i] - minus[i]\\n        \\n        return res[-2] % 1000000007\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908875,
                "title": "java-o-n-straight-forward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] dp=new int[n+1];\\n        int mod=1_000_000_007;\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            if(i<=delay)\\n                dp[i]=dp[i-1];\\n            else if(i<=forget)\\n                dp[i]=(dp[i-1]+dp[i-delay])%mod;\\n            else\\n                dp[i]=(dp[i-1]+(dp[i-delay]-dp[i-forget]+mod)%mod)%mod;\\n        }\\n        return (dp[n]-dp[n-forget]+mod)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] dp=new int[n+1];\\n        int mod=1_000_000_007;\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            if(i<=delay)\\n                dp[i]=dp[i-1];\\n            else if(i<=forget)\\n                dp[i]=(dp[i-1]+dp[i-delay])%mod;\\n            else\\n                dp[i]=(dp[i-1]+(dp[i-delay]-dp[i-forget]+mod)%mod)%mod;\\n        }\\n        return (dp[n]-dp[n-forget]+mod)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850881,
                "title": "easy-solution-c-86-16-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       int val[n+1];\\n        memset(val,0,sizeof(val));\\n        \\n        int forgetCount[n+1];\\n        memset(forgetCount,0,sizeof(forgetCount));\\n        \\n        val[1]=1;\\n        \\n        long long int sum=0;\\n        val[2]-=1;\\n        long long int tot=0;\\n        \\n        const int mod=1000000007;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n        //    if(val[i]>0){\\n               \\n            sum+=val[i];\\n            sum%=mod;\\n            \\n            tot+=sum;\\n            tot%=mod;\\n            \\n            if(i+delay<=n)\\n                    val[i+delay]+=sum,val[i+delay]%=mod;\\n                if(i+forget<=n)\\n                   forgetCount[i+forget]=(forgetCount[i+forget]+sum)%mod, val[i+forget]-=sum,val[i+forget]=(val[i+forget]+mod)%mod;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            tot-=forgetCount[i];\\n            tot+=mod;\\n            tot%=mod;\\n        }\\n        \\n        return tot;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n       int val[n+1];\\n        memset(val,0,sizeof(val));\\n        \\n        int forgetCount[n+1];\\n        memset(forgetCount,0,sizeof(forgetCount));\\n        \\n        val[1]=1;\\n        \\n        long long int sum=0;\\n        val[2]-=1;\\n        long long int tot=0;\\n        \\n        const int mod=1000000007;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n        //    if(val[i]>0){\\n               \\n            sum+=val[i];\\n            sum%=mod;\\n            \\n            tot+=sum;\\n            tot%=mod;\\n            \\n            if(i+delay<=n)\\n                    val[i+delay]+=sum,val[i+delay]%=mod;\\n                if(i+forget<=n)\\n                   forgetCount[i+forget]=(forgetCount[i+forget]+sum)%mod, val[i+forget]-=sum,val[i+forget]=(val[i+forget]+mod)%mod;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            tot-=forgetCount[i];\\n            tot+=mod;\\n            tot%=mod;\\n        }\\n        \\n        return tot;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837001,
                "title": "c-simple-linear-dp-o-n",
                "content": "# Intuition\\nDP\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long>dp(n+1,0);\\n        dp[1]=1;\\n        long long sum=0;\\n        for(int i=delay+1;i<=n;i++)\\n        {     \\n            sum=(sum+dp[i-delay])%mod;\\n            if(i-forget>=0){\\n                sum=(sum-dp[i-forget]+mod)%mod;\\n                dp[i-forget]=0;\\n                }\\n            dp[i]=sum;\\n\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=n;i++)ans=(ans+dp[i])%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long mod=1e9+7;\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        \\n        vector<long long>dp(n+1,0);\\n        dp[1]=1;\\n        long long sum=0;\\n        for(int i=delay+1;i<=n;i++)\\n        {     \\n            sum=(sum+dp[i-delay])%mod;\\n            if(i-forget>=0){\\n                sum=(sum-dp[i-forget]+mod)%mod;\\n                dp[i-forget]=0;\\n                }\\n            dp[i]=sum;\\n\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=n;i++)ans=(ans+dp[i])%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818175,
                "title": "number-of-people-aware",
                "content": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[][] dp = new long[n + forget][3];\\n        long mod = (long) 1e9 + 7;\\n        dp[0][0] = dp[delay][1] = dp[forget][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = (dp[i][1] + dp[i - 1][1] - dp[i][2] + mod) % mod;\\n            dp[i + forget][2] = dp[i][1];\\n            dp[i + delay][1] = dp[i][1];\\n           \\n            dp[i][0] = (dp[i - 1][0] + dp[i][1] - dp[i][2] + mod) % mod;\\n        }\\n        return (int) dp[n - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long[][] dp = new long[n + forget][3];\\n        long mod = (long) 1e9 + 7;\\n        dp[0][0] = dp[delay][1] = dp[forget][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = (dp[i][1] + dp[i - 1][1] - dp[i][2] + mod) % mod;\\n            dp[i + forget][2] = dp[i][1];\\n            dp[i + delay][1] = dp[i][1];\\n           \\n            dp[i][0] = (dp[i - 1][0] + dp[i][1] - dp[i][2] + mod) % mod;\\n        }\\n        return (int) dp[n - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814978,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp, total = [0]*n, 0\\n\\n        dp[0] = 1\\n\\n        for i in range(1,n):\\n            dp[i] = total = total + dp[i-delay] - dp[i-forget]\\n\\n        return sum(dp[n-forget:])%(10**9+7)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        dp, total = [0]*n, 0\\n\\n        dp[0] = 1\\n\\n        for i in range(1,n):\\n            dp[i] = total = total + dp[i-delay] - dp[i-forget]\\n\\n        return sum(dp[n-forget:])%(10**9+7)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799066,
                "title": "where-am-going-wrong-with-this-when-using-maps",
                "content": "\\n    int peopleAwareOfSecret(int n, int delay, int forget)\\n    {\\n\\n        int numPeople = 1;\\n\\n        unordered_map<int, int> people;\\n\\n        people[numPeople] = 0;\\n        int totalPeople = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n\\n            int temp = people[1];\\n\\n            for (auto &[key, val] : people)\\n            {\\n\\n                if (val != 0 && val != -1)\\n                {\\n                        if ((val) == (forget))\\n                {\\n                    numPeople--;\\n                    val = -1;\\n                }\\n                        if ((val) >= (delay))\\n                        {\\n                            numPeople++;\\n                            totalPeople++;\\n                        }\\n                    \\n                }\\n\\n                \\n            }\\n\\n            for (int j = 1; j <= totalPeople; j++)\\n            {\\n                if (people[j] != -1)\\n                    people[j]++;\\n            }\\n        }\\n\\n        return numPeople;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int peopleAwareOfSecret(int n, int delay, int forget)\\n    {\\n\\n        int numPeople = 1;\\n\\n        unordered_map<int, int> people;\\n\\n        people[numPeople] = 0;\\n        int totalPeople = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n\\n            int temp = people[1];\\n\\n            for (auto &[key, val] : people)\\n            {\\n\\n                if (val != 0 && val != -1)\\n                {\\n                        if ((val) == (forget))\\n                {\\n                    numPeople--;\\n                    val = -1;\\n                }\\n                        if ((val) >= (delay))\\n                        {\\n                            numPeople++;\\n                            totalPeople++;\\n                        }\\n                    \\n                }\\n\\n                \\n            }\\n\\n            for (int j = 1; j <= totalPeople; j++)\\n            {\\n                if (people[j] != -1)\\n                    people[j]++;\\n            }\\n        }\\n\\n        return numPeople;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2782524,
                "title": "golang-0-ms-2-3-mb-dp-time-o-n-space-o-n",
                "content": "```\\nconst mod = uint32(1_000_000_007)\\n\\ntype Day struct {\\n\\tnew   uint32\\n\\ttotal uint32\\n}\\n\\nfunc peopleAwareOfSecret(n int, delay int, forget int) int {\\n\\tdays := make([]Day, n)\\n\\tfor i := 0; i < delay; i++ {\\n\\t\\tdays[i].total = 1\\n\\t}\\n\\tdays[delay] = Day{\\n\\t\\tnew:   1,\\n\\t\\ttotal: 2,\\n\\t}\\n\\tfor i := delay + 1; i < forget; i++ {\\n\\t\\tdays[i].new = (days[i-1].new + days[i-delay].new) % mod\\n\\t\\tdays[i].total = (days[i-1].total + days[i].new) % mod\\n\\t}\\n\\tif n != forget {\\n\\t\\tdays[forget].new = (days[forget-1].new + days[forget-delay].new - 1) % mod\\n\\t\\tdays[forget].total = (days[forget-1].total + days[forget].new - 1) % mod\\n\\t\\tfor i := forget + 1; i < n; i++ {\\n\\t\\t\\tdays[i].new = (days[i-1].new + days[i-delay].new - days[i-forget].new + mod) % mod\\n\\t\\t\\tdays[i].total = (days[i-1].total + days[i].new - days[i-forget].new + mod) % mod\\n\\t\\t}\\n\\t}\\n\\treturn int(days[n-1].total)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst mod = uint32(1_000_000_007)\\n\\ntype Day struct {\\n\\tnew   uint32\\n\\ttotal uint32\\n}\\n\\nfunc peopleAwareOfSecret(n int, delay int, forget int) int {\\n\\tdays := make([]Day, n)\\n\\tfor i := 0; i < delay; i++ {\\n\\t\\tdays[i].total = 1\\n\\t}\\n\\tdays[delay] = Day{\\n\\t\\tnew:   1,\\n\\t\\ttotal: 2,\\n\\t}\\n\\tfor i := delay + 1; i < forget; i++ {\\n\\t\\tdays[i].new = (days[i-1].new + days[i-delay].new) % mod\\n\\t\\tdays[i].total = (days[i-1].total + days[i].new) % mod\\n\\t}\\n\\tif n != forget {\\n\\t\\tdays[forget].new = (days[forget-1].new + days[forget-delay].new - 1) % mod\\n\\t\\tdays[forget].total = (days[forget-1].total + days[forget].new - 1) % mod\\n\\t\\tfor i := forget + 1; i < n; i++ {\\n\\t\\t\\tdays[i].new = (days[i-1].new + days[i-delay].new - days[i-forget].new + mod) % mod\\n\\t\\t\\tdays[i].total = (days[i-1].total + days[i].new - days[i-forget].new + mod) % mod\\n\\t\\t}\\n\\t}\\n\\treturn int(days[n-1].total)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758915,
                "title": "java-intuitive-simulation-without-dp",
                "content": "did not realize this can be solved by DP, instead going to simulation approach. the key here is to have a running sum of count of how many people know the secret and how many can share.\\n```\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] lost=new int[2*n+1];\\n        int[] cantell=new int[2*n+1];\\n        Arrays.fill(lost,0);\\n        Arrays.fill(cantell,0);\\n        ++cantell[1+delay];\\n        ++lost[1+forget];\\n        int ans=1,tells=0;\\n        for (int i=2;i<=n;++i) {\\n            ans=modadd(ans,-lost[i]);\\n            tells=modadd(tells,-lost[i]);\\n            tells=modadd(tells,cantell[i]);\\n            ans=modadd(ans,tells);\\n            cantell[i+delay]=modadd(cantell[i+delay],tells);\\n            lost[i+forget]=modadd(lost[i+forget],tells);\\n        }\\n        return ans;\\n    }\\n\\n    private int modadd(int a, int b) {\\n        int MOD=1000000007;\\n        a=(a+MOD)%MOD;\\n        b=(b+MOD)%MOD;\\n        return (a+b)%MOD;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        int[] lost=new int[2*n+1];\\n        int[] cantell=new int[2*n+1];\\n        Arrays.fill(lost,0);\\n        Arrays.fill(cantell,0);\\n        ++cantell[1+delay];\\n        ++lost[1+forget];\\n        int ans=1,tells=0;\\n        for (int i=2;i<=n;++i) {\\n            ans=modadd(ans,-lost[i]);\\n            tells=modadd(tells,-lost[i]);\\n            tells=modadd(tells,cantell[i]);\\n            ans=modadd(ans,tells);\\n            cantell[i+delay]=modadd(cantell[i+delay],tells);\\n            lost[i+forget]=modadd(lost[i+forget],tells);\\n        }\\n        return ans;\\n    }\\n\\n    private int modadd(int a, int b) {\\n        int MOD=1000000007;\\n        a=(a+MOD)%MOD;\\n        b=(b+MOD)%MOD;\\n        return (a+b)%MOD;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1756449,
                "content": [
                    {
                        "username": "Nitesh_Ag",
                        "content": "here i stuck in the test case\\nn=289,delay=7, forget=18;\\ni use unordered_map and 1 for loop\\n\\n//*************************************************************************************************//\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int,long long>mpp;\\n        mpp[1]=1;\\n        int remen=pow(10,9)+7;\\n        long long sum=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long first=(mpp[i-forget]-sum)%remen;\\n             if(mpp[i-forget]==1 && sum==0 ) sum=1;\\n            //  else first=(mpp[i-forget]-sum)%remen;\\n             mpp[i]=(mpp[i-1]+mpp[i-delay]-sum-first)%remen;\\n            sum=(sum+first)%remen;\\n             cout<<i<<\" \"<<mpp[i]<<endl;\\n        }\\n        return mpp[n];\\n    }\\nmy code work properly for every input and output but due to some remen it gave error please find it\\n//**********************************************************************************************//"
                    },
                    {
                        "username": "realitant",
                        "content": "I was so close to getting this on my first try. No syntax errors, no indices off by 1, nothing.\\nI forgot the mod..."
                    },
                    {
                        "username": "ak7050971651",
                        "content": "int solveop(int n, int odelay, int oforget,int mod){\\n        //vector<vector<vector<int>>>dp (n+1,vector<vector<int>>(odelay+1,vector<int>(oforget+1,0)));\\n        //vector<vector<int>>(0,vector<int>())\\n        vector<vector<int>>curr (odelay+1,vector<int>(oforget+1,0));\\n        vector<vector<int>>next (odelay+1,vector<int>(oforget+1,0));\\n        for(int index=n;index>=1;index--){\\n            for(int delay=0;delay<=odelay;delay++){\\n                for(int forget=0;forget<=oforget;forget++){\\n                    if(forget==0){curr[delay][forget]= 0;}\\n\\n                    else if(delay==0){\\n                        if(index+1>n){\\n                            curr[delay][forget]=2;\\n                        }\\n                        else{\\n                            curr[delay][forget]=(next[0][forget-1]%mod+next[odelay-1][oforget-1]%mod)%mod;\\n                        }\\n                     \\n                    }\\n                    else{\\n                        if(index+1>n){\\n                            curr[delay][forget]=1;\\n                        }\\n                        else{\\n                            curr[delay][forget]=next[delay-1][forget-1]%mod;\\n                        }\\n                        \\n                    } \\n                }\\n            }\\n            next=curr;\\n        }\\n\\n        return curr[odelay][oforget];\\n    }"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "You can also do it without DP.(2 for loops)\\nTry 3-4 test cases,think how you are incrementing the day with delay, that how many people who know the secret at a certain day store in a vector."
                    },
                    {
                        "username": "likhar",
                        "content": "What is wrong with this solution? It is giving wrong answer on test case 2.\n\ndp[i] => number of people which found out about the secret on ith day.\n\nanswer will be sum of dp[n]+dp[n-1]+.......+dp[n-forget+1].\n\nTransition -\n// d = delay\n\n=>dp[i] =  dp[i-d] + dp[i-d-1] +..........+ dp[i-forget+1]\n\n=>dp[i+1]  = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1] + dp[i-forget+1] - dp[i-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i] - dp[i-forget+1]\n\n=>let j=i+1\n=>dp[j] = dp[j-d] + dp[j-1] - dp[j-forget]\n=>dp[i] = dp[i-1] + dp[i-d] - dp[i-forget]\n\ndp[0] = 0;\ndp[1] = 1;\n\n ```\nint peopleAwareOfSecret(int n, int delay, int forget) {\n        vector<long long int> dp(n+1,0);\n        int d = delay;\n        int f = forget;\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i] = (i-d>0?dp[i-d]+dp[i-1]:0) - (i-f>0?dp[i-f]:0);\n            cout<<dp[i]<<\" \";\n        }\n        int mod = 1e9+7;\n        int ans=0;\n        while(f)\n        {\n            ans = (ans+dp[n-f+1])%mod;\n            f--;\n        }\n        return ans;\n    }\n```\n\nIn second test case, the dp array should be => 0 1 1 2 2\nBut it is coming out to be => 0 1 2 4 7"
                    }
                ]
            },
            {
                "id": 2067479,
                "content": [
                    {
                        "username": "Nitesh_Ag",
                        "content": "here i stuck in the test case\\nn=289,delay=7, forget=18;\\ni use unordered_map and 1 for loop\\n\\n//*************************************************************************************************//\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int,long long>mpp;\\n        mpp[1]=1;\\n        int remen=pow(10,9)+7;\\n        long long sum=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long first=(mpp[i-forget]-sum)%remen;\\n             if(mpp[i-forget]==1 && sum==0 ) sum=1;\\n            //  else first=(mpp[i-forget]-sum)%remen;\\n             mpp[i]=(mpp[i-1]+mpp[i-delay]-sum-first)%remen;\\n            sum=(sum+first)%remen;\\n             cout<<i<<\" \"<<mpp[i]<<endl;\\n        }\\n        return mpp[n];\\n    }\\nmy code work properly for every input and output but due to some remen it gave error please find it\\n//**********************************************************************************************//"
                    },
                    {
                        "username": "realitant",
                        "content": "I was so close to getting this on my first try. No syntax errors, no indices off by 1, nothing.\\nI forgot the mod..."
                    },
                    {
                        "username": "ak7050971651",
                        "content": "int solveop(int n, int odelay, int oforget,int mod){\\n        //vector<vector<vector<int>>>dp (n+1,vector<vector<int>>(odelay+1,vector<int>(oforget+1,0)));\\n        //vector<vector<int>>(0,vector<int>())\\n        vector<vector<int>>curr (odelay+1,vector<int>(oforget+1,0));\\n        vector<vector<int>>next (odelay+1,vector<int>(oforget+1,0));\\n        for(int index=n;index>=1;index--){\\n            for(int delay=0;delay<=odelay;delay++){\\n                for(int forget=0;forget<=oforget;forget++){\\n                    if(forget==0){curr[delay][forget]= 0;}\\n\\n                    else if(delay==0){\\n                        if(index+1>n){\\n                            curr[delay][forget]=2;\\n                        }\\n                        else{\\n                            curr[delay][forget]=(next[0][forget-1]%mod+next[odelay-1][oforget-1]%mod)%mod;\\n                        }\\n                     \\n                    }\\n                    else{\\n                        if(index+1>n){\\n                            curr[delay][forget]=1;\\n                        }\\n                        else{\\n                            curr[delay][forget]=next[delay-1][forget-1]%mod;\\n                        }\\n                        \\n                    } \\n                }\\n            }\\n            next=curr;\\n        }\\n\\n        return curr[odelay][oforget];\\n    }"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "You can also do it without DP.(2 for loops)\\nTry 3-4 test cases,think how you are incrementing the day with delay, that how many people who know the secret at a certain day store in a vector."
                    },
                    {
                        "username": "likhar",
                        "content": "What is wrong with this solution? It is giving wrong answer on test case 2.\n\ndp[i] => number of people which found out about the secret on ith day.\n\nanswer will be sum of dp[n]+dp[n-1]+.......+dp[n-forget+1].\n\nTransition -\n// d = delay\n\n=>dp[i] =  dp[i-d] + dp[i-d-1] +..........+ dp[i-forget+1]\n\n=>dp[i+1]  = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1] + dp[i-forget+1] - dp[i-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i] - dp[i-forget+1]\n\n=>let j=i+1\n=>dp[j] = dp[j-d] + dp[j-1] - dp[j-forget]\n=>dp[i] = dp[i-1] + dp[i-d] - dp[i-forget]\n\ndp[0] = 0;\ndp[1] = 1;\n\n ```\nint peopleAwareOfSecret(int n, int delay, int forget) {\n        vector<long long int> dp(n+1,0);\n        int d = delay;\n        int f = forget;\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i] = (i-d>0?dp[i-d]+dp[i-1]:0) - (i-f>0?dp[i-f]:0);\n            cout<<dp[i]<<\" \";\n        }\n        int mod = 1e9+7;\n        int ans=0;\n        while(f)\n        {\n            ans = (ans+dp[n-f+1])%mod;\n            f--;\n        }\n        return ans;\n    }\n```\n\nIn second test case, the dp array should be => 0 1 1 2 2\nBut it is coming out to be => 0 1 2 4 7"
                    }
                ]
            },
            {
                "id": 2050721,
                "content": [
                    {
                        "username": "Nitesh_Ag",
                        "content": "here i stuck in the test case\\nn=289,delay=7, forget=18;\\ni use unordered_map and 1 for loop\\n\\n//*************************************************************************************************//\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int,long long>mpp;\\n        mpp[1]=1;\\n        int remen=pow(10,9)+7;\\n        long long sum=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long first=(mpp[i-forget]-sum)%remen;\\n             if(mpp[i-forget]==1 && sum==0 ) sum=1;\\n            //  else first=(mpp[i-forget]-sum)%remen;\\n             mpp[i]=(mpp[i-1]+mpp[i-delay]-sum-first)%remen;\\n            sum=(sum+first)%remen;\\n             cout<<i<<\" \"<<mpp[i]<<endl;\\n        }\\n        return mpp[n];\\n    }\\nmy code work properly for every input and output but due to some remen it gave error please find it\\n//**********************************************************************************************//"
                    },
                    {
                        "username": "realitant",
                        "content": "I was so close to getting this on my first try. No syntax errors, no indices off by 1, nothing.\\nI forgot the mod..."
                    },
                    {
                        "username": "ak7050971651",
                        "content": "int solveop(int n, int odelay, int oforget,int mod){\\n        //vector<vector<vector<int>>>dp (n+1,vector<vector<int>>(odelay+1,vector<int>(oforget+1,0)));\\n        //vector<vector<int>>(0,vector<int>())\\n        vector<vector<int>>curr (odelay+1,vector<int>(oforget+1,0));\\n        vector<vector<int>>next (odelay+1,vector<int>(oforget+1,0));\\n        for(int index=n;index>=1;index--){\\n            for(int delay=0;delay<=odelay;delay++){\\n                for(int forget=0;forget<=oforget;forget++){\\n                    if(forget==0){curr[delay][forget]= 0;}\\n\\n                    else if(delay==0){\\n                        if(index+1>n){\\n                            curr[delay][forget]=2;\\n                        }\\n                        else{\\n                            curr[delay][forget]=(next[0][forget-1]%mod+next[odelay-1][oforget-1]%mod)%mod;\\n                        }\\n                     \\n                    }\\n                    else{\\n                        if(index+1>n){\\n                            curr[delay][forget]=1;\\n                        }\\n                        else{\\n                            curr[delay][forget]=next[delay-1][forget-1]%mod;\\n                        }\\n                        \\n                    } \\n                }\\n            }\\n            next=curr;\\n        }\\n\\n        return curr[odelay][oforget];\\n    }"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "You can also do it without DP.(2 for loops)\\nTry 3-4 test cases,think how you are incrementing the day with delay, that how many people who know the secret at a certain day store in a vector."
                    },
                    {
                        "username": "likhar",
                        "content": "What is wrong with this solution? It is giving wrong answer on test case 2.\n\ndp[i] => number of people which found out about the secret on ith day.\n\nanswer will be sum of dp[n]+dp[n-1]+.......+dp[n-forget+1].\n\nTransition -\n// d = delay\n\n=>dp[i] =  dp[i-d] + dp[i-d-1] +..........+ dp[i-forget+1]\n\n=>dp[i+1]  = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1] + dp[i-forget+1] - dp[i-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i] - dp[i-forget+1]\n\n=>let j=i+1\n=>dp[j] = dp[j-d] + dp[j-1] - dp[j-forget]\n=>dp[i] = dp[i-1] + dp[i-d] - dp[i-forget]\n\ndp[0] = 0;\ndp[1] = 1;\n\n ```\nint peopleAwareOfSecret(int n, int delay, int forget) {\n        vector<long long int> dp(n+1,0);\n        int d = delay;\n        int f = forget;\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i] = (i-d>0?dp[i-d]+dp[i-1]:0) - (i-f>0?dp[i-f]:0);\n            cout<<dp[i]<<\" \";\n        }\n        int mod = 1e9+7;\n        int ans=0;\n        while(f)\n        {\n            ans = (ans+dp[n-f+1])%mod;\n            f--;\n        }\n        return ans;\n    }\n```\n\nIn second test case, the dp array should be => 0 1 1 2 2\nBut it is coming out to be => 0 1 2 4 7"
                    }
                ]
            },
            {
                "id": 1753912,
                "content": [
                    {
                        "username": "Nitesh_Ag",
                        "content": "here i stuck in the test case\\nn=289,delay=7, forget=18;\\ni use unordered_map and 1 for loop\\n\\n//*************************************************************************************************//\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int,long long>mpp;\\n        mpp[1]=1;\\n        int remen=pow(10,9)+7;\\n        long long sum=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long first=(mpp[i-forget]-sum)%remen;\\n             if(mpp[i-forget]==1 && sum==0 ) sum=1;\\n            //  else first=(mpp[i-forget]-sum)%remen;\\n             mpp[i]=(mpp[i-1]+mpp[i-delay]-sum-first)%remen;\\n            sum=(sum+first)%remen;\\n             cout<<i<<\" \"<<mpp[i]<<endl;\\n        }\\n        return mpp[n];\\n    }\\nmy code work properly for every input and output but due to some remen it gave error please find it\\n//**********************************************************************************************//"
                    },
                    {
                        "username": "realitant",
                        "content": "I was so close to getting this on my first try. No syntax errors, no indices off by 1, nothing.\\nI forgot the mod..."
                    },
                    {
                        "username": "ak7050971651",
                        "content": "int solveop(int n, int odelay, int oforget,int mod){\\n        //vector<vector<vector<int>>>dp (n+1,vector<vector<int>>(odelay+1,vector<int>(oforget+1,0)));\\n        //vector<vector<int>>(0,vector<int>())\\n        vector<vector<int>>curr (odelay+1,vector<int>(oforget+1,0));\\n        vector<vector<int>>next (odelay+1,vector<int>(oforget+1,0));\\n        for(int index=n;index>=1;index--){\\n            for(int delay=0;delay<=odelay;delay++){\\n                for(int forget=0;forget<=oforget;forget++){\\n                    if(forget==0){curr[delay][forget]= 0;}\\n\\n                    else if(delay==0){\\n                        if(index+1>n){\\n                            curr[delay][forget]=2;\\n                        }\\n                        else{\\n                            curr[delay][forget]=(next[0][forget-1]%mod+next[odelay-1][oforget-1]%mod)%mod;\\n                        }\\n                     \\n                    }\\n                    else{\\n                        if(index+1>n){\\n                            curr[delay][forget]=1;\\n                        }\\n                        else{\\n                            curr[delay][forget]=next[delay-1][forget-1]%mod;\\n                        }\\n                        \\n                    } \\n                }\\n            }\\n            next=curr;\\n        }\\n\\n        return curr[odelay][oforget];\\n    }"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "You can also do it without DP.(2 for loops)\\nTry 3-4 test cases,think how you are incrementing the day with delay, that how many people who know the secret at a certain day store in a vector."
                    },
                    {
                        "username": "likhar",
                        "content": "What is wrong with this solution? It is giving wrong answer on test case 2.\n\ndp[i] => number of people which found out about the secret on ith day.\n\nanswer will be sum of dp[n]+dp[n-1]+.......+dp[n-forget+1].\n\nTransition -\n// d = delay\n\n=>dp[i] =  dp[i-d] + dp[i-d-1] +..........+ dp[i-forget+1]\n\n=>dp[i+1]  = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1] + dp[i-forget+1] - dp[i-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i] - dp[i-forget+1]\n\n=>let j=i+1\n=>dp[j] = dp[j-d] + dp[j-1] - dp[j-forget]\n=>dp[i] = dp[i-1] + dp[i-d] - dp[i-forget]\n\ndp[0] = 0;\ndp[1] = 1;\n\n ```\nint peopleAwareOfSecret(int n, int delay, int forget) {\n        vector<long long int> dp(n+1,0);\n        int d = delay;\n        int f = forget;\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i] = (i-d>0?dp[i-d]+dp[i-1]:0) - (i-f>0?dp[i-f]:0);\n            cout<<dp[i]<<\" \";\n        }\n        int mod = 1e9+7;\n        int ans=0;\n        while(f)\n        {\n            ans = (ans+dp[n-f+1])%mod;\n            f--;\n        }\n        return ans;\n    }\n```\n\nIn second test case, the dp array should be => 0 1 1 2 2\nBut it is coming out to be => 0 1 2 4 7"
                    }
                ]
            },
            {
                "id": 1736756,
                "content": [
                    {
                        "username": "Nitesh_Ag",
                        "content": "here i stuck in the test case\\nn=289,delay=7, forget=18;\\ni use unordered_map and 1 for loop\\n\\n//*************************************************************************************************//\\n    int peopleAwareOfSecret(int n, int delay, int forget) {\\n        unordered_map<int,long long>mpp;\\n        mpp[1]=1;\\n        int remen=pow(10,9)+7;\\n        long long sum=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long first=(mpp[i-forget]-sum)%remen;\\n             if(mpp[i-forget]==1 && sum==0 ) sum=1;\\n            //  else first=(mpp[i-forget]-sum)%remen;\\n             mpp[i]=(mpp[i-1]+mpp[i-delay]-sum-first)%remen;\\n            sum=(sum+first)%remen;\\n             cout<<i<<\" \"<<mpp[i]<<endl;\\n        }\\n        return mpp[n];\\n    }\\nmy code work properly for every input and output but due to some remen it gave error please find it\\n//**********************************************************************************************//"
                    },
                    {
                        "username": "realitant",
                        "content": "I was so close to getting this on my first try. No syntax errors, no indices off by 1, nothing.\\nI forgot the mod..."
                    },
                    {
                        "username": "ak7050971651",
                        "content": "int solveop(int n, int odelay, int oforget,int mod){\\n        //vector<vector<vector<int>>>dp (n+1,vector<vector<int>>(odelay+1,vector<int>(oforget+1,0)));\\n        //vector<vector<int>>(0,vector<int>())\\n        vector<vector<int>>curr (odelay+1,vector<int>(oforget+1,0));\\n        vector<vector<int>>next (odelay+1,vector<int>(oforget+1,0));\\n        for(int index=n;index>=1;index--){\\n            for(int delay=0;delay<=odelay;delay++){\\n                for(int forget=0;forget<=oforget;forget++){\\n                    if(forget==0){curr[delay][forget]= 0;}\\n\\n                    else if(delay==0){\\n                        if(index+1>n){\\n                            curr[delay][forget]=2;\\n                        }\\n                        else{\\n                            curr[delay][forget]=(next[0][forget-1]%mod+next[odelay-1][oforget-1]%mod)%mod;\\n                        }\\n                     \\n                    }\\n                    else{\\n                        if(index+1>n){\\n                            curr[delay][forget]=1;\\n                        }\\n                        else{\\n                            curr[delay][forget]=next[delay-1][forget-1]%mod;\\n                        }\\n                        \\n                    } \\n                }\\n            }\\n            next=curr;\\n        }\\n\\n        return curr[odelay][oforget];\\n    }"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "You can also do it without DP.(2 for loops)\\nTry 3-4 test cases,think how you are incrementing the day with delay, that how many people who know the secret at a certain day store in a vector."
                    },
                    {
                        "username": "likhar",
                        "content": "What is wrong with this solution? It is giving wrong answer on test case 2.\n\ndp[i] => number of people which found out about the secret on ith day.\n\nanswer will be sum of dp[n]+dp[n-1]+.......+dp[n-forget+1].\n\nTransition -\n// d = delay\n\n=>dp[i] =  dp[i-d] + dp[i-d-1] +..........+ dp[i-forget+1]\n\n=>dp[i+1]  = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i-d] +........+ dp[i+1-forget+1] + dp[i-forget+1] - dp[i-forget+1]\n=>dp[i+1] = dp[i+1-d] + dp[i] - dp[i-forget+1]\n\n=>let j=i+1\n=>dp[j] = dp[j-d] + dp[j-1] - dp[j-forget]\n=>dp[i] = dp[i-1] + dp[i-d] - dp[i-forget]\n\ndp[0] = 0;\ndp[1] = 1;\n\n ```\nint peopleAwareOfSecret(int n, int delay, int forget) {\n        vector<long long int> dp(n+1,0);\n        int d = delay;\n        int f = forget;\n        dp[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i] = (i-d>0?dp[i-d]+dp[i-1]:0) - (i-f>0?dp[i-f]:0);\n            cout<<dp[i]<<\" \";\n        }\n        int mod = 1e9+7;\n        int ans=0;\n        while(f)\n        {\n            ans = (ans+dp[n-f+1])%mod;\n            f--;\n        }\n        return ans;\n    }\n```\n\nIn second test case, the dp array should be => 0 1 1 2 2\nBut it is coming out to be => 0 1 2 4 7"
                    }
                ]
            }
        ]
    }
]