[
    {
        "title": "Largest Positive Integer That Exists With Its Negative",
        "question_content": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.\n\nExample 2:\n\nInput: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\n\nExample 3:\n\nInput: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t-1000 <= nums[i] <= 1000\n\tnums[i] != 0",
        "solutions": [
            {
                "id": 2708051,
                "title": "c-2-pointers-approach-easy-approach",
                "content": "**Please upvote if you find this solution helpful :)**\\n```\\nclass Solution \\n{\\npublic:\\n    int findMaxK(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int low=0, high=nums.size()-1;\\n        \\n        while(low < high)\\n        {\\n            if((nums[low] + nums[high]) == 0)\\n            {\\n                return  nums[high];\\n            }\\n            \\n            else if((nums[low] + nums[high]) < 0)\\n                low++;\\n            \\n            else high--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findMaxK(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int low=0, high=nums.size()-1;\\n        \\n        while(low < high)\\n        {\\n            if((nums[low] + nums[high]) == 0)\\n            {\\n                return  nums[high];\\n            }\\n            \\n            else if((nums[low] + nums[high]) < 0)\\n                low++;\\n            \\n            else high--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708072,
                "title": "python3-simple-o-n-beginner-friendly",
                "content": "First, convert the nums into a set for quick access.\\nSecond, go over the entire nums, for each element k, do:\\n1. check if k is positive.\\n2. check if -k exist in nums using the set, which takes O(1).\\n3. check if k is larger than the largest element we have seen so far. And if it is, update the largest element so far and the result.\\n\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        Set = set(nums) ### convert nums into a set\\n        maxSoFar = -inf\\n        res = -inf\\n        for n in nums:\\n        \\t### check condition 1-3\\n            if n>0 and -n in Set and n>maxSoFar:\\n                maxSoFar = n\\n                res = n\\n        ### If there is no such integer (res==-inf which never got updated), return -1.\\n        return res if res!=-inf else -1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        Set = set(nums) ### convert nums into a set\\n        maxSoFar = -inf\\n        res = -inf\\n        for n in nums:\\n        \\t### check condition 1-3\\n            if n>0 and -n in Set and n>maxSoFar:\\n                maxSoFar = n\\n                res = n\\n        ### If there is no such integer (res==-inf which never got updated), return -1.\\n        return res if res!=-inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708141,
                "title": "array",
                "content": "**C++**\\n```cpp\\nint findMaxK(vector<int>& nums) {\\n    int arr[2001] = {}, res = -1;\\n    for (int n : nums) {\\n        if (arr[-n + 1000])\\n            res = max(res, abs(n));\\n        ++arr[n + 1000];        \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint findMaxK(vector<int>& nums) {\\n    int arr[2001] = {}, res = -1;\\n    for (int n : nums) {\\n        if (arr[-n + 1000])\\n            res = max(res, abs(n));\\n        ++arr[n + 1000];        \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708447,
                "title": "variation-of-two-sum-problem-two-approaches",
                "content": "### First Approach\\n#### This problem is similar to Two sum problem \\n\\n`Two Sum Problem :-  finding two elements that make up a sum k`\\n`This problem :- the value of k is zero that is sum we need to find is 0 and then if there are multiple of them return the max`\\n\\nSo simply we need to find its additive inverse \\n\\n```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\t\\t// keep track of maximum\\n        int maxi = INT_MIN;\\n\\t\\t// set to remeber the other value \\n        unordered_set<int> s;\\n        for(auto i : nums){\\n            if(s.find(i * -1) == s.end()){\\n\\t\\t\\t\\t// if not found insert\\n                s.insert(i);\\n            }else{\\n\\t\\t\\t\\t// if found update maxi \\n                maxi = max(maxi, abs(i));\\n            }\\n        }\\n\\t\\t// if not present return -1 else return maxi\\n        return maxi == INT_MIN ? -1 : maxi;\\n    }\\n};\\n//  time complexiy O(n) \\n// space complexity O(n)\\n```\\n### Second Approach \\n\\n* sort the numbers then using two pointers solve the problem\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\t\\t// sort the numbers O(nlogn)\\n        sort(nums.begin(), nums.end());\\n        int l = 0, h = nums.size() - 1;\\n        while(l < h){\\n            int sum = nums[l] + nums[h];\\n\\t\\t\\t// if sum is zero we have found our answer\\n            if(sum == 0)\\n                return nums[h];\\n\\t\\t\\t// if sum is positive then we need to push right pointer to reduce the positiveness \\n            else if(sum > 0){\\n                h--;\\n            }else{\\n                l++;\\n            }\\n        }\\n\\t\\t// If not found\\n        return -1;\\n    }\\n};\\n// Time complexity: O(nlogn)\\n// Space complexity O(1)\\n// IDK Why but this one is faster than the O(n) solution\\n```\\n##### Edit:- \\n\\n* The reason Why the first approach is little bit slower is because unordered_map does some internal hashing which also costs some time \\n* But as the value of n keeps on increasing O(n) << O(nlogn) i.e time for computing Hash would be significantly lower than sorting\\n\\n[dvsip](https://leetcode.com/dvisp/) Thank you for pointing this out.",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```c++\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\t\\t// keep track of maximum\\n        int maxi = INT_MIN;\\n\\t\\t// set to remeber the other value \\n        unordered_set<int> s;\\n        for(auto i : nums){\\n            if(s.find(i * -1) == s.end()){\\n\\t\\t\\t\\t// if not found insert\\n                s.insert(i);\\n            }else{\\n\\t\\t\\t\\t// if found update maxi \\n                maxi = max(maxi, abs(i));\\n            }\\n        }\\n\\t\\t// if not present return -1 else return maxi\\n        return maxi == INT_MIN ? -1 : maxi;\\n    }\\n};\\n//  time complexiy O(n) \\n// space complexity O(n)\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\t\\t// sort the numbers O(nlogn)\\n        sort(nums.begin(), nums.end());\\n        int l = 0, h = nums.size() - 1;\\n        while(l < h){\\n            int sum = nums[l] + nums[h];\\n\\t\\t\\t// if sum is zero we have found our answer\\n            if(sum == 0)\\n                return nums[h];\\n\\t\\t\\t// if sum is positive then we need to push right pointer to reduce the positiveness \\n            else if(sum > 0){\\n                h--;\\n            }else{\\n                l++;\\n            }\\n        }\\n\\t\\t// If not found\\n        return -1;\\n    }\\n};\\n// Time complexity: O(nlogn)\\n// Space complexity O(1)\\n// IDK Why but this one is faster than the O(n) solution\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2708085,
                "title": "hashing-c-java",
                "content": "Count positive whose `negative` is there in the array using `hashing`.\\n\\nTime - O(`n`)\\nSpace - O(`n`)\\n# C++\\n    int findMaxK(vector<int>& a) {\\n        unordered_set<int> st(begin(a),end(a));\\n        int res = -1;\\n        for(int p : a) \\n            if(p > 0 and st.count(-p)) res = max(res , p);\\n        return res;\\n    }\\n\\t\\n# Java\\n    public int findMaxK(int[] nums) {\\n        HashSet<Integer> st = new HashSet<>();\\n        for (int i : nums) st.add(i);\\n        int res = -1;\\n        for (int p : nums)\\n\\t\\t     if (p > 0 && st.contains(-p)) res = Math.max(res, p);\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Count positive whose `negative` is there in the array using `hashing`.\\n\\nTime - O(`n`)\\nSpace - O(`n`)\\n# C++\\n    int findMaxK(vector<int>& a) {\\n        unordered_set<int> st(begin(a),end(a));\\n        int res = -1;\\n        for(int p : a) \\n            if(p > 0 and st.count(-p)) res = max(res , p);\\n        return res;\\n    }\\n\\t\\n# Java\\n    public int findMaxK(int[] nums) {\\n        HashSet<Integer> st = new HashSet<>();\\n        for (int i : nums) st.add(i);\\n        int res = -1;\\n        for (int p : nums)\\n\\t\\t     if (p > 0 && st.contains(-p)) res = Math.max(res, p);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2711300,
                "title": "c-6-different-approaches-clean-code",
                "content": "The leetcode runtimes are not very consistent, but approach 3 seems to be the fastest.\\n\\n### Approach 1: brute force (127ms)\\n\\nThe problem is constraint enough that we can just use brute force.\\n\\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = -1;\\n        for (int i : nums)\\n            for (int j : nums)\\n                if (i == -j) ans = max(ans, abs(i));\\n\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n^2)$$\\n  * Space complexity: $$O(1)$$\\n\\n### Approach 2: hash set, two passes (42ms)\\n\\nIn the first pass we keep track of all the negative numbers in a hash set and in the next pass we look at all to positive numbers.\\n\\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        unordered_set<int> neg;\\n        for (int num : nums) {\\n            if (num < 0) neg.insert(num);\\n        }\\n        int ans = -1;\\n        for (int num : nums) {\\n            if (num > ans && neg.count(-num)) ans = num;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(n)$$\\n\\n### Approach 3: bitset, two passes (7ms)\\n\\nThe input range is limited enough that we can just use a ```bitset```.\\n\\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        bitset<1024> neg;\\n        for (int num : nums) {\\n            if (num < 0) neg[-num] = true;\\n        }\\n        int ans = -1;\\n        for (int num : nums) {\\n            if (num > ans && neg[num]) ans = num;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(1)$$ albeit it\\'s a big 1.\\n\\n### Approach 4: hash set, single pass (36ms)\\n\\nIf we keep track of both negative and positive numbers we can also solve the problem in a single pass.\\n\\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = 0;\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            const int abs_num = abs(num);\\n            if (abs_num > ans && seen.count(-num)) ans = abs_num;\\n            seen.insert(num);\\n        }\\n        return ans ?: -1;\\n    }\\n```\\n\\nThe complexity is the same as approach 2.\\n\\n### Approach 5: bitset, single pass (29ms)\\n\\nAgain, we can just use a ```bitset```.\\n\\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = 0;\\n        bitset<2048> seen;\\n        for (int num : nums) {\\n            const int abs_num = abs(num);\\n            if (abs_num > ans && seen[-num + 1024]) ans = abs_num;\\n            seen[num + 1024] = true;\\n        }\\n        return ans ?: -1;\\n    }\\n```\\n\\nThe complexity is the same as approach 3.\\n\\n### Approach 6: sort and two pointers\\n\\nThis is a variation of a solution for the two sum problem, but we have to sort the input first. Note that all the other approach don\\'t modify ```nums```.\\n\\n```cpp\\n    static int findMaxK(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int lo = 0;\\n        int hi = size(nums) - 1;\\n        while (lo < hi) {\\n            if (-nums[lo] == nums[hi]) {\\n                return nums[hi];\\n            } else if (-nums[lo] > nums[hi]) {\\n                ++lo;\\n            } else {\\n                --hi;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n \\\\log n)$$ for the ```sort```ing the rest is linear.\\n  * Space complexity: $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = -1;\\n        for (int i : nums)\\n            for (int j : nums)\\n                if (i == -j) ans = max(ans, abs(i));\\n\\n        return ans;\\n    }\\n```\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        unordered_set<int> neg;\\n        for (int num : nums) {\\n            if (num < 0) neg.insert(num);\\n        }\\n        int ans = -1;\\n        for (int num : nums) {\\n            if (num > ans && neg.count(-num)) ans = num;\\n        }\\n        return ans;\\n    }\\n```\n```bitset```\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        bitset<1024> neg;\\n        for (int num : nums) {\\n            if (num < 0) neg[-num] = true;\\n        }\\n        int ans = -1;\\n        for (int num : nums) {\\n            if (num > ans && neg[num]) ans = num;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = 0;\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            const int abs_num = abs(num);\\n            if (abs_num > ans && seen.count(-num)) ans = abs_num;\\n            seen.insert(num);\\n        }\\n        return ans ?: -1;\\n    }\\n```\n```bitset```\n```cpp\\n    static int findMaxK(const vector<int>& nums) {\\n        int ans = 0;\\n        bitset<2048> seen;\\n        for (int num : nums) {\\n            const int abs_num = abs(num);\\n            if (abs_num > ans && seen[-num + 1024]) ans = abs_num;\\n            seen[num + 1024] = true;\\n        }\\n        return ans ?: -1;\\n    }\\n```\n```nums```\n```cpp\\n    static int findMaxK(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int lo = 0;\\n        int hi = size(nums) - 1;\\n        while (lo < hi) {\\n            if (-nums[lo] == nums[hi]) {\\n                return nums[hi];\\n            } else if (-nums[lo] > nums[hi]) {\\n                ++lo;\\n            } else {\\n                --hi;\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```sort```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708093,
                "title": "python-rust-fastest-100-using-two-pointers-binary-search-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n\\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/823480874/) employs sorting and a two-pointers approach. It demonstrated **127 ms runtime (100.00%)** and used **14.2 MB memory (33.33%)**. Time complexity is log-linear (due to sorting): **O(N\\\\*logN)**. Space complexity is constant (in-place operations): **O(1)**. \\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        \\n        # [1] two use two-pointers approach, we need\\n        #     to prepare the list by sorting\\n        nums.sort()\\n        \\n        # [2] move pointers towards each other to find\\n        #     largest positive integer with its negative\\n        i, j = 0, len(nums)-1\\n        while i < j:\\n            if nums[i] == - nums[j]:\\n                return nums[j]\\n            if abs(nums[i]) > abs(nums[j]):\\n                i += 1\\n            else:\\n                j -= 1\\n                \\n        return -1\\n```\\n\\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/823474467/) employs sorting and binary search. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (100.00%)**. Time complexity is log-linear (due to sorting): **O(N\\\\*logN)**. Space complexity is constant (in-place operations): **O(1)**. \\n```\\nimpl Solution \\n{\\n    pub fn find_max_k(mut nums: Vec<i32>) -> i32 \\n    {\\n        // [1] to use binary search, we need\\n        //     to prepare the list by sorting\\n        nums.sort();\\n        \\n        // [2] now we can move from the right\\n        //     and make binary search queries\\n        for i in (0..nums.len()).rev()\\n        {\\n            match nums.binary_search(&(-nums[i]))\\n            {\\n                Ok(j) => return nums[i],\\n                _ => {}\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        \\n        # [1] two use two-pointers approach, we need\\n        #     to prepare the list by sorting\\n        nums.sort()\\n        \\n        # [2] move pointers towards each other to find\\n        #     largest positive integer with its negative\\n        i, j = 0, len(nums)-1\\n        while i < j:\\n            if nums[i] == - nums[j]:\\n                return nums[j]\\n            if abs(nums[i]) > abs(nums[j]):\\n                i += 1\\n            else:\\n                j -= 1\\n                \\n        return -1\\n```\n```\\nimpl Solution \\n{\\n    pub fn find_max_k(mut nums: Vec<i32>) -> i32 \\n    {\\n        // [1] to use binary search, we need\\n        //     to prepare the list by sorting\\n        nums.sort();\\n        \\n        // [2] now we can move from the right\\n        //     and make binary search queries\\n        for i in (0..nums.len()).rev()\\n        {\\n            match nums.binary_search(&(-nums[i]))\\n            {\\n                Ok(j) => return nums[i],\\n                _ => {}\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707992,
                "title": "c-using-vector-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up Vote  if you like the solution\\n```\\n/*\\nSimply consider an array of size 1001, then keep on updating each nth index with value of n,\\nWhile placing value of n in array, keep on checking if it has already a number with opposite\\nsign is present or not. if present then take it as ans if it greater then prev ans \\n*/\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans = -1;\\n        vector<int> v(10001, 0);\\n        for(auto n: nums){\\n            if( v[abs(n)] != 0 && (v[abs(n)] + n == 0) ) ans = max(ans, abs(n));\\n            else v[abs(n)] = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimply consider an array of size 1001, then keep on updating each nth index with value of n,\\nWhile placing value of n in array, keep on checking if it has already a number with opposite\\nsign is present or not. if present then take it as ans if it greater then prev ans \\n*/\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans = -1;\\n        vector<int> v(10001, 0);\\n        for(auto n: nums){\\n            if( v[abs(n)] != 0 && (v[abs(n)] + n == 0) ) ans = max(ans, abs(n));\\n            else v[abs(n)] = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711038,
                "title": "python-2-lines-t-m-100-50",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        return max(({x for x in nums if -x in nums}), default=-1)\\n```\\n[https://leetcode.com/submissions/detail/823865222/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        return max(({x for x in nums if -x in nums}), default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129693,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        pos, neg= set(), set()\\n        for digit in nums:\\n            pos.add(digit) if digit > 0 else neg.add(digit)\\n            \\n        for digit in sorted(pos,reverse = True):\\n            if (digit*-1) in neg:\\n                return digit\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        pos, neg= set(), set()\\n        for digit in nums:\\n            pos.add(digit) if digit > 0 else neg.add(digit)\\n            \\n        for digit in sorted(pos,reverse = True):\\n            if (digit*-1) in neg:\\n                return digit\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709295,
                "title": "java-two-solutions-using-sorting-and-hash-set",
                "content": "Solution one, using sorting and hashset..\\nFirst, the array is sorted in ascending order and all the elements of the array are stored in a hashset. Then the sorted array is traversed from the end to the 0 index and whenever we found an element whose negative is also present in the hash set, we return the ans. Else returning -1 in the end.\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            set.add(nums[i]);\\n        }\\n        for(int i = nums.length-1; i>=0 ; i--){//Checking the largest numbers from the last index as the array is sorted\\n            if(set.contains(-nums[i])){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nTime Complexity: O(n Log n) \\nNow optimizing the code...\\nFirst traversing the entire array and adding all the elements in the hash set. Then initially assuming the ans as -1, iterating through the array and checking for every element whether it is greater than the current ans and its negative is also present in the hash set. Returning this answer variable in the end.\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++){\\n            set.add(nums[i]);\\n\\t\\t\\t}\\n        int ans = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > ans && set.contains(-nums[i]))\\n                ans = nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            set.add(nums[i]);\\n        }\\n        for(int i = nums.length-1; i>=0 ; i--){//Checking the largest numbers from the last index as the array is sorted\\n            if(set.contains(-nums[i])){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++){\\n            set.add(nums[i]);\\n\\t\\t\\t}\\n        int ans = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > ans && set.contains(-nums[i]))\\n                ans = nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708921,
                "title": "5-line-code-easy-understanding-beginner-level",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2441. Largest Positive Integer That Exists With Its Negative***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        a=sorted(set(nums))\\n        m=0\\n        for i in nums:\\n            if -i in a:\\n                m=max(m,i)\\n        return m  if m!=0 else -1\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        a=sorted(set(nums))\\n        m=0\\n        for i in nums:\\n            if -i in a:\\n                m=max(m,i)\\n        return m  if m!=0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708275,
                "title": "python-o-n",
                "content": "# Complexity\\n- Time complexity: O(nlog<sub>2</sub>n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            d[i] = d.get(i, 0)+1\\n        \\n        ans = -1\\n        for i in sorted(d.keys()):\\n            if i<0:\\n                continue\\n            elif i>0 and -i in d:\\n                ans = i\\n        \\n        return ans\\n```\\n--------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            d[i] = d.get(i, 0)+1\\n        \\n        ans = -1\\n        for i in sorted(d.keys()):\\n            if i<0:\\n                continue\\n            elif i>0 and -i in d:\\n                ans = i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534915,
                "title": "java-javascript-100-faster-4line-code",
                "content": "**PLEASE UPVOTE IF YOU LIKE IT**\\n# Complexity\\n- Time complexity:O(N)\\n- Space complexity:O(N)\\n\\n# Code\\n**JAVA**\\n```\\nclass Solution {\\n    public int findMaxK(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int max = -1;\\n        for (int i : arr) {\\n            if (map.containsKey(i * -1)) {\\n                max = Math.max(max, Math.abs(i));\\n            }\\n            map.put(i, 0);\\n        }\\n        return max;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <unordered_map>\\n#include <algorithm>\\n\\nint findMaxK(int arr[], int size) {\\n    std::unordered_map<int, int> map;\\n    int max = -1;\\n    for (int i = 0; i < size; i++) {\\n        if (map.count(arr[i] * -1)) {\\n            max = std::max(max, std::abs(arr[i]));\\n        }\\n        map[arr[i]] = 0;\\n    }\\n    return max;\\n}\\n```\\n**JAVASCRIPT**\\n```\\nvar findMaxK = function(arr) {\\n  const map = new Map()\\n  let max = -1;\\n  for(let i of arr){\\n    if(map.has(i * -1)){\\n      max = Math.max(max,Math.abs(i))\\n    }\\n    map.set(i, 0)\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int max = -1;\\n        for (int i : arr) {\\n            if (map.containsKey(i * -1)) {\\n                max = Math.max(max, Math.abs(i));\\n            }\\n            map.put(i, 0);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n#include <unordered_map>\\n#include <algorithm>\\n\\nint findMaxK(int arr[], int size) {\\n    std::unordered_map<int, int> map;\\n    int max = -1;\\n    for (int i = 0; i < size; i++) {\\n        if (map.count(arr[i] * -1)) {\\n            max = std::max(max, std::abs(arr[i]));\\n        }\\n        map[arr[i]] = 0;\\n    }\\n    return max;\\n}\\n```\n```\\nvar findMaxK = function(arr) {\\n  const map = new Map()\\n  let max = -1;\\n  for(let i of arr){\\n    if(map.has(i * -1)){\\n      max = Math.max(max,Math.abs(i))\\n    }\\n    map.set(i, 0)\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2718910,
                "title": "java-easiest-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = nums.length-1; j>=0; j--) {\\n                if(nums[i]+nums[j]==0)return nums[j];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = nums.length-1; j>=0; j--) {\\n                if(nums[i]+nums[j]==0)return nums[j];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711268,
                "title": "short-javascript-solution-using-a-set-object",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst findMaxK = (nums) => {\\n    let numsSet = new Set(nums)\\n    let largestInteger = -Infinity\\n\\n    for (let num of numsSet) {\\n        if (num > 0 && numsSet.has(-num)) {\\n            largestInteger = Math.max(largestInteger, num)\\n        }\\n    }\\n\\n    return largestInteger === -Infinity ? -1 : largestInteger\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findMaxK = (nums) => {\\n    let numsSet = new Set(nums)\\n    let largestInteger = -Infinity\\n\\n    for (let num of numsSet) {\\n        if (num > 0 && numsSet.has(-num)) {\\n            largestInteger = Math.max(largestInteger, num)\\n        }\\n    }\\n\\n    return largestInteger === -Infinity ? -1 : largestInteger\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709302,
                "title": "c-2-pointers-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int l = 0;\\n        int r = nums.size() - 1;\\n        \\n        while(l < r){\\n            if(nums[l]*-1 == nums[r]){\\n                return nums[r];\\n            } else if (nums[l]*-1 < nums[r]){\\n                r--;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int l = 0;\\n        int r = nums.size() - 1;\\n        \\n        while(l < r){\\n            if(nums[l]*-1 == nums[r]){\\n                return nums[r];\\n            } else if (nums[l]*-1 < nums[r]){\\n                r--;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077945,
                "title": "easy-to-understand-c-solution-using-set-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI used the set to store the numbers in sorted order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set <int> s;\\n        for(int i:nums) s.insert(i);\\n        int mini=INT_MIN;\\n        for(auto it:s){\\n            if(it<0){\\n                if(s.find(abs(it))!=s.end()){\\n                    mini=max(abs(it),mini);\\n                }\\n            }\\n        }\\n        if(mini!=INT_MIN)\\n            return mini;\\n            else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set <int> s;\\n        for(int i:nums) s.insert(i);\\n        int mini=INT_MIN;\\n        for(auto it:s){\\n            if(it<0){\\n                if(s.find(abs(it))!=s.end()){\\n                    mini=max(abs(it),mini);\\n                }\\n            }\\n        }\\n        if(mini!=INT_MIN)\\n            return mini;\\n            else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874000,
                "title": "python-sort-double-pointers",
                "content": "https://leetcode.com/submissions/detail/854012683/\\n```\\nRuntime: 126 ms, faster than 98.12% of Python3 online submissions for Largest Positive Integer That Exists With Its Negative.\\nMemory Usage: 14.1 MB, less than 90.76% of Python3 online submissions for Largest Positive Integer That Exists With Its Negative.\\n```\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l = len(nums)\\n        i, j = 0, l-1\\n        while i<l and j>=0:\\n            if -nums[i]==nums[j]:\\n                return nums[j]\\n            elif -nums[i]<nums[j]:\\n                j-=1\\n            else:\\n                i+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nRuntime: 126 ms, faster than 98.12% of Python3 online submissions for Largest Positive Integer That Exists With Its Negative.\\nMemory Usage: 14.1 MB, less than 90.76% of Python3 online submissions for Largest Positive Integer That Exists With Its Negative.\\n```\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l = len(nums)\\n        i, j = 0, l-1\\n        while i<l and j>=0:\\n            if -nums[i]==nums[j]:\\n                return nums[j]\\n            elif -nums[i]<nums[j]:\\n                j-=1\\n            else:\\n                i+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854520,
                "title": "simple-c-solution-o-n-2-pointer-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0,e=nums.size()-1;\\n        while(s<e){\\n            if(nums[s]+nums[e]==0)\\n                return nums[e];\\n            else if(nums[s]+nums[e]<0)s++;\\n            else\\n                e--;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0,e=nums.size()-1;\\n        while(s<e){\\n            if(nums[s]+nums[e]==0)\\n                return nums[e];\\n            else if(nums[s]+nums[e]<0)s++;\\n            else\\n                e--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2774238,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in nums[::-1]:\\n            if -i in nums:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in nums[::-1]:\\n            if -i in nums:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739610,
                "title": "java-easiest-two-pointer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n      Arrays.sort(nums);\\n      for(int i = 0; i < nums.length; i ++) {\\n          for(int j = nums.length - 1; j > 0; j --) \\n          if(nums[i] + nums[j] == 0) return nums[j];\\n      }  \\n      return - 1;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n      Arrays.sort(nums);\\n      for(int i = 0; i < nums.length; i ++) {\\n          for(int j = nums.length - 1; j > 0; j --) \\n          if(nums[i] + nums[j] == 0) return nums[j];\\n      }  \\n      return - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718067,
                "title": "java-2-pointer-easiest-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = nums.length-1; j>=0; j--) {\\n                if(nums[i]+nums[j]==0)return nums[j];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = nums.length-1; j>=0; j--) {\\n                if(nums[i]+nums[j]==0)return nums[j];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708814,
                "title": "java-hashset-easy-to-understand",
                "content": "```\\n    //Runtime: 5 ms, faster than 100.00% of Java online submissions for Largest Positive Integer That Exists With Its Negative.\\n    //Memory Usage: 42.5 MB, less than 60.00% of Java online submissions for Largest Positive Integer That Exists With Its Negative.\\n\\t//Time: O(N); Space: O(N)\\n    public int findMaxK(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++)\\n            //if (nums[i] < 0)\\n            set.add(nums[i]);\\n\\n        int res = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > res && set.contains(-nums[i]))\\n                res = nums[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\n    //Runtime: 5 ms, faster than 100.00% of Java online submissions for Largest Positive Integer That Exists With Its Negative.\\n    //Memory Usage: 42.5 MB, less than 60.00% of Java online submissions for Largest Positive Integer That Exists With Its Negative.\\n\\t//Time: O(N); Space: O(N)\\n    public int findMaxK(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++)\\n            //if (nums[i] < 0)\\n            set.add(nums[i]);\\n\\n        int res = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > res && set.contains(-nums[i]))\\n                res = nums[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708519,
                "title": "binary-search-o-nlogn-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int> &nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (nums[i] < 0) return -1;\\n            if (binary_search(nums.begin(), nums.end(), -nums[i])) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(N * logN)**\\nSpace Complexity: **O(1)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int> &nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (nums[i] < 0) return -1;\\n            if (binary_search(nums.begin(), nums.end(), -nums[i])) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708215,
                "title": "c-intuitive-hashmap-short-code",
                "content": "```\\nint findMaxK(vector<int>& nums) {\\n        \\n        map<int,int> mp ;\\n        for( auto it : nums ) mp[it]++;\\n        \\n        int ans = INT_MIN ;\\n        bool gotAnsr = false ;\\n        \\n        for( int i=0 ; i<nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ) {\\n                if( mp.find( 0-nums[i] ) != mp.end() ){\\n                    \\n                    ans = max( ans, nums[i] );\\n                    gotAnsr = true ;\\n                }\\n            }\\n        }\\n        \\n        if( gotAnsr ) return ans ;\\n        return -1 ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findMaxK(vector<int>& nums) {\\n        \\n        map<int,int> mp ;\\n        for( auto it : nums ) mp[it]++;\\n        \\n        int ans = INT_MIN ;\\n        bool gotAnsr = false ;\\n        \\n        for( int i=0 ; i<nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ) {\\n                if( mp.find( 0-nums[i] ) != mp.end() ){\\n                    \\n                    ans = max( ans, nums[i] );\\n                    gotAnsr = true ;\\n                }\\n            }\\n        }\\n        \\n        if( gotAnsr ) return ans ;\\n        return -1 ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708212,
                "title": "2-pointers",
                "content": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = 0 , j = nums.size()-1;\\n        for(int k = 0 ; k < nums.size() ; k++){\\n            if(-nums[i] == nums[j]) return nums[j];\\n            else if(-nums[i] > nums[j]) i++;\\n            else j--;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = 0 , j = nums.size()-1;\\n        for(int k = 0 ; k < nums.size() ; k++){\\n            if(-nums[i] == nums[j]) return nums[j];\\n            else if(-nums[i] > nums[j]) i++;\\n            else j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2708184,
                "title": "c-array",
                "content": "Bruteforce Approach \\n```\\n int findMaxK(vector<int>& nums) {\\n        int maxi = -1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (nums[i] == nums[j]*-1)\\n                    maxi = max(nums[i], maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int findMaxK(vector<int>& nums) {\\n        int maxi = -1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (nums[i] == nums[j]*-1)\\n                    maxi = max(nums[i], maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708148,
                "title": "c-simple-brute-force-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int sum = 0;\\n        int maxi = -1;\\n        for(int i=0;i<n;i++){\\n           int a =  nums[i];           \\n           for(int j=i+1;j<n;j++){\\n               if(a+nums[j] == 0){\\n                   sum = nums[j];\\n                   if(nums[j] > maxi ){\\n                       maxi = nums[j];\\n                 }\\n               }\\n           }\\n       }\\n        if(maxi > 0){\\n            return maxi;\\n        }\\n         return -1;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int sum = 0;\\n        int maxi = -1;\\n        for(int i=0;i<n;i++){\\n           int a =  nums[i];           \\n           for(int j=i+1;j<n;j++){\\n               if(a+nums[j] == 0){\\n                   sum = nums[j];\\n                   if(nums[j] > maxi ){\\n                       maxi = nums[j];\\n                 }\\n               }\\n           }\\n       }\\n        if(maxi > 0){\\n            return maxi;\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533058,
                "title": "easiest-c-map-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& a) {\\n        int i,j,k,ans=INT_MIN;\\n        unordered_map<int,int>m;\\n        for(auto x : a){\\n            if(m.find(-x)!=m.end())\\n            ans=max(abs(x),ans);\\n\\n            m[x]++;\\n        }\\n        if(ans==INT_MIN)\\n        return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& a) {\\n        int i,j,k,ans=INT_MIN;\\n        unordered_map<int,int>m;\\n        for(auto x : a){\\n            if(m.find(-x)!=m.end())\\n            ans=max(abs(x),ans);\\n\\n            m[x]++;\\n        }\\n        if(ans==INT_MIN)\\n        return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401937,
                "title": "c-easy-solution-4-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans=-1;\\n        for(int it : nums)\\n        {\\n            if(it>0 && count(nums.begin(),nums.end(),-it)) ans=max(ans,it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans=-1;\\n        for(int it : nums)\\n        {\\n            if(it>0 && count(nums.begin(),nums.end(),-it)) ans=max(ans,it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823642,
                "title": "easy-to-understand-for-loop-comparison-80-faster",
                "content": "``` \\nvar findMaxK = function(nums) {\\n    let obj = {};\\n    let arr = [-1];\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        for(let j = i + 1; j < nums.length; j++){\\n            if(nums[i] === -nums[j]) arr.push(Math.abs(nums[j]))\\n        }\\n    }\\n    \\n    return Math.max(...arr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar findMaxK = function(nums) {\\n    let obj = {};\\n    let arr = [-1];\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        for(let j = i + 1; j < nums.length; j++){\\n            if(nums[i] === -nums[j]) arr.push(Math.abs(nums[j]))\\n        }\\n    }\\n    \\n    return Math.max(...arr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793863,
                "title": "82-faster-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& vec) {\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        int j = vec.size() - 1;\\n        while(i < j && vec[i] < 0 && vec[j] > 0) {\\n            if(vec[i] == -vec[j]) return vec[j];\\n            if(abs(vec[i]) < vec[j]) {\\n                j--;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n     return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& vec) {\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        int j = vec.size() - 1;\\n        while(i < j && vec[i] < 0 && vec[j] > 0) {\\n            if(vec[i] == -vec[j]) return vec[j];\\n            if(abs(vec[i]) < vec[j]) {\\n                j--;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n     return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748541,
                "title": "explained-java-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max = -1;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length ; i++){\\n            if(nums[i] > 0){\\n                // Adding all the positive numbers in the set.\\n                set.add(nums[i]);\\n            }\\n        }\\n         for(int i = 0; i < nums.length ; i++){\\n//              If a negative number is found, we check whether it\\'s positive counterpart is greater than max. \\n//              If yes, we check whether we have that number in our set or not. If we have, we set max to it.\\n            if(nums[i] < 0 && (-1)*nums[i] > max){\\n                if(set.contains((-1)*nums[i])){\\n                    max = (-1)*nums[i];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max = -1;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length ; i++){\\n            if(nums[i] > 0){\\n                // Adding all the positive numbers in the set.\\n                set.add(nums[i]);\\n            }\\n        }\\n         for(int i = 0; i < nums.length ; i++){\\n//              If a negative number is found, we check whether it\\'s positive counterpart is greater than max. \\n//              If yes, we check whether we have that number in our set or not. If we have, we set max to it.\\n            if(nums[i] < 0 && (-1)*nums[i] > max){\\n                if(set.contains((-1)*nums[i])){\\n                    max = (-1)*nums[i];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719705,
                "title": "two-sum-c-java-4-lines-solution-sorting",
                "content": "\\n\\n# Code\\nJAVA solution \\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n         for(int i=0;i<nums.length;i++)\\n            for(int j=nums.length-1;j>=0;j--)\\n                if(nums[i]+nums[j]==0) return nums[j];\\n        return -1;\\n    }\\n}\\n```\\nC++ solution \\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n            for(int j=nums.size()-1;j>=0;j--)\\n                if(nums[i]+nums[j]==0) return nums[j];\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n         for(int i=0;i<nums.length;i++)\\n            for(int j=nums.length-1;j>=0;j--)\\n                if(nums[i]+nums[j]==0) return nums[j];\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n            for(int j=nums.size()-1;j>=0;j--)\\n                if(nums[i]+nums[j]==0) return nums[j];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717993,
                "title": "java-hashset-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> hs = new HashSet();\\n        int max = -1;\\n        for(int i=0;i<nums.length;++i){\\n            hs.add(nums[i]);\\n            if(hs.contains(nums[i]*-1))     max = Math.max(max , Math.max(nums[i],nums[i]*-1));\\n        }\\n        return max;\\n    }\\n}\\n```\\n*Kindly upvote if you find it helpful*",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> hs = new HashSet();\\n        int max = -1;\\n        for(int i=0;i<nums.length;++i){\\n            hs.add(nums[i]);\\n            if(hs.contains(nums[i]*-1))     max = Math.max(max , Math.max(nums[i],nums[i]*-1));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716047,
                "title": "hash-map",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*  constant map size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        short score[1001] = {0};\\n        \\n        for(int num: nums)\\n            if(num < 0)\\n                score[-num] = (score[-num] == 0 || score[-num] == -1) ? -1 : 2;\\n            else\\n                score[num] = (score[num] == 0 || score[num] == 1) ? 1 : 2;\\n        \\n        for(int i = 1000; i > 0; i--)\\n            if(score[i] == 2)\\n                return i;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        short score[1001] = {0};\\n        \\n        for(int num: nums)\\n            if(num < 0)\\n                score[-num] = (score[-num] == 0 || score[-num] == -1) ? -1 : 2;\\n            else\\n                score[num] = (score[num] == 0 || score[num] == 1) ? 1 : 2;\\n        \\n        for(int i = 1000; i > 0; i--)\\n            if(score[i] == 2)\\n                return i;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711178,
                "title": "python-simple-solution-in-5-lines-faster-than-100",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        m=-1\\n        for i in nums:\\n            if i>m:\\n                if i*(-1) in nums: m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        m=-1\\n        for i in nums:\\n            if i>m:\\n                if i*(-1) in nums: m=i\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708415,
                "title": "java-two-pointer-approach",
                "content": "Using ArraySort + Two Pointer Approach : \\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int largest = -1;\\n        Arrays.sort(nums); //Sort Array\\n        int l=0,r=nums.length-1;\\n        while(l<r){\\n            if(nums[l]+nums[r]==0 && nums[r]>largest)\\n                largest=nums[r];\\n            else if(nums[l]+nums[r]>0)\\n                r--;\\n            else\\n                l++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int largest = -1;\\n        Arrays.sort(nums); //Sort Array\\n        int l=0,r=nums.length-1;\\n        while(l<r){\\n            if(nums[l]+nums[r]==0 && nums[r]>largest)\\n                largest=nums[r];\\n            else if(nums[l]+nums[r]>0)\\n                r--;\\n            else\\n                l++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708283,
                "title": "rust-three-solutions-with-comments",
                "content": "EDIT 2022-10-17: Revisiting this as I didn\\'t like my contest submission. Here is a cleaner implementation of the same approach as the contest submission:\\n\\n```\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut set = nums.iter().fold(vec![false; 1001], |mut v, num| {\\n            if *num < 0 {\\n                v[-*num as usize] = true;\\n            }\\n            v\\n        });\\n        nums.into_iter().filter(|num| *num > 0 && set[*num as usize]).max().unwrap_or(-1)\\n    }\\n}\\n```\\n\\nand here is a one-pass solution, using an array as a set to keep track of whether we\\'ve seen a certain positive/negative number using bit flags:\\n\\n```\\nconst POS: u8 = 1 << 0;\\nconst NEG: u8 = 1 << 1;\\n\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().scan([0_u8; 1001], |set, num| {\\n            if num > 0 {\\n                set[num as usize] |= POS;\\n                Some((num, set[num as usize]))\\n            } else {\\n                set[-num as usize] |= NEG;\\n                Some((-num, set[-num as usize]))\\n            }\\n        }).filter_map(|(num, state)| (state == POS | NEG).then(|| num)).max().unwrap_or(-1)\\n    }\\n}\\n```\\n\\n**Original Post**\\n\\nThis is my unrevised submission for the 2022-10-16 Weekly Contest 315. Collect all numbers in a set. Then for every positive number, check of the negative number is in the set.\\n\\nComment: Could have been done with just an array to map the negative numbers, but I was lazy and went for a set. I relaxed too much and made some mistakes before I got it right - lesson learned.\\n\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut set = nums.iter().copied().collect::<HashSet<_>>();\\n        let mut max = None;\\n        for num in nums {\\n            if num > 0 && set.contains(&-num) {\\n                if max.is_none() {\\n                    max = Some(num);\\n                } else {\\n                    max = Some(max.unwrap().max(num));\\n                }\\n                \\n            }\\n        }\\n        max.unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut set = nums.iter().fold(vec![false; 1001], |mut v, num| {\\n            if *num < 0 {\\n                v[-*num as usize] = true;\\n            }\\n            v\\n        });\\n        nums.into_iter().filter(|num| *num > 0 && set[*num as usize]).max().unwrap_or(-1)\\n    }\\n}\\n```\n```\\nconst POS: u8 = 1 << 0;\\nconst NEG: u8 = 1 << 1;\\n\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().scan([0_u8; 1001], |set, num| {\\n            if num > 0 {\\n                set[num as usize] |= POS;\\n                Some((num, set[num as usize]))\\n            } else {\\n                set[-num as usize] |= NEG;\\n                Some((-num, set[-num as usize]))\\n            }\\n        }).filter_map(|(num, state)| (state == POS | NEG).then(|| num)).max().unwrap_or(-1)\\n    }\\n}\\n```\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut set = nums.iter().copied().collect::<HashSet<_>>();\\n        let mut max = None;\\n        for num in nums {\\n            if num > 0 && set.contains(&-num) {\\n                if max.is_none() {\\n                    max = Some(num);\\n                } else {\\n                    max = Some(max.unwrap().max(num));\\n                }\\n                \\n            }\\n        }\\n        max.unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708135,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int, set<int>> mp;\\n        for(auto &it: nums) {\\n            mp[abs(it)].insert(it);\\n        }\\n        int maxi = INT_MIN;\\n        \\n        for(auto &it: mp) {\\n            if(it.second.size() == 2) {\\n                maxi = max(it.first, maxi);\\n            }\\n        }\\n        return maxi == INT_MIN ? -1 : maxi;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int, set<int>> mp;\\n        for(auto &it: nums) {\\n            mp[abs(it)].insert(it);\\n        }\\n        int maxi = INT_MIN;\\n        \\n        for(auto &it: mp) {\\n            if(it.second.size() == 2) {\\n                maxi = max(it.first, maxi);\\n            }\\n        }\\n        return maxi == INT_MIN ? -1 : maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708116,
                "title": "c-simple-and-easy-to-understand",
                "content": "explanation:- \\nfind the positive number if it is greater than previous answer than search for negative integer if foud than update the answer to the positive number \\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] > 0 && nums[i] > ans)\\n            {\\n                for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] < 0 && (nums[j]*-1) == nums[i])\\n                    {\\n                        ans = nums[i];\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int ans = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] > 0 && nums[i] > ans)\\n            {\\n                for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] < 0 && (nums[j]*-1) == nums[i])\\n                    {\\n                        ans = nums[i];\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708045,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set<int> s;\\n        for(int x:nums)\\n            s.insert(x);\\n        int maxi=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.find(-nums[i])!=s.end())\\n                maxi=max(maxi,nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set<int> s;\\n        for(int x:nums)\\n            s.insert(x);\\n        int maxi=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.find(-nums[i])!=s.end())\\n                maxi=max(maxi,nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979872,
                "title": "simple-easy-cpp-solution",
                "content": "\\n\\n# Complexity \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        int ans = -1;\\n\\n        for(auto x : m){\\n            int ele = -x.first;\\n            if(m.find(ele) != m.end() ){\\n                ans = max(ans,x.first);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        int ans = -1;\\n\\n        for(auto x : m){\\n            int ele = -x.first;\\n            if(m.find(ele) != m.end() ){\\n                ans = max(ans,x.first);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752668,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\nsort(nums.begin(), nums.end());\\nreverse(nums.begin(), nums.end());\\n    map<int, int>mp;\\n    for(int i =0; i<nums.size(); i++){\\n        mp[nums[i]]++;\\n    }\\n  for(int i =0;i<nums.size(); i++){\\n   int z = nums[i];\\n   if(mp.find(-z)!=mp.end())return z;\\n  }\\n  return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\nsort(nums.begin(), nums.end());\\nreverse(nums.begin(), nums.end());\\n    map<int, int>mp;\\n    for(int i =0; i<nums.size(); i++){\\n        mp[nums[i]]++;\\n    }\\n  for(int i =0;i<nums.size(); i++){\\n   int z = nums[i];\\n   if(mp.find(-z)!=mp.end())return z;\\n  }\\n  return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723920,
                "title": "easy-solution-100-beats-fully-explained",
                "content": "# Approach\\nThe given problem asks for finding the largest positive integer \"k\" in an integer array such that its negative value \"-k\" also exists in the array. If such a number is found, it should be returned as the output. Otherwise, if no such number exists, the function should return -1.\\n\\nHere\\'s a detailed, clear, and concise explanation of the approach used in the provided solution:\\n\\n1. Start by initializing a variable named `prev` with the maximum possible integer value, `Integer.MAX_VALUE`. This variable will be used to keep track of the current maximum value encountered in the array.\\n\\n2. Enter an infinite loop using `while (true)` since we don\\'t know the termination condition upfront.\\n\\n3. Inside the loop, call the `getMax()` function to find the maximum value in the array that is less than the `prev` value. The `getMax()` function iterates over the array elements and updates the `max` variable if a larger element is found. This function returns the maximum value found.\\n\\n4. If the returned maximum value from `getMax()` is `Integer.MIN_VALUE`, it means there are no more valid values less than the previous maximum. In this case, break out of the loop.\\n\\n5. If a valid maximum value is found, check if its negative counterpart exists in the array using the `hasNegative()` function. This function iterates over the array elements and returns `true` if it finds a number that is the negative of the current maximum value.\\n\\n6. If a negative counterpart is found, return the current maximum value as the output, since it satisfies the condition.\\n\\n7. If no negative counterpart is found, continue the loop, updating the `prev` value with the current maximum value found.\\n\\n8. If the loop completes without finding a valid maximum value with its negative counterpart, return -1 as the output, indicating that no such number exists in the array.\\n\\nThe approach traverses the array multiple times to find the maximum value and check for its negative counterpart. While this solution is correct, it may not be the most efficient one, as it has a time complexity of O(n^2), where n is the length of the input array.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int prev = Integer.MAX_VALUE;\\n\\n        while(true){\\n            prev = getMax(nums, prev);\\n            if(prev == Integer.MIN_VALUE) \\n                break;\\n            if(hasNegative(nums, prev)) \\n                return prev;\\n        }\\n\\n        return -1;\\n    }\\n\\n    public int getMax(int[] nums, int prev){\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            if(num > max && num < prev)\\n                max = num;\\n        return max;\\n    }\\n\\n    public boolean hasNegative(int[] nums, int max) {\\n        for(int i = 0; i < nums.length; i++)\\n            if(nums[i] == -1 * max)\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int prev = Integer.MAX_VALUE;\\n\\n        while(true){\\n            prev = getMax(nums, prev);\\n            if(prev == Integer.MIN_VALUE) \\n                break;\\n            if(hasNegative(nums, prev)) \\n                return prev;\\n        }\\n\\n        return -1;\\n    }\\n\\n    public int getMax(int[] nums, int prev){\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            if(num > max && num < prev)\\n                max = num;\\n        return max;\\n    }\\n\\n    public boolean hasNegative(int[] nums, int max) {\\n        for(int i = 0; i < nums.length; i++)\\n            if(nums[i] == -1 * max)\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388752,
                "title": "largest-positive-integer-naive-and-easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, the thing coming to mind is the need to separate positive and negative numbers from the array and then search for the maximum positive number from that array having its negative value present in the array too.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe positive and negative numbers from array num are divided into two different arrays v1 which has all positive numbers and v2 having all negatives. Then sort both the arrays with sort() function. Then, iterate from the last element in the array v1 and iterate over the array v2 simultaneously from starting element and check whether (v1[i]==abs(v2[j])) or not if yes, then return k=v1[i] else check whether (v1[i]>abs(v2[j])) if yes, then break the inner for loop. At the end if no such number is found which is the case when all numbers are positive, return -1;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Time complexity of this approach is O(nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        int x=nums.size();\\n        int y=0,z=0;\\n        for(int i=0;i<x;i++){\\n            if(nums[i]>=0){\\n                v1.push_back(nums[i]);\\n                y++;\\n            }else{\\n                v2.push_back(nums[i]);\\n                z++;\\n            }\\n        }\\n        int k=0;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=y-1;i>=0;i--){\\n            for(int j=0;j<z;j++){\\n                if(abs(v2[j])==v1[i]){\\n                    k=v1[i];\\n                    return k;\\n                }else if(abs(v2[j])<v1[i]){\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        int x=nums.size();\\n        int y=0,z=0;\\n        for(int i=0;i<x;i++){\\n            if(nums[i]>=0){\\n                v1.push_back(nums[i]);\\n                y++;\\n            }else{\\n                v2.push_back(nums[i]);\\n                z++;\\n            }\\n        }\\n        int k=0;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=y-1;i>=0;i--){\\n            for(int j=0;j<z;j++){\\n                if(abs(v2[j])==v1[i]){\\n                    k=v1[i];\\n                    return k;\\n                }else if(abs(v2[j])<v1[i]){\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353001,
                "title": "largest-positive-with-its-negative-js-nums-indexof-83-ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    result = -1\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums.indexOf(-nums[i], i+1) > 0) \\n            if (Math.abs(nums[i]) > result) result = Math.abs(nums[i])            \\n    }\\n\\n    return result\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    result = -1\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums.indexOf(-nums[i], i+1) > 0) \\n            if (Math.abs(nums[i]) > result) result = Math.abs(nums[i])            \\n    }\\n\\n    return result\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3340381,
                "title": "largest-positive-integer-that-exists-with-its-negative-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int i, j;\\n        sort(nums.begin(), nums.end());\\n        for(i=nums.size()-1 ; i>=0 ; i--)\\n        {\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]<0 && abs(nums[j])==nums[i])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int i, j;\\n        sort(nums.begin(), nums.end());\\n        for(i=nums.size()-1 ; i>=0 ; i--)\\n        {\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]<0 && abs(nums[j])==nums[i])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101103,
                "title": "set-for-loop-efficient-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    const numsSet = new Set();\\n    let res = -1;\\n\\n    for (const num of nums) {\\n        if (Math.abs(num) <= res) continue;\\n        if (numsSet.has(-num)) {\\n            res = Math.abs(num);\\n        }\\n        numsSet.add(num);\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    const numsSet = new Set();\\n    let res = -1;\\n\\n    for (const num of nums) {\\n        if (Math.abs(num) <= res) continue;\\n        if (numsSet.has(-num)) {\\n            res = Math.abs(num);\\n        }\\n        numsSet.add(num);\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054585,
                "title": "easiest-5-liner-approach-please-upvote-if-you-like-the-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0, h=nums.size()-1;\\n        while(l < h)\\n        {\\n            if((nums[l] + nums[h]) == 0) return  nums[h];\\n            else if((nums[l] + nums[h]) < 0) l++;\\n            else h--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0, h=nums.size()-1;\\n        while(l < h)\\n        {\\n            if((nums[l] + nums[h]) == 0) return  nums[h];\\n            else if((nums[l] + nums[h]) < 0) l++;\\n            else h--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982925,
                "title": "python-simple-efficient-approach-using-dictionary",
                "content": "# Approach\\nPlease let me know in the comment section if you have any doubts about the solution, and I\\'ll be happy to clarify.\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int :\\n        dict1 = {}\\n        res = []\\n        for i in nums :\\n            if abs(i) in dict1.keys() :\\n                if dict1[abs(i)] + i == 0 :\\n                    res.append(abs(i))\\n            else:\\n                dict1.update({abs(i) : i})\\n        if res : \\n            return max(res)\\n        else : \\n            return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int :\\n        dict1 = {}\\n        res = []\\n        for i in nums :\\n            if abs(i) in dict1.keys() :\\n                if dict1[abs(i)] + i == 0 :\\n                    res.append(abs(i))\\n            else:\\n                dict1.update({abs(i) : i})\\n        if res : \\n            return max(res)\\n        else : \\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911049,
                "title": "easiest-python-solution-with-comments-way-concise-than-most-voted",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        # 1) Optimal (HashSet): TC = O(n); SC = O(n)\\n        hs = set()  # for O(1) lookup\\n        max_k = -1  # \"If there is no such integer, return `-1`.\"\\n        for k in nums:\\n            if -k in hs:  # check\\n                max_k = max(max_k, abs(k))  # `abs(num)` because \"Return the positive integer `k`.\"\\n            hs.add(k)  # save\\n        return max_k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        # 1) Optimal (HashSet): TC = O(n); SC = O(n)\\n        hs = set()  # for O(1) lookup\\n        max_k = -1  # \"If there is no such integer, return `-1`.\"\\n        for k in nums:\\n            if -k in hs:  # check\\n                max_k = max(max_k, abs(k))  # `abs(num)` because \"Return the positive integer `k`.\"\\n            hs.add(k)  # save\\n        return max_k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891092,
                "title": "my-submission-using-treemap-java",
                "content": "- 337/337 cases passed (11 ms)\\n- Your runtime beats 62.61 % of java submissions\\n- Your memory usage beats 84.51 % of java submissions (42.7 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        TreeMap<Integer,Integer> t=new TreeMap<>();\\n        \\n        for(int i:nums)t.put(i, i);\\n\\n        for(Integer i:t.descendingKeySet())\\n              if(i==-t.getOrDefault(-i, 0))\\n                return i;\\n        \\n          \\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        TreeMap<Integer,Integer> t=new TreeMap<>();\\n        \\n        for(int i:nums)t.put(i, i);\\n\\n        for(Integer i:t.descendingKeySet())\\n              if(i==-t.getOrDefault(-i, 0))\\n                return i;\\n        \\n          \\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854812,
                "title": "rust-using-a-hashset",
                "content": "\\nShort version:\\n```rust\\nuse std::collections::HashSet;\\n\\npub fn find_max_k(nums: impl AsRef<[i32]>) -> i32 {\\n    let nums = nums.as_ref();\\n\\n    let mut seen = HashSet::new();\\n    let mut max = -1;\\n\\n    for n in nums.iter().copied() {\\n        if seen.contains(&(-n)) {\\n            max = n.abs().max(max);\\n        }\\n\\n        seen.insert(n);\\n    }\\n\\n    max\\n}\\n```\\n\\nOptimised version:\\n\\n```rust\\nuse std::collections::HashSet;\\n\\npub fn find_max_k(nums: impl AsRef<[i32]>) -> i32 {\\n    let nums = nums.as_ref();\\n    let mut max = 0;\\n    let mut seen = HashSet::new();\\n\\n    for n in nums.iter().copied() {\\n        // skip elements that cannot improve the answer\\n        // because adding/checking the hashset is slow\\n        if n.abs() <= max {\\n            continue;\\n        }\\n\\n        // If we\\'ve seen the same number, but with the opposite sign,\\n        // then update the answer.\\n        // Note that because we\\'ve already checked if this number is larger\\n        // we can just assign it without checking it a second time\\n        if seen.contains(&(-n)) {\\n            max = n.abs();\\n            continue;\\n        }\\n\\n        // This number is larger than the current maximum\\n        // and we\\'ve not seen it with any (+/-) sign\\n        seen.insert(n);\\n    }\\n\\n    max\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\npub fn find_max_k(nums: impl AsRef<[i32]>) -> i32 {\\n    let nums = nums.as_ref();\\n\\n    let mut seen = HashSet::new();\\n    let mut max = -1;\\n\\n    for n in nums.iter().copied() {\\n        if seen.contains(&(-n)) {\\n            max = n.abs().max(max);\\n        }\\n\\n        seen.insert(n);\\n    }\\n\\n    max\\n}\\n```\n```rust\\nuse std::collections::HashSet;\\n\\npub fn find_max_k(nums: impl AsRef<[i32]>) -> i32 {\\n    let nums = nums.as_ref();\\n    let mut max = 0;\\n    let mut seen = HashSet::new();\\n\\n    for n in nums.iter().copied() {\\n        // skip elements that cannot improve the answer\\n        // because adding/checking the hashset is slow\\n        if n.abs() <= max {\\n            continue;\\n        }\\n\\n        // If we\\'ve seen the same number, but with the opposite sign,\\n        // then update the answer.\\n        // Note that because we\\'ve already checked if this number is larger\\n        // we can just assign it without checking it a second time\\n        if seen.contains(&(-n)) {\\n            max = n.abs();\\n            continue;\\n        }\\n\\n        // This number is larger than the current maximum\\n        // and we\\'ve not seen it with any (+/-) sign\\n        seen.insert(n);\\n    }\\n\\n    max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793941,
                "title": "c-o-n-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& vec) {\\n        unordered_set<int> st;\\n        int ans;\\n        int res = -1;\\n        for(auto i : vec) st.insert(i);\\n        for(auto i : vec) {\\n            if(st.find(-i) != st.end()) {\\n                ans = abs(i);\\n                res = max(res, ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\'\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& vec) {\\n        unordered_set<int> st;\\n        int ans;\\n        int res = -1;\\n        for(auto i : vec) st.insert(i);\\n        for(auto i : vec) {\\n            if(st.find(-i) != st.end()) {\\n                ans = abs(i);\\n                res = max(res, ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789765,
                "title": "c-hashmap-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        int ans = -1;\\n        \\n        for( auto i : nums ){\\n            mp[i]++;\\n        }\\n        \\n        for( auto i : nums ){\\n            if( i>0 && mp.find(-1*i) != mp.end() ){\\n                ans = max( ans, i );\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        int ans = -1;\\n        \\n        for( auto i : nums ){\\n            mp[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2763635,
                "title": "swift-brute-force-two-pointer",
                "content": "\\n# - Brute Force\\n\\ncomplexity\\uFF1AO(n) \\n\\n```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tvar result = -1\\n\\tvar dict = [Int: Int]()\\n\\n\\tfor num in nums {\\n\\t\\tdict[num, default: 0] += 1\\n\\n\\t\\tif let _ = dict[-num] {\\n\\t\\t\\tresult = max(result, abs(num))\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\nmore faster\\n\\n```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tvar result = -1\\n\\tvar dict = [Int: Int]()\\n\\n\\tfor i in 0...nums.count/2 {\\n\\t\\tlet left = nums[i]\\n\\t\\tlet right = nums[nums.count-1-i]\\n\\n\\t\\tdict[left, default: 0] += 1\\n\\t\\tdict[right, default: 0] += 1\\n\\n\\t\\tif let _ = dict[-left] {\\n\\t\\t\\tresult = max(result, abs(left))\\n\\t\\t}\\n\\t\\tif let _ = dict[-right] {\\n\\t\\t\\tresult = max(result, abs(right))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n<br>\\n\\n# - Two Pointer\\n\\ncomplexity\\uFF1AO(n log n)\\n\\n```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tlet sortedNums = nums.sorted()\\n\\tvar start = 0, end = nums.count-1\\n\\n\\twhile start < end {\\n\\t\\tlet left = sortedNums[start]\\n\\t\\tlet right = sortedNums[end]\\n\\t\\tlet sum = left + right\\n\\n\\t\\tif sum == 0 {\\n\\t\\t\\treturn right\\n\\t\\t}\\n\\t\\tif sum < 0 {\\n\\t\\t\\tstart += 1\\n\\t\\t} else if 0 < sum {\\n\\t\\t\\tend -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tvar result = -1\\n\\tvar dict = [Int: Int]()\\n\\n\\tfor num in nums {\\n\\t\\tdict[num, default: 0] += 1\\n\\n\\t\\tif let _ = dict[-num] {\\n\\t\\t\\tresult = max(result, abs(num))\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tvar result = -1\\n\\tvar dict = [Int: Int]()\\n\\n\\tfor i in 0...nums.count/2 {\\n\\t\\tlet left = nums[i]\\n\\t\\tlet right = nums[nums.count-1-i]\\n\\n\\t\\tdict[left, default: 0] += 1\\n\\t\\tdict[right, default: 0] += 1\\n\\n\\t\\tif let _ = dict[-left] {\\n\\t\\t\\tresult = max(result, abs(left))\\n\\t\\t}\\n\\t\\tif let _ = dict[-right] {\\n\\t\\t\\tresult = max(result, abs(right))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc findMaxK(_ nums: [Int]) -> Int {\\n\\tlet sortedNums = nums.sorted()\\n\\tvar start = 0, end = nums.count-1\\n\\n\\twhile start < end {\\n\\t\\tlet left = sortedNums[start]\\n\\t\\tlet right = sortedNums[end]\\n\\t\\tlet sum = left + right\\n\\n\\t\\tif sum == 0 {\\n\\t\\t\\treturn right\\n\\t\\t}\\n\\t\\tif sum < 0 {\\n\\t\\t\\tstart += 1\\n\\t\\t} else if 0 < sum {\\n\\t\\t\\tend -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746883,
                "title": "1-line-javascript-easy-to-understand",
                "content": "```\\nfindMaxK=(s, jz = new Set(s), sol = -1)=>{for(z of s)if(z > 0 && z > sol && jz.has(-z))sol = z;return sol}\\n```\\nif you like it please subscribe: https://www.youtube.com/channel/UCyrEBoz0korE69X-escwMnw/videos",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfindMaxK=(s, jz = new Set(s), sol = -1)=>{for(z of s)if(z > 0 && z > sol && jz.has(-z))sol = z;return sol}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741970,
                "title": "python-easy-faster-than-80",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        maxi = -1\\n        for i in nums: \\n            if (0-i) in nums:\\n                maxi = max(maxi,i)\\n        return maxi\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        maxi = -1\\n        for i in nums: \\n            if (0-i) in nums:\\n                maxi = max(maxi,i)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735618,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.first<0){\\n                int a=0;\\n                a=abs(i.first);\\n                if(mp[a]>=1){\\n                    return a;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.first<0){\\n                int a=0;\\n                a=abs(i.first);\\n                if(mp[a]>=1){\\n                    return a;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733798,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public int FindMaxK(int[] nums) \\n    {\\n        nums = nums.OrderByDescending(x=>x).ToArray();\\n        int i=0;\\n        int j= nums.Length - 1;\\n\\n        while(j>i)\\n        {\\n            if (nums[i] == -1*nums[j])\\n            {\\n                return nums[i];\\n            }\\n            else if (nums[i] > -1*nums[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }  \\n\\n        return -1;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindMaxK(int[] nums) \\n    {\\n        nums = nums.OrderByDescending(x=>x).ToArray();\\n        int i=0;\\n        int j= nums.Length - 1;\\n\\n        while(j>i)\\n        {\\n            if (nums[i] == -1*nums[j])\\n            {\\n                return nums[i];\\n            }\\n            else if (nums[i] > -1*nums[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }  \\n\\n        return -1;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730386,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set<int> st;\\n        for(auto itr: nums){\\n            st.insert(itr);\\n        }\\n        int ans=-1;\\n        for(auto itr: st){\\n            if(itr>0){\\n                if(st.find(-itr)!=st.end()){\\n                    ans=max(ans, itr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        set<int> st;\\n        for(auto itr: nums){\\n            st.insert(itr);\\n        }\\n        int ans=-1;\\n        for(auto itr: st){\\n            if(itr>0){\\n                if(st.find(-itr)!=st.end()){\\n                    ans=max(ans, itr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727952,
                "title": "sorted-hashset-is-98-faster-with-two-pointer-technique",
                "content": "_Sorting the set(nums) and going through two pointers_\\n\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n\\t\\tnums=sorted(set(nums))\\n        i, j = 0, len(nums)-1\\n        while i < j:\\n            if nums[i] == - nums[j]: return nums[j]\\n            if abs(nums[i]) > abs(nums[j]): i += 1\\n            else: j -= 1\\n        return -1\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f28776e4-89d2-441e-a974-95f676f55e60_1666330464.1243658.png)\\n",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n\\t\\tnums=sorted(set(nums))\\n        i, j = 0, len(nums)-1\\n        while i < j:\\n            if nums[i] == - nums[j]: return nums[j]\\n            if abs(nums[i]) > abs(nums[j]): i += 1\\n            else: j -= 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725291,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int max = -1;\\n        for (Integer n : set) {\\n            if (set.contains(-n) && Math.abs(n) > max) {\\n                max = Math.abs(n);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int max = -1;\\n        for (Integer n : set) {\\n            if (set.contains(-n) && Math.abs(n) > max) {\\n                max = Math.abs(n);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723787,
                "title": "nlogn-hashset-o-n-and-o-1",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        max_ = -1\\n        for i in nums:\\n            if -i in nums:\\n                if max_ < abs(i):\\n                    max_ = abs(i)\\n        return max(-1,max_)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        max_ = -1\\n        for i in nums:\\n            if -i in nums:\\n                if max_ < abs(i):\\n                    max_ = abs(i)\\n        return max(-1,max_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723214,
                "title": "scala-partition-set-contains",
                "content": "```scala\\ndef findMaxK(nums: Array[Int]): Int = {\\n  val (negative, positive) = nums.partition(_ < 0)\\n  val negativeSet = negative.toSet\\n  positive.filter(i => negativeSet.contains(-i)).maxOption.getOrElse(-1)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef findMaxK(nums: Array[Int]): Int = {\\n  val (negative, positive) = nums.partition(_ < 0)\\n  val negativeSet = negative.toSet\\n  positive.filter(i => negativeSet.contains(-i)).maxOption.getOrElse(-1)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2719334,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& ar) \\n    {\\n        sort(ar.begin(), ar.end());\\n        int n = ar.size();\\n        int i = 0 ,  j = n - 1;\\n        int ans = -1;\\n        while(i < j){\\n            if(abs(ar[i]) ==  ar[j] && ar[i] < 0){\\n                ans = max(ans , ar[j]);\\n                i++;\\n                j--;\\n            }\\n            else if(abs(ar[i]) > ar[j]){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& ar) \\n    {\\n        sort(ar.begin(), ar.end());\\n        int n = ar.size();\\n        int i = 0 ,  j = n - 1;\\n        int ans = -1;\\n        while(i < j){\\n            if(abs(ar[i]) ==  ar[j] && ar[i] < 0){\\n                ans = max(ans , ar[j]);\\n                i++;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2713238,
                "title": "c-cpp-easy-understanding-sort-two-pointer",
                "content": "**C++ Code for Largest Positive Integer That Exists With Its Negative :**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int start=0;\\n        int end=nums.size()-1;\\n        \\n        while(start<end){\\n            if(nums[start]+nums[end]==0){\\n                return nums[end];\\n            }\\n            else if(nums[start]+nums[end]>0){\\n                end--;\\n            }\\n            else if(nums[start]+nums[end]<0){\\n                start++;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Upvote if finds Helpful !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int start=0;\\n        int end=nums.size()-1;\\n        \\n        while(start<end){\\n            if(nums[start]+nums[end]==0){\\n                return nums[end];\\n            }\\n            else if(nums[start]+nums[end]>0){\\n                end--;\\n            }\\n            else if(nums[start]+nums[end]<0){\\n                start++;\\n            }\\n            else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711806,
                "title": "easy-java-solution-5ms-100-better",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j)\\n        {\\n            if(nums[i]<0)\\n            {\\n                if(Math.abs(nums[i])==nums[j])\\n                    return nums[j];\\n                if(Math.abs(nums[i])<nums[j])\\n                    j--;\\n                if(Math.abs(nums[i])>nums[j])\\n                    i++;\\n            }\\n            else\\n                break;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j)\\n        {\\n            if(nums[i]<0)\\n            {\\n                if(Math.abs(nums[i])==nums[j])\\n                    return nums[j];\\n                if(Math.abs(nums[i])<nums[j])\\n                    j--;\\n                if(Math.abs(nums[i])>nums[j])\\n                    i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2711589,
                "title": "c-easy-two-approaches",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int ans=-1;\\n        for(auto &i:nums)\\n        {\\n            if(m.find(-1*i)!=m.end())\\n            {\\n                ans=max(ans,abs(i));\\n            }\\n            else\\n            {\\n                m[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        map<int,int>m;\\n        int ans=-1;\\n        for(auto &i:nums)\\n        {\\n            if(i<0)\\n            {\\n                pq.push(i);\\n            }\\n            else \\n            {\\n                m[i]++;\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            int curr=pq.top();\\n            pq.pop();\\n            if(m.find(abs(curr))!=m.end())\\n            {\\n                ans=abs(curr);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int ans=-1;\\n        for(auto &i:nums)\\n        {\\n            if(m.find(-1*i)!=m.end())\\n            {\\n                ans=max(ans,abs(i));\\n            }\\n            else\\n            {\\n                m[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        map<int,int>m;\\n        int ans=-1;\\n        for(auto &i:nums)\\n        {\\n            if(i<0)\\n            {\\n                pq.push(i);\\n            }\\n            else \\n            {\\n                m[i]++;\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            int curr=pq.top();\\n            pq.pop();\\n            if(m.find(abs(curr))!=m.end())\\n            {\\n                ans=abs(curr);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711526,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut counter = [0_i32; 1001];\\n        let mut k = -1;\\n        nums.iter().for_each(|&x| {\\n            let n = &mut counter[x.unsigned_abs() as usize];\\n            let (sign_x, sign_n) = (x.signum(), (*n).signum());\\n            match sign_n {\\n                0 => *n = sign_x,\\n                _ if sign_n != sign_x => k = k.max(x.abs()),\\n                _ => (),\\n            }\\n        });\\n        k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\\n        let mut counter = [0_i32; 1001];\\n        let mut k = -1;\\n        nums.iter().for_each(|&x| {\\n            let n = &mut counter[x.unsigned_abs() as usize];\\n            let (sign_x, sign_n) = (x.signum(), (*n).signum());\\n            match sign_n {\\n                0 => *n = sign_x,\\n                _ if sign_n != sign_x => k = k.max(x.abs()),\\n                _ => (),\\n            }\\n        });\\n        k\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710399,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        for(int x : nums) list.add(x);\\n\\t\\t\\n        for(int i = 0;i<list.size();i++){\\n            int max = list.get(i) * -1;\\n            if(list.contains(max)){\\n               return max;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n//Time Complexity O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        for(int x : nums) list.add(x);\\n\\t\\t\\n        for(int i = 0;i<list.size();i++){\\n            int max = list.get(i) * -1;\\n            if(list.contains(max)){\\n               return max;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n//Time Complexity O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709883,
                "title": "java-hashset-clean-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) set.add(i);\\n\\n        int ans = -1;\\n\\n        for (int i : nums) {\\n            if (i > 0 && set.contains(-i)) {\\n                ans = Math.max(ans, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) set.add(i);\\n\\n        int ans = -1;\\n\\n        for (int i : nums) {\\n            if (i > 0 && set.contains(-i)) {\\n                ans = Math.max(ans, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708901,
                "title": "well-commented-elegant-o-nlogn",
                "content": "**Please upvote this if u find this helpful**\\n\\n```\\nint findMaxK(vector<int>& nums) {\\n//first sort the given vector\\n      sort(nums.begin(),nums.end());  \\n //now apply two pointer approach \\n\\t    int i=0,j=nums.size()-1;\\n//now we can have 4 cases \\n        while(j>i){\\n            if(nums[j]>abs(nums[i])) j--; \\n//then ans can only lie in left of j so do j--  not i++ \\n//cause there can be case that ans value lie in j-- part so do j--\\n            else if(nums[j]<abs(nums[i])) i++;\\n// we got abs(nums[j])==nums[i] but this can be cause of two cases\\n//1.actually nums[i] and nums[j] both>0 that is why in this case \\n//we can do either of i++ or j-- but not both(cause of \\n//dupplicate absoulte value same situation) so we did j--\\n//2.another case is our ans case\\n            else if(nums[j]==nums[i])j--;\\n            else return nums[j];\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxK(vector<int>& nums) {\\n//first sort the given vector\\n      sort(nums.begin(),nums.end());  \\n //now apply two pointer approach \\n\\t    int i=0,j=nums.size()-1;\\n//now we can have 4 cases \\n        while(j>i){\\n            if(nums[j]>abs(nums[i])) j--; \\n//then ans can only lie in left of j so do j--  not i++ \\n//cause there can be case that ans value lie in j-- part so do j--\\n            else if(nums[j]<abs(nums[i])) i++;\\n// we got abs(nums[j])==nums[i] but this can be cause of two cases\\n//1.actually nums[i] and nums[j] both>0 that is why in this case \\n//we can do either of i++ or j-- but not both(cause of \\n//dupplicate absoulte value same situation) so we did j--\\n//2.another case is our ans case\\n            else if(nums[j]==nums[i])j--;\\n            else return nums[j];\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708513,
                "title": "largest-positive-integer-that-exists-with-its-negative",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708444,
                "title": "javascript-o-n",
                "content": "```\\nvar findMaxK = function(nums) {\\n    let max = 0;\\n    const set = new Set();\\n    const pos = [];\\n    for(const num of nums) {\\n        if(num<0){\\n            set.add(num);\\n        }\\n        else {\\n            pos.push(num);\\n        }\\n    }\\n    for(const num of pos) {\\n        if(num > max && set.has(-num)) {\\n            max = num;\\n        }\\n    }\\n    return max === 0 ? -1 : max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMaxK = function(nums) {\\n    let max = 0;\\n    const set = new Set();\\n    const pos = [];\\n    for(const num of nums) {\\n        if(num<0){\\n            set.add(num);\\n        }\\n        else {\\n            pos.push(num);\\n        }\\n    }\\n    for(const num of pos) {\\n        if(num > max && set.has(-num)) {\\n            max = num;\\n        }\\n    }\\n    return max === 0 ? -1 : max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708409,
                "title": "java-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        Set<Integer> set = new HashSet<>();\\n        for(int item: nums) {\\n            if(item > 0) {\\n                pq.add(item);\\n            } else {\\n                set.add(item);\\n            }\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            int k = pq.poll();\\n            if(set.contains(0 - k)) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        Set<Integer> set = new HashSet<>();\\n        for(int item: nums) {\\n            if(item > 0) {\\n                pq.add(item);\\n            } else {\\n                set.add(item);\\n            }\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            int k = pq.poll();\\n            if(set.contains(0 - k)) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708387,
                "title": "hashing-java",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> map = new HashSet<>();\\n        int res = -1;\\n        for(int i: nums){\\n            if(map.contains(-i) && Math.abs(i) > res){\\n                res = Math.abs(i);\\n            }\\n            map.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> map = new HashSet<>();\\n        int res = -1;\\n        for(int i: nums){\\n            if(map.contains(-i) && Math.abs(i) > res){\\n                res = Math.abs(i);\\n            }\\n            map.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708218,
                "title": "c-map-easy-self-explanatory",
                "content": "```\\nint findMaxK(vector<int>& nums) {\\n        map<int,int,greater<int>>mp;\\n        for(auto i : nums) mp[i]++;\\n        for(auto i : mp) if(mp.count(0-i.first)) return i.first;\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findMaxK(vector<int>& nums) {\\n        map<int,int,greater<int>>mp;\\n        for(auto i : nums) mp[i]++;\\n        for(auto i : mp) if(mp.count(0-i.first)) return i.first;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708190,
                "title": "c-accepted-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> ump;\\n        sort(nums.begin(),nums.end());\\n        ump[abs(nums[0])]++;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            ump[abs(nums[i])]++;\\n        }\\n        int ma=-1;\\n        for(auto it:ump){\\n            if(it.second==2)\\n                ma=max(ma,it.first);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int> ump;\\n        sort(nums.begin(),nums.end());\\n        ump[abs(nums[0])]++;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            ump[abs(nums[i])]++;\\n        }\\n        int ma=-1;\\n        for(auto it:ump){\\n            if(it.second==2)\\n                ma=max(ma,it.first);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708127,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            s=-1*i\\n            if s in nums:\\n                l.append(i)\\n        if len(l)==0:\\n            return -1\\n        maxi=l[0]\\n        for i in l:\\n            if i>maxi:\\n                maxi=i\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            s=-1*i\\n            if s in nums:\\n                l.append(i)\\n        if len(l)==0:\\n            return -1\\n        maxi=l[0]\\n        for i in l:\\n            if i>maxi:\\n                maxi=i\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708118,
                "title": "a-good-approach",
                "content": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int size = nums.size();\\n        int cute_first=0;\\n        int cute_last = size-1;\\n\\n        sort(nums.begin(),nums.end());\\n        for(int k=0;k<size;k++){\\n            if(-nums[cute_first]==nums[cute_last]){\\n                return nums[cute_last];\\n            }else if(-nums[cute_first]>nums[cute_last]) cute_first++;\\n            else cute_last--;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int size = nums.size();\\n        int cute_first=0;\\n        int cute_last = size-1;\\n\\n        sort(nums.begin(),nums.end());\\n        for(int k=0;k<size;k++){\\n            if(-nums[cute_first]==nums[cute_last]){\\n                return nums[cute_last];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2708103,
                "title": "c-brute-force-easy-weekly-contest-315",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n          vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == -nums[j])\\n                    ans.push_back(max(nums[i],nums[j]));\\n            }\\n            \\n        }\\n        int maxi=-1;\\n        for(int  i=0;i<ans.size();i++){\\n            maxi = max(maxi,ans[i]);\\n            //cout<<ans[i];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n          vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == -nums[j])\\n                    ans.push_back(max(nums[i],nums[j]));\\n            }\\n            \\n        }\\n        int maxi=-1;\\n        for(int  i=0;i<ans.size();i++){\\n            maxi = max(maxi,ans[i]);\\n            //cout<<ans[i];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2708088,
                "title": "c-easy-to-understand-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto &x:nums)\\n        {\\n            m[x]=1;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(nums[i])!=m.end() and m.find(-nums[i])!=m.end() and ans<abs(nums[i]))\\n            {\\n                ans=abs(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto &x:nums)\\n        {\\n            m[x]=1;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(nums[i])!=m.end() and m.find(-nums[i])!=m.end() and ans<abs(nums[i]))\\n            {\\n                ans=abs(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708086,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        x=[]\\n        flag=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==-nums[j]:\\n                        x.append(nums[i])\\n                        flag=1\\n                        break\\n            if flag==1:\\n                break\\n        if len(x)==0:\\n            return -1\\n        return abs(x[0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        x=[]\\n        flag=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==-nums[j]:\\n                        x.append(nums[i])\\n                        flag=1\\n                        break\\n            if flag==1:\\n                break\\n        if len(x)==0:\\n            return -1\\n        return abs(x[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708048,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int findMaxK(vector<int>&v) {\\n        set<ll>st(begin(v), end(v));\\n        for(auto it=st.rbegin(); it!=st.rend();++it){\\n            if(st.find(-*it)!=st.end()){\\n                return *it;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int findMaxK(vector<int>&v) {\\n        set<ll>st(begin(v), end(v));\\n        for(auto it=st.rbegin(); it!=st.rend();++it){\\n            if(st.find(-*it)!=st.end()){\\n                return *it;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708037,
                "title": "java-o-n-time-o-n-space",
                "content": "```\\npublic int findMaxK(int[] nums) {\\n\\t\\tPriorityQueue<Integer> p = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tPriorityQueue<Integer> n = new PriorityQueue<>();\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (i > 0) p.add(i);\\n\\t\\t\\telse n.add(i);\\n\\t\\t}\\n\\t\\twhile (!p.isEmpty() && !n.isEmpty()) {\\n\\t\\t\\tint a = p.peek();\\n\\t\\t\\tint b = n.peek();\\n\\t\\t\\tif (a + b == 0) return a;\\n\\t\\t\\telse if (a + b > 0) p.remove();\\n\\t\\t\\telse if (a + b < 0) n.remove();\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findMaxK(int[] nums) {\\n\\t\\tPriorityQueue<Integer> p = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tPriorityQueue<Integer> n = new PriorityQueue<>();\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (i > 0) p.add(i);\\n\\t\\t\\telse n.add(i);\\n\\t\\t}\\n\\t\\twhile (!p.isEmpty() && !n.isEmpty()) {\\n\\t\\t\\tint a = p.peek();\\n\\t\\t\\tint b = n.peek();\\n\\t\\t\\tif (a + b == 0) return a;\\n\\t\\t\\telse if (a + b > 0) p.remove();\\n\\t\\t\\telse if (a + b < 0) n.remove();\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2707994,
                "title": "python-easy-solution",
                "content": "```\\ndef findMaxK(self, nums: List[int]) -> int:\\n        seen = set(nums)\\n        \\n        for num in sorted(list(nums), reverse = True):\\n            if -num in seen:\\n                return num\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\ndef findMaxK(self, nums: List[int]) -> int:\\n        seen = set(nums)\\n        \\n        for num in sorted(list(nums), reverse = True):\\n            if -num in seen:\\n                return num\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092651,
                "title": "two-lines-solution",
                "content": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        set_negative = set(-n for n in nums if n < 0)\\n        return max((n for n in nums if n in set_negative), default= -1)    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        set_negative = set(-n for n in nums if n < 0)\\n        return max((n for n in nums if n in set_negative), default= -1)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079826,
                "title": "2441-largest-positive-integer-that-exists-with-its-negative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int n=nums.length;\\n        while(n>0){\\n            if(nums[i]<0){\\n            for(int j=i;j<nums.length;j++){\\n                int a=nums[i];\\n                if((-1*a)==nums[j]){\\n                    return -1*a;\\n                }\\n            }\\n            i++;\\n            }\\n            n--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int n=nums.length;\\n        while(n>0){\\n            if(nums[i]<0){\\n            for(int j=i;j<nums.length;j++){\\n                int a=nums[i];\\n                if((-1*a)==nums[j]){\\n                    return -1*a;\\n                }\\n            }\\n            i++;\\n            }\\n            n--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079391,
                "title": "c-solution-using-hashset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int FindMaxK(int[] nums)\\n    {\\n        var max = -1;\\n        var set = new HashSet<int>();\\n\\n        foreach (var num in nums)\\n        {\\n            if (set.Contains(-num))\\n            {\\n                max = Math.Max(max, Math.Abs(num));\\n            }\\n\\n            set.Add(num);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int FindMaxK(int[] nums)\\n    {\\n        var max = -1;\\n        var set = new HashSet<int>();\\n\\n        foreach (var num in nums)\\n        {\\n            if (set.Contains(-num))\\n            {\\n                max = Math.Max(max, Math.Abs(num));\\n            }\\n\\n            set.Add(num);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074336,
                "title": "simple-answer-w-walkthrough-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to look for the existence of the negative corresponding value, for each value in the list. If we find two values that exist with their negative, then we compare it to the max value. Which is what will be returned in the end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of we create the max variable that will contain the max value that exists in the list with its negative.\\nThe for loop will run through the values of the list.\\nFir each value we look for the existance of the correspondinf negative value.\\nIf it exists we compare it with the max value; if the it\\'s superior max value will be set to i.\\nFinally we return the max value once the for loop ends.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        max = -1\\n        for i in nums:\\n            if (-i) in nums and i> max:\\n                max = i\\n        return max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        max = -1\\n        for i in nums:\\n            if (-i) in nums and i> max:\\n                max = i\\n        return max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061607,
                "title": "easy-to-understand",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    nums.sort((a,b) => b - a)\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums.includes(-nums[i])) {\\n            return nums[i]\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    nums.sort((a,b) => b - a)\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums.includes(-nums[i])) {\\n            return nums[i]\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055492,
                "title": "simple-and-clean-solution-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        d = {}\\n        mx = 0\\n\\n        for i in range(n):\\n            if ((-1)*nums[i]) in d:\\n                mx = max(mx,abs(nums[i]))\\n            else:\\n                d[nums[i]] = i\\n        if mx == 0:\\n            return -1\\n        return (mx)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        d = {}\\n        mx = 0\\n\\n        for i in range(n):\\n            if ((-1)*nums[i]) in d:\\n                mx = max(mx,abs(nums[i]))\\n            else:\\n                d[nums[i]] = i\\n        if mx == 0:\\n            return -1\\n        return (mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039528,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        result = [x for x in sorted(nums)[::-1] if x > 0 and -x in nums]\\n        return result[0] if len(result) > 0 else -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        result = [x for x in sorted(nums)[::-1] if x > 0 and -x in nums]\\n        return result[0] if len(result) > 0 else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032984,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j && nums[i]<0)\\n        {\\n            if(Math.abs(nums[i])<=nums[j])\\n            {\\n               if(Math.abs(nums[i])==nums[j])\\n                 return nums[j];\\n               else\\n                  j--;  \\n            }\\n            else\\n               i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j && nums[i]<0)\\n        {\\n            if(Math.abs(nums[i])<=nums[j])\\n            {\\n               if(Math.abs(nums[i])==nums[j])\\n                 return nums[j];\\n               else\\n                  j--;  \\n            }\\n            else\\n               i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022991,
                "title": "largest-positive-integer-that-exists-with-its-negative-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            if(i>max && Search(nums,-1*i))\\n            {\\n                max=i;\\n            }\\n        }\\n        return (max==Integer.MIN_VALUE)?-1:max;\\n    }\\n    public boolean Search(int nums[], int n)\\n    {\\n        for(int j:nums)\\n        if(j==n)\\n        return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            if(i>max && Search(nums,-1*i))\\n            {\\n                max=i;\\n            }\\n        }\\n        return (max==Integer.MIN_VALUE)?-1:max;\\n    }\\n    public boolean Search(int nums[], int n)\\n    {\\n        for(int j:nums)\\n        if(j==n)\\n        return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019080,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function (nums) {\\n\\n    // initialize result to -1\\n    let result = -1;\\n\\n    // loop through every element of array nums\\n    for (let i = 0; i < nums.length; i++) {\\n\\n        // find existInt from array nums using slice() and includes()\\n        let existInt = nums.slice(i + 1).includes(-nums[i]);\\n\\n        // if existInt is true and result is less than every element of nums or result is less than every element of negative value of nums then add absolute value of that element of nums into result \\n        if (existInt && (result < nums[i] || result < -nums[i])) {\\n\\n            result = Math.abs(nums[i]);\\n        }\\n    }\\n\\n    // return the result \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function (nums) {\\n\\n    // initialize result to -1\\n    let result = -1;\\n\\n    // loop through every element of array nums\\n    for (let i = 0; i < nums.length; i++) {\\n\\n        // find existInt from array nums using slice() and includes()\\n        let existInt = nums.slice(i + 1).includes(-nums[i]);\\n\\n        // if existInt is true and result is less than every element of nums or result is less than every element of negative value of nums then add absolute value of that element of nums into result \\n        if (existInt && (result < nums[i] || result < -nums[i])) {\\n\\n            result = Math.abs(nums[i]);\\n        }\\n    }\\n\\n    // return the result \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016473,
                "title": "java-hashset-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int res = -1;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(set.contains(nums[i] * (-1))){\\n                res = Math.max(res, Math.abs(nums[i]));\\n            }\\n            set.add(nums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int res = -1;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(set.contains(nums[i] * (-1))){\\n                res = Math.max(res, Math.abs(nums[i]));\\n            }\\n            set.add(nums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016308,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n2441. Largest Positive Integer That Exists With Its Negative\\nhttps://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/\\n\\nGiven an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\\n\\nReturn the positive integer k. If there is no such integer, return -1.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [-1,2,-3,3]\\nOutput: 3\\nExplanation: 3 is the only valid k we can find in the array.\\nExample 2:\\n\\nInput: nums = [-1,10,6,7,-7,1]\\nOutput: 7\\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\\nExample 3:\\n\\nInput: nums = [-10,8,6,7,-2,-3]\\nOutput: -1\\nExplanation: There is no a single valid k, we return -1.\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 1000\\n-1000 <= nums[i] <= 1000\\nnums[i] != 0\\n\\nData Structures:\\ninput: Array of integers\\noutput: integer\\n\\nAlgorithm:\\n1. Declare and Create a hashset named `set` and initialize it with an empty set.\\n2. Iterate through the nums array and continue adding the numbers to the set.\\n3. Declare and Create an arrRefVar, res and initialize it to an empty array. \\n4. Iterate through the nums array. \\n    - If the number is greater than 0 and its negative value is present in set. Push the number to the res array.\\n5. Return the maximum number from the res array. \\n\\nComplexity Analysis:\\n1. Time Complexity = O(N)\\n2. Space Complexity = O(N)\\n\\n*/\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function (nums) {\\n  const set = new Set();\\n\\n  nums.forEach(number => set.add(number));\\n  // console.log(set);\\n  let res = [];\\n  nums.forEach(number => {\\n    if (number > 0 && set.has(-1 * number)) {\\n      res.push(number);\\n    }\\n  });\\n\\n  return res.length === 0 ? -1 : Math.max(...res);\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n2441. Largest Positive Integer That Exists With Its Negative\\nhttps://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/\\n\\nGiven an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\\n\\nReturn the positive integer k. If there is no such integer, return -1.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [-1,2,-3,3]\\nOutput: 3\\nExplanation: 3 is the only valid k we can find in the array.\\nExample 2:\\n\\nInput: nums = [-1,10,6,7,-7,1]\\nOutput: 7\\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\\nExample 3:\\n\\nInput: nums = [-10,8,6,7,-2,-3]\\nOutput: -1\\nExplanation: There is no a single valid k, we return -1.\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 1000\\n-1000 <= nums[i] <= 1000\\nnums[i] != 0\\n\\nData Structures:\\ninput: Array of integers\\noutput: integer\\n\\nAlgorithm:\\n1. Declare and Create a hashset named `set` and initialize it with an empty set.\\n2. Iterate through the nums array and continue adding the numbers to the set.\\n3. Declare and Create an arrRefVar, res and initialize it to an empty array. \\n4. Iterate through the nums array. \\n    - If the number is greater than 0 and its negative value is present in set. Push the number to the res array.\\n5. Return the maximum number from the res array. \\n\\nComplexity Analysis:\\n1. Time Complexity = O(N)\\n2. Space Complexity = O(N)\\n\\n*/\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function (nums) {\\n  const set = new Set();\\n\\n  nums.forEach(number => set.add(number));\\n  // console.log(set);\\n  let res = [];\\n  nums.forEach(number => {\\n    if (number > 0 && set.has(-1 * number)) {\\n      res.push(number);\\n    }\\n  });\\n\\n  return res.length === 0 ? -1 : Math.max(...res);\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009611,
                "title": "c-solution-two-pointer-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int start = 0;\\n        int end = nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(-nums[start] == nums[end]){\\n                return nums[end];\\n            }\\n            else if(-nums[start] < nums[end]){\\n                end--;\\n            }\\n            else{\\n                start++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int start = 0;\\n        int end = nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(-nums[start] == nums[end]){\\n                return nums[end];\\n            }\\n            else if(-nums[start] < nums[end]){\\n                end--;\\n            }\\n            else{\\n                start++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003071,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        numsSet = set()\\n        res = -1\\n        for n in nums:\\n            numsSet.add(n)\\n            if n * -1 in numsSet:\\n                res = max(res, abs(n))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        numsSet = set()\\n        res = -1\\n        for n in nums:\\n            numsSet.add(n)\\n            if n * -1 in numsSet:\\n                res = max(res, abs(n))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001828,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint findMaxK(int* nums, int n){\\n    int *fre = (int*)calloc(sizeof(int), 2001);\\n    int ans = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        fre[nums[i] + 1000]++;\\n        if(fre[nums[i] + 1000] > 0 && fre[-nums[i] + 1000] > 0){\\n            if(fabs(nums[i]) > ans){\\n                ans = fabs(nums[i]);\\n            }\\n        }        \\n    }\\n    free(fre);\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxK(int* nums, int n){\\n    int *fre = (int*)calloc(sizeof(int), 2001);\\n    int ans = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        fre[nums[i] + 1000]++;\\n        if(fre[nums[i] + 1000] > 0 && fre[-nums[i] + 1000] > 0){\\n            if(fabs(nums[i]) > ans){\\n                ans = fabs(nums[i]);\\n            }\\n        }        \\n    }\\n    free(fre);\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001111,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int x = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int y = Math.abs(nums[i]);\\n            for(int j=i+1;j<nums.length;j++){\\n                if(y==nums[j] && nums[i]<0){\\n                    if(count<nums[j]){\\n                      x = nums[j];\\n                      count = nums[j];\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int x = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int y = Math.abs(nums[i]);\\n            for(int j=i+1;j<nums.length;j++){\\n                if(y==nums[j] && nums[i]<0){\\n                    if(count<nums[j]){\\n                      x = nums[j];\\n                      count = nums[j];\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991887,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n       Set<Integer>set=new HashSet<>();\\n       int maxValue=-1;\\n\\n       for (int num:nums){\\n           if (set.contains(-num)){\\n               maxValue=Math.max(maxValue,Math.abs(num));\\n           }\\n\\n           set.add(num);\\n        \\n\\n       }\\n        return maxValue==-1?-1:maxValue;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n       Set<Integer>set=new HashSet<>();\\n       int maxValue=-1;\\n\\n       for (int num:nums){\\n           if (set.contains(-num)){\\n               maxValue=Math.max(maxValue,Math.abs(num));\\n           }\\n\\n           set.add(num);\\n        \\n\\n       }\\n        return maxValue==-1?-1:maxValue;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990266,
                "title": "c-hash-table-beats-98-20-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_set<int> hash(nums.size());\\n        int ans = -1;\\n\\n        int front = 0;\\n        int back = nums.size() - 1;\\n        while(front < back) {\\n            if(nums[front] > 0) {\\n                int tmp = nums[front];\\n                nums[front] = nums[back];\\n                nums[back] = tmp;\\n                --back;\\n            }\\n            else {\\n                hash.insert(-nums[front]);\\n                ++front;\\n            }\\n        }\\n\\n        if(nums[front] < 0) {\\n            hash.insert(-nums[front]);\\n            ++front;\\n        }\\n\\n        while(front < nums.size()) {\\n            if(hash.count(nums[front]) && nums[front] > ans) {\\n                ans = nums[front];\\n            }\\n            ++front;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_set<int> hash(nums.size());\\n        int ans = -1;\\n\\n        int front = 0;\\n        int back = nums.size() - 1;\\n        while(front < back) {\\n            if(nums[front] > 0) {\\n                int tmp = nums[front];\\n                nums[front] = nums[back];\\n                nums[back] = tmp;\\n                --back;\\n            }\\n            else {\\n                hash.insert(-nums[front]);\\n                ++front;\\n            }\\n        }\\n\\n        if(nums[front] < 0) {\\n            hash.insert(-nums[front]);\\n            ++front;\\n        }\\n\\n        while(front < nums.size()) {\\n            if(hash.count(nums[front]) && nums[front] > ans) {\\n                ans = nums[front];\\n            }\\n            ++front;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988704,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n      Arrays.sort(nums);\\n      int i=0;\\n      int j=nums.length-1;\\n      while(i<=j)\\n      {\\n          if(nums[i]*-1==nums[j])\\n          {\\n              return nums[j];\\n          }\\n          else if(nums[i]*-1<nums[j])\\n          {\\n              j--;\\n          }\\n          else\\n          {\\n              i++;\\n          }\\n      }  \\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n      Arrays.sort(nums);\\n      int i=0;\\n      int j=nums.length-1;\\n      while(i<=j)\\n      {\\n          if(nums[i]*-1==nums[j])\\n          {\\n              return nums[j];\\n          }\\n          else if(nums[i]*-1<nums[j])\\n          {\\n              j--;\\n          }\\n          else\\n          {\\n              i++;\\n          }\\n      }  \\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986416,
                "title": "easy-python-solution-using-while-loop-and-max-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        while nums!=[]:\\n            maxi=max(nums)\\n            if -maxi in nums:\\n                return maxi\\n            else:\\n                 nums.remove(maxi)\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        while nums!=[]:\\n            maxi=max(nums)\\n            if -maxi in nums:\\n                return maxi\\n            else:\\n                 nums.remove(maxi)\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984231,
                "title": "simple-java-solution-using-hashset",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int ele : nums) {\\n            hs.add(ele);\\n        }\\n        for(int i=nums.length-1;i>=0;i--) {\\n            int n=(-1)*nums[i];\\n            if(hs.contains(n)) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int ele : nums) {\\n            hs.add(ele);\\n        }\\n        for(int i=nums.length-1;i>=0;i--) {\\n            int n=(-1)*nums[i];\\n            if(hs.contains(n)) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970066,
                "title": "java-straight-forward-solution",
                "content": "\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);  // sorted in ascending order\\n        int i = 0, j= nums.length-1;\\n        while(i<j){\\n        if(nums[i]+nums[j] == 0){  // found the ans\\n               return nums[j];\\n        }\\n        if(nums[i]+nums[j] > 0){  //sum is greater so reduce it\\n            j--;\\n        }else{  // increase the sum\\n            i++;\\n        }\\n    }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);  // sorted in ascending order\\n        int i = 0, j= nums.length-1;\\n        while(i<j){\\n        if(nums[i]+nums[j] == 0){  // found the ans\\n               return nums[j];\\n        }\\n        if(nums[i]+nums[j] > 0){  //sum is greater so reduce it\\n            j--;\\n        }else{  // increase the sum\\n            i++;\\n        }\\n    }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967511,
                "title": "python3-solution-beats-99-89",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        nums.sort()\\n        coma = nums.index(0)\\n        neg = nums[:coma]\\n        pos = nums[coma+1:][::-1]\\n        neg = set(neg)\\n        for i in pos:\\n            if -i in neg:\\n                return i\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        nums.sort()\\n        coma = nums.index(0)\\n        neg = nums[:coma]\\n        pos = nums[coma+1:][::-1]\\n        neg = set(neg)\\n        for i in pos:\\n            if -i in neg:\\n                return i\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966040,
                "title": "java-easy-hashmap-solution-o-n",
                "content": "\\n# Approach : HashMap Solution Java\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int x : nums){\\n            map.put(x,1);\\n        }\\n\\n        int max = -1;\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            int key = e.getKey();\\n\\n            if(key < 0){\\n                if(map.containsKey(Math.abs(key))){\\n                    if(max < Math.abs(key)){\\n                        max =  Math.abs(key);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int x : nums){\\n            map.put(x,1);\\n        }\\n\\n        int max = -1;\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            int key = e.getKey();\\n\\n            if(key < 0){\\n                if(map.containsKey(Math.abs(key))){\\n                    if(max < Math.abs(key)){\\n                        max =  Math.abs(key);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965555,
                "title": "with-basics-of-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res=-1\\n        lis=[]\\n        for i in range(len(nums)):\\n            if nums[i]<0:\\n                lis.append(abs(nums[i]))\\n            else:\\n                break\\n        while i<len(nums):\\n            if nums[i] in lis and nums[i]>res:\\n                res=nums[i]\\n            i+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res=-1\\n        lis=[]\\n        for i in range(len(nums)):\\n            if nums[i]<0:\\n                lis.append(abs(nums[i]))\\n            else:\\n                break\\n        while i<len(nums):\\n            if nums[i] in lis and nums[i]>res:\\n                res=nums[i]\\n            i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964289,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int tocheckele=0;\\n         \\n        for(int i= nums.length-1;i>=0;i--){\\n            if(nums[i]>0){\\n                tocheckele = -nums[i];\\n            }\\n            for(int index=0;index<nums.length;index++){\\n                if(nums[index]==tocheckele){\\n                    return nums[i];\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int tocheckele=0;\\n         \\n        for(int i= nums.length-1;i>=0;i--){\\n            if(nums[i]>0){\\n                tocheckele = -nums[i];\\n            }\\n            for(int index=0;index<nums.length;index++){\\n                if(nums[index]==tocheckele){\\n                    return nums[i];\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964109,
                "title": "easy-c-solution-beginner-s-friendly-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Divide the vector into two parts and store the values in respective vectors.\\n2. sort the positive vector and reverse it. So that the largest no will come in front and we can easuily check whether that no is available in negative number.\\n3. Remove the positive number from thec vector so that next number can be checked.\\n4. Return the value if that exits in both vector.\\n5. Else return -1;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        vector<int> positive;\\n        vector<int> negative;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                positive.push_back(nums[i]);\\n            }\\n            else{\\n                negative.push_back(nums[i]);\\n            }\\n        }\\n\\n        sort(positive.begin(),positive.end());\\n        reverse(positive.begin(),positive.end());\\n\\n        while(positive.size()!=0){\\n            int value1=positive[0];\\n            for(int i=0;i<negative.size();i++){\\n        //so that both value become positive and comparison become easy\\n                int value2=-negative[i];  \\n                if(value1==value2){\\n                    return value1;\\n                }\\n            }\\n            positive.erase(positive.begin());\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        vector<int> positive;\\n        vector<int> negative;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                positive.push_back(nums[i]);\\n            }\\n            else{\\n                negative.push_back(nums[i]);\\n            }\\n        }\\n\\n        sort(positive.begin(),positive.end());\\n        reverse(positive.begin(),positive.end());\\n\\n        while(positive.size()!=0){\\n            int value1=positive[0];\\n            for(int i=0;i<negative.size();i++){\\n        //so that both value become positive and comparison become easy\\n                int value2=-negative[i];  \\n                if(value1==value2){\\n                    return value1;\\n                }\\n            }\\n            positive.erase(positive.begin());\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963542,
                "title": "cpp-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n    \\n        int j=nums.size()-1;\\n        int i=0;\\n        for(int k=0; k<nums.size(); k++){\\n            \\n            \\n            if(-nums[i]==nums[j]){\\n                return nums[j];\\n            }\\n            else if(-nums[i]>nums[j]){\\n                i++;\\n            }\\n            else{\\n               \\n                j--;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n    \\n        int j=nums.size()-1;\\n        int i=0;\\n        for(int k=0; k<nums.size(); k++){\\n            \\n            \\n            if(-nums[i]==nums[j]){\\n                return nums[j];\\n            }\\n            else if(-nums[i]>nums[j]){\\n                i++;\\n            }\\n            else{\\n               \\n                j--;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963338,
                "title": "easy-to-understand-for-the-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        l=[]\\n        l2=[]\\n        for i in nums:\\n            if i<0:\\n                l.append(i)\\n            else:\\n                l2.append(i)\\n        ans=[]\\n        for i in l2:\\n            if(-i in l):\\n                ans.append(i)\\n        if len(ans)>0:\\n            return max(ans)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        l=[]\\n        l2=[]\\n        for i in nums:\\n            if i<0:\\n                l.append(i)\\n            else:\\n                l2.append(i)\\n        ans=[]\\n        for i in l2:\\n            if(-i in l):\\n                ans.append(i)\\n        if len(ans)>0:\\n            return max(ans)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958589,
                "title": "using-sort-method-solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBasically, we\\'re sorting here - to get negative numbers first in traversal, then we\\'re looping throught it and checking if the positive digit exists for the same or not, as we have sorted array then we\\'re comparing, we won\\'t need to add condition for getting largest number - in case multiple cases are there.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindMaxK(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        for(int i = 0;i<nums.Length-1;i++){\\n            if(nums.Contains(nums[i]*-1)){\\n                return nums[i]*-1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxK(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        for(int i = 0;i<nums.Length-1;i++){\\n            if(nums.Contains(nums[i]*-1)){\\n                return nums[i]*-1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952104,
                "title": "c-easy-solution",
                "content": "Use a hash map to check if we get a positive vs. negtive pair and remeber the max answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\n        int i, x, ans;\\n        map<int, int> m;\\n        ans = -1;\\n\\n        for(i = 0 ; i < nums.size(); i++){            \\n            x = abs(nums[i]);            \\n            if (m.find(x) != m.end()){                \\n                if (nums[i] != m[x]){                    \\n                    ans = max(x, ans);\\n                }\\n            }else{\\n                m[x] = nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n\\n        int i, x, ans;\\n        map<int, int> m;\\n        ans = -1;\\n\\n        for(i = 0 ; i < nums.size(); i++){            \\n            x = abs(nums[i]);            \\n            if (m.find(x) != m.end()){                \\n                if (nums[i] != m[x]){                    \\n                    ans = max(x, ans);\\n                }\\n            }else{\\n                m[x] = nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951697,
                "title": "as-always-potatopie-brings-you-the-easiest-and-most-understandable-solutions-two-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst method:\\n1)sort the array into largest numbers first\\n2) initialise a list output\\n3) populate the list if and only if there are negative corollaries in nums sorted\\n4) note output will be descending order as well\\n5)If length of output is not zero then we got a non -1 result, and we can just take first element\\n\\n\\nsecond method: Two pointers:\\n1)initialise two pointers one at the end and one at the beginning\\n2) they get closer to each other in the sorted array\\n3) before each move we check, \\n3)i) IF equal RETURN AND THEN BREAK\\n3)ii) IF left is more than absolute(right) then we only move the left because it tells us that this largest number in the list doesnt have a negative corollary and we need to check the smaller number in the list\\n3)iii) IF abs(right) is less than left, then again, it means there is no negative corollary, and we need to check a smaller number!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums_sorted=sorted(nums,reverse=True)\\n        #method 1: for loop\\n        # output=[]\\n        # for i in nums_sorted:\\n        #     if -i in nums_sorted:\\n        #         output.append(i) \\n\\n        # if len(output)>0:\\n        #     return (output[0])\\n        # else:\\n        #     return (-1)       \\n\\n        #method 2: 2 pointer\\n        left=0\\n        right=len(nums)-1 #-1 cuz index\\n\\n        while left<right: \\n            if nums_sorted[left]==-nums_sorted[right]:\\n                return (nums_sorted[left])\\n                break\\n            elif nums_sorted[left]>-nums_sorted[right]:\\n                left+=1\\n            elif nums_sorted[left]<-nums_sorted[right]:\\n                right-=1\\n        else:\\n            return (-1)\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums_sorted=sorted(nums,reverse=True)\\n        #method 1: for loop\\n        # output=[]\\n        # for i in nums_sorted:\\n        #     if -i in nums_sorted:\\n        #         output.append(i) \\n\\n        # if len(output)>0:\\n        #     return (output[0])\\n        # else:\\n        #     return (-1)       \\n\\n        #method 2: 2 pointer\\n        left=0\\n        right=len(nums)-1 #-1 cuz index\\n\\n        while left<right: \\n            if nums_sorted[left]==-nums_sorted[right]:\\n                return (nums_sorted[left])\\n                break\\n            elif nums_sorted[left]>-nums_sorted[right]:\\n                left+=1\\n            elif nums_sorted[left]<-nums_sorted[right]:\\n                right-=1\\n        else:\\n            return (-1)\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950233,
                "title": "python3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        s= set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        s= set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942955,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        s = set()\\n        max_res = -1\\n        for i in nums:\\n            if -(i) in s and max_res < abs(i):\\n                max_res = abs(i)\\n            else:\\n                s.add(i)\\n        return max_res \\n```\\n![catty.png](https://assets.leetcode.com/users/images/cb648be6-bd1d-4b9c-8e11-2847ebf2ce13_1692657131.1021788.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        s = set()\\n        max_res = -1\\n        for i in nums:\\n            if -(i) in s and max_res < abs(i):\\n                max_res = abs(i)\\n            else:\\n                s.add(i)\\n        return max_res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942646,
                "title": "2-easy-java-solutions-using-hashtable-two-pointers",
                "content": "```java\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        boolean[] pos = new boolean[1001];\\n        boolean[] neg = new boolean[1001];\\n        for(int n: nums) {\\n            if(n>0) pos[n] = true;\\n            else if(n<0) neg[-n] = true;\\n        }\\n        for(int i = 1000; i>=0; i--) {\\n            if(pos[i] && neg[i]) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```java\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i<j) {\\n            if(nums[i] + nums[j] == 0) {\\n                return nums[j];\\n            } else if(nums[i] + nums[j] <0) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        boolean[] pos = new boolean[1001];\\n        boolean[] neg = new boolean[1001];\\n        for(int n: nums) {\\n            if(n>0) pos[n] = true;\\n            else if(n<0) neg[-n] = true;\\n        }\\n        for(int i = 1000; i>=0; i--) {\\n            if(pos[i] && neg[i]) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i<j) {\\n            if(nums[i] + nums[j] == 0) {\\n                return nums[j];\\n            } else if(nums[i] + nums[j] <0) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940351,
                "title": "finding-maximum-of-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity henre, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]==(-nums[j])){\\n                    return (nums[j]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]==(-nums[j])){\\n                    return (nums[j]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937666,
                "title": "php-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findMaxK($nums) {\\n        $res = [];\\n        foreach($nums as $num){\\n            if($num < 0 && in_array(abs($num), $nums)){\\n                $res[] = abs($num);\\n            }\\n        }\\n\\n        if(empty($res)){\\n            return -1;\\n        }\\n        return max($res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findMaxK($nums) {\\n        $res = [];\\n        foreach($nums as $num){\\n            if($num < 0 && in_array(abs($num), $nums)){\\n                $res[] = abs($num);\\n            }\\n        }\\n\\n        if(empty($res)){\\n            return -1;\\n        }\\n        return max($res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914014,
                "title": "python-no-sortin-solution-beats-97",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        check = set(nums)\\n        maxi = max(nums)\\n        while maxi > 0:\\n            if maxi*(-1) in check: \\n                return maxi\\n            else:\\n                maxi -= 1\\n                while maxi not in check:\\n                    if maxi == 0: return -1\\n                    maxi -= 1              \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        check = set(nums)\\n        maxi = max(nums)\\n        while maxi > 0:\\n            if maxi*(-1) in check: \\n                return maxi\\n            else:\\n                maxi -= 1\\n                while maxi not in check:\\n                    if maxi == 0: return -1\\n                    maxi -= 1              \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898340,
                "title": "easiest-solution-available-on-the-world-wide-web",
                "content": "# Intuition\\nSort the array, Then iterarte the array by keeping one pointer at the end of the arrray \"j\" and the other array at the start of the array \"i\", Now at every iterartion we will check if(nums[j] == -nums[i]) if yes then return nums[i], If not then i++; and j--;  \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        \\n        for(int i = nums.length-1; i > 0; i--){\\n            int j = 0;\\n            while(j < i){\\n                if(nums[j] == -nums[i]){\\n                    return nums[i];\\n                }\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        \\n        for(int i = nums.length-1; i > 0; i--){\\n            int j = 0;\\n            while(j < i){\\n                if(nums[j] == -nums[i]){\\n                    return nums[i];\\n                }\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896207,
                "title": "easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find((-nums[i]))!=mp.end())\\n            {\\n                mx=max(nums[i],mx);\\n            }\\n        }\\n        if(mx==INT_MIN)\\n        return -1;\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find((-nums[i]))!=mp.end())\\n            {\\n                mx=max(nums[i],mx);\\n            }\\n        }\\n        if(mx==INT_MIN)\\n        return -1;\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894376,
                "title": "easy-c-solution-harsha",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       for(int i=nums.size()-1;i>=0;i--){\\n           for(int j=0;j<nums.size();j++){\\n               if(nums[i]+nums[j]==0)\\n               return nums[i];\\n           }\\n       } \\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       for(int i=nums.size()-1;i>=0;i--){\\n           for(int j=0;j<nums.size();j++){\\n               if(nums[i]+nums[j]==0)\\n               return nums[i];\\n           }\\n       } \\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893810,
                "title": "solving-the-proplem-using-set-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_set<int> numSet; // Use unordered_set for efficient lookup\\n\\n        for (int num : nums) {\\n            numSet.insert(num); // Insert the element into the set\\n        }\\n\\n        int maxK = -1;\\n\\n        for (int num : numSet) {\\n            if (numSet.count(num) && numSet.count(-num)) {\\n                maxK = max(maxK, abs(num)); // Update maxK if valid k is found\\n            }\\n        }\\n\\n        return maxK;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_set<int> numSet; // Use unordered_set for efficient lookup\\n\\n        for (int num : nums) {\\n            numSet.insert(num); // Insert the element into the set\\n        }\\n\\n        int maxK = -1;\\n\\n        for (int num : numSet) {\\n            if (numSet.count(num) && numSet.count(-num)) {\\n                maxK = max(maxK, abs(num)); // Update maxK if valid k is found\\n            }\\n        }\\n\\n        return maxK;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882627,
                "title": "2-different-approach-binary-search-using-hash-set-easiest-solution",
                "content": "# Complexity for hash_Set approach\\n- Time complexity: ***O(n)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:  ***O(n)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code *using hash set and loop*\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n      unordered_set<int> st;\\n      for(int num:nums){\\n          if(num<0) st.insert(num);\\n\\n      }\\n      int ans=-1;\\n      for(int num:nums){\\n          if(num>ans && st.count(-(num))){\\n              ans=num;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```\\n\\n# Complexity for *binary search* approach\\n- Time complexity: ***O(nlog n)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:  ***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code *Binary search approach*\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;     \\n        while(i<j){\\n          if( nums[i]+nums[j] == 0){\\n              return nums[j];\\n          }\\n            else if(nums[i]+nums[j] < 0){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n\\n      }\\n      return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n      unordered_set<int> st;\\n      for(int num:nums){\\n          if(num<0) st.insert(num);\\n\\n      }\\n      int ans=-1;\\n      for(int num:nums){\\n          if(num>ans && st.count(-(num))){\\n              ans=num;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;     \\n        while(i<j){\\n          if( nums[i]+nums[j] == 0){\\n              return nums[j];\\n          }\\n            else if(nums[i]+nums[j] < 0){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864617,
                "title": "100-beats-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0||n==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        while(n-1){\\n            int num=nums[n-1];\\n            for( int i=0;i<n;i++){\\n                if(nums[i]==-num)return num;\\n            }\\n            n--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0||n==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        while(n-1){\\n            int num=nums[n-1];\\n            for( int i=0;i<n;i++){\\n                if(nums[i]==-num)return num;\\n            }\\n            n--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862729,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i<j){\\n            if(nums[i] + nums[j] == 0)\\n                return nums[j];\\n            else if(nums[i] + nums[j] > 0){\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] < 0){\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i<j){\\n            if(nums[i] + nums[j] == 0)\\n                return nums[j];\\n            else if(nums[i] + nums[j] > 0){\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] < 0){\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855906,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n\\n        for ele in nums:\\n            if ele > 0:\\n                k = ele - (ele * 2)\\n                if k in nums:\\n                    return ele\\n            else:\\n                break\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n\\n        for ele in nums:\\n            if ele > 0:\\n                k = ele - (ele * 2)\\n                if k in nums:\\n                    return ele\\n            else:\\n                break\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843782,
                "title": "o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int res = -1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num: nums) {\\n            if (set.contains(num * (-1)) && Math.abs(num) > res) {\\n                res = Math.abs(num);\\n            }\\n            set.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int res = -1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num: nums) {\\n            if (set.contains(num * (-1)) && Math.abs(num) > res) {\\n                res = Math.abs(num);\\n            }\\n            set.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843208,
                "title": "2441-largest-positive-integer-that-exists-with-its-negative",
                "content": "# Intuition\\nTry sorting \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n\\n        for(int i = 0 ; i<nums.length ; i++){\\n            boolean swap = false ;\\n            for(int j = 0 ; j< nums.length - i - 1 ; j++){\\n                if(nums[j]>nums[j+1]){\\n                    int temp = nums[j];\\n                    nums[j] = nums[j+1];\\n                    nums[j+1] = temp ;\\n                    swap = true ;\\n                }\\n            }\\n            if(!swap){\\n                break ;\\n            }\\n        }\\n\\n        int[] arr = new int[2];\\n        int x = nums.length-1 ;\\n       \\n\\n        boolean found = true ;\\n        while(found && x>0){ \\n            int k =  nums[x] ;\\n            for(int i = 0 ; i<nums.length ; i++){\\n                arr[0] = k;\\n            }\\n            for(int i = 0 ; i<nums.length ; i++){\\n                if(nums[i]==-k){\\n                    found = false ;\\n                    break ;\\n                }\\n            }\\n            x--;\\n        }\\n\\n        if(!found){\\n            return arr[0];\\n        }else{\\n            return - 1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n\\n        for(int i = 0 ; i<nums.length ; i++){\\n            boolean swap = false ;\\n            for(int j = 0 ; j< nums.length - i - 1 ; j++){\\n                if(nums[j]>nums[j+1]){\\n                    int temp = nums[j];\\n                    nums[j] = nums[j+1];\\n                    nums[j+1] = temp ;\\n                    swap = true ;\\n                }\\n            }\\n            if(!swap){\\n                break ;\\n            }\\n        }\\n\\n        int[] arr = new int[2];\\n        int x = nums.length-1 ;\\n       \\n\\n        boolean found = true ;\\n        while(found && x>0){ \\n            int k =  nums[x] ;\\n            for(int i = 0 ; i<nums.length ; i++){\\n                arr[0] = k;\\n            }\\n            for(int i = 0 ; i<nums.length ; i++){\\n                if(nums[i]==-k){\\n                    found = false ;\\n                    break ;\\n                }\\n            }\\n            x--;\\n        }\\n\\n        if(!found){\\n            return arr[0];\\n        }else{\\n            return - 1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841721,
                "title": "largest-positive-integer-that-exists-with-its-negative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max = -1;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>0&&arr.contains(-nums[i]))\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        int max = -1;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>0&&arr.contains(-nums[i]))\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840901,
                "title": "set-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findMaxK(int[] nums) {\\n\\t\\t   HashSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor(int i: nums) set.add(i);\\n\\t\\t\\tint ans = -1;\\n\\t\\t   for(int i: nums){\\n\\t\\t\\t   if(set.contains(-i)) ans = Math.max(i,ans);\\n\\t\\t   }\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findMaxK(int[] nums) {\\n\\t\\t   HashSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor(int i: nums) set.add(i);\\n\\t\\t\\tint ans = -1;\\n\\t\\t   for(int i: nums){\\n\\t\\t\\t   if(set.contains(-i)) ans = Math.max(i,ans);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 3839425,
                "title": "beats-90-87-runtime-easy-to-understand-python-solution",
                "content": "# Intuition\\nto find the numebr just opposite to the sign can be done using loop and conditional statements\\n\\n# Approach\\nfurthermore, to find the max element among the elements that follows the same property, we use sort() fn and reverse it, so the moment we traverse through the array, the \\'first\\' element to follow the condition will always be the maximum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        for i in nums:\\n            if -i in nums :\\n                return i\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        for i in nums:\\n            if -i in nums :\\n                return i\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836072,
                "title": "hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {\\n            if(m.find(-(it.first))!=m.end())\\n            {\\n                if(it.first>a)\\n              a= it.first;\\n            }\\n        }\\n        if(a)\\n        return a;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {\\n            if(m.find(-(it.first))!=m.end())\\n            {\\n                if(it.first>a)\\n              a= it.first;\\n            }\\n        }\\n        if(a)\\n        return a;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832483,
                "title": "two-lines-of-fast-code-set-max-generator",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        return max((i if -i in nums else -1 for i in nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        return max((i if -i in nums else -1 for i in nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830658,
                "title": "very-easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& a) \\n    {\\n        unordered_map<int,int> mp;\\n        int n = a.size();\\n        int ans = -1;\\n        \\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<0 && mp.find(abs(a[i]))!=mp.end())\\n            {\\n                ans = max(ans,abs(a[i]));\\n            }\\n            else\\n            {\\n                mp[a[i]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxK(vector<int>& a) \\n    {\\n        unordered_map<int,int> mp;\\n        int n = a.size();\\n        int ans = -1;\\n        \\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<0 && mp.find(abs(a[i]))!=mp.end())\\n            {\\n                ans = max(ans,abs(a[i]));\\n            }\\n            else\\n            {\\n                mp[a[i]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830261,
                "title": "easy-solution-easy-to-understand-easy-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0;i<nums.length-1;i++){\\n            for(int j = nums.length-1;j>0;j--){\\n                if(nums[i]+nums[j]==0){\\n                    return nums[j];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0;i<nums.length-1;i++){\\n            for(int j = nums.length-1;j>0;j--){\\n                if(nums[i]+nums[j]==0){\\n                    return nums[j];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829252,
                "title": "easy-sol-east-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n      int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==(-1)*nums[j]) {\\n                   c++;\\n                    return nums[j];\\n                }\\n            }\\n        }\\n       if(c==0){\\n        return -1;\\n       }\\n       return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n      int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==(-1)*nums[j]) {\\n                   c++;\\n                    return nums[j];\\n                }\\n            }\\n        }\\n       if(c==0){\\n        return -1;\\n       }\\n       return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826843,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int f=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j && (-1 *nums[i])==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int f=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j && (-1 *nums[i])==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826629,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int f=0;\\n        int h=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int y=-1*nums[i];\\n            if(f==0){\\n            for(int j=0;j<nums.length;j++){\\n                if(y==nums[j]){\\n                    h=nums[i];\\n                    f=1;\\n                    break;\\n                }\\n            }\\n        }\\n        }\\n        if(f==0){\\n            return -1;\\n        }\\n        else{\\n            return h;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxK(int[] nums) {\\n        Arrays.sort(nums);\\n        int f=0;\\n        int h=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int y=-1*nums[i];\\n            if(f==0){\\n            for(int j=0;j<nums.length;j++){\\n                if(y==nums[j]){\\n                    h=nums[i];\\n                    f=1;\\n                    break;\\n                }\\n            }\\n        }\\n        }\\n        if(f==0){\\n            return -1;\\n        }\\n        else{\\n            return h;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825109,
                "title": "easy-go-solution-using-map-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Its easier find a solution if nums slice is sorted, if \"k\" negative numbers exists in nums, the first k positions are negative integers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find the max integer \"n\" in nums, such that \"-n\" also exists, so, sort nums, iterate all the negative numbers and store them in a map (map[value]position).\\n\\nThen, continue iterating through the positive numbers and look for a number \"x\", such that x == -nums[i], this works because nums is sorted in non-decreasing order, if there is a \"n\" such that \"-n\" exist, maybe there is a largest \"n\" such that \"-n\" exists.\\n\\nif there are no negative numbers, the loop will not find any \"-n\", hence, there is no solution.\\n\\n# Code\\n```\\nfunc findMaxK(nums []int) int {\\n\\n    var max int = -1\\n    sort.Ints(nums)\\n    var mem map[int]int = make(map[int]int)\\n\\n    for i := 0; i < len(nums); i++{\\n        if nums[i] < 0{\\n            mem[nums[i]] = i\\n            continue\\n        }\\n\\n        //current - negative = 0\\n        var x = -nums[i]\\n\\n        if _, ok := mem[x]; ok{\\n            max = nums[i]\\n        }\\n\\n    }\\n\\n    return max\\n}\\n\\n/* \\n * Time: O(nlogn)\\n * Space: O(n)\\n*/\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMaxK(nums []int) int {\\n\\n    var max int = -1\\n    sort.Ints(nums)\\n    var mem map[int]int = make(map[int]int)\\n\\n    for i := 0; i < len(nums); i++{\\n        if nums[i] < 0{\\n            mem[nums[i]] = i\\n            continue\\n        }\\n\\n        //current - negative = 0\\n        var x = -nums[i]\\n\\n        if _, ok := mem[x]; ok{\\n            max = nums[i]\\n        }\\n\\n    }\\n\\n    return max\\n}\\n\\n/* \\n * Time: O(nlogn)\\n * Space: O(n)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823991,
                "title": "javascript-4-lines-2-variable-if-condition-math-max-map-filter-flat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    var moin = nums.filter(e=>e<= 0)\\n    var plus = nums.filter(e=>e>= 0)\\n    if(moin.map(e=>plus.filter(a=>-a==e)).flat(Infinity).length ==0)return -1\\n    return Math.max(...moin.map(e=>plus.filter(a=>-a==e)).flat(Infinity))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxK = function(nums) {\\n    var moin = nums.filter(e=>e<= 0)\\n    var plus = nums.filter(e=>e>= 0)\\n    if(moin.map(e=>plus.filter(a=>-a==e)).flat(Infinity).length ==0)return -1\\n    return Math.max(...moin.map(e=>plus.filter(a=>-a==e)).flat(Infinity))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819518,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for x in range(len(nums)):\\n            if nums[x]>=0:\\n                break\\n            elif abs(nums[x]) in nums:\\n                return abs(nums[x])\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for x in range(len(nums)):\\n            if nums[x]>=0:\\n                break\\n            elif abs(nums[x]) in nums:\\n                return abs(nums[x])\\n        return -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1676799,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            },
            {
                "id": 2010584,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            },
            {
                "id": 1969771,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            },
            {
                "id": 1932270,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            },
            {
                "id": 1921875,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            },
            {
                "id": 1830270,
                "content": [
                    {
                        "username": "Pizzasoccer",
                        "content": "EASY BRO"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Sort the array use nested loops keep two pointers on the either ends and keep iterarting and check if(nums[j] == -nums[i]) and voilaa you are done here"
                    },
                    {
                        "username": "Tatha1414",
                        "content": "can we use abs instead of that negative sign i have used the abs function but it did not passed the last test case  please help"
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "wont nested loops increase the time complexity to O(n^2)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "first I tried HASHMAP and submitted it it was taking 7ms time. then I tried by sorting and using binary search it was taking 5ms time and space complexity was also better. IDK how it\\'s sorting and then binary search is better than hashmap."
                    },
                    {
                        "username": "Ishantkamboj",
                        "content": "my code is working fine in my machine but here it is showing runtime error and showing heap buffer overflow, btw my code is following the give constraints.\\nAny suggestion?\\n"
                    },
                    {
                        "username": "karthikmokila09",
                        "content": "Same issue bro, figured out something?"
                    },
                    {
                        "username": "dieg0350",
                        "content": "input = [-9,-43,24,-23,-16,-30,-38,-30]\\noutput = 30\\n\\nis this correct for the test cases?"
                    },
                    {
                        "username": "potatopie",
                        "content": "no it is not. should be -1"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "No it is not correct as we have to find the positive maximum number."
                    },
                    {
                        "username": "Suffolk",
                        "content": "same to 2sum"
                    }
                ]
            }
        ]
    }
]