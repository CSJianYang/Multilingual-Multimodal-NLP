[
    {
        "title": "Magic Squares In Grid",
        "question_content": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col&nbsp;grid&nbsp;of integers, how many 3 x 3 \"magic square\" subgrids are there?&nbsp; (Each subgrid is contiguous).\n&nbsp;\nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\nwhile this one is not:\nIn total, there is only one magic square inside the given grid.\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "solutions": [
            {
                "id": 133874,
                "title": "python-5-and-43816729",
                "content": "The intuition is brute force, don\\'t need any tricky. \\nOne thing to pay attention: A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from **1 to 9**.\\nI just find many sumbmission ignoring this condition. \\n\\nHere I just want share two observatons with this **1-9** condition:\\n\\nAssume a magic square:\\na1,a2,a3\\na4,a5,a6\\na7,a8,a9\\n\\n`a2 + a5 + a8 = 15`\\n`a4 + a5 + a6 = 15`\\n`a1 + a5 + a9 = 15`\\n`a3 + a5 + a7 = 15`\\n\\nAccumulate all, then we have:\\n`sum(ai) + 3 * a5 = 60`\\n`3 * a5 = 15`\\n`a5 = 5`\\n\\nThe center of magic square must be 5.\\n\\nAnother observation for other 8 numbers:\\nThe even must be in the corner, and the odd must be on the edge.\\nAnd it must be in a order like \"43816729\" \\uFF08clockwise or anticlockwise)\\n\\n```\\n    def numMagicSquaresInside(self, g):\\n        def isMagic(i, j):\\n            s = \"\".join(str(g[i + x / 3][j + x % 3]) for x in [0, 1, 2, 5, 8, 7, 6, 3])\\n            return g[i][j] % 2 == 0 and (s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2)\\n        return sum(isMagic(i, j) for i in range(len(g) - 2) for j in range(len(g[0]) - 2) if g[i + 1][j + 1] == 5)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def numMagicSquaresInside(self, g):\\n        def isMagic(i, j):\\n            s = \"\".join(str(g[i + x / 3][j + x % 3]) for x in [0, 1, 2, 5, 8, 7, 6, 3])\\n            return g[i][j] % 2 == 0 and (s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2)\\n        return sum(isMagic(i, j) for i in range(len(g) - 2) for j in range(len(g[0]) - 2) if g[i + 1][j + 1] == 5)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133861,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, result = 0;\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                if (isMagic(grid, i, j)) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isMagic(int[][] grid, int row, int col) {\\n        int[] record = new int[10];\\n        for (int i = row; i < row + 3; i++) {\\n            for (int j = col; j < col + 3; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9 || record[grid[i][j]] > 0) {\\n                    return false;\\n                }\\n                record[grid[i][j]] = 1;\\n            }\\n        }\\n        int sum1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int sum2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        if (sum1 != sum2) {\\n            return false;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (grid[row + i][col] + grid[row + i][col + 1] + grid[row + i][col + 2] != sum1) {\\n                return false;\\n            }\\n            if (grid[row][col + i] + grid[row + 1][col + i] + grid[row + 2][col + i] != sum1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, result = 0;\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                if (isMagic(grid, i, j)) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isMagic(int[][] grid, int row, int col) {\\n        int[] record = new int[10];\\n        for (int i = row; i < row + 3; i++) {\\n            for (int j = col; j < col + 3; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9 || record[grid[i][j]] > 0) {\\n                    return false;\\n                }\\n                record[grid[i][j]] = 1;\\n            }\\n        }\\n        int sum1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int sum2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        if (sum1 != sum2) {\\n            return false;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (grid[row + i][col] + grid[row + i][col + 1] + grid[row + i][col + 2] != sum1) {\\n                return false;\\n            }\\n            if (grid[row][col + i] + grid[row + 1][col + i] + grid[row + 2][col + i] != sum1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208894,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133938,
                "title": "java-8-ms-straightforward-ugly-solution",
                "content": "The center of the square must be 5.\\nAnd I judge whether         **1.** the square contains number 1~9.        **2.** the four sides and two diagonal lines all equal to 15. \\nUgly and straightforward solution.\\n```\\npublic int numMagicSquaresInside(int[][] grid) {\\n        int cnt=0;\\n        for(int i=0;i<=grid.length-3;i++)\\n            for(int j=0;j<=grid[0].length-3;j++)\\n                if(helper(i,j,grid)) cnt++;\\n            \\n        return cnt;\\n    }  \\n    \\n    private boolean helper(int x,int y,int[][] grid){\\n        if(grid[x+1][y+1]!=5) return false;\\n        \\n        int[] valid=new int[16];\\n        \\n        for(int i=x;i<=x+2;i++)\\n            for(int j=y;j<=y+2;j++)\\n                valid[grid[i][j]]++;\\n            \\n        for (int v = 1; v <= 9; v++)\\n            if (valid[v] != 1) return false;\\n        \\n        if((grid[x][y]+grid[x][y+1]+grid[x][y+2])!=15)         return false;\\n        if((grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2])!=15)     return false;\\n        if((grid[x][y]+grid[x+1][y]+grid[x+2][y])!=15)         return false;\\n        if((grid[x+2][y]+grid[x+2][y+1]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+2]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y])!=15)     return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numMagicSquaresInside(int[][] grid) {\\n        int cnt=0;\\n        for(int i=0;i<=grid.length-3;i++)\\n            for(int j=0;j<=grid[0].length-3;j++)\\n                if(helper(i,j,grid)) cnt++;\\n            \\n        return cnt;\\n    }  \\n    \\n    private boolean helper(int x,int y,int[][] grid){\\n        if(grid[x+1][y+1]!=5) return false;\\n        \\n        int[] valid=new int[16];\\n        \\n        for(int i=x;i<=x+2;i++)\\n            for(int j=y;j<=y+2;j++)\\n                valid[grid[i][j]]++;\\n            \\n        for (int v = 1; v <= 9; v++)\\n            if (valid[v] != 1) return false;\\n        \\n        if((grid[x][y]+grid[x][y+1]+grid[x][y+2])!=15)         return false;\\n        if((grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2])!=15)     return false;\\n        if((grid[x][y]+grid[x+1][y]+grid[x+2][y])!=15)         return false;\\n        if((grid[x+2][y]+grid[x+2][y+1]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+2]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y])!=15)     return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390880,
                "title": "java-100-both",
                "content": "Skipping the part on sliding the window, the key idea is to work in the understanding of the \\npossibilities you can have with 9 **different** digits form **1 to 9** *(like a sudoku box)* in the same 3x3 matrix giving you only limited possible outcomes.\\nIf you try to put an element different form 5 in the center you will never be able to have a magicBox, so 5 must be at the center.\\nNow if you try to put **odd** numbers in the corners you can never menage to find a way to obtain all diagonal values equal, forcing you to put these values between angles.\\nTo end this you can discover after some attempt that the only way to have equal sum is only with a sum equal to 15, so you have only to check if the rows and columns sum to 15 ( the diagonals are granted from the Even/Odd checks), you can avoid checking 1 column or row because if the other sums to 15 they imply that the last one does it as well.\\n\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133857,
                "title": "why-is-this-test-case-yielding-0",
                "content": "My submission failed on this: ```[[10,3,5],[1,6,11],[7,9,2]]```\\nIt says expected result is 0, but clearly you can do it by hand that the sum is 18 for all cases",
                "solutionTags": [],
                "code": "```[[10,3,5],[1,6,11],[7,9,2]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 754816,
                "title": "c-4-ms-solution-complete-brute-force-easy-to-understand",
                "content": "***Runtime: 4 ms, faster than 92.34% of C++ online submissions for Magic Squares In Grid.\\nMemory Usage: 8.3 MB, less than 96.49% of C++ online submissions for Magic Squares In Grid.***\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194689,
                "title": "100-simple-c-solution",
                "content": "Here is a simple C++ Solution which beats 100% - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool chk(vector<vector<int>>& grid, int m, int n) {\\n        \\n        if (m + 3 > grid.size())\\n            return false;\\n        \\n        if (n + 3 > grid[m].size())\\n            return false;\\n        \\n        vector<bool> v (10, false);\\n        \\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                v[grid[i][j]] = true;\\n            }\\n        }\\n        \\n        int sum = grid[m][n] + grid[m+1][n+1] + grid[m+2][n+2];\\n        \\n        if (sum != grid[m][n+2] + grid[m+1][n+1] + grid[m+2][n])\\n            return false;\\n        \\n        \\n        for (int i = m; i < m + 3; i++) {\\n            if (grid[i][n] + grid[i][n+1] + grid[i][n+2] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = n; i < n + 3; i++) {\\n            if (grid[m][i] + grid[m+1][i] + grid[m+2][i] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (!v[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    } \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (chk(grid, i, j))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nThanks",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool chk(vector<vector<int>>& grid, int m, int n) {\\n        \\n        if (m + 3 > grid.size())\\n            return false;\\n        \\n        if (n + 3 > grid[m].size())\\n            return false;\\n        \\n        vector<bool> v (10, false);\\n        \\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                v[grid[i][j]] = true;\\n            }\\n        }\\n        \\n        int sum = grid[m][n] + grid[m+1][n+1] + grid[m+2][n+2];\\n        \\n        if (sum != grid[m][n+2] + grid[m+1][n+1] + grid[m+2][n])\\n            return false;\\n        \\n        \\n        for (int i = m; i < m + 3; i++) {\\n            if (grid[i][n] + grid[i][n+1] + grid[i][n+2] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = n; i < n + 3; i++) {\\n            if (grid[m][i] + grid[m+1][i] + grid[m+2][i] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (!v[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    } \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (chk(grid, i, j))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514157,
                "title": "javascript-solution-44ms-runtime",
                "content": "There are only a [small number of possible magic squares](https://oeis.org/A217568).\\n\\nRuntime: 44 ms, faster than 100.00% of JavaScript online submissions\\nMemory Usage: 35.2 MB, less than 100.00% of JavaScript online submissions\\n\\n```javascript\\nconst numMagicSquaresInside = grid => {\\n  const magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n  let cnt = 0;\\n  for (let i = 0; i < grid.length - 2; i++)\\n    for (let j = 0; j < grid[0].length - 2; j++)\\n      if (\\n        magicSquares.has(\\n          grid[i][j].toString() +\\n            grid[i][j + 1] +\\n            grid[i][j + 2] +\\n            grid[i + 1][j] +\\n            grid[i + 1][j + 1] +\\n            grid[i + 1][j + 2] +\\n            grid[i + 2][j] +\\n            grid[i + 2][j + 1] +\\n            grid[i + 2][j + 2],\\n        )\\n      )\\n        cnt++;\\n  return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\nconst numMagicSquaresInside = grid => {\\n  const magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n  let cnt = 0;\\n  for (let i = 0; i < grid.length - 2; i++)\\n    for (let j = 0; j < grid[0].length - 2; j++)\\n      if (\\n        magicSquares.has(\\n          grid[i][j].toString() +\\n            grid[i][j + 1] +\\n            grid[i][j + 2] +\\n            grid[i + 1][j] +\\n            grid[i + 1][j + 1] +\\n            grid[i + 1][j + 2] +\\n            grid[i + 2][j] +\\n            grid[i + 2][j + 1] +\\n            grid[i + 2][j + 2],\\n        )\\n      )\\n        cnt++;\\n  return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181724,
                "title": "java-brute-force-math-beats-100-0ms-t-c-o-r-c",
                "content": "\\n    // O(m*n)\\n\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\tint m = grid.length, n = grid[0].length, ans = 0;\\n\\t\\tfor (int i = 0; i <= m - 3; i++) {\\n\\t\\t\\tfor (int j = 0; j <= n - 3; j++) {\\n\\t\\t\\t\\tif (grid[i + 1][j + 1] != 5)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tboolean flag = isMagicSquare(grid, i, j);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic boolean isMagicSquare(int[][] grid, int top, int left) {\\n\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tfor (int i = 0; i <= 2; i++) {\\n\\t\\t\\tfor (int j = 0; j <= 2; j++) {\\n\\t\\t\\t\\tif (grid[top + i][left + j] >= 10)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tmap[grid[top + i][left + j]] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn (grid[top][left] + grid[top][left + 1] + grid[top][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 1][left] + grid[top + 1][left + 1] + grid[top + 1][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 2][left] + grid[top + 2][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left] + grid[top + 2][left] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 1] + grid[top + 1][left + 1] + grid[top + 2][left + 1] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 2] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 1] + grid[top + 2][left] == 15);\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(m*n)\\n\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\tint m = grid.length, n = grid[0].length, ans = 0;\\n\\t\\tfor (int i = 0; i <= m - 3; i++) {\\n\\t\\t\\tfor (int j = 0; j <= n - 3; j++) {\\n\\t\\t\\t\\tif (grid[i + 1][j + 1] != 5)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tboolean flag = isMagicSquare(grid, i, j);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic boolean isMagicSquare(int[][] grid, int top, int left) {\\n\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tfor (int i = 0; i <= 2; i++) {\\n\\t\\t\\tfor (int j = 0; j <= 2; j++) {\\n\\t\\t\\t\\tif (grid[top + i][left + j] >= 10)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tmap[grid[top + i][left + j]] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn (grid[top][left] + grid[top][left + 1] + grid[top][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 1][left] + grid[top + 1][left + 1] + grid[top + 1][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 2][left] + grid[top + 2][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left] + grid[top + 2][left] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 1] + grid[top + 1][left + 1] + grid[top + 2][left + 1] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 2] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 1] + grid[top + 2][left] == 15);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 581967,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows < 3 || cols < 3) return 0;\\n        int count = 0;\\n        for (int i=0;i<rows-2;i++) {\\n            for (int j=0;j<cols-2;j++) {\\n                if(isMagicGrid(grid,i, j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    public boolean isMagicGrid(int[][] grid,int rowStart,int colStart) {\\n        int diagonalsSum = 0;\\n\\t\\tint antiDiagonalSum = 0;\\n        int[] rowsSum = new int[3];\\n        int[] colsSum = new int[3];\\n        int[] numbers = new int[9];\\n        for (int i = rowStart,row =0; i < rowStart + 3; i++,row++) {\\n            for (int j = colStart,col=0; j < colStart + 3; j++,col++) {\\n                if(grid[i][j] > 9 || grid[i][j] < 1) return false;\\n                rowsSum[i%3] += grid[i][j];\\n                colsSum[j%3] += grid[i][j];\\n                if(numbers[grid[i][j]-1] == 0) {\\n                    numbers[grid[i][j]-1]++;\\n                } else {\\n                    return false;\\n                }\\n                if (row == col) diagonalsSum += grid[i][j];\\n                if ((3 - row - 1) == col) antiDiagonalSum += grid[i][j];\\n            }\\n        }\\n        if(diagonalsSum != antiDiagonalSum) return false;\\n        boolean isRowsEqual = rowsSum[0] == rowsSum[1]  && rowsSum[1] == rowsSum[2];\\n        boolean isColsEqual = colsSum[0] == colsSum[1]  && colsSum[1] == colsSum[2];\\n        return isRowsEqual && isColsEqual;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows < 3 || cols < 3) return 0;\\n        int count = 0;\\n        for (int i=0;i<rows-2;i++) {\\n            for (int j=0;j<cols-2;j++) {\\n                if(isMagicGrid(grid,i, j)) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2330775,
                "title": "c-brute-force",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i+2<grid.size();i++)\\n        {\\n            for(int j=0;j+2<grid[0].size();j++)\\n            {\\n                res+=fun(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<int> v(16,0);\\n        for(int x=i;x<i+3;x++)\\n        {\\n            for(int y=j;y<j+3;y++)\\n            {\\n                v[grid[x][y]]=1;\\n            }\\n        }\\n        for(int x=1;x<10;x++)\\n        {\\n            if(!v[x])\\n                return 0;\\n        }\\n        int sum=0,t=0;\\n        int p=i,q=j;\\n        for(int k=0;k<3;k++)\\n        {\\n            sum+=grid[p][q];\\n            p++;\\n            q++;\\n        }\\n        p=i,q=j+2;\\n        for(int k=0;k<3;k++)\\n        {\\n            t+=grid[p][q];\\n            p++;\\n            q--;\\n        }\\n        if(t!=sum)\\n            return 0;\\n        \\n        for(int x=i;x<i+3;x++)\\n        {\\n            t=0;\\n            for(int y=j;y<j+3;y++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        for(int y=j;y<j+3;y++)\\n        {\\n            t=0;\\n            for(int x=i;x<i+3;x++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i+2<grid.size();i++)\\n        {\\n            for(int j=0;j+2<grid[0].size();j++)\\n            {\\n                res+=fun(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<int> v(16,0);\\n        for(int x=i;x<i+3;x++)\\n        {\\n            for(int y=j;y<j+3;y++)\\n            {\\n                v[grid[x][y]]=1;\\n            }\\n        }\\n        for(int x=1;x<10;x++)\\n        {\\n            if(!v[x])\\n                return 0;\\n        }\\n        int sum=0,t=0;\\n        int p=i,q=j;\\n        for(int k=0;k<3;k++)\\n        {\\n            sum+=grid[p][q];\\n            p++;\\n            q++;\\n        }\\n        p=i,q=j+2;\\n        for(int k=0;k<3;k++)\\n        {\\n            t+=grid[p][q];\\n            p++;\\n            q--;\\n        }\\n        if(t!=sum)\\n            return 0;\\n        \\n        for(int x=i;x<i+3;x++)\\n        {\\n            t=0;\\n            for(int y=j;y<j+3;y++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        for(int y=j;y<j+3;y++)\\n        {\\n            t=0;\\n            for(int x=i;x<i+3;x++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409821,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int row, int col){\\n        return hasDistinctNumbers(grid, row, col) && rowSumEqual(grid, row, col) && colSumEqual(grid, row, col) && diagSumEqual(grid, row, col);\\n    }\\n    \\n    public boolean rowSumEqual(int[][] grid, int row, int col){\\n        int rs1 = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n        int rs2 = grid[row + 1][col] + grid[row + 1][col + 1] + grid[row + 1][col + 2];\\n        int rs3 = grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n        return rs1 == rs2 && rs2 == rs3;\\n    }\\n    \\n    public boolean colSumEqual(int[][] grid, int row, int col){\\n        int cs1 = grid[row][col] + grid[row + 1][col] + grid[row + 2][col];\\n        int cs2 = grid[row][col + 1] + grid[row + 1][col + 1] + grid[row + 2][col + 1];\\n        int cs3 = grid[row][col + 2] + grid[row + 1][col + 2] + grid[row + 2][col + 2];\\n        return cs1 == cs2 && cs2 == cs3;\\n    }\\n    \\n    public boolean diagSumEqual(int[][] grid, int row, int col){\\n        int rds1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int rds2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        return rds1 == rds2;\\n    }\\n    \\n    public boolean hasDistinctNumbers(int[][] grid, int row, int col){\\n        boolean[] nums = new boolean[10];\\n        for(int i = row; i < row + 3; i++){\\n            for(int j = col; j < col + 3; j++){\\n                if(grid[i][j] == 0 || grid[i][j] > 9 || nums[grid[i][j]]){\\n                    return false;\\n                }\\n                else{\\n                    nums[grid[i][j]] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int row, int col){\\n        return hasDistinctNumbers(grid, row, col) && rowSumEqual(grid, row, col) && colSumEqual(grid, row, col) && diagSumEqual(grid, row, col);\\n    }\\n    \\n    public boolean rowSumEqual(int[][] grid, int row, int col){\\n        int rs1 = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n        int rs2 = grid[row + 1][col] + grid[row + 1][col + 1] + grid[row + 1][col + 2];\\n        int rs3 = grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n        return rs1 == rs2 && rs2 == rs3;\\n    }\\n    \\n    public boolean colSumEqual(int[][] grid, int row, int col){\\n        int cs1 = grid[row][col] + grid[row + 1][col] + grid[row + 2][col];\\n        int cs2 = grid[row][col + 1] + grid[row + 1][col + 1] + grid[row + 2][col + 1];\\n        int cs3 = grid[row][col + 2] + grid[row + 1][col + 2] + grid[row + 2][col + 2];\\n        return cs1 == cs2 && cs2 == cs3;\\n    }\\n    \\n    public boolean diagSumEqual(int[][] grid, int row, int col){\\n        int rds1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int rds2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        return rds1 == rds2;\\n    }\\n    \\n    public boolean hasDistinctNumbers(int[][] grid, int row, int col){\\n        boolean[] nums = new boolean[10];\\n        for(int i = row; i < row + 3; i++){\\n            for(int j = col; j < col + 3; j++){\\n                if(grid[i][j] == 0 || grid[i][j] > 9 || nums[grid[i][j]]){\\n                    return false;\\n                }\\n                else{\\n                    nums[grid[i][j]] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290240,
                "title": "java-0ms-solution",
                "content": "**Explanation:**\\nA magic sqaure is always size 3 x 3, and having distinct numbers 1-9 in each slot.\\n```\\na b c\\nd e f\\ng h i\\n```\\nAnd, according to the definition of a magic square:\\n```\\nsum(a,b,c,d,e,f,g,h,i) = sum(1,2,3,4,5,6,7,8,9) = 45\\n```\\nThus, we can conclude that\\n```\\nrows: sum(a,b,c) = sum(d,e,f) = sum(g,h,i) = 15 (sum of each row to be 15)\\ncols: sum(a,d,g) = sum(b,e,h) = sum(c,f,i) = 15 (sum of each column to be 15)\\ndiagonals: sum(a,e,i) = sum(c,e,g) = 15 (sum of each diagnoal to be 15)\\n```\\n\\nFor terns that have the center number:\\n```\\nsum(a,e,i) = sum(d,e,f) = sum(c,e,g) = sum(b,e,h) = 15\\nAssume sum(a,i) = sum(d,f) = sum(c,g) = sum(b,h) = x\\n\\n=> 4*x + 4*e = 4*15 = 60, 4*x + e = 45(sum of all 9 numbers)\\n=> 3*e = 15\\n=> e = 5 (the center of a magic square has to be 5)\\n=> x = 10(the other 2 numbers, which can form up a line together with the center number, have the sum to be 10)\\n```\\n\\n**Checklist:**\\n1. The center number has to be 5, all square without a center number as 5 can be ignored.\\n2. The other 2 numbers, which can form up a line together with the center number, have the sum to be 10.\\n3. The rows and columns that don\\'t include the center number should also have the sum to be 15.\\n4. The square should include distinct numbers from `1-9`, no duplicates are allowed, and number `0, 10-15` are also invalid.\\n\\nAlso, the numbers on the edges of the grid can never be the center number of a valid magic square, so we can start checking the center number with index `1 <= i < row - 1` and `1 <= j < col - 1`.\\n\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int res = 0;\\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n\\t\\t\\t\\t// check the center number of a square\\n                if (grid[i][j] != 5) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the other 2 numbers that can form up a line with the center number\\n                if (grid[i][j - 1] + grid[i][j + 1] != 10) continue;\\n                if (grid[i - 1][j] + grid[i + 1][j] != 10) continue;\\n                if (grid[i - 1][j - 1] + grid[i + 1][j + 1] != 10) continue;\\n                if (grid[i + 1][j - 1] + grid[i - 1][j + 1] != 10) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the rows and columns that don\\'t include the center number\\n                if (grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] != 15) continue;\\n                if (grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1] != 15) continue;\\n                if (grid[i - 1][j - 1] + grid[i][j - 1] + grid[i + 1][j - 1] != 15) continue;\\n                if (grid[i - 1][j + 1] + grid[i][j + 1] + grid[i + 1][j + 1] != 15) continue;\\n                   \\n\\t\\t\\t\\t// check if the current square is valid (distinct numbers from 1 to 9)\\n                if (isValid(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int x, int y) {\\n        int[] dx = {-1, 0, 1};\\n        int[] dy = {-1, 0, 1};\\n        int[] cnt = new int[16];\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                cnt[grid[x + dx[i]][y + dy[j]]]++;\\n            }\\n        }\\n        \\n        for (int n = 1; n <= 9; ++n) {\\n            if (cnt[n] != 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\na b c\\nd e f\\ng h i\\n```\n```\\nsum(a,b,c,d,e,f,g,h,i) = sum(1,2,3,4,5,6,7,8,9) = 45\\n```\n```\\nrows: sum(a,b,c) = sum(d,e,f) = sum(g,h,i) = 15 (sum of each row to be 15)\\ncols: sum(a,d,g) = sum(b,e,h) = sum(c,f,i) = 15 (sum of each column to be 15)\\ndiagonals: sum(a,e,i) = sum(c,e,g) = 15 (sum of each diagnoal to be 15)\\n```\n```\\nsum(a,e,i) = sum(d,e,f) = sum(c,e,g) = sum(b,e,h) = 15\\nAssume sum(a,i) = sum(d,f) = sum(c,g) = sum(b,h) = x\\n\\n=> 4*x + 4*e = 4*15 = 60, 4*x + e = 45(sum of all 9 numbers)\\n=> 3*e = 15\\n=> e = 5 (the center of a magic square has to be 5)\\n=> x = 10(the other 2 numbers, which can form up a line together with the center number, have the sum to be 10)\\n```\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int res = 0;\\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n\\t\\t\\t\\t// check the center number of a square\\n                if (grid[i][j] != 5) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the other 2 numbers that can form up a line with the center number\\n                if (grid[i][j - 1] + grid[i][j + 1] != 10) continue;\\n                if (grid[i - 1][j] + grid[i + 1][j] != 10) continue;\\n                if (grid[i - 1][j - 1] + grid[i + 1][j + 1] != 10) continue;\\n                if (grid[i + 1][j - 1] + grid[i - 1][j + 1] != 10) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the rows and columns that don\\'t include the center number\\n                if (grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] != 15) continue;\\n                if (grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1] != 15) continue;\\n                if (grid[i - 1][j - 1] + grid[i][j - 1] + grid[i + 1][j - 1] != 15) continue;\\n                if (grid[i - 1][j + 1] + grid[i][j + 1] + grid[i + 1][j + 1] != 15) continue;\\n                   \\n\\t\\t\\t\\t// check if the current square is valid (distinct numbers from 1 to 9)\\n                if (isValid(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int x, int y) {\\n        int[] dx = {-1, 0, 1};\\n        int[] dy = {-1, 0, 1};\\n        int[] cnt = new int[16];\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                cnt[grid[x + dx[i]][y + dy[j]]]++;\\n            }\\n        }\\n        \\n        for (int n = 1; n <= 9; ++n) {\\n            if (cnt[n] != 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162192,
                "title": "clean-python-solution-easily-scalable-for-nxn-magic-squares",
                "content": "I avoided hardcoding my solution too much, so instead I made it scalable for NxN magic squares (just replace every occurence of 3 with N)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(i, j):\\n            nums_set = {k for k in range(1, 3 * 3 + 1)}\\n            target = 0\\n            \\n            # Traverse first row and use sum(first_row) as the target\\n            for num in grid[i][j:j + 3]:\\n                if 1 <= num <= 3 * 3:\\n                    nums_set.discard(num)\\n                    target += num\\n                else:\\n                    return 0\\n            \\n            # Traverse the other rows\\n            for k in range(i + 1, i + 3):\\n                t = 0\\n                for num in grid[k][j:j + 3]:\\n                    if 1 <= num <= 3 * 3:\\n                        nums_set.discard(num)\\n                        t += num\\n                    else:\\n                        return 0\\n                if t != target:\\n                    return 0\\n            \\n            # After traversing all rows, this set should be empty if all numbers were distinct\\n            if len(nums_set) != 0: return 0\\n            \\n            # Traverse the columns\\n            for q in range(j, j + 3):\\n                t = 0\\n                for p in range(i, i + 3):\\n                    t += grid[p][q]\\n                if t != target:\\n                    return 0\\n            \\n            # Traverse the top-left diagonal\\n            p, q = i, j\\n            t = 0\\n            while p < i + 3 and q < j + 3:\\n                t += grid[p][q]\\n                p += 1\\n                q += 1\\n            if t != target:\\n                return 0\\n            \\n            # Traverse the top-right diagonal\\n            p, q = i, j + 3\\n            t = 0\\n            while p < i + 3 and q > j:\\n                q -= 1\\n                t += grid[p][q]\\n                p += 1\\n            if t != target:\\n                return 0\\n                \\n            return 1\\n        \\n        # Go through all magic squares of length 3\\n        ans = 0\\n        for i in range(len(grid) - 3 + 1):\\n            for j in range(len(grid[0]) - 3 + 1):\\n                ans += is_magic_square(i, j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(i, j):\\n            nums_set = {k for k in range(1, 3 * 3 + 1)}\\n            target = 0\\n            \\n            # Traverse first row and use sum(first_row) as the target\\n            for num in grid[i][j:j + 3]:\\n                if 1 <= num <= 3 * 3:\\n                    nums_set.discard(num)\\n                    target += num\\n                else:\\n                    return 0\\n            \\n            # Traverse the other rows\\n            for k in range(i + 1, i + 3):\\n                t = 0\\n                for num in grid[k][j:j + 3]:\\n                    if 1 <= num <= 3 * 3:\\n                        nums_set.discard(num)\\n                        t += num\\n                    else:\\n                        return 0\\n                if t != target:\\n                    return 0\\n            \\n            # After traversing all rows, this set should be empty if all numbers were distinct\\n            if len(nums_set) != 0: return 0\\n            \\n            # Traverse the columns\\n            for q in range(j, j + 3):\\n                t = 0\\n                for p in range(i, i + 3):\\n                    t += grid[p][q]\\n                if t != target:\\n                    return 0\\n            \\n            # Traverse the top-left diagonal\\n            p, q = i, j\\n            t = 0\\n            while p < i + 3 and q < j + 3:\\n                t += grid[p][q]\\n                p += 1\\n                q += 1\\n            if t != target:\\n                return 0\\n            \\n            # Traverse the top-right diagonal\\n            p, q = i, j + 3\\n            t = 0\\n            while p < i + 3 and q > j:\\n                q -= 1\\n                t += grid[p][q]\\n                p += 1\\n            if t != target:\\n                return 0\\n                \\n            return 1\\n        \\n        # Go through all magic squares of length 3\\n        ans = 0\\n        for i in range(len(grid) - 3 + 1):\\n            for j in range(len(grid[0]) - 3 + 1):\\n                ans += is_magic_square(i, j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765635,
                "title": "easy-and-clean-code-with-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is1To9Exist(vector<vector<int>>& grid, int m1, int n1, int m2, int n2){\\n        vector<bool> arr(10,false);\\n        arr[0]=true;\\n        for(int i=m1;i<m2;i++){\\n           for(int j=n1;j<n2;j++){\\n               if(grid[i][j]>9 or arr[grid[i][j]]){\\n                   return false;\\n               }\\n               arr[grid[i][j]]=true;\\n           }\\n        }\\n        return true;\\n    }\\n    \\n    int isMagic(int row0, int row1, int row2, int col0, int col1, int col2, int daig1, int daig2){\\n        return (row0==row1 and row0==row2 and row0==col0 and row0==col1 and row0==col2 and row0==daig1 and row0==daig2)?1:0;        \\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        if(row<3){\\n            return 0;\\n        }\\n        int row1=0, row2=0, row0=0, col1=0, col2=0, col0=0, daig1=0, daig2=0, count=0;\\n        int i=0;\\n        for(int i=0;i<row-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                if(!is1To9Exist(grid, i, j, i+3, j+3)){\\n                    continue;\\n                }\\n                row0 = grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                col0 = grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n                row1 = grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n                col1 = grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];            \\n                row2 = grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                col2 = grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n                daig1 = grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n                daig2 = grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n                // cout<<row0<<\" \"<<row1<<\" \"<<row2<<\" \"<<col0<<\" \"<<col1<<\" \"<<col2<<\" \"<<daig1<<\" \"<<daig2<<endl;\\n                count+=isMagic(row0, row1, row2, col0, col1, col2, daig1, daig2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is1To9Exist(vector<vector<int>>& grid, int m1, int n1, int m2, int n2){\\n        vector<bool> arr(10,false);\\n        arr[0]=true;\\n        for(int i=m1;i<m2;i++){\\n           for(int j=n1;j<n2;j++){\\n               if(grid[i][j]>9 or arr[grid[i][j]]){\\n                   return false;\\n               }\\n               arr[grid[i][j]]=true;\\n           }\\n        }\\n        return true;\\n    }\\n    \\n    int isMagic(int row0, int row1, int row2, int col0, int col1, int col2, int daig1, int daig2){\\n        return (row0==row1 and row0==row2 and row0==col0 and row0==col1 and row0==col2 and row0==daig1 and row0==daig2)?1:0;        \\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        if(row<3){\\n            return 0;\\n        }\\n        int row1=0, row2=0, row0=0, col1=0, col2=0, col0=0, daig1=0, daig2=0, count=0;\\n        int i=0;\\n        for(int i=0;i<row-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                if(!is1To9Exist(grid, i, j, i+3, j+3)){\\n                    continue;\\n                }\\n                row0 = grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                col0 = grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n                row1 = grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n                col1 = grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];            \\n                row2 = grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                col2 = grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n                daig1 = grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n                daig2 = grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n                // cout<<row0<<\" \"<<row1<<\" \"<<row2<<\" \"<<col0<<\" \"<<col1<<\" \"<<col2<<\" \"<<daig1<<\" \"<<daig2<<endl;\\n                count+=isMagic(row0, row1, row2, col0, col1, col2, daig1, daig2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 663698,
                "title": "go-beats-100",
                "content": "```go\\nimport \"sort\"\\n\\nfunc numMagicSquaresInside(grid [][]int) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid) - 2; i++ {\\n        for j := 0; j < len(grid[0]) - 2; j++ {\\n            if grid[i + 1][j + 1] != 5 {\\n                continue\\n            }\\n            \\n            if check(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                     grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                     grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2]) {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc check(a, b, c, d, e, f, g, h, i int) bool {\\n    nums := []int{a, b, c, d, e, f, g, h, i}\\n    \\n    sort.Ints(nums)\\n    \\n    for i, v := range nums {\\n        if i + 1 != v {\\n            return false\\n        }\\n    }\\n    \\n    return a + b + c == 15 &&  d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 && c + f + i == 15 && a + e + i == 15 && c + e + g == 15\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"sort\"\\n\\nfunc numMagicSquaresInside(grid [][]int) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid) - 2; i++ {\\n        for j := 0; j < len(grid[0]) - 2; j++ {\\n            if grid[i + 1][j + 1] != 5 {\\n                continue\\n            }\\n            \\n            if check(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                     grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                     grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2]) {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc check(a, b, c, d, e, f, g, h, i int) bool {\\n    nums := []int{a, b, c, d, e, f, g, h, i}\\n    \\n    sort.Ints(nums)\\n    \\n    for i, v := range nums {\\n        if i + 1 != v {\\n            return false\\n        }\\n    }\\n    \\n    return a + b + c == 15 &&  d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 && c + f + i == 15 && a + e + i == 15 && c + e + g == 15\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 533267,
                "title": "c-double-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isFrom1to9(vector<vector<int>>& grid, int si, int sj) {\\n        bool find[16]{false};\\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                find[grid[si+i][sj+j]] = true;\\n            }\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (!find[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isMagic(vector<vector<int>>& grid, int si, int sj) {\\n        if (!isFrom1to9(grid, si, sj))\\n            return false;\\n        int sum = grid[si][sj] + grid[si][sj+1] + grid[si][sj+2];\\n        for (int i = 0; i < 3; ++i) {\\n            int tmp1 = grid[si+i][sj] + grid[si+i][sj+1] + grid[si+i][sj+2];\\n            int tmp2 = grid[si][sj+i] + grid[si+1][sj+i] + grid[si+2][sj+i];\\n            if (tmp1 != sum || tmp2 != sum) return false;\\n        }\\n        int tmp3 = grid[si][sj] + grid[si+1][sj+1] + grid[si+2][sj+2];\\n        int tmp4 = grid[si+2][sj] + grid[si+1][sj+1] + grid[si][sj+2];\\n        printf(\"tmp3=%d tmp4=%d\\\\n\", tmp3, tmp4);\\n        if (tmp3 != sum || tmp4 != sum) return false;\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int max_i = grid.size();\\n        int max_j = grid[0].size();\\n        int sum = 0;\\n        for (int i = 0; i < max_i - 2; ++i) {\\n            for (int j = 0; j < max_j - 2; ++j) {\\n                if (isMagic(grid, i, j)) ++sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFrom1to9(vector<vector<int>>& grid, int si, int sj) {\\n        bool find[16]{false};\\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                find[grid[si+i][sj+j]] = true;\\n            }\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (!find[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isMagic(vector<vector<int>>& grid, int si, int sj) {\\n        if (!isFrom1to9(grid, si, sj))\\n            return false;\\n        int sum = grid[si][sj] + grid[si][sj+1] + grid[si][sj+2];\\n        for (int i = 0; i < 3; ++i) {\\n            int tmp1 = grid[si+i][sj] + grid[si+i][sj+1] + grid[si+i][sj+2];\\n            int tmp2 = grid[si][sj+i] + grid[si+1][sj+i] + grid[si+2][sj+i];\\n            if (tmp1 != sum || tmp2 != sum) return false;\\n        }\\n        int tmp3 = grid[si][sj] + grid[si+1][sj+1] + grid[si+2][sj+2];\\n        int tmp4 = grid[si+2][sj] + grid[si+1][sj+1] + grid[si][sj+2];\\n        printf(\"tmp3=%d tmp4=%d\\\\n\", tmp3, tmp4);\\n        if (tmp3 != sum || tmp4 != sum) return false;\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int max_i = grid.size();\\n        int max_j = grid[0].size();\\n        int sum = 0;\\n        for (int i = 0; i < max_i - 2; ++i) {\\n            for (int j = 0; j < max_j - 2; ++j) {\\n                if (isMagic(grid, i, j)) ++sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453742,
                "title": "javascript-solution",
                "content": "### \\u5206\\u6790 1\\n\\n> \\u66B4\\u529B\\u62C6\\u89E3 + \\u6821\\u9A8C\\n\\n\\u66B4\\u529B\\u62C6\\u89E3\\uFF1A\\n\\n1. \\u4E09\\u9636\\u4EE5\\u4E0B\\uFF0C\\u8FD4\\u56DE 0\\n\\n2. \\u5927\\u4E8E\\u7B49\\u4E8E\\u4E09\\u9636\\uFF0C\\u904D\\u5386\\u6240\\u6709\\u4E5D\\u5BAB\\u683C\\u77E9\\u9635\\n\\n\\u6821\\u9A8C\\uFF1A\\n\\n1. 1-9\\n2. \\u6570\\u5B57\\u5404\\u4E0D\\u76F8\\u540C\\n3. \\u6BCF\\u884C\\u6BCF\\u5217\\u53CA\\u5BF9\\u89D2\\u7EBF\\u548C\\u76F8\\u7B49\\uFF088\\u4E2A\\u7B49\\u5F0F\\uFF09\\n\\n\\n\\n### \\u5206\\u6790 2\\n\\n> \\u4ECD\\u7136\\u662F \\u66B4\\u529B\\u62C6\\u89E3 + \\u6821\\u9A8C\\uFF0C\\u4F46\\u5728\\u5206\\u6790 1 \\u7684\\u57FA\\u7840\\u4E0A\\uFF0C\\u5BF9\\u6821\\u9A8C\\u6761\\u4EF6 3 \\u505A\\u4F18\\u5316\\n\\n| a     | b     | s-a-b |\\n| ----- | ----- | ----- |\\n| c     | d     | s-c-d |\\n| s-a-c | s-b-d | s-a-d |\\n\\n\\u5047\\u8BBE\\u5E7B\\u65B9\\u53F3\\u4E0A\\u89D2\\u56DB\\u4E2A\\u5143\\u7D20\\u4E3Aa,b,c,d\\uFF0C\\u6BCF\\u4E00\\u884C\\u7684\\u548C\\u4E3A s ,\\u5219\\u5269\\u4F59 5 \\u4E2A\\u5143\\u7D20\\u90FD\\u53EF\\u4EE5\\u6C42\\u5F97\\u3002\\n\\n\\u5219\\u7B2C\\u4E09\\u884C\\uFF08\\u5217\\uFF09\\u5FC5\\u7136\\u6EE1\\u8DB3\\uFF1A\\n\\n\\u200B\\t(s-a-c)+(s-b-d)+(s-a-d)=s\\n\\n=> 2a+b+c+2d=2s\\n\\n\\u8FD9\\u6837\\uFF0C\\u5206\\u6790 1 \\u7684\\u6821\\u9A8C 3 \\u5C31\\u4ECE 8 \\u4E2A \\u88AB\\u4F18\\u5316\\u5230 1 \\u4E2A\\u7B49\\u5F0F\\u3002\\n\\n\\n\\n## \\u5206\\u6790 3\\n\\n> \\u51E1\\u662F\\u8FD9\\u79CD\\u9AD8\\u5EA6\\u5BF9\\u79F0\\u7684\\u56FE\\u5F62\\u6216\\u6570\\u96C6\\uFF0C\\u53EF\\u4EE5\\u731C\\u60F3\\u4E2D\\u5FC3\\u6570\\u5B57\\u662F\\u5426\\u4E3A\\u5BF9\\u79F0\\u4E2D\\u5FC3\\uFF081-9 \\u7684\\u5BF9\\u79F0\\u4E2D\\u5FC3\\u662F 5\\uFF09\\u3002\\n\\n\\u6240\\u6709\\u884C\\u5217\\u548C\\uFF088 \\u5BF9\\uFF09\\u76F8\\u7B49\\uFF0C\\u5219\\u52BF\\u5FC5\\u6DB5\\u76D6\\u4E2D\\u5FC3\\u7684\\uFF084 \\u5BF9\\uFF09\\u76F8\\u7B49\\uFF0C\\u7531\\u6821\\u9A8C\\u6761\\u4EF6 1\\uFF0C2 \\u53EF\\u4EE5\\u63A8\\u51FA\\uFF0C\\u8981\\u5728 1-9 \\u5185\\u627E\\u51FA 4 \\u5BF9\\u548C\\u76F8\\u540C\\u7684\\u6570\\u5B57\\uFF0C\\u5FC5\\u7136\\u662F \\uFF081\\u30019\\uFF09\\uFF082\\u30018\\uFF09\\uFF083\\u30017\\uFF09\\uFF084\\u30016\\uFF09\\uFF085\\uFF09\\uFF0C\\u6240\\u4EE5\\u4E2D\\u5FC3\\u6570\\u5B57\\u4E00\\u5B9A\\u4E3A 5\\u3002\\uFF08\\u8BE6\\u7EC6\\u8BC1\\u660E\\u7565\\uFF09\\n\\n```javascript\\nvar numMagicSquaresInside = function(grid) {\\n  let num = 0;\\n  if (grid.length < 3 || grid.some(r => r.length < 3)) {\\n    return num;\\n  }\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length - 2; j++) {\\n      const square = [\\n        grid[i][j],\\n        grid[i][j + 1],\\n        grid[i][j + 2],\\n        grid[i + 1][j],\\n        grid[i + 1][j + 1],\\n        grid[i + 1][j + 2],\\n        grid[i + 2][j],\\n        grid[i + 2][j + 1],\\n        grid[i + 2][j + 2]\\n      ];\\n      if (\\n        grid[4]!==5 ||\\n        square.some(x => x < 1 || x > 9) ||\\n        Array.from(new Set(square)).length < 9\\n      ) {\\n        continue;\\n      }\\n      if (\\n        2 * square[0] + square[1] + square[3] + 2 * square[4] ===\\n        2 * (square[0] + square[1] + square[2])\\n      ) {\\n        num++;\\n      }\\n    }\\n  }\\n  return num;\\n};\\n```\\n\\n\\n\\n### \\u603B\\u7ED3\\n\\n\\u4E09\\u79CD\\u65B9\\u6CD5\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1A\\u5206\\u6790 1>\\u5206\\u6790 2>\\u5206\\u6790 3",
                "solutionTags": [],
                "code": "```javascript\\nvar numMagicSquaresInside = function(grid) {\\n  let num = 0;\\n  if (grid.length < 3 || grid.some(r => r.length < 3)) {\\n    return num;\\n  }\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length - 2; j++) {\\n      const square = [\\n        grid[i][j],\\n        grid[i][j + 1],\\n        grid[i][j + 2],\\n        grid[i + 1][j],\\n        grid[i + 1][j + 1],\\n        grid[i + 1][j + 2],\\n        grid[i + 2][j],\\n        grid[i + 2][j + 1],\\n        grid[i + 2][j + 2]\\n      ];\\n      if (\\n        grid[4]!==5 ||\\n        square.some(x => x < 1 || x > 9) ||\\n        Array.from(new Set(square)).length < 9\\n      ) {\\n        continue;\\n      }\\n      if (\\n        2 * square[0] + square[1] + square[3] + 2 * square[4] ===\\n        2 * (square[0] + square[1] + square[2])\\n      ) {\\n        num++;\\n      }\\n    }\\n  }\\n  return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241515,
                "title": "no-tricks-plain-brute-force-elaborate-and-understandable-beats-100-python",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: \\'List[List[int]]\\') -> \\'int\\':\\n        verticalstep = 0\\n        magiccnt = 0\\n        if len(grid[0]) < 3 or len(grid[1]) < 3:\\n            return magiccnt\\n            \\n        while verticalstep+2 < len(grid):\\n            startindex = 0\\n            endindex = 2\\n            while endindex < len(grid[0]):\\n                \\n                s = []\\n                for i in range(verticalstep, verticalstep+3):\\n                    s.extend( grid[i][startindex:endindex+1])\\n                \\n                s = set(s)\\n                if len(s) < 9 or min(s) < 1 or max(s) > 9:\\n                    startindex+=1\\n                    endindex+=1\\n                    continue\\n                \\n                rowsum = getSum(grid[verticalstep:verticalstep+3], \\'row\\', startindex, endindex, verticalstep)\\n                colsum = getSum(grid[verticalstep:verticalstep+3], \\'col\\', startindex, endindex, verticalstep)\\n                daigonalsum = getSum(grid[verticalstep:verticalstep+3], \\'daigonal\\', startindex, endindex, verticalstep)\\n                \\n                \\n                if rowsum[1] and colsum[1] and daigonalsum[1] and rowsum[0]== colsum[0] and daigonalsum[0]:\\n                    magiccnt += 1\\n                startindex+=1\\n                endindex+=1\\n            \\n            verticalstep+=1\\n            \\n        return magiccnt\\n            \\n\\ndef getSum(grd, way, startindex, endindex, verticalstep):\\n    \\n    summ = 0\\n    if way == \\'row\\':\\n        for item in grd:\\n            if summ==0:\\n                summ = sum(item[startindex:endindex+1])\\n            else:\\n                if summ != sum(item[startindex:endindex+1]):\\n                    return(-1, False)\\n        return (summ, True)\\n    \\n    elif way== \\'col\\':\\n        \\n        col1, col2, col3 = 0, 0, 0\\n        for col in grd:\\n            col1+= col[startindex]\\n            col2+= col[startindex+1]\\n            col3+= col[startindex+2]\\n        \\n        if col1 == col2 == col3 :\\n            summ = col1\\n            return (summ, True)\\n        else:\\n            return (-1, False)\\n            \\n    elif way == \\'daigonal\\':\\n        for daig in grd:\\n            daig1 = grd[0][startindex] + grd[1][startindex+1] + grd[2][startindex+2]\\n            daig2 = grd[0][endindex] + grd[1][endindex-1] + grd[2][endindex-2]\\n            \\n            if daig1 == daig2:\\n                summ = daig1\\n                return (summ, True)\\n            else:\\n                return (-1, False)\\n            \\n    # Error Checking\\n    else:\\n        return -1\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: \\'List[List[int]]\\') -> \\'int\\':\\n        verticalstep = 0\\n        magiccnt = 0\\n        if len(grid[0]) < 3 or len(grid[1]) < 3:\\n            return magiccnt\\n            \\n        while verticalstep+2 < len(grid):\\n            startindex = 0\\n            endindex = 2\\n            while endindex < len(grid[0]):\\n                \\n                s = []\\n                for i in range(verticalstep, verticalstep+3):\\n                    s.extend( grid[i][startindex:endindex+1])\\n                \\n                s = set(s)\\n                if len(s) < 9 or min(s) < 1 or max(s) > 9:\\n                    startindex+=1\\n                    endindex+=1\\n                    continue\\n                \\n                rowsum = getSum(grid[verticalstep:verticalstep+3], \\'row\\', startindex, endindex, verticalstep)\\n                colsum = getSum(grid[verticalstep:verticalstep+3], \\'col\\', startindex, endindex, verticalstep)\\n                daigonalsum = getSum(grid[verticalstep:verticalstep+3], \\'daigonal\\', startindex, endindex, verticalstep)\\n                \\n                \\n                if rowsum[1] and colsum[1] and daigonalsum[1] and rowsum[0]== colsum[0] and daigonalsum[0]:\\n                    magiccnt += 1\\n                startindex+=1\\n                endindex+=1\\n            \\n            verticalstep+=1\\n            \\n        return magiccnt\\n            \\n\\ndef getSum(grd, way, startindex, endindex, verticalstep):\\n    \\n    summ = 0\\n    if way == \\'row\\':\\n        for item in grd:\\n            if summ==0:\\n                summ = sum(item[startindex:endindex+1])\\n            else:\\n                if summ != sum(item[startindex:endindex+1]):\\n                    return(-1, False)\\n        return (summ, True)\\n    \\n    elif way== \\'col\\':\\n        \\n        col1, col2, col3 = 0, 0, 0\\n        for col in grd:\\n            col1+= col[startindex]\\n            col2+= col[startindex+1]\\n            col3+= col[startindex+2]\\n        \\n        if col1 == col2 == col3 :\\n            summ = col1\\n            return (summ, True)\\n        else:\\n            return (-1, False)\\n            \\n    elif way == \\'daigonal\\':\\n        for daig in grd:\\n            daig1 = grd[0][startindex] + grd[1][startindex+1] + grd[2][startindex+2]\\n            daig2 = grd[0][endindex] + grd[1][endindex-1] + grd[2][endindex-2]\\n            \\n            if daig1 == daig2:\\n                summ = daig1\\n                return (summ, True)\\n            else:\\n                return (-1, False)\\n            \\n    # Error Checking\\n    else:\\n        return -1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041450,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            if(ax[i]==0) return false;\\n        }\\n\\n        int sum = arr[a][b]+arr[a][b+1]+arr[a][b+2];\\n\\n        for(int i=a; i<=c; i++){\\n            int s = arr[i][b]+arr[i][b+1]+arr[i][b+2];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        for(int j=b; j<=d; j++){\\n            int s = arr[a][j]+arr[a+1][j]+arr[a+2][j];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        if(arr[a][b]+arr[a+1][b+1]+arr[a+2][b+2]!=sum) {\\n            return false;\\n        }\\n        if(arr[a][b+2]+arr[a+1][b+1]+arr[a+2][b]!=sum) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] arr) {\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++){\\n            for(int j=0; j<m-2; j++){\\n                if(helper(arr,i,j,i+2,j+2)) ans++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            if(ax[i]==0) return false;\\n        }\\n\\n        int sum = arr[a][b]+arr[a][b+1]+arr[a][b+2];\\n\\n        for(int i=a; i<=c; i++){\\n            int s = arr[i][b]+arr[i][b+1]+arr[i][b+2];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        for(int j=b; j<=d; j++){\\n            int s = arr[a][j]+arr[a+1][j]+arr[a+2][j];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        if(arr[a][b]+arr[a+1][b+1]+arr[a+2][b+2]!=sum) {\\n            return false;\\n        }\\n        if(arr[a][b+2]+arr[a+1][b+1]+arr[a+2][b]!=sum) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] arr) {\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++){\\n            for(int j=0; j<m-2; j++){\\n                if(helper(arr,i,j,i+2,j+2)) ans++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489358,
                "title": "solution",
                "content": "```C++ []\\n#define DO(...) { __VA_ARGS__ do\\n#define WHILE(...) while(__VA_ARGS__); }\\n\\nclass Solution {\\n    typedef unsigned int uInt;\\n    typedef const uInt c_uInt;\\n    static constexpr uInt\\n        magicSize = 3, magicSizeM1 = magicSize - 1;\\n    bool contained[10];\\n    bool isMagicSqr (const vector<vector<int>> &grid, c_uInt c_row, c_uInt c_col) {\\n        uInt sum, targetSum;\\n        DO ( uInt row = 0; ) {\\n            sum = 0;\\n            DO ( uInt col = 0; ) {\\n                uInt num = grid[c_row + row][c_col + col];\\n                if ((1 <= num) && (num <= 9)) {} else return false;\\n                bool &hasNum = contained[num];\\n                if (hasNum) return false;\\n                hasNum = true; sum += num;\\n            } WHILE (++col < magicSize);\\n            if (row) {\\n                if (targetSum != sum) return false;\\n            } else { targetSum = sum; }\\n        } WHILE (++row < magicSize);\\n        DO ( uInt col = 0; ) {\\n            sum = 0;\\n            DO ( uInt row = 0; ) {\\n                sum += grid[c_row + row][c_col + col];\\n            } WHILE (++row < magicSize);\\n            if (targetSum != sum) return false;\\n        } WHILE (++col < magicSize);\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        if (targetSum != sum) return false;\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + magicSizeM1 - ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        return (targetSum == sum);\\n    }\\npublic:\\n    uInt numMagicSquaresInside(const vector<vector<int>> &grid) {\\n        uInt magicCnt = 0;\\n        c_uInt rowCnt = grid.size(), colCnt = grid[0].size();\\n        for (uInt lstRow = magicSizeM1; lstRow < rowCnt; lstRow++) {\\n            for (uInt lstCol = magicSizeM1; lstCol < colCnt; lstCol++) {\\n                fill(contained + 1, contained + 10, false);\\n                if (isMagicSqr(grid, lstRow - magicSizeM1, lstCol - magicSizeM1)) { ++magicCnt; }\\n            }\\n        }\\n        return magicCnt;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n\\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n        return count\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        return magicBoxCount;\\n    }\\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 || \\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15)\\n        {\\n            return false;\\n        }\\n        return true;   \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#define DO(...) { __VA_ARGS__ do\\n#define WHILE(...) while(__VA_ARGS__); }\\n\\nclass Solution {\\n    typedef unsigned int uInt;\\n    typedef const uInt c_uInt;\\n    static constexpr uInt\\n        magicSize = 3, magicSizeM1 = magicSize - 1;\\n    bool contained[10];\\n    bool isMagicSqr (const vector<vector<int>> &grid, c_uInt c_row, c_uInt c_col) {\\n        uInt sum, targetSum;\\n        DO ( uInt row = 0; ) {\\n            sum = 0;\\n            DO ( uInt col = 0; ) {\\n                uInt num = grid[c_row + row][c_col + col];\\n                if ((1 <= num) && (num <= 9)) {} else return false;\\n                bool &hasNum = contained[num];\\n                if (hasNum) return false;\\n                hasNum = true; sum += num;\\n            } WHILE (++col < magicSize);\\n            if (row) {\\n                if (targetSum != sum) return false;\\n            } else { targetSum = sum; }\\n        } WHILE (++row < magicSize);\\n        DO ( uInt col = 0; ) {\\n            sum = 0;\\n            DO ( uInt row = 0; ) {\\n                sum += grid[c_row + row][c_col + col];\\n            } WHILE (++row < magicSize);\\n            if (targetSum != sum) return false;\\n        } WHILE (++col < magicSize);\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        if (targetSum != sum) return false;\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + magicSizeM1 - ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        return (targetSum == sum);\\n    }\\npublic:\\n    uInt numMagicSquaresInside(const vector<vector<int>> &grid) {\\n        uInt magicCnt = 0;\\n        c_uInt rowCnt = grid.size(), colCnt = grid[0].size();\\n        for (uInt lstRow = magicSizeM1; lstRow < rowCnt; lstRow++) {\\n            for (uInt lstCol = magicSizeM1; lstCol < colCnt; lstCol++) {\\n                fill(contained + 1, contained + 10, false);\\n                if (isMagicSqr(grid, lstRow - magicSizeM1, lstCol - magicSizeM1)) { ++magicCnt; }\\n            }\\n        }\\n        return magicCnt;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n\\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        return magicBoxCount;\\n    }\\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 || \\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15)\\n        {\\n            return false;\\n        }\\n        return true;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414013,
                "title": "c-easy-to-under-stand",
                "content": "# Intuition\\n![WhatsApp Image 2023-04-14 at 00.11.01.jpg](https://assets.leetcode.com/users/images/bfa78578-a8f9-44ec-9874-de030cecfe4c_1681411350.9803658.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool magicsquare(vector<vector<int>> &grid , int i , int j){\\n\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(magicsquare(grid, i, j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool magicsquare(vector<vector<int>> &grid , int i , int j){\\n\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(magicsquare(grid, i, j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066406,
                "title": "0ms-runtime-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to check each 3x3 sub-grid in the grid for the conditions of a magic square, and if all conditions are satisfied, increment the count of the number of magic squares. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo do that, we first check if the sum of each row, column and diagonal are equal. If they are, we then check if the central element is 5, and if all the numbers from 1 to 9 are present in the 3x3 sub-grid. If all conditions are met, we increment our count.\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the above code is O(n^3), where n is the size of the grid. This is because the code iterates through each element in the grid, and then checks each row, column, and diagonal for a sum of 15.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the above code is O(1), as the code does not use any additional memory and only uses variables declared within the function.\\n# Code\\n```\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698216,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        M, N = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        \\n        def magic(a,b,c,\\n                  d,e,f,\\n                  g,h,i):\\n            \\n            return (reduce(lambda d, c: d + 1 if 1<=c<=9 else 0, set([a,b,c,d,e,f,g,h,i]), 0) == 9 and\\n                (a+b+c == d+e+f == g+h+i == a+d+g == b+e+h == c+f+i == a+e+i == c+e+g == 15))\\n        \\n        for i in range(M-2):\\n            for j in range(N-2):\\n                if magic(grid[i][j], grid[i][j+1], grid[i][j+2], \\n                      grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2], \\n                      grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]) : ans += 1\\n                       \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        M, N = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        \\n        def magic(a,b,c,\\n                  d,e,f,\\n                  g,h,i):\\n            \\n            return (reduce(lambda d, c: d + 1 if 1<=c<=9 else 0, set([a,b,c,d,e,f,g,h,i]), 0) == 9 and\\n                (a+b+c == d+e+f == g+h+i == a+d+g == b+e+h == c+f+i == a+e+i == c+e+g == 15))\\n        \\n        for i in range(M-2):\\n            for j in range(N-2):\\n                if magic(grid[i][j], grid[i][j+1], grid[i][j+2], \\n                      grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2], \\n                      grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]) : ans += 1\\n                       \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898235,
                "title": "java-1ms-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651894,
                "title": "java-easy-solution-bfa",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[i].length;j++) \\n                if(magic(grid,i,j))\\n                    count++;\\n        \\n        \\n        \\n        return count;\\n    }\\n    boolean magic(int grid[][],int x,int y){\\n        if(x+2>=grid.length || y+2 >=grid[0].length)\\n            return false;\\n        int row[]=new int[3];\\n        int col[]=new int[3];\\n        int diagonal[]=new int[2];\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=x;i<=x+2;i++){\\n            for(int j=y;j<=y+2;j++){\\n                \\n                if(set.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                set.add(grid[i][j]);\\n                \\n                row[i-x]+=grid[i][j];\\n                col[j-y]+=grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n                \\n            }\\n        }\\n        int val=row[0];\\n        for(int i:row) if(val!=i) return false;\\n        val=col[0];\\n        for(int i:col) if(val!=i) return false;\\n        if(diagonal[0]!=diagonal[1]) return false;\\n        return true;\\n        \\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[i].length;j++) \\n                if(magic(grid,i,j))\\n                    count++;\\n        \\n        \\n        \\n        return count;\\n    }\\n    boolean magic(int grid[][],int x,int y){\\n        if(x+2>=grid.length || y+2 >=grid[0].length)\\n            return false;\\n        int row[]=new int[3];\\n        int col[]=new int[3];\\n        int diagonal[]=new int[2];\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=x;i<=x+2;i++){\\n            for(int j=y;j<=y+2;j++){\\n                \\n                if(set.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                set.add(grid[i][j]);\\n                \\n                row[i-x]+=grid[i][j];\\n                col[j-y]+=grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n                \\n            }\\n        }\\n        int val=row[0];\\n        for(int i:row) if(val!=i) return false;\\n        val=col[0];\\n        for(int i:col) if(val!=i) return false;\\n        if(diagonal[0]!=diagonal[1]) return false;\\n        return true;\\n        \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595289,
                "title": "py-magic-squares-in-grid",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n        \\n        R,C = len(G), len(G[0])\\n        if R < 3 or C < 3: return 0\\n        \\n        ans = 0\\n        for r in range(R-2):\\n            for c in range(C-2):\\n                nums = set(G[r][c:c+3] + G[r+1][c:c+3] + G[r+2][c:c+3])\\n                r1 = sum(G[r][c:c+3])\\n                r2 = sum(G[r+1][c:c+3])\\n                r3 = sum(G[r+2][c:c+3])\\n                c1 = G[r][c] + G[r+1][c] + G[r+2][c]\\n                c2 = G[r][c+1] + G[r+1][c+1] + G[r+2][c+1]\\n                c3 = G[r][c+2] + G[r+1][c+2] + G[r+2][c+2]\\n                d1 = G[r][c] + G[r+1][c+1] + G[r+2][c+2]\\n                d2 = G[r+2][c] + G[r+1][c+1] + G[r][c+2]\\n                ans += len(nums) == 9 and min(nums) >= 1 and max(nums) <= 9 and r1 == r2 == r3 == c1 == c2 == c3 == d1 == d2\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n        \\n        R,C = len(G), len(G[0])\\n        if R < 3 or C < 3: return 0\\n        \\n        ans = 0\\n        for r in range(R-2):\\n            for c in range(C-2):\\n                nums = set(G[r][c:c+3] + G[r+1][c:c+3] + G[r+2][c:c+3])\\n                r1 = sum(G[r][c:c+3])\\n                r2 = sum(G[r+1][c:c+3])\\n                r3 = sum(G[r+2][c:c+3])\\n                c1 = G[r][c] + G[r+1][c] + G[r+2][c]\\n                c2 = G[r][c+1] + G[r+1][c+1] + G[r+2][c+1]\\n                c3 = G[r][c+2] + G[r+1][c+2] + G[r+2][c+2]\\n                d1 = G[r][c] + G[r+1][c+1] + G[r+2][c+2]\\n                d2 = G[r+2][c] + G[r+1][c+1] + G[r][c+2]\\n                ans += len(nums) == 9 and min(nums) >= 1 and max(nums) <= 9 and r1 == r2 == r3 == c1 == c2 == c3 == d1 == d2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437092,
                "title": "math-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416192,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid == null || grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isValid(grid, i, j)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int m, int n) {\\n        int sum = grid[m][n] + grid[m][n + 1] + grid[m][n + 2];\\n        //row\\n        for (int i = m; i < m + 3; i++) {\\n            int rowSum = 0;\\n            for (int j = n; j < n + 3; j++) {\\n                rowSum += grid[i][j];\\n            }\\n            if (rowSum != sum) {\\n                return false;\\n            }\\n        }\\n        //column\\n        for (int j = n; j < n + 3; j++) {\\n            int colSum = 0;\\n            for (int i = m; i < m + 3; i++) {\\n                colSum += grid[i][j];\\n            }\\n            if (colSum != sum) {\\n                return false;\\n            }\\n        }\\n        //diagonal\\n        if (sum != grid[m][n] + grid[m + 1][n + 1] + grid[m + 2][n + 2]) {\\n            return false;\\n        }\\n        //back diagonal\\n        if (sum != grid[m][n + 2] + grid[m + 1][n + 1] + grid[m + 2][n]) {\\n            return false;\\n        }\\n        //distinct and 1-9\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                if (grid[i][j] > 9 || grid[i][j] < 1) {\\n                    return false;\\n                }\\n                if (set.contains(grid[i][j])) {\\n                    return false;\\n                } else {\\n                    set.add(grid[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid == null || grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isValid(grid, i, j)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int m, int n) {\\n        int sum = grid[m][n] + grid[m][n + 1] + grid[m][n + 2];\\n        //row\\n        for (int i = m; i < m + 3; i++) {\\n            int rowSum = 0;\\n            for (int j = n; j < n + 3; j++) {\\n                rowSum += grid[i][j];\\n            }\\n            if (rowSum != sum) {\\n                return false;\\n            }\\n        }\\n        //column\\n        for (int j = n; j < n + 3; j++) {\\n            int colSum = 0;\\n            for (int i = m; i < m + 3; i++) {\\n                colSum += grid[i][j];\\n            }\\n            if (colSum != sum) {\\n                return false;\\n            }\\n        }\\n        //diagonal\\n        if (sum != grid[m][n] + grid[m + 1][n + 1] + grid[m + 2][n + 2]) {\\n            return false;\\n        }\\n        //back diagonal\\n        if (sum != grid[m][n + 2] + grid[m + 1][n + 1] + grid[m + 2][n]) {\\n            return false;\\n        }\\n        //distinct and 1-9\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                if (grid[i][j] > 9 || grid[i][j] < 1) {\\n                    return false;\\n                }\\n                if (set.contains(grid[i][j])) {\\n                    return false;\\n                } else {\\n                    set.add(grid[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1413117,
                "title": "solved-without-skills",
                "content": "There are only 8 magic squares\\n- The center must be 5. We know that sum of each column/row is 15 ((1+2+3+4+5+6+7+8+9) / 3). If the center is not 5, there is no place for 9. If the center is 9, there is no place for 8.\\n- The corners must not be 9. If it is, we need 9 + 2 + 4 and 9 + 3 + 3 which is not possible.\\n- And so on and so forth.\\n- All 8 magic squares are flipped / reversed / mirrored from the others.\\n\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        squares = [\\n            [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\\n            [[2, 7, 6], [9, 5, 1], [4, 3, 8]],\\n            [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\\n            [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\\n            \\n            [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\\n            [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\\n            [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\\n            [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\\n        ]\\n        \\n        ans = 0\\n        \\n        for x, y, z in itertools.product(range(len(grid[0]) - 2), range(len(grid) - 2), range(8)):\\n            for dx, dy in itertools.product(range(3), range(3)):\\n                if grid[y+dy][x+dx] != squares[z][dy][dx]:\\n                    break\\n            else:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        squares = [\\n            [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\\n            [[2, 7, 6], [9, 5, 1], [4, 3, 8]],\\n            [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\\n            [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\\n            \\n            [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\\n            [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\\n            [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\\n            [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\\n        ]\\n        \\n        ans = 0\\n        \\n        for x, y, z in itertools.product(range(len(grid[0]) - 2), range(len(grid) - 2), range(8)):\\n            for dx, dy in itertools.product(range(3), range(3)):\\n                if grid[y+dy][x+dx] != squares[z][dy][dx]:\\n                    break\\n            else:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124534,
                "title": "fast-c-solution",
                "content": "```\\npublic int NumMagicSquaresInside(int[][] grid) {\\n        var subGrids = GetSubGrids(grid); \\n        var count = 0; \\n        foreach(var subGrid in subGrids) {\\n            if(IsMagicSquare(subGrid))\\n                count++; \\n        }\\n        return count; \\n    }\\n    private List<int[,]> GetSubGrids(int[][] grid) {\\n        var subGrids = new List<int[,]>(); \\n        for(int row = 0; row < grid.Length - 2; row++) {\\n            for(int col = 0; col < grid[0].Length - 2; col++) {\\n                int[,] magicSquare = new int[3, 3]; \\n                magicSquare[0, 0] = grid[row][col]; \\n                magicSquare[0, 1] = grid[row][col + 1]; \\n                magicSquare[0, 2] = grid[row][col + 2]; \\n                magicSquare[1, 0] = grid[row + 1][col];\\n                magicSquare[1, 1] = grid[row + 1][col + 1]; \\n                magicSquare[1, 2] = grid[row + 1][col + 2]; \\n                magicSquare[2, 0] = grid[row + 2][col];\\n                magicSquare[2, 1] = grid[row + 2][col + 1]; \\n                magicSquare[2 ,2] = grid[row + 2][col + 2]; \\n                subGrids.Add(magicSquare);\\n            }\\n        }\\n        return subGrids; \\n    }\\n    \\n    private bool IsMagicSquare(int[,] grid) {\\n        var mid = grid[1,1]; \\n        \\n        if(mid != 5 || !IsNumbersUniqueInMagicSquare(grid)) \\n            return false;\\n        \\n        var sums = new [] {\\n            grid[0,0] + grid[0,1] + grid[0,2], \\n            grid[1,0] + mid + grid[1,2], \\n            grid[2, 0] + grid[2,1] + grid[2,2], \\n            grid[0,0] + mid + grid[2,2], \\n            grid[0,2] + mid + grid[2,0], \\n            grid[0, 0] + grid[1, 0] + grid[2, 0], \\n            grid[0, 1] + mid + grid[2, 1],  \\n            grid[0, 2] + grid[1, 2] + grid[2, 2]\\n        }; \\n        foreach(var sum in sums) {\\n            if(sum != 15)\\n                return false;   \\n        } \\n        \\n        return true; \\n    }\\n    \\n    private bool IsNumbersUniqueInMagicSquare(int[,] grid) {\\n        HashSet<int> numbers = new HashSet<int>(); \\n        \\n        for(int i = 0; i < grid.GetLength(0); i++) {\\n            for(int j = 0; j < grid.GetLength(1); j++) {\\n                if(grid[i, j] < 1 || grid[i, j] > 10 || numbers.Contains(grid[i, j]))\\n                    return false; \\n                \\n                numbers.Add(grid[i, j]);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumMagicSquaresInside(int[][] grid) {\\n        var subGrids = GetSubGrids(grid); \\n        var count = 0; \\n        foreach(var subGrid in subGrids) {\\n            if(IsMagicSquare(subGrid))\\n                count++; \\n        }\\n        return count; \\n    }\\n    private List<int[,]> GetSubGrids(int[][] grid) {\\n        var subGrids = new List<int[,]>(); \\n        for(int row = 0; row < grid.Length - 2; row++) {\\n            for(int col = 0; col < grid[0].Length - 2; col++) {\\n                int[,] magicSquare = new int[3, 3]; \\n                magicSquare[0, 0] = grid[row][col]; \\n                magicSquare[0, 1] = grid[row][col + 1]; \\n                magicSquare[0, 2] = grid[row][col + 2]; \\n                magicSquare[1, 0] = grid[row + 1][col];\\n                magicSquare[1, 1] = grid[row + 1][col + 1]; \\n                magicSquare[1, 2] = grid[row + 1][col + 2]; \\n                magicSquare[2, 0] = grid[row + 2][col];\\n                magicSquare[2, 1] = grid[row + 2][col + 1]; \\n                magicSquare[2 ,2] = grid[row + 2][col + 2]; \\n                subGrids.Add(magicSquare);\\n            }\\n        }\\n        return subGrids; \\n    }\\n    \\n    private bool IsMagicSquare(int[,] grid) {\\n        var mid = grid[1,1]; \\n        \\n        if(mid != 5 || !IsNumbersUniqueInMagicSquare(grid)) \\n            return false;\\n        \\n        var sums = new [] {\\n            grid[0,0] + grid[0,1] + grid[0,2], \\n            grid[1,0] + mid + grid[1,2], \\n            grid[2, 0] + grid[2,1] + grid[2,2], \\n            grid[0,0] + mid + grid[2,2], \\n            grid[0,2] + mid + grid[2,0], \\n            grid[0, 0] + grid[1, 0] + grid[2, 0], \\n            grid[0, 1] + mid + grid[2, 1],  \\n            grid[0, 2] + grid[1, 2] + grid[2, 2]\\n        }; \\n        foreach(var sum in sums) {\\n            if(sum != 15)\\n                return false;   \\n        } \\n        \\n        return true; \\n    }\\n    \\n    private bool IsNumbersUniqueInMagicSquare(int[,] grid) {\\n        HashSet<int> numbers = new HashSet<int>(); \\n        \\n        for(int i = 0; i < grid.GetLength(0); i++) {\\n            for(int j = 0; j < grid.GetLength(1); j++) {\\n                if(grid[i, j] < 1 || grid[i, j] > 10 || numbers.Contains(grid[i, j]))\\n                    return false; \\n                \\n                numbers.Add(grid[i, j]);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865143,
                "title": "c-optimized-soln-with-detailed-explanation",
                "content": "```\\n// The center of the magic square has to be 5\\n// Total sum = n * (n+1) /2 => 45\\n// 3 rows  = 3 cols = 2 digs = 45. So each row and each col => 15\\n// All lines crossing center => middle row + middle col + diag + anti-diag = 15 + 15+ 15+ 15 => 60\\n// top element of middle col + diag + anti diag = 15\\n// similarly bottom elment of middle col + diag + anti diag = 15\\n// so middle row + 3 * center value = 60 - 15 - 15 = 30\\n// 3* center value = 15 => center value = 5.\\n// Scan the grid and every time we see a 5, check the 3*3 matrix formed with 5 in middle is a magic square\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n        var row = grid.Length;\\n        var col = row > 0 ? grid[0].Length : 0;\\n        \\n        if(row < 3 || col < 3)\\n            return 0;\\n        \\n        var sq = 0;\\n        for(var i = 0; i < row ; i++)\\n            for(var j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 5 && IsMagicSquare((i, j), row, col, grid))\\n                    sq++;                    \\n            }\\n        \\n        return sq;\\n    }\\n    \\n    private bool IsMagicSquare((int Row, int Col) centerPoint, int row, int col, int[][] grid)\\n    {\\n        if(centerPoint.Row - 1 < 0\\n           || centerPoint.Row + 1 >= row \\n           || centerPoint.Col - 1 < 0\\n           || centerPoint.Col + 1 >= col)\\n            return false;\\n        \\n        // Row sum\\n        var allDigits = new bool[9];\\n        for(var i = centerPoint.Row - 1; i <= centerPoint.Row + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Col - 1; j <= centerPoint.Col + 1; j++)\\n            {\\n                sum += grid[i][j];\\n                \\n                // Digits shd be in range of 1..9\\n                if(grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                \\n                allDigits[grid[i][j] - 1] = true;\\n            }\\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // All digits needs to be present\\n        if(allDigits.Any(d => !d))\\n            return false;\\n        \\n        // Col sum\\n        for(var i = centerPoint.Col - 1; i <= centerPoint.Col + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Row - 1; j <= centerPoint.Row + 1; j++)\\n            {\\n                sum += grid[j][i];\\n            }\\n            \\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // diag and anti-diag\\n        if(grid[centerPoint.Row-1][centerPoint.Col-1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col+1] != 15)\\n            return false;\\n        \\n        if(grid[centerPoint.Row-1][centerPoint.Col+1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col-1] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The center of the magic square has to be 5\\n// Total sum = n * (n+1) /2 => 45\\n// 3 rows  = 3 cols = 2 digs = 45. So each row and each col => 15\\n// All lines crossing center => middle row + middle col + diag + anti-diag = 15 + 15+ 15+ 15 => 60\\n// top element of middle col + diag + anti diag = 15\\n// similarly bottom elment of middle col + diag + anti diag = 15\\n// so middle row + 3 * center value = 60 - 15 - 15 = 30\\n// 3* center value = 15 => center value = 5.\\n// Scan the grid and every time we see a 5, check the 3*3 matrix formed with 5 in middle is a magic square\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n        var row = grid.Length;\\n        var col = row > 0 ? grid[0].Length : 0;\\n        \\n        if(row < 3 || col < 3)\\n            return 0;\\n        \\n        var sq = 0;\\n        for(var i = 0; i < row ; i++)\\n            for(var j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 5 && IsMagicSquare((i, j), row, col, grid))\\n                    sq++;                    \\n            }\\n        \\n        return sq;\\n    }\\n    \\n    private bool IsMagicSquare((int Row, int Col) centerPoint, int row, int col, int[][] grid)\\n    {\\n        if(centerPoint.Row - 1 < 0\\n           || centerPoint.Row + 1 >= row \\n           || centerPoint.Col - 1 < 0\\n           || centerPoint.Col + 1 >= col)\\n            return false;\\n        \\n        // Row sum\\n        var allDigits = new bool[9];\\n        for(var i = centerPoint.Row - 1; i <= centerPoint.Row + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Col - 1; j <= centerPoint.Col + 1; j++)\\n            {\\n                sum += grid[i][j];\\n                \\n                // Digits shd be in range of 1..9\\n                if(grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                \\n                allDigits[grid[i][j] - 1] = true;\\n            }\\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // All digits needs to be present\\n        if(allDigits.Any(d => !d))\\n            return false;\\n        \\n        // Col sum\\n        for(var i = centerPoint.Col - 1; i <= centerPoint.Col + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Row - 1; j <= centerPoint.Row + 1; j++)\\n            {\\n                sum += grid[j][i];\\n            }\\n            \\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // diag and anti-diag\\n        if(grid[centerPoint.Row-1][centerPoint.Col-1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col+1] != 15)\\n            return false;\\n        \\n        if(grid[centerPoint.Row-1][centerPoint.Col+1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col-1] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792469,
                "title": "question-about-a-test-case-i-am-not-seeing",
                "content": "The test case I got stuck on is when input is [[10,3,5],[1,6,11],[7,9,2]]\\n\\nBoth row, column, and diag is equal is 18. How is this wrong?\\n\\nThe problem states that the numbers are from 1-9, but in the test cases 0 <= grid[i][j] <= 15 ????\\n\\n\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        // 840\\n        //1 : check row\\n        //2: check colum\\n        //3: chcek diag\\n        // m x n ; m can be any and so can n\\n        // all sum = same\\n        //all nums have to be unique\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n        \\n        for(int x = 0; x < m -2; x++){\\n            for(int y = 0; y < n -2; y++){\\n                count+=check(grid,x,y);\\n            }\\n        }\\n        \\n        return count;\\n    }\\nprivate:\\n    int check(vector<vector<int>>& grid, int m, int n){\\n        printf(\"called\");\\n        vector<bool> number(15,false);//check all 15 people\\n        int sum = grid[m][n]+grid[m+1][n+1]+grid[m+2][n+2]; //check diag\\n        if(sum!=grid[m][n+2]+grid[m+1][n+1]+grid[m+2][n]) return 0;\\n        for(int i = 0; i < 3; i++){ //check x axis\\n            if(sum!=grid[m+i][n]+grid[m+i][n+1]+grid[m+i][n+2]) return 0;\\n            if(sum!=grid[m][n+i]+grid[m+1][n+i]+grid[m+2][n+i]) return 0;\\n            //also need to see if all the numbers are unique\\n            if(number[grid[m+i][n]] || number[grid[m+i][n+1]] || number[grid[m+i][n+2]]) return 0;\\n            number[grid[m+i][n]] = true;\\n            number[grid[m+i][n+1]] = true;\\n            number[grid[m+i][n+2]] = true;\\n        }\\n\\n        return 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        // 840\\n        //1 : check row\\n        //2: check colum\\n        //3: chcek diag\\n        // m x n ; m can be any and so can n\\n        // all sum = same\\n        //all nums have to be unique\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n        \\n        for(int x = 0; x < m -2; x++){\\n            for(int y = 0; y < n -2; y++){\\n                count+=check(grid,x,y);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 789919,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\tpublic int numMagicSquaresInside(int[][] grid) {\\n     \\n\\t\\tint rows = grid.length;\\n\\t\\tint cols = grid[0].length;\\n\\t\\t\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i + 3 <= rows; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 0; j + 3<= cols; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ismGrid =  isMagicGrid(grid, i, j);\\n\\t\\t\\t\\tif(ismGrid == true)\\n\\t\\t\\t\\t\\tresult += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn result;\\n    }\\n\\tprivate boolean isMagicGrid(int[][] grid, int row, int col) {\\n\\t\\tint[] arr = new int[10];\\n    for (int i = row; i < row + 3; i++) {\\n        for (int j = col; j < col + 3; j++) {\\n            if (grid[i][j] < 1 || grid[i][j] > 9 || arr[grid[i][j]] > 0) {\\n                return false;\\n            }\\n            arr[grid[i][j]] = 1;\\n        }\\n    }\\n\\n\\t\\tint sumDiagonal = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n\\t\\tint sumOppDiagonal = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n\\t\\t\\n\\t\\tif(sumDiagonal != sumOppDiagonal)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tint i =0;\\n\\t\\twhile(i < 3)\\n\\t\\t{\\n\\t\\t\\tint sum = grid[row+i][col] + grid[row+i][col+1] + grid[row+i][col+2];\\n\\t\\t\\t\\n\\t\\t\\tif(sum != sumDiagonal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint j = 0;\\n\\t\\twhile(j < 3)\\n\\t\\t{\\n\\t\\t\\tint sum = grid[row][col+j] + grid[row+1][col+j] + grid[row+2][col+j];\\n\\t\\t\\tif(sum != sumDiagonal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic int numMagicSquaresInside(int[][] grid) {\\n     \\n\\t\\tint rows = grid.length;\\n\\t\\tint cols = grid[0].length;\\n\\t\\t\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i + 3 <= rows; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 0; j + 3<= cols; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ismGrid =  isMagicGrid(grid, i, j);\\n\\t\\t\\t\\tif(ismGrid == true)\\n\\t\\t\\t\\t\\tresult += 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 572672,
                "title": "java-simple-beats-100-runtime-and-space",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        final int row = grid.length;\\n        final int col = grid[0].length;\\n        int res = 0;\\n        for(int r = 0; r < row-2; r++){\\n            for(int c = 0; c < col-2; c++){\\n                if(grid[r+1][c+1] != 5) continue;\\n                if(magic(grid[r][c], grid[r][c+1], grid[r][c+2], grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2], grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2])) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean magic(int... vals){\\n        Set<Integer> uniqs = new HashSet<>();\\n        for(int v : vals){\\n            if(uniqs.contains(v) || v > 9 || v < 1) return false;\\n            uniqs.add(v);\\n        }\\n        return (vals[0] + vals[1] + vals[2] == 15 &&\\n                vals[3] + vals[4] + vals[5] == 15 &&\\n                vals[6] + vals[7] + vals[8] == 15 &&\\n                vals[0] + vals[3] + vals[6] == 15 &&\\n                vals[1] + vals[4] + vals[7] == 15 &&\\n                vals[2] + vals[5] + vals[8] == 15 &&\\n                vals[0] + vals[4] + vals[8] == 15 &&\\n                vals[2] + vals[4] + vals[6] == 15);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        final int row = grid.length;\\n        final int col = grid[0].length;\\n        int res = 0;\\n        for(int r = 0; r < row-2; r++){\\n            for(int c = 0; c < col-2; c++){\\n                if(grid[r+1][c+1] != 5) continue;\\n                if(magic(grid[r][c], grid[r][c+1], grid[r][c+2], grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2], grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2])) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean magic(int... vals){\\n        Set<Integer> uniqs = new HashSet<>();\\n        for(int v : vals){\\n            if(uniqs.contains(v) || v > 9 || v < 1) return false;\\n            uniqs.add(v);\\n        }\\n        return (vals[0] + vals[1] + vals[2] == 15 &&\\n                vals[3] + vals[4] + vals[5] == 15 &&\\n                vals[6] + vals[7] + vals[8] == 15 &&\\n                vals[0] + vals[3] + vals[6] == 15 &&\\n                vals[1] + vals[4] + vals[7] == 15 &&\\n                vals[2] + vals[5] + vals[8] == 15 &&\\n                vals[0] + vals[4] + vals[8] == 15 &&\\n                vals[2] + vals[4] + vals[6] == 15);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557666,
                "title": "python-easy",
                "content": "Note that this does not check the diagonals and it seems that it is enough for the all of the test cases\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        # for each 5 check if there is a magic square around\\n        # and the total should be 15\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                #five is the col index\\n                #rowix is the row index of number five\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n                #check if this subgrid is a magic square\\n\\n                \\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n                \\n        return count                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        # for each 5 check if there is a magic square around\\n        # and the total should be 15\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                #five is the col index\\n                #rowix is the row index of number five\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n                #check if this subgrid is a magic square\\n\\n                \\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n                \\n        return count                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 538492,
                "title": "my-java-sol-beats-100",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(check(i,j,grid))count++;\\n            }\\n        }return count;\\n        \\n    }\\n    private boolean check(int i, int j, int[][] grid){\\n        int[] temp = new int[10];\\n         for (int k = i; k < i + 3; k++) {\\n            for (int l = j; l < j + 3; l++) {\\n                if (grid[k][l] < 1 || grid[k][l] > 9 || temp[grid[k][l]] > 0) {\\n                    return false;\\n                }\\n                temp[grid[k][l]] = 1;\\n            }\\n        }\\n        return grid[i][j]+grid[i+1][j]+grid[i+2][j]==15 &&\\n                grid[i][j]+grid[i][j+1]+grid[i][j+2]==15 &&\\n                grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]==15 &&\\n                grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]==15 &&\\n                grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]==15 &&\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]==15;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(check(i,j,grid))count++;\\n            }\\n        }return count;\\n        \\n    }\\n    private boolean check(int i, int j, int[][] grid){\\n        int[] temp = new int[10];\\n         for (int k = i; k < i + 3; k++) {\\n            for (int l = j; l < j + 3; l++) {\\n                if (grid[k][l] < 1 || grid[k][l] > 9 || temp[grid[k][l]] > 0) {\\n                    return false;\\n                }\\n                temp[grid[k][l]] = 1;\\n            }\\n        }\\n        return grid[i][j]+grid[i+1][j]+grid[i+2][j]==15 &&\\n                grid[i][j]+grid[i][j+1]+grid[i][j+2]==15 &&\\n                grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]==15 &&\\n                grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]==15 &&\\n                grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]==15 &&\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]==15;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515676,
                "title": "use-two-way-map-to-match",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    private Map<Integer, Integer> mapRev;\\n    private Set<Integer> st;\\n    public int numMagicSquaresInside(int[][] g) {\\n        int res = 0, m = g.length, n = g[0].length;\\n        int k = 0;\\n        int[] arr = {4,3,8,1,6,7,2,9};\\n        map = new HashMap<>();\\n        mapRev = new HashMap<>();\\n        st = new HashSet<>();\\n        for (int i : arr){\\n            map.put(i, k);\\n            mapRev.put(k++, i);\\n            st.add(i);\\n        }\\n        for (int i = 0; i < m - 2; i++) {\\n            for(int j = 0; j < n - 2; j++) {\\n                if (g[i+1][j+1] != 5) continue; \\n                if (isPerf(g, i, j)) res++; \\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    private boolean isPerf(int[][] g, int i, int j){\\n        if (g[i][j] % 2 != 0 || (!st.contains(g[i][j]))) return false;\\n        int start = map.get(g[i][j]);\\n        int rev = start;\\n        boolean counter = false;\\n        int[] arr = {0, 1, 2, 5, 8, 7, 6, 3};\\n        for ( int x : arr) {\\n            if(start > 7) start = 0;\\n            if(rev < 0) rev = 7;\\n            int curr = g[i + x / 3][j + x % 3];\\n            if (!st.contains(curr)) return false;\\n            if (x == 1) {\\n                if (curr != mapRev.get(start)) counter = true;\\n                if (counter && (curr != mapRev.get(rev))) return false;\\n                start++;\\n                rev--;\\n                continue;\\n            }\\n            \\n            if (!counter && (curr != mapRev.get(start))) return false;\\n            if (counter && (curr != mapRev.get(rev))) return false;\\n            start++;\\n            rev--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    private Map<Integer, Integer> mapRev;\\n    private Set<Integer> st;\\n    public int numMagicSquaresInside(int[][] g) {\\n        int res = 0, m = g.length, n = g[0].length;\\n        int k = 0;\\n        int[] arr = {4,3,8,1,6,7,2,9};\\n        map = new HashMap<>();\\n        mapRev = new HashMap<>();\\n        st = new HashSet<>();\\n        for (int i : arr){\\n            map.put(i, k);\\n            mapRev.put(k++, i);\\n            st.add(i);\\n        }\\n        for (int i = 0; i < m - 2; i++) {\\n            for(int j = 0; j < n - 2; j++) {\\n                if (g[i+1][j+1] != 5) continue; \\n                if (isPerf(g, i, j)) res++; \\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    private boolean isPerf(int[][] g, int i, int j){\\n        if (g[i][j] % 2 != 0 || (!st.contains(g[i][j]))) return false;\\n        int start = map.get(g[i][j]);\\n        int rev = start;\\n        boolean counter = false;\\n        int[] arr = {0, 1, 2, 5, 8, 7, 6, 3};\\n        for ( int x : arr) {\\n            if(start > 7) start = 0;\\n            if(rev < 0) rev = 7;\\n            int curr = g[i + x / 3][j + x % 3];\\n            if (!st.contains(curr)) return false;\\n            if (x == 1) {\\n                if (curr != mapRev.get(start)) counter = true;\\n                if (counter && (curr != mapRev.get(rev))) return false;\\n                start++;\\n                rev--;\\n                continue;\\n            }\\n            \\n            if (!counter && (curr != mapRev.get(start))) return false;\\n            if (counter && (curr != mapRev.get(rev))) return false;\\n            start++;\\n            rev--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507719,
                "title": "c-100-runtime-75-mem",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    \\n    bool checkRowSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int i=x;i<x+3;i++){\\n            int rowSum = 0;\\n            for (int j=y;j<y+3;j++){\\n                rowSum+= grid[i][j];\\n            }\\n            if (rowSum != sum)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkColSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int j=y;j<y+3;j++){\\n            int colSum = 0;\\n            for (int i=x;i<x+3;i++){\\n                colSum +=grid[i][j];\\n            }\\n            if (colSum != sum)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkDiagSum(vector<vector<int>> & grid, int x, int y, int sum){\\n       \\n        if (  (grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2] != sum) && (grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y] != sum) )\\n            return false;\\n        return true;\\n       \\n    }\\n    \\n    bool checkOneToNine(vector<vector<int>> & grid, int x, int y, int sum){\\n        unordered_set<int> u_set;\\n        for (int i=x;i<x+3;i++){\\n            for (int j=y;j<y+3;j++){\\n                if (grid[i][j] >=1 && grid[i][j] <= 9){\\n                    if (u_set.find(grid[i][j]) != u_set.end())\\n                        return false;\\n                    else\\n                        u_set.insert(grid[i][j]);\\n                        \\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        if(u_set.size() == 9)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isMagicSquare(vector<vector<int>> & grid, int x, int y){\\n        bool isMagic = false;\\n        int sum = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n\\n        // cout << x << \" \" << y<< \" \" << sum << \" \" << checkRowSum(grid,x,y, sum) << \" \" << checkColSum(grid,x,y, sum) << \" \" << checkDiagSum(grid, x, y, sum)  << \" \" << checkOneToNine( grid,x, y, sum) << \"\\\\n\";\\n        if (checkRowSum(grid,x,y, sum) && checkColSum(grid,x,y, sum) && checkDiagSum(grid, x, y, sum) && checkOneToNine( grid,x, y, sum))\\n            isMagic =true;\\n        return isMagic;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (m*n < 9)\\n            return 0;\\n        int count = 0;\\n        for (int i=0;i<=m-3;i++){\\n            for (int j=0;j<=n-3;j++){\\n                if(isMagicSquare(grid, i, j))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool checkRowSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int i=x;i<x+3;i++){\\n            int rowSum = 0;\\n            for (int j=y;j<y+3;j++){\\n                rowSum+= grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 500848,
                "title": "python-solution-less-than-100-memory-usage",
                "content": "Yes, it is indeed a boring question. Below is my version of solution.\\n\\n```\\ndef numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ct=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                if isSubGridMagic(grid,i,j):\\n                    ct+=1\\n        return ct\\n\\ndef isSubGridMagic(grid,i,j): \\n    nums = set(grid[a][b] for b in range(j,j+3) for a in range(i,i+3) if grid[a][b]>=1 and grid[a][b]<=9)\\n    a = grid[i][j:j+3]\\n    b = grid[i+1][j:j+3]\\n    c = grid[i+2][j:j+3]\\n    d = [grid[x][j] for x in range(i,i+3)]\\n    e = [grid[x][j+1] for x in range(i,i+3)]\\n    f = [grid[x][j+2] for x in range(i,i+3)]\\n    g = [grid[x+i][y+j] for x in range(3) for y in range(3) if x==y]\\n    h = [grid[x+i][y+j] for x in range(2,-1,-1) for y in range(3) if x+y==2]\\n    if sum(a)==sum(b)==sum(c) == sum(d)==sum(e)==sum(f)==sum(g)==sum(h) and len(nums)==9:\\n        return True\\n    else:\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ct=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                if isSubGridMagic(grid,i,j):\\n                    ct+=1\\n        return ct\\n\\ndef isSubGridMagic(grid,i,j): \\n    nums = set(grid[a][b] for b in range(j,j+3) for a in range(i,i+3) if grid[a][b]>=1 and grid[a][b]<=9)\\n    a = grid[i][j:j+3]\\n    b = grid[i+1][j:j+3]\\n    c = grid[i+2][j:j+3]\\n    d = [grid[x][j] for x in range(i,i+3)]\\n    e = [grid[x][j+1] for x in range(i,i+3)]\\n    f = [grid[x][j+2] for x in range(i,i+3)]\\n    g = [grid[x+i][y+j] for x in range(3) for y in range(3) if x==y]\\n    h = [grid[x+i][y+j] for x in range(2,-1,-1) for y in range(3) if x+y==2]\\n    if sum(a)==sum(b)==sum(c) == sum(d)==sum(e)==sum(f)==sum(g)==sum(h) and len(nums)==9:\\n        return True\\n    else:\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416921,
                "title": "python-brute-force-in-place-in-case-anybody-wants-to-practice-basics",
                "content": "```\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def ismagic(grid, x, y):\\n            flat = [grid[x+i][y+j] for i in (-1, 0, 1) for j in (-1, 0, 1)]\\n            if set(flat) != {1, 2, 3, 4, 5, 6, 7, 8, 9}:\\n                return False\\n            rsums = [sum(grid[x+i][y+j] for j in (-1, 0, 1)) for i in (-1, 0, 1)]\\n            csums = [sum(grid[x+i][y+j] for i in (-1, 0, 1)) for j in (-1, 0, 1)]\\n            dsums = [sum(grid[x-i][y-i] for i in (-1, 0, 1)), sum(grid[x+i][y-i] for i in (-1, 0, 1))]\\n            sums = rsums + csums + dsums\\n            return len(set(sums)) == 1\\n     \\n        rst = 0\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid) - 1):\\n                if ismagic(grid, i, j):\\n                    rst += 1\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def ismagic(grid, x, y):\\n            flat = [grid[x+i][y+j] for i in (-1, 0, 1) for j in (-1, 0, 1)]\\n            if set(flat) != {1, 2, 3, 4, 5, 6, 7, 8, 9}:\\n                return False\\n            rsums = [sum(grid[x+i][y+j] for j in (-1, 0, 1)) for i in (-1, 0, 1)]\\n            csums = [sum(grid[x+i][y+j] for i in (-1, 0, 1)) for j in (-1, 0, 1)]\\n            dsums = [sum(grid[x-i][y-i] for i in (-1, 0, 1)), sum(grid[x+i][y-i] for i in (-1, 0, 1))]\\n            sums = rsums + csums + dsums\\n            return len(set(sums)) == 1\\n     \\n        rst = 0\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid) - 1):\\n                if ismagic(grid, i, j):\\n                    rst += 1\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 381223,
                "title": "two-solutions-in-python-3-beats-99-two-lines",
                "content": "_Two-Line Solution:_ (beats ~99%)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)\\n    \\treturn sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))\\n\\n\\n```\\n_Standard Solution_: (beats ~94%)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t, s = len(G), len(G[0]), set(range(1,10)), range(3), 0\\n    \\tfor i in range(M-2):\\n    \\t\\tfor j in range(N-2):\\n    \\t\\t\\tg = [G[i+k][j:j+3] for k in t]\\n    \\t\\t\\tif set(sum(g,[])) != S or g[1][1] != 5: continue\\n    \\t\\t\\tif any(sum(g[k]) != 15 for k in t) or any(sum([g[k][l] for k in t]) != 15 for l in t): continue\\n    \\t\\t\\tif sum([g[k][k] for k in t]) != 15 or sum([g[k][2-k] for k in t]) != 15: continue\\n    \\t\\t\\ts += 1\\n    \\treturn s\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)\\n    \\treturn sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378498,
                "title": "python-solution-brute-force",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def chk(lst):\\n            t=[]\\n            for i in lst:\\n                t+=i\\n            if sorted(t)!=[x for x in range(1,10)]:return False\\n            ls=list(zip(*lst))\\n            s=sum(lst[0])\\n            su=0\\n            su1=0\\n            for i in range(3):\\n                if sum(lst[i])!=s:return False\\n                if sum(ls[i])!=s:return False\\n                su+=lst[i][i]\\n                su1+=lst[i][2-i]\\n            if su!=s or su1!=s:return False\\n            return True\\n        count=0\\n        r=len(grid)\\n        c=len(grid[0])\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                lst=[]\\n                lst.append(grid[i][j:j+3])\\n                lst.append(grid[i+1][j:j+3])\\n                lst.append(grid[i+2][j:j+3])\\n                m=chk(lst)\\n                if m:count+=1\\n        return count\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def chk(lst):\\n            t=[]\\n            for i in lst:\\n                t+=i\\n            if sorted(t)!=[x for x in range(1,10)]:return False\\n            ls=list(zip(*lst))\\n            s=sum(lst[0])\\n            su=0\\n            su1=0\\n            for i in range(3):\\n                if sum(lst[i])!=s:return False\\n                if sum(ls[i])!=s:return False\\n                su+=lst[i][i]\\n                su1+=lst[i][2-i]\\n            if su!=s or su1!=s:return False\\n            return True\\n        count=0\\n        r=len(grid)\\n        c=len(grid[0])\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                lst=[]\\n                lst.append(grid[i][j:j+3])\\n                lst.append(grid[i+1][j:j+3])\\n                lst.append(grid[i+2][j:j+3])\\n                m=chk(lst)\\n                if m:count+=1\\n        return count\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 337418,
                "title": "php-solution-beats-100",
                "content": "I started with mathematical solutions, then saw there really aren\\'t that many possibilities.\\n\\nRuntime: 4 ms, faster than 100.00% of PHP online submissions\\nMemory Usage: 14.9 MB, less than 100.00% of PHP online submissions\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $grid\\n     * @return Integer\\n     */\\n    function numMagicSquaresInside($grid)\\n    {\\n        list($cols, $rows) = [count($grid[0]), count($grid)];\\n        if ($cols < 3 || $rows < 3) return 0;\\n        $result = 0;\\n        for ($i = 0; $i < $rows - 2; $i++) {\\n            for ($j = 0; $j < $cols - 2; $j++) {\\n                if (5 !== $grid[$i + 1][$j + 1]) continue;\\n                $perimiter = $grid[$i][$j] .\\n                    $grid[$i][$j + 1] .\\n                    $grid[$i][$j + 2] .\\n                    $grid[$i + 1][$j] .\\n                    $grid[$i + 1][$j + 2] .\\n                    $grid[$i + 2][$j] .\\n                    $grid[$i + 2][$j + 1] .\\n                    $grid[$i + 2][$j + 2];\\n                if (\\n                    $perimiter === \\'29473618\\' ||\\n                    $perimiter === \\'67219834\\' ||\\n                    $perimiter === \\'81637492\\' ||\\n                    $perimiter === \\'43891276\\' ||\\n                    $perimiter === \\'27691438\\' ||\\n                    $perimiter === \\'49237816\\' ||\\n                    $perimiter === \\'83419672\\' ||\\n                    $perimiter === \\'61873294\\'\\n                ) $result++;\\n            }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $grid\\n     * @return Integer\\n     */\\n    function numMagicSquaresInside($grid)\\n    {\\n        list($cols, $rows) = [count($grid[0]), count($grid)];\\n        if ($cols < 3 || $rows < 3) return 0;\\n        $result = 0;\\n        for ($i = 0; $i < $rows - 2; $i++) {\\n            for ($j = 0; $j < $cols - 2; $j++) {\\n                if (5 !== $grid[$i + 1][$j + 1]) continue;\\n                $perimiter = $grid[$i][$j] .\\n                    $grid[$i][$j + 1] .\\n                    $grid[$i][$j + 2] .\\n                    $grid[$i + 1][$j] .\\n                    $grid[$i + 1][$j + 2] .\\n                    $grid[$i + 2][$j] .\\n                    $grid[$i + 2][$j + 1] .\\n                    $grid[$i + 2][$j + 2];\\n                if (\\n                    $perimiter === \\'29473618\\' ||\\n                    $perimiter === \\'67219834\\' ||\\n                    $perimiter === \\'81637492\\' ||\\n                    $perimiter === \\'43891276\\' ||\\n                    $perimiter === \\'27691438\\' ||\\n                    $perimiter === \\'49237816\\' ||\\n                    $perimiter === \\'83419672\\' ||\\n                    $perimiter === \\'61873294\\'\\n                ) $result++;\\n            }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309842,
                "title": "java-hashset-1-ms-faster-than-51-84-34-4-mb-less-than-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int diagSum = 0;\\n        int rowSum = 0;\\n        int columnSum = 0;\\n        int count = 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0; i<grid.length-2; i++) {            \\n            for(int j=0; j<grid[0].length-2; j++)\\n            {\\n                set = new HashSet<Integer>();\\n                rowSum = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n                diagSum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n                columnSum = grid[i][j] + grid[i+1][j] + grid[i+2][j];               \\n                \\n                if((rowSum == diagSum) && (rowSum == columnSum))\\n                {\\n                    for(int x=i; x<i+3; x++)\\n                        for(int y=j; y<j+3; y++)\\n                            if(grid[x][y] > 0 && grid[x][y] < 10)\\n                                set.add(grid[x][y]);\\n                    \\n                    if(set.size() == 9)\\n                        count++;\\n                }                   \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int diagSum = 0;\\n        int rowSum = 0;\\n        int columnSum = 0;\\n        int count = 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0; i<grid.length-2; i++) {            \\n            for(int j=0; j<grid[0].length-2; j++)\\n            {\\n                set = new HashSet<Integer>();\\n                rowSum = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n                diagSum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n                columnSum = grid[i][j] + grid[i+1][j] + grid[i+2][j];               \\n                \\n                if((rowSum == diagSum) && (rowSum == columnSum))\\n                {\\n                    for(int x=i; x<i+3; x++)\\n                        for(int y=j; y<j+3; y++)\\n                            if(grid[x][y] > 0 && grid[x][y] < 10)\\n                                set.add(grid[x][y]);\\n                    \\n                    if(set.size() == 9)\\n                        count++;\\n                }                   \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302082,
                "title": "python-stupid-solution",
                "content": "```python \\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        def isMagic(grid):\\n            #d = set(grid)\\n            #print(d)\\n            d = set()\\n            s = sum(grid[0])\\n            diag1 = 0\\n            diag2 = 0\\n            for i in range(0,3):\\n                if sum(grid[i]) != s:\\n                    return False\\n                #col_s = 0\\n                for j in range(0,3):\\n                    col_s = grid[0][j]+grid[1][j]+grid[2][j]\\n                    if col_s != s:\\n                        return False\\n                    if grid[i][j]>9 or grid[i][j]<1:\\n                        return False\\n                    else:\\n                        d.add(grid[i][j])\\n            for k in range(0,3):\\n                diag1 += grid[k][k]\\n                diag2 += grid[k][2-k]\\n            if diag1 != s or diag2 != s:\\n                return False\\n            if len(d) != 9:\\n                return False\\n            \\n            return True\\n        \\n        count = 0\\n        for i in range(0,len(grid)-2):\\n            #print(\"debug\")\\n            for j in range(0,len(grid[0])-2):\\n                cur_grid = []\\n                for k in range(3):\\n                    #print(grid[0,0:2])\\n                    cur_grid.append(grid[i+k][j:j+3])\\n                #print(cur_grid)\\n                if isMagic(cur_grid):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        def isMagic(grid):\\n            #d = set(grid)\\n            #print(d)\\n            d = set()\\n            s = sum(grid[0])\\n            diag1 = 0\\n            diag2 = 0\\n            for i in range(0,3):\\n                if sum(grid[i]) != s:\\n                    return False\\n                #col_s = 0\\n                for j in range(0,3):\\n                    col_s = grid[0][j]+grid[1][j]+grid[2][j]\\n                    if col_s != s:\\n                        return False\\n                    if grid[i][j]>9 or grid[i][j]<1:\\n                        return False\\n                    else:\\n                        d.add(grid[i][j])\\n            for k in range(0,3):\\n                diag1 += grid[k][k]\\n                diag2 += grid[k][2-k]\\n            if diag1 != s or diag2 != s:\\n                return False\\n            if len(d) != 9:\\n                return False\\n            \\n            return True\\n        \\n        count = 0\\n        for i in range(0,len(grid)-2):\\n            #print(\"debug\")\\n            for j in range(0,len(grid[0])-2):\\n                cur_grid = []\\n                for k in range(3):\\n                    #print(grid[0,0:2])\\n                    cur_grid.append(grid[i+k][j:j+3])\\n                #print(cur_grid)\\n                if isMagic(cur_grid):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216579,
                "title": "clean-and-readable-solution",
                "content": "```\\n    private boolean isValid(int a1, int a2, int a3, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0) || (a3 > 9 || a3 < 0)) return false;\\n        if (a1 == a2 || a1 == a3 || a2 == a3) return false;\\n        return (a1 + a2 + a3 == sum);\\n    }\\n\\n    private boolean isValid(int a1, int a2, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0)) return false;\\n        return (a1 != a2 && a1 + a2 == sum);\\n    }\\n\\n    public int numMagicSquaresInside(int[][] A) {\\n        int M = A.length, N = A[0].length, count = 0;\\n        for (int i = 1; i < M-1; i++) {\\n            for (int j = 1; j < N-1; j++) {\\n                // center\\n                if (A[i][j] != 5) continue;\\n                // row\\n                if (!isValid(A[i-1][j-1], A[i-1][j],A[i-1][j+1], 15)) continue;\\n                if (!isValid(A[i+1][j-1], A[i+1][j], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i][j-1], A[i][j+1], 10)) continue;\\n                // column\\n                if (!isValid(A[i-1][j-1], A[i][j-1], A[i+1][j-1], 15)) continue;\\n                if (!isValid(A[i-1][j+1], A[i][j+1], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i-1][j], A[i+1][j], 10)) continue;\\n                // diagonal\\n                if (!isValid(A[i-1][j-1], A[i+1][j+1], 10)) continue;\\n                if (!isValid(A[i-1][j+1], A[i+1][j-1], 10)) continue;\\n\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private boolean isValid(int a1, int a2, int a3, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0) || (a3 > 9 || a3 < 0)) return false;\\n        if (a1 == a2 || a1 == a3 || a2 == a3) return false;\\n        return (a1 + a2 + a3 == sum);\\n    }\\n\\n    private boolean isValid(int a1, int a2, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0)) return false;\\n        return (a1 != a2 && a1 + a2 == sum);\\n    }\\n\\n    public int numMagicSquaresInside(int[][] A) {\\n        int M = A.length, N = A[0].length, count = 0;\\n        for (int i = 1; i < M-1; i++) {\\n            for (int j = 1; j < N-1; j++) {\\n                // center\\n                if (A[i][j] != 5) continue;\\n                // row\\n                if (!isValid(A[i-1][j-1], A[i-1][j],A[i-1][j+1], 15)) continue;\\n                if (!isValid(A[i+1][j-1], A[i+1][j], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i][j-1], A[i][j+1], 10)) continue;\\n                // column\\n                if (!isValid(A[i-1][j-1], A[i][j-1], A[i+1][j-1], 15)) continue;\\n                if (!isValid(A[i-1][j+1], A[i][j+1], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i-1][j], A[i+1][j], 10)) continue;\\n                // diagonal\\n                if (!isValid(A[i-1][j-1], A[i+1][j+1], 10)) continue;\\n                if (!isValid(A[i-1][j+1], A[i+1][j-1], 10)) continue;\\n\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181626,
                "title": "beats-100-20ms-python",
                "content": "```\nclass Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        R=len(grid)\n        C=len(grid[0]) if R>0 else 0\n        ans=0\n        for r in range(1,R-1):\n            for c in range(1,C-1):\n                if grid[r][c]==5:\n                    valid=True\n                    seen=set()\n                    for a,b in [\n                        (grid[r][c-1], grid[r][c+1]),\n                        (grid[r-1][c], grid[r+1][c]),\n                        (grid[r-1][c-1], grid[r+1][c+1]),\n                        (grid[r-1][c+1], grid[r+1][c-1])\n                        ]:\n                        valid &= a+b==10 and a>0 and b > 0\n                        seen.add(a)\n                        seen.add(b)\n                    if valid and len(seen)==8:\n                        ans+=1\n                    \n        return ans\n\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        R=len(grid)\n        C=len(grid[0]) if R>0 else 0\n        ans=0\n        for r in range(1,R-1):\n            for c in range(1,C-1):\n                if grid[r][c]==5:\n                    valid=True\n                    seen=set()\n                    for a,b in [\n                        (grid[r][c-1], grid[r][c+1]),\n                        (grid[r-1][c], grid[r+1][c]),\n                        (grid[r-1][c-1], grid[r+1][c+1]),\n                        (grid[r-1][c+1], grid[r+1][c-1])\n                        ]:\n                        valid &= a+b==10 and a>0 and b > 0\n                        seen.add(a)\n                        seen.add(b)\n                    if valid and len(seen)==8:\n                        ans+=1\n                    \n        return ans\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 181322,
                "title": "beats-100-javascript",
                "content": "1. For magic square, 5 must be in the center, so we should skip `1st row, last row, 1st left col, last right col` because 5 should not be there if it is a valid magic square\\n\\n2. cheeck surrounding number must be 1-9 (using set)\\n3. check sums etc.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    if (!grid || grid.length < 3 || grid[0].length < 3) return 0;\\n    \\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let count = 0;\\n    \\n    for (let r = 1; r < row - 1; r++) {\\n        for (let c = 1; c < col - 1; c++) {\\n            if (grid[r][c] === 5) {\\n                \\n                if (!validSurroundNum(grid,r,c)) continue;\\n                \\n                if (grid[r-1][c-1] + grid[r+1][c+1] !== 10) continue; // left top, right bottom = 10\\n                if (grid[r+1][c-1] + grid[r-1][c+1] !== 10) continue; // left bottom, right top =10\\n                \\n                if (grid[r-1][c-1] + grid[r-1][c] + grid[r-1][c+1] !== 15) continue; // top row = 15\\n                if (grid[r+1][c-1] + grid[r+1][c] + grid[r+1][c+1] !== 15) continue; // bottom row = 15\\n                \\n                if (grid[r-1][c-1] + grid[r][c-1] + grid[r+1][c-1] !== 15) continue; // left col = 15\\n                if (grid[r-1][c+1] + grid[r][c+1] + grid[r+1][c+1] !== 15) continue; // right col = 15\\n                \\n                count += 1;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction validSurroundNum(grid, x,y) {\\n    let set = new Set();\\n    for (let i = -1; i < 1; i++) {\\n        for (let j = -1; j < 1; j++) {\\n            if (set.has(grid[x+i][y+j]) || grid[x+i][y+j] < 1 || grid[x+i][y+j] > 9) {\\n                return false;   \\n            } else {\\n                set.add(grid[x+i][y+j]);\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    if (!grid || grid.length < 3 || grid[0].length < 3) return 0;\\n    \\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let count = 0;\\n    \\n    for (let r = 1; r < row - 1; r++) {\\n        for (let c = 1; c < col - 1; c++) {\\n            if (grid[r][c] === 5) {\\n                \\n                if (!validSurroundNum(grid,r,c)) continue;\\n                \\n                if (grid[r-1][c-1] + grid[r+1][c+1] !== 10) continue; // left top, right bottom = 10\\n                if (grid[r+1][c-1] + grid[r-1][c+1] !== 10) continue; // left bottom, right top =10\\n                \\n                if (grid[r-1][c-1] + grid[r-1][c] + grid[r-1][c+1] !== 15) continue; // top row = 15\\n                if (grid[r+1][c-1] + grid[r+1][c] + grid[r+1][c+1] !== 15) continue; // bottom row = 15\\n                \\n                if (grid[r-1][c-1] + grid[r][c-1] + grid[r+1][c-1] !== 15) continue; // left col = 15\\n                if (grid[r-1][c+1] + grid[r][c+1] + grid[r+1][c+1] !== 15) continue; // right col = 15\\n                \\n                count += 1;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction validSurroundNum(grid, x,y) {\\n    let set = new Set();\\n    for (let i = -1; i < 1; i++) {\\n        for (let j = -1; j < 1; j++) {\\n            if (set.has(grid[x+i][y+j]) || grid[x+i][y+j] < 1 || grid[x+i][y+j] > 9) {\\n                return false;   \\n            } else {\\n                set.add(grid[x+i][y+j]);\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148543,
                "title": "fastest-cpp-solution-beats-100",
                "content": "```\\n bool inRange(int x)\\n    {\\n        return 0<x && x<10;\\n    }\\n    bool isValidOrig(vector<vector<int>>& grid, int r, int c)\\n    {\\n        return r+2<grid.size() && c+2<grid[r].size() && inRange(grid[r][c]) && inRange(grid[r][c+1]) \\n            && inRange(grid[r][c+2]) && inRange(grid[r+1][c]) && inRange(grid[r+1][c+1]) && \\n            inRange(grid[r+1][c+2])&&inRange(grid[r+2][c]) && inRange(grid[r+2][c+1]) && \\n            inRange(grid[r+2][c+2]);\\n    }\\n    bool isMagicSq(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(!isValidOrig(grid,r,c))\\n            return false;\\n        \\n        int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n        return ((grid[r][c]+grid[r][c+1]+grid[r][c+2] == sum) &&\\n            (grid[r+1][c]+grid[r+1][c+1]+grid[r+1][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+2][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c]+grid[r+2][c] == sum) &&\\n            (grid[r][c+1]+grid[r+1][c+1]+grid[r+2][c+1] == sum) &&\\n            (grid[r][c+2]+grid[r+1][c+2]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+1][c+1]+grid[r][c+2]==sum));\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        for(int r=0;r<grid.size();++r)\\n            for(int c=0;c<grid[r].size();++c)\\n                if(isMagicSq(grid, r, c))\\n                    count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool inRange(int x)\\n    {\\n        return 0<x && x<10;\\n    }\\n    bool isValidOrig(vector<vector<int>>& grid, int r, int c)\\n    {\\n        return r+2<grid.size() && c+2<grid[r].size() && inRange(grid[r][c]) && inRange(grid[r][c+1]) \\n            && inRange(grid[r][c+2]) && inRange(grid[r+1][c]) && inRange(grid[r+1][c+1]) && \\n            inRange(grid[r+1][c+2])&&inRange(grid[r+2][c]) && inRange(grid[r+2][c+1]) && \\n            inRange(grid[r+2][c+2]);\\n    }\\n    bool isMagicSq(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(!isValidOrig(grid,r,c))\\n            return false;\\n        \\n        int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n        return ((grid[r][c]+grid[r][c+1]+grid[r][c+2] == sum) &&\\n            (grid[r+1][c]+grid[r+1][c+1]+grid[r+1][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+2][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c]+grid[r+2][c] == sum) &&\\n            (grid[r][c+1]+grid[r+1][c+1]+grid[r+2][c+1] == sum) &&\\n            (grid[r][c+2]+grid[r+1][c+2]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+1][c+1]+grid[r][c+2]==sum));\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        for(int r=0;r<grid.size();++r)\\n            for(int c=0;c<grid[r].size();++c)\\n                if(isMagicSq(grid, r, c))\\n                    count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134620,
                "title": "simple-solution-in-c",
                "content": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n            int result = 0;\\n            for (int i = 0; i < grid.Length - 2; ++i)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; ++j)\\n                {\\n\\n                    if (isMagicGrid(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                                    grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                                    grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2])){result++;} ;\\n\\n                }\\n            }\\n            return result;\\n    }\\n    \\n        private bool isMagicGrid(params int[] values)\\n        {\\n            int[] count = new int[16];\\n            foreach (var value in values)\\n            {\\n                count[value] = 1;\\n            }\\n            for (int i = 1; i <= values.Length; ++i)\\n            {\\n                if (count[i] != 1)\\n                    return false;\\n            }\\n            return (values[0] + values[1] + values[2] == 15 &&\\n                    values[3] + values[4] + values[5] == 15 &&\\n                    values[6] + values[7] + values[8] == 15 &&\\n                    values[0] + values[3] + values[6] == 15 &&\\n                    values[1] + values[4] + values[7] == 15 &&\\n                    values[2] + values[5] + values[8] == 15 &&\\n                    values[0] + values[4] + values[8] == 15 &&\\n                    values[2] + values[4] + values[6] == 15);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n            int result = 0;\\n            for (int i = 0; i < grid.Length - 2; ++i)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; ++j)\\n                {\\n\\n                    if (isMagicGrid(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                                    grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                                    grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2])){result++;} ;\\n\\n                }\\n            }\\n            return result;\\n    }\\n    \\n        private bool isMagicGrid(params int[] values)\\n        {\\n            int[] count = new int[16];\\n            foreach (var value in values)\\n            {\\n                count[value] = 1;\\n            }\\n            for (int i = 1; i <= values.Length; ++i)\\n            {\\n                if (count[i] != 1)\\n                    return false;\\n            }\\n            return (values[0] + values[1] + values[2] == 15 &&\\n                    values[3] + values[4] + values[5] == 15 &&\\n                    values[6] + values[7] + values[8] == 15 &&\\n                    values[0] + values[3] + values[6] == 15 &&\\n                    values[1] + values[4] + values[7] == 15 &&\\n                    values[2] + values[5] + values[8] == 15 &&\\n                    values[0] + values[4] + values[8] == 15 &&\\n                    values[2] + values[4] + values[6] == 15);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133976,
                "title": "brute-force-java-solution",
                "content": "```\\n    public int numMagicSquaresInside(int[][] g) {\\n        int count = 0;\\n        for(int i=2; i<g.length; i++) {\\n            for(int j=2; j<g[0].length; j++) {\\n                if(g[i][j] >9 || g[i][j] < 1\\n                 || g[i][j-1] >9 || g[i][j-1] < 1\\n                 || g[i][j-2] >9 || g[i][j-2] < 1\\n                 || g[i-1][j] >9 || g[i-1][j] < 1\\n                 || g[i-1][j-1] >9 || g[i-1][j-1] < 1\\n                 || g[i-1][j-2] >9 || g[i-1][j-2] < 1\\n                 || g[i-2][j] >9 || g[i-2][j] < 1\\n                 || g[i-2][j-1] >9 || g[i-2][j-1] < 1\\n                 || g[i-2][j-2] >9 || g[i-2][j-2] < 1\\n                    \\n                  ||  g[i][j]+g[i-2][j-2] != g[i-2][j]+ g[i][j-2]\\n                  || g[i-1][j]+g[i-1][j-2] != g[i-2][j-1]+ g[i][j-1]\\n                  || g[i][j]+g[i][j-1] != g[i-2][j-2]+ g[i-1][j-2]\\n                  || g[i][j]+g[i-1][j] != g[i-2][j-2]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i-1][j-2] != g[i-2][j]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i][j-1] != g[i-2][j]+ g[i-1][j]) continue;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numMagicSquaresInside(int[][] g) {\\n        int count = 0;\\n        for(int i=2; i<g.length; i++) {\\n            for(int j=2; j<g[0].length; j++) {\\n                if(g[i][j] >9 || g[i][j] < 1\\n                 || g[i][j-1] >9 || g[i][j-1] < 1\\n                 || g[i][j-2] >9 || g[i][j-2] < 1\\n                 || g[i-1][j] >9 || g[i-1][j] < 1\\n                 || g[i-1][j-1] >9 || g[i-1][j-1] < 1\\n                 || g[i-1][j-2] >9 || g[i-1][j-2] < 1\\n                 || g[i-2][j] >9 || g[i-2][j] < 1\\n                 || g[i-2][j-1] >9 || g[i-2][j-1] < 1\\n                 || g[i-2][j-2] >9 || g[i-2][j-2] < 1\\n                    \\n                  ||  g[i][j]+g[i-2][j-2] != g[i-2][j]+ g[i][j-2]\\n                  || g[i-1][j]+g[i-1][j-2] != g[i-2][j-1]+ g[i][j-1]\\n                  || g[i][j]+g[i][j-1] != g[i-2][j-2]+ g[i-1][j-2]\\n                  || g[i][j]+g[i-1][j] != g[i-2][j-2]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i-1][j-2] != g[i-2][j]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i][j-1] != g[i-2][j]+ g[i-1][j]) continue;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133879,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def is_magic(sq):\\n            s = sum(sq[0])\\n            return set(x for row in sq for x in row) == set(range(1, 10)) and all(sum(row) == s for row in sq) and all(sum(sq[i][j] for i in range(3)) == s for j in range(3)) and sum(sq[i][i] for i in range(3)) == s and sum(sq[i][2-i] for i in range(3)) == s        \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):                \\n                mgrid = [[grid[k][m] for m in range(j,j+3)] for k in range(i,i+3) ]\\n                if is_magic(mgrid)==True:\\n                    count+=1\\n                               \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def is_magic(sq):\\n            s = sum(sq[0])\\n            return set(x for row in sq for x in row) == set(range(1, 10)) and all(sum(row) == s for row in sq) and all(sum(sq[i][j] for i in range(3)) == s for j in range(3)) and sum(sq[i][i] for i in range(3)) == s and sum(sq[i][2-i] for i in range(3)) == s        \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):                \\n                mgrid = [[grid[k][m] for m in range(j,j+3)] for k in range(i,i+3) ]\\n                if is_magic(mgrid)==True:\\n                    count+=1\\n                               \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074825,
                "title": "python3-intuitive-but-not-most-optimal-beats-82-52-runtime-and-85-44-memory",
                "content": "# Intuition\\nSlice down grid into 3x3 sub-grids and calculate sums for each:\\n- rows\\n- columns\\n- diagonals\\n\\n# Approach\\n1. Figure out row and column index range (i.e. highest value when slicing to 3x3 sub-grids)\\n2. For each row index and column index in respective index_range\\n2.1 calculate `expected_sum` (to be used when calculating rows/columns/diagonals sums)\\n2.2 calculate sums for `rows`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n2.3 calculate sums for `columns`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n2.4 calculate sums for `diagonals`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n3. check if `len(rows) == 3 && len(columns) == 3 && len(diagonals) == 2`\\n3.1 check if all values for `rows`, `columns` and `diagonals` are the same, if so, increase `results`\\n4. return `results` value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        result = 0\\n\\n        no_rows = len(grid)\\n        no_columns = len(grid[0])\\n\\n        if no_rows < 3:\\n            return 0\\n        if no_columns < 3:\\n            return 0\\n\\n        row_index_range = 1 if no_columns == 3 else no_rows - 2\\n        column_index_range = 1 if no_columns == 3 else no_columns - 2\\n        for row_idx in range(row_index_range):\\n            for col_idx in range(column_index_range):\\n                expected_sum = sum(grid[row_idx][col_idx : col_idx + 3])\\n                rows = self.get_rows(grid[row_idx : row_idx + 3], col_idx, expected_sum)\\n                columns = self.get_columns(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                diags = self.get_diags(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                if len(rows) == 3 and len(columns) == 3 and len(diags) == 2:\\n                    if all(rows) and all(columns) and all(diags):\\n                        result += 1\\n\\n        return result\\n\\n    def get_rows(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx in range(len(grid)):\\n            summ = sum(grid[idx][column_index : column_index + 3])\\n            if summ != expected_sum or any(\\n                el < 1 or el > 9 for el in grid[idx][column_index : column_index + 3]\\n            ) or len(set(grid[idx][column_index : column_index + 3])) < 3:\\n                return []\\n            result.append(summ)\\n        return result\\n\\n    def get_columns(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx_col in range(column_index, column_index + 3):\\n            tmp = []\\n            for idx_row in range(len(grid)):\\n                if 1 > grid[idx_row][idx_col] > 9:\\n                    return []\\n                tmp.append(grid[idx_row][idx_col])\\n            if sum(tmp) != expected_sum or len(set(tmp)) < 3:\\n                return []\\n            result.append(sum(tmp))\\n        return result\\n\\n    def get_diags(self, grid, column_index, expected_sum):\\n        result = []\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][idx + column_index] > 9:\\n                return []\\n            tmp.append(grid[idx][idx + column_index])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][column_index + 2 - idx] > 9:\\n                return []\\n            tmp.append(grid[idx][column_index + 2 - idx])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        result = 0\\n\\n        no_rows = len(grid)\\n        no_columns = len(grid[0])\\n\\n        if no_rows < 3:\\n            return 0\\n        if no_columns < 3:\\n            return 0\\n\\n        row_index_range = 1 if no_columns == 3 else no_rows - 2\\n        column_index_range = 1 if no_columns == 3 else no_columns - 2\\n        for row_idx in range(row_index_range):\\n            for col_idx in range(column_index_range):\\n                expected_sum = sum(grid[row_idx][col_idx : col_idx + 3])\\n                rows = self.get_rows(grid[row_idx : row_idx + 3], col_idx, expected_sum)\\n                columns = self.get_columns(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                diags = self.get_diags(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                if len(rows) == 3 and len(columns) == 3 and len(diags) == 2:\\n                    if all(rows) and all(columns) and all(diags):\\n                        result += 1\\n\\n        return result\\n\\n    def get_rows(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx in range(len(grid)):\\n            summ = sum(grid[idx][column_index : column_index + 3])\\n            if summ != expected_sum or any(\\n                el < 1 or el > 9 for el in grid[idx][column_index : column_index + 3]\\n            ) or len(set(grid[idx][column_index : column_index + 3])) < 3:\\n                return []\\n            result.append(summ)\\n        return result\\n\\n    def get_columns(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx_col in range(column_index, column_index + 3):\\n            tmp = []\\n            for idx_row in range(len(grid)):\\n                if 1 > grid[idx_row][idx_col] > 9:\\n                    return []\\n                tmp.append(grid[idx_row][idx_col])\\n            if sum(tmp) != expected_sum or len(set(tmp)) < 3:\\n                return []\\n            result.append(sum(tmp))\\n        return result\\n\\n    def get_diags(self, grid, column_index, expected_sum):\\n        result = []\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][idx + column_index] > 9:\\n                return []\\n            tmp.append(grid[idx][idx + column_index])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][column_index + 2 - idx] > 9:\\n                return []\\n            tmp.append(grid[idx][column_index + 2 - idx])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038080,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979924,
                "title": "easy-c-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        int s=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    map<int,int> p,q;\\n                    bool b=1;\\n                    for(int r=i;r<i+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=j;c<j+3;c++)\\n                         {t+=g[r][c];\\n                         q[g[r][c]]++;\\n                         if(g[r][c]==0 || g[r][c]>9) b=0;\\n                         }\\n                         p[t]++;\\n                     }\\n                     for(int r=j;r<j+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=i;c<i+3;c++)\\n                         t+=g[c][r];\\n                         p[t]++;\\n                     }\\n                     int t=0;\\n                      for(int r=i;r<i+3;r++)\\n                     {\\n                         for(int c=j;c<j+3;c++)\\n                         if(c-j==r-i)\\n                         t+=g[r][c]; \\n                     }\\n                     p[t]++;\\n                     if(p.size()==1 && q.size()==9 && b)\\n                     s++;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        int s=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    map<int,int> p,q;\\n                    bool b=1;\\n                    for(int r=i;r<i+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=j;c<j+3;c++)\\n                         {t+=g[r][c];\\n                         q[g[r][c]]++;\\n                         if(g[r][c]==0 || g[r][c]>9) b=0;\\n                         }\\n                         p[t]++;\\n                     }\\n                     for(int r=j;r<j+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=i;c<i+3;c++)\\n                         t+=g[c][r];\\n                         p[t]++;\\n                     }\\n                     int t=0;\\n                      for(int r=i;r<i+3;r++)\\n                     {\\n                         for(int c=j;c<j+3;c++)\\n                         if(c-j==r-i)\\n                         t+=g[r][c]; \\n                     }\\n                     p[t]++;\\n                     if(p.size()==1 && q.size()==9 && b)\\n                     s++;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958596,
                "title": "check-function-for-each-3x3-sub-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int i,int j,vector<vector<int>>& grid){\\n        vector<int>row(3,0);\\n        vector<int>col(3,0);\\n        int mx=INT_MIN,mn=INT_MAX;\\n        unordered_set<int>h;\\n        for(int r=i;r<i+3;r++){\\n            for(int c=j;c<j+3;c++){\\n                row[r-i]=row[r-i]+grid[r][c];\\n                h.insert(grid[r][c]);\\n                mx=max(mx,grid[r][c]);\\n                mn=min(mn,grid[r][c]);\\n            }\\n        }\\n        if(h.size()<9)return 0;\\n        if(mn>9||mn<1||mx>9||mx<1)return 0;\\n        if(row[0]!=row[1]||row[1]!=row[2])return 0;\\n        for(int c=j;c<j+3;c++){\\n            for(int r=i;r<i+3;r++){\\n                col[c-j]=col[c-j]+grid[r][c];\\n            }\\n        }\\n        if(col[0]!=col[1]||col[1]!=col[2])return 0;\\n        if(row[0]!=col[0])return 0;\\n        int d1=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n        int d2=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n        if(d1!=d2||d1!=row[0])return 0;\\n        return 1;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i+2<grid.size();i++){\\n            for(int j=0;j+2<grid[0].size();j++){\\n                if(check(i,j,grid))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int i,int j,vector<vector<int>>& grid){\\n        vector<int>row(3,0);\\n        vector<int>col(3,0);\\n        int mx=INT_MIN,mn=INT_MAX;\\n        unordered_set<int>h;\\n        for(int r=i;r<i+3;r++){\\n            for(int c=j;c<j+3;c++){\\n                row[r-i]=row[r-i]+grid[r][c];\\n                h.insert(grid[r][c]);\\n                mx=max(mx,grid[r][c]);\\n                mn=min(mn,grid[r][c]);\\n            }\\n        }\\n        if(h.size()<9)return 0;\\n        if(mn>9||mn<1||mx>9||mx<1)return 0;\\n        if(row[0]!=row[1]||row[1]!=row[2])return 0;\\n        for(int c=j;c<j+3;c++){\\n            for(int r=i;r<i+3;r++){\\n                col[c-j]=col[c-j]+grid[r][c];\\n            }\\n        }\\n        if(col[0]!=col[1]||col[1]!=col[2])return 0;\\n        if(row[0]!=col[0])return 0;\\n        int d1=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n        int d2=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n        if(d1!=d2||d1!=row[0])return 0;\\n        return 1;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i+2<grid.size();i++){\\n            for(int j=0;j+2<grid[0].size();j++){\\n                if(check(i,j,grid))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862360,
                "title": "fast-solution",
                "content": "# Intuition\\nRuntime: 15ms (100%)\\nMemory: 13.2 MB (94.74%)\\n\\n# Approach\\nA function to check validity of of each 3x3 matrix, by getting all rows, columns and both diagonals and then comparing their sums, as well as making sure the 3x3 matrix contains all numbers from 1 to 9.\\n\\nSecond part of code is to get each 3x3 submatrix. On each row, increasing the start unit by one each time before moving onto the column below.\\n\\n# Complexity\\n- Time complexity:\\n\\nidk\\n- Space complexity:\\nidk\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n\\n        \\n        def check(matrix):\\n            nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            mat2 = []\\n            for x in matrix:\\n                mat2.extend(x)\\n           \\n            for x in nums:\\n                if x not in mat2:\\n                    return False\\n            rows = [x for x in matrix]\\n            cols = []\\n            for x in range(0, 3):\\n                a = []\\n                for y in matrix:\\n                    a.append(y[x])\\n                cols.append(a)\\n            \\n            diagonal1 = [matrix[0][0], matrix[1][1], matrix[2][2]]\\n            diagonal2 = [matrix[0][2], matrix[1][1], matrix[2][0]]\\n            \\n            target = sum(diagonal1)\\n            \\n            for x in rows:\\n                if sum(x) != target:\\n                    return False\\n            for x in cols:\\n                if sum(x) != target:\\n                    return False\\n            if sum(diagonal2) != target:\\n                return False\\n            \\n            return True\\n        \\n        #get mini matrixes\\n    \\n        num1 = 0\\n        num2 = 0\\n        def rows(mat, r):\\n            count = 0\\n            out = []\\n            start = 0\\n            for x in range(len(mat[0]) - 3 + 1):\\n                a = []\\n                for y in range(r, r + 3):\\n                    lst = mat[y]\\n                    a.append(lst[start:start + 3])\\n                start += 1\\n                \\n               \\n                if check(a) == True:\\n                    count += 1\\n            return count\\n        mats = []\\n        out = 0\\n        \\n        for x in range(len(grid) - 3 + 1):\\n           out += rows(grid, x)\\n       \\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n\\n        \\n        def check(matrix):\\n            nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            mat2 = []\\n            for x in matrix:\\n                mat2.extend(x)\\n           \\n            for x in nums:\\n                if x not in mat2:\\n                    return False\\n            rows = [x for x in matrix]\\n            cols = []\\n            for x in range(0, 3):\\n                a = []\\n                for y in matrix:\\n                    a.append(y[x])\\n                cols.append(a)\\n            \\n            diagonal1 = [matrix[0][0], matrix[1][1], matrix[2][2]]\\n            diagonal2 = [matrix[0][2], matrix[1][1], matrix[2][0]]\\n            \\n            target = sum(diagonal1)\\n            \\n            for x in rows:\\n                if sum(x) != target:\\n                    return False\\n            for x in cols:\\n                if sum(x) != target:\\n                    return False\\n            if sum(diagonal2) != target:\\n                return False\\n            \\n            return True\\n        \\n        #get mini matrixes\\n    \\n        num1 = 0\\n        num2 = 0\\n        def rows(mat, r):\\n            count = 0\\n            out = []\\n            start = 0\\n            for x in range(len(mat[0]) - 3 + 1):\\n                a = []\\n                for y in range(r, r + 3):\\n                    lst = mat[y]\\n                    a.append(lst[start:start + 3])\\n                start += 1\\n                \\n               \\n                if check(a) == True:\\n                    count += 1\\n            return count\\n        mats = []\\n        out = 0\\n        \\n        for x in range(len(grid) - 3 + 1):\\n           out += rows(grid, x)\\n       \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835094,
                "title": "javascript-solution",
                "content": "# Intuition\\nIt is necessary to count the number of magic squares in the grid.\\nWe assume that the sum of rows, columns and diagonals in the \"magic square\" will be equal to 15 (always).\\nAlso, all numbers must be from 1 to 9.\\n\\n# Approach\\nCreate a function to select a 3 * 3 subgrid.\\nWe create a function to check if a 3 x 3 subgrid is a magic square.\\nWe go through all possible 3 x 3 subgrids in a given grid and apply functions to test for each of them.\\nIf the subgrid is a magic square, increment the counter by 1.\\nWe return the value of the counter as a response to the task.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nfunction numMagicSquaresInside(grid) {\\n    function MagicSquare(matrix) {\\n        let hash = new Set();\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (hash.has(matrix[i][j])) {\\n                    return false;\\n                } else {\\n                    hash.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        // Checking sums of diagonals\\n        const magicSum = 15;\\n        if (\\n            matrix[0][0] + matrix[1][1] + matrix[2][2] !== magicSum ||\\n            matrix[0][2] + matrix[1][1] + matrix[2][0] !== magicSum\\n        ) {\\n            return false;\\n        }\\n\\n        // Checking sums of rows and columns\\n        for (let i = 0; i < 3; i++) {\\n            if (\\n                magicSum !== matrix[i].reduce((sum, item) => (sum += item), 0) ||\\n                magicSum !== matrix.reduce((sum, row) => (sum += row[i]), 0)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function toMatrix(col, row) {\\n        let matrix = [[], [], []];\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (grid[row + i] && grid[row + i][col + j]) {\\n                    matrix[i].push(grid[row + i][col + j]);\\n                } else {\\n                    return null; // Handle incomplete 3x3 matrices\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n\\n    let sumMagicSquares = 0;\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 0; j < grid[i].length - 2; j++) {\\n            const matrix = toMatrix(j, i);\\n            if (matrix !== null && MagicSquare(matrix)) {\\n                sumMagicSquares++;\\n            }\\n        }\\n    }\\n    return sumMagicSquares;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nfunction numMagicSquaresInside(grid) {\\n    function MagicSquare(matrix) {\\n        let hash = new Set();\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (hash.has(matrix[i][j])) {\\n                    return false;\\n                } else {\\n                    hash.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        // Checking sums of diagonals\\n        const magicSum = 15;\\n        if (\\n            matrix[0][0] + matrix[1][1] + matrix[2][2] !== magicSum ||\\n            matrix[0][2] + matrix[1][1] + matrix[2][0] !== magicSum\\n        ) {\\n            return false;\\n        }\\n\\n        // Checking sums of rows and columns\\n        for (let i = 0; i < 3; i++) {\\n            if (\\n                magicSum !== matrix[i].reduce((sum, item) => (sum += item), 0) ||\\n                magicSum !== matrix.reduce((sum, row) => (sum += row[i]), 0)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function toMatrix(col, row) {\\n        let matrix = [[], [], []];\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (grid[row + i] && grid[row + i][col + j]) {\\n                    matrix[i].push(grid[row + i][col + j]);\\n                } else {\\n                    return null; // Handle incomplete 3x3 matrices\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n\\n    let sumMagicSquares = 0;\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 0; j < grid[i].length - 2; j++) {\\n            const matrix = toMatrix(j, i);\\n            if (matrix !== null && MagicSquare(matrix)) {\\n                sumMagicSquares++;\\n            }\\n        }\\n    }\\n    return sumMagicSquares;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808827,
                "title": "easy-to-understand-c-basic-2-d-matrix-traversing",
                "content": "# Intuition\\nI simply traversed the grid from square one and checked if all the conditions matched for that particular cell i.e. if a magic square could be formed from there.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$ As we are traversing the grid so it\\'s space is included in the stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool f(vector<vector<int>> &grid , int i , int j){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        \\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(i+2<grid.size() && j+2< grid[0].size()){\\n                    if(f(grid, i, j)){\\n                        res++;\\n                    } \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool f(vector<vector<int>> &grid , int i , int j){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        \\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(i+2<grid.size() && j+2< grid[0].size()){\\n                    if(f(grid, i, j)){\\n                        res++;\\n                    } \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801035,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752330,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(r, c):\\n            if grid[r + 1][c + 1] != 5:\\n                return False\\n            unique, sums = set(), set()\\n            for dr in range(3):\\n                row_sum = col_sum = diag_sum = adiag_sum = 0\\n                for dc in range(3):\\n                    unique.add(grid[r + dr][c + dc])\\n                    row_sum += grid[r + dr][c + dc]\\n                    col_sum += grid[r + dc][c + dr]\\n                    diag_sum += grid[r + dc][c + dc]\\n                    adiag_sum += grid[r + dc][c + 2 - dc]\\n                sums.update((row_sum, col_sum, diag_sum, adiag_sum))\\n            return len(sums) == 1 and len(unique) == 9 and min(unique) == 1 and max(unique) == 9\\n        R, C = len(grid), len(grid[0])\\n        return sum(r + 2 < R and c + 2 < C and is_magic_square(r, c)\\n                   for r,c in product(range(R), range(C)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(r, c):\\n            if grid[r + 1][c + 1] != 5:\\n                return False\\n            unique, sums = set(), set()\\n            for dr in range(3):\\n                row_sum = col_sum = diag_sum = adiag_sum = 0\\n                for dc in range(3):\\n                    unique.add(grid[r + dr][c + dc])\\n                    row_sum += grid[r + dr][c + dc]\\n                    col_sum += grid[r + dc][c + dr]\\n                    diag_sum += grid[r + dc][c + dc]\\n                    adiag_sum += grid[r + dc][c + 2 - dc]\\n                sums.update((row_sum, col_sum, diag_sum, adiag_sum))\\n            return len(sums) == 1 and len(unique) == 9 and min(unique) == 1 and max(unique) == 9\\n        R, C = len(grid), len(grid[0])\\n        return sum(r + 2 < R and c + 2 < C and is_magic_square(r, c)\\n                   for r,c in product(range(R), range(C)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709590,
                "title": "beats-92-of-runtime-detailed-explanation",
                "content": "\\n# Approach\\nWe divide the requirements and implement functions for each requirement. This way, it\\'s easier to debug the code and also know what\\'s happening at every step. From the problem, it can be seen that a 3*3 grid is classified as a magic square if:\\n    - all rows are equal\\n    - all columns are equal \\n    - all diagonals are equal\\n    - and the 3* *by 3 grid contains elements from 1-9 without repetition*.\\n\\nFor all the requirements we create the necessary functions for them. We then traverse the main matrix in a 3 * 3 grid mode and check if each grid satisfies all the requirements. We then output the number of grids in the matrix which satisfy all four requirements   \\n\\n# Code\\n```\\nclass Solution:\\n    def check_diagonals(self, matrix): #Checks validity of sums of diagonals\\n        n = int(len(matrix)/2)+1\\n        front, back = [], []\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j:\\n                    front.extend([matrix[i][j],matrix[n-i][n-j]])\\n                    back.extend([matrix[i][n-j],matrix[n-j][i]])\\n        if sum(front[:len(matrix)]) == sum(back[:len(matrix)]):\\n            return True\\n        return False\\n\\n    def check_rows(self, matrix): #Checks validity of sums of rows\\n        top_row, middle_row, bottom_row = sum(matrix[0]), sum(matrix[1]), sum(matrix[2])\\n        if top_row==middle_row==bottom_row:\\n            return True\\n        return False\\n        \\n    def check_cols(self, matrix): #Checks validity of sums of columns\\n        right_col, middle_col, left_col = 0, 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                right_col+=matrix[i][0]\\n                middle_col+=matrix[i][1]\\n                left_col+=matrix[i][2]\\n        if right_col==middle_col==left_col:\\n            return True\\n        return False\\n    \\n    def check_matrix(self, matrix): #Checks validity of sub_matrix or sub_grid\\n        nums = set()\\n        for i in matrix:\\n            for j in range(len(i)):\\n                if i[j]<10 and i[j]>0:\\n                    nums.add(i[j])\\n        if len(nums)!= 9:\\n            return False\\n        return True\\n\\n    def numMagicSquaresInside(self, grid: list[list[int]]):  \\n        ans = 0\\n        for i in range(len(grid)-2):\\n            for j in range(0,len(grid[0])-2):\\n                sub_grid = grid[i:i+3]\\n                for k in range(len(sub_grid)):\\n                    sub_grid[k] = sub_grid[k][j:j+3]\\n                if self.check_matrix(sub_grid) is False:\\n                    continue\\n                else:\\n                    if self.check_diagonals(sub_grid) and self.check_cols(sub_grid) and self.check_rows(sub_grid):\\n                        ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def check_diagonals(self, matrix): #Checks validity of sums of diagonals\\n        n = int(len(matrix)/2)+1\\n        front, back = [], []\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j:\\n                    front.extend([matrix[i][j],matrix[n-i][n-j]])\\n                    back.extend([matrix[i][n-j],matrix[n-j][i]])\\n        if sum(front[:len(matrix)]) == sum(back[:len(matrix)]):\\n            return True\\n        return False\\n\\n    def check_rows(self, matrix): #Checks validity of sums of rows\\n        top_row, middle_row, bottom_row = sum(matrix[0]), sum(matrix[1]), sum(matrix[2])\\n        if top_row==middle_row==bottom_row:\\n            return True\\n        return False\\n        \\n    def check_cols(self, matrix): #Checks validity of sums of columns\\n        right_col, middle_col, left_col = 0, 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                right_col+=matrix[i][0]\\n                middle_col+=matrix[i][1]\\n                left_col+=matrix[i][2]\\n        if right_col==middle_col==left_col:\\n            return True\\n        return False\\n    \\n    def check_matrix(self, matrix): #Checks validity of sub_matrix or sub_grid\\n        nums = set()\\n        for i in matrix:\\n            for j in range(len(i)):\\n                if i[j]<10 and i[j]>0:\\n                    nums.add(i[j])\\n        if len(nums)!= 9:\\n            return False\\n        return True\\n\\n    def numMagicSquaresInside(self, grid: list[list[int]]):  \\n        ans = 0\\n        for i in range(len(grid)-2):\\n            for j in range(0,len(grid[0])-2):\\n                sub_grid = grid[i:i+3]\\n                for k in range(len(sub_grid)):\\n                    sub_grid[k] = sub_grid[k][j:j+3]\\n                if self.check_matrix(sub_grid) is False:\\n                    continue\\n                else:\\n                    if self.check_diagonals(sub_grid) and self.check_cols(sub_grid) and self.check_rows(sub_grid):\\n                        ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701149,
                "title": "set-theory-and-memo-s-100-time-and-space-complexity-on-average-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are only so many magic and non-magic squares we may encounter (though the latter is quite great!). Based on this, we can utilize memoization to speed up a set based approach to our problem. \\n\\nTo start, notice that we can use the order of the items in a square (called subgrid from here on) as a memo-key, which we can then mark after analysis as either a magic square or a non magic square. \\n\\nIf we know the number of magic squares, we also know when we can hit a real speed boost! To learn more, check this new york times article here : https://mindyourdecisions.com/blog/2015/11/08/how-many-3x3-magic-squares-are-there-sunday-puzzle/\\n\\nWith this in mind, we can outline our approach as follows \\nWe are going to count the number of magic squares \\nTo be a magic square, a square of 3 x 3 values in a grid must \\n- have all values 1 to 9  \\n- have all 3 rows sum to 15 \\n- have all 3 cols sum to 15 \\n\\nFrom the article, we know there are only 8 magic squares. In the interest of fairness, we\\'ll build these up as we go rather than simply enter them all at the start. \\n\\nThen, for each square subgrid in our grid \\n- Get the subgrid key for the subgrid \\n- If we have 8 magic keys already \\n    - increment number of magic squares by int cast of boolean of whether or not the subgrid key is in our magic keys \\n    - continue \\n- otherwise if it is in our magic keys \\n    - increment number of magic squares by 1 and continue \\n- otherwise if it is in our normal keys \\n    - continue \\n- otherwise if it has all values 1 to 9 and has all rows sum to 15 and all cols sum to 15 \\n    - add the subgrid key to the magic squares set \\n    - increment number magic squares by 1 \\n    - continue \\n- otherwise \\n    - add the subgrid key to the normal keys \\n    - continue \\n\\nAt end return number of magic squares     \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is fairly laid out in the intuition, however, we\\'ll note a few additions here \\n\\nIf you want the number of each type of magic square \\n- change from magic square sets to magic square frequency dictionaries \\n- make sure you increment on that as needed \\n\\nSimilar for the normal squares \\n\\nTo get each subgrid is actually a bit of a process. For our purposes we do the following \\n- Loop row index in range 1 to rows - 1 \\n    - set row as grid at row index \\n    - set col indices as [index for index in range(1, cols-1) if row[index] == 5] (we can skip over those others in this way) \\n    - for col index in col indices \\n        - set a subgrid as the list of sub rows from col index - 1 to col index + 2 for sub row in grid from row index - 1 to row index + 2 \\n        - set a subgrid key as \"\".join([str(item) for row_s in subgrid for item in row_s]) \\n        - from here, above logic follows \\n\\n# Complexity\\n- Time complexity : O(R * (C + c)) \\n    - We loop each row basically \\n        - In each row we do C work to loop each col and build col indices\\n        - Then we do c work for each col indices \\n        - Then we do O(1) work to build subgrid and get key \\n        - Then we do O(1) work for reset of processing \\n    - In total then we do O(R * (C + c))   \\n\\n- Space complexity : O(K) \\n    - We store at most 8 magic keys \\n    - We store at most the unique normal keys K \\n    - All other space is technically referential \\n    - O(K) is the final space, where K is the number of keys \\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int :\\n        # what we are after \\n        num_magic_squares = 0 \\n        # what a magic square must contain \\n        num_set = set(range(1, 10))\\n        # dimensions of our problem \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        # square list of normal and magical keys respectively \\n        square_list = [set(), set()]\\n        # for row index in range 1 to rows - 1 \\n        for row_index in range(1, rows - 1) : \\n            # get the row \\n            row = grid[row_index]\\n            # only care about col indices where row at index is 5 as an optional skip\\n            col_indices = [index for index in range(1, cols-1) if row[index] == 5]\\n            # for col indices we care about \\n            for col_index in col_indices : \\n                # get the subgrid as sub row at col_index - 1 to col index + 2 for each sub row in grid \\n                subgrid = [row_s[col_index-1:col_index+2] for row_s in grid[row_index-1 : row_index + 2]]\\n                # build your subgrid key in order to utilize memo \\n                subgrid_key = \"\".join([str(item) for row_s in subgrid for item in row_s])\\n                # if you found them all, use that fact to skip out early \\n                if len(square_list[1]) == 8 : \\n                    num_magic_squares += int(subgrid_key in square_list[1])\\n                    continue\\n                elif subgrid_key in square_list[1] : \\n                    # otherwise, if you found this one increment and continue to next col index\\n                    num_magic_squares += 1 \\n                    continue\\n                elif subgrid_key in square_list[0] : \\n                    # or skip out early if you already know it\\'s not magical \\n                    continue\\n                else : \\n                    # if we have all numbers in 0 - 9 and our row sum is 15 3 times and our col sum is 15 3 times, this is a magic square. Otherwise it is not. \\n                    magical = (len(num_set-set([item for row_s in subgrid for item in row_s]))==0) and (sum([sum(row_s)==15 for row_s in subgrid])== sum([sum(col_s)==15 for col_s in zip(*subgrid)])==3)\\n                    # increment based on status \\n                    num_magic_squares += magical \\n                    # and assign appropriately \\n                    square_list[magical].add(subgrid_key)\\n                    # then continue\\n                    continue\\n        # return when done \\n        return num_magic_squares\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int :\\n        # what we are after \\n        num_magic_squares = 0 \\n        # what a magic square must contain \\n        num_set = set(range(1, 10))\\n        # dimensions of our problem \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        # square list of normal and magical keys respectively \\n        square_list = [set(), set()]\\n        # for row index in range 1 to rows - 1 \\n        for row_index in range(1, rows - 1) : \\n            # get the row \\n            row = grid[row_index]\\n            # only care about col indices where row at index is 5 as an optional skip\\n            col_indices = [index for index in range(1, cols-1) if row[index] == 5]\\n            # for col indices we care about \\n            for col_index in col_indices : \\n                # get the subgrid as sub row at col_index - 1 to col index + 2 for each sub row in grid \\n                subgrid = [row_s[col_index-1:col_index+2] for row_s in grid[row_index-1 : row_index + 2]]\\n                # build your subgrid key in order to utilize memo \\n                subgrid_key = \"\".join([str(item) for row_s in subgrid for item in row_s])\\n                # if you found them all, use that fact to skip out early \\n                if len(square_list[1]) == 8 : \\n                    num_magic_squares += int(subgrid_key in square_list[1])\\n                    continue\\n                elif subgrid_key in square_list[1] : \\n                    # otherwise, if you found this one increment and continue to next col index\\n                    num_magic_squares += 1 \\n                    continue\\n                elif subgrid_key in square_list[0] : \\n                    # or skip out early if you already know it\\'s not magical \\n                    continue\\n                else : \\n                    # if we have all numbers in 0 - 9 and our row sum is 15 3 times and our col sum is 15 3 times, this is a magic square. Otherwise it is not. \\n                    magical = (len(num_set-set([item for row_s in subgrid for item in row_s]))==0) and (sum([sum(row_s)==15 for row_s in subgrid])== sum([sum(col_s)==15 for col_s in zip(*subgrid)])==3)\\n                    # increment based on status \\n                    num_magic_squares += magical \\n                    # and assign appropriately \\n                    square_list[magical].add(subgrid_key)\\n                    # then continue\\n                    continue\\n        # return when done \\n        return num_magic_squares\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669180,
                "title": "simple-java-solution-0ms-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3) {\\n            return 0;\\n        }\\n        if (grid[0].length < 3) {\\n            return 0;\\n        }\\n\\n        int magic = 0;\\n        for (int y = 0; y < grid.length - 2; y++) {\\n            for (int x = 0; x < grid.length - 2; x++) {\\n                int c1 = grid[y][x];\\n                int c2 = grid[y][x + 1];\\n                int c3 = grid[y][x + 2];\\n                if (c1 < 1 || c1 > 9 || c2 < 1 || c2 > 9 || c3 < 1 || c3 > 9) {\\n                    continue;\\n                }\\n\\n                int c4 = grid[y + 1][x];\\n                int c5 = grid[y + 1][x + 1];\\n                int c6 = grid[y + 1][x + 2];\\n                if (c4 < 1 || c4 > 9 || c5 < 1 || c5 > 9 || c6 < 1 || c6 > 9) {\\n                    continue;\\n                }\\n\\n                int c7 = grid[y + 2][x];\\n                int c8 = grid[y + 2][x + 1];\\n                int c9 = grid[y + 2][x + 2];\\n                if (c7 < 1 || c7 > 9 || c8 < 1 || c8 > 9 || c9 < 1 || c9 > 9) {\\n                    continue;\\n                }\\n\\n                int row1 = c1 + c2 + c3;\\n                int row2 = c4 + c5 + c6;\\n                int row3 = c7 + c8 + c9;\\n\\n                int col1 = c1 + c4 + c7;\\n                int col2 = c2 + c5 + c8;\\n                int col3 = c3 + c6 + c9;\\n\\n                int diag1 = c1 + c5 + c9;\\n                int diag2 = c7 + c5 + c3;\\n\\n                if (c1 != c2 && c2 != c3 && c3 != c4 && c4 != c5 && c5 != c6 && c6 != c7 && c7 != c8 && c8 != c9) {\\n                    if (row1 + row2 + row3 == 45 && row1 == row2 && row2 == row3 && col1 == col2 && col2 == col3 && diag1 == diag2) {\\n                        magic++;\\n                    }\\n                }\\n            }\\n        }\\n        return magic;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3) {\\n            return 0;\\n        }\\n        if (grid[0].length < 3) {\\n            return 0;\\n        }\\n\\n        int magic = 0;\\n        for (int y = 0; y < grid.length - 2; y++) {\\n            for (int x = 0; x < grid.length - 2; x++) {\\n                int c1 = grid[y][x];\\n                int c2 = grid[y][x + 1];\\n                int c3 = grid[y][x + 2];\\n                if (c1 < 1 || c1 > 9 || c2 < 1 || c2 > 9 || c3 < 1 || c3 > 9) {\\n                    continue;\\n                }\\n\\n                int c4 = grid[y + 1][x];\\n                int c5 = grid[y + 1][x + 1];\\n                int c6 = grid[y + 1][x + 2];\\n                if (c4 < 1 || c4 > 9 || c5 < 1 || c5 > 9 || c6 < 1 || c6 > 9) {\\n                    continue;\\n                }\\n\\n                int c7 = grid[y + 2][x];\\n                int c8 = grid[y + 2][x + 1];\\n                int c9 = grid[y + 2][x + 2];\\n                if (c7 < 1 || c7 > 9 || c8 < 1 || c8 > 9 || c9 < 1 || c9 > 9) {\\n                    continue;\\n                }\\n\\n                int row1 = c1 + c2 + c3;\\n                int row2 = c4 + c5 + c6;\\n                int row3 = c7 + c8 + c9;\\n\\n                int col1 = c1 + c4 + c7;\\n                int col2 = c2 + c5 + c8;\\n                int col3 = c3 + c6 + c9;\\n\\n                int diag1 = c1 + c5 + c9;\\n                int diag2 = c7 + c5 + c3;\\n\\n                if (c1 != c2 && c2 != c3 && c3 != c4 && c4 != c5 && c5 != c6 && c6 != c7 && c7 != c8 && c8 != c9) {\\n                    if (row1 + row2 + row3 == 45 && row1 == row2 && row2 == row3 && col1 == col2 && col2 == col3 && diag1 == diag2) {\\n                        magic++;\\n                    }\\n                }\\n            }\\n        }\\n        return magic;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660233,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<stdio.h>\\n#include<stdlib.h>\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<stdio.h>\\n#include<stdlib.h>\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3620003,
                "title": "runtime-0-ms-beats-100-intuition-and-approach-java",
                "content": "# Intuition and Approach :\\nThe given code provides a solution for the \"Magic Squares In Grid\" problem. The problem requires us to count the number of 3x3 magic squares in the given grid.\\n\\nLet\\'s understand the intuition and approach used in the code:\\n\\n- The code begins by checking the dimensions of the grid. If either the number of rows or the number of columns is less than 3, it means there are not enough cells to form a 3x3 magic square. In such cases, the code returns 0.\\n\\n- A variable magicSquares is initialized to keep track of the count of magic squares found.\\n\\n- The code uses two nested loops to iterate over the grid, excluding the last two rows and the last two columns. This is done to ensure that there are enough cells remaining in the grid to form a 3x3 magic square.\\n\\n- For each starting cell (i, j) in the grid, the code checks if it forms a magic square by calling the isMagicSquare helper function.\\n\\n- The isMagicSquare function checks the properties of a magic square starting from the given row row and column col.\\n\\n- Inside the isMagicSquare function, an array seen is used to keep track of numbers seen so far. It is initialized as a boolean array of size 10, with all values initially set to false. The purpose of this array is to ensure that each number from 1 to 9 appears exactly once in the magic square.\\n\\n- The function calculates the expected sum of the magic square by summing the values in the first row starting from the given row and col position.\\n\\n- The function then checks the row sums by iterating over each row and summing the values. It also checks if each number in the grid is within the range of 1 to 9 and has not been seen before. If any of these conditions fail, it returns false.\\n\\n- After checking the row sums, the function checks the column sums by iterating over each column and summing the values. If any column sum does not equal the expected sum, the function returns false.\\n\\n- Finally, the function checks the two diagonal sums. If either diagonal sum does not equal the expected sum, the function returns false.\\n\\n- If all the checks pass, the function returns true, indicating that the 3x3 grid starting from (row, col) is a magic square.\\n\\n- The main function counts the number of magic squares found by incrementing magicSquares whenever the isMagicSquare function returns true.\\n\\n- Finally, the count of magic squares is returned as the result.\\n\\nThe approach followed in this code involves iterating over each possible 3x3 grid in the given grid and checking if it forms a magic square according to the defined properties. By using helper functions and carefully checking the row sums, column sums, and diagonal sums, the code efficiently determines the count of magic squares.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3){\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n\\n    private boolean isMagicSquare(int[][] grid, int row, int col){\\n        boolean[] seen = new boolean[10];\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n\\n        //ROW SUM :\\n        for(int i = row; i <= row+2; i++){\\n            tempSum = 0;\\n            for(int j = col; j <= col+2; j++){\\n                if(grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]){\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if(tempSum != sum){\\n                return false;\\n            }\\n        }\\n\\n        // COL SUM :\\n        for(int j = col; j <= col+2; j++){\\n            if(grid[row][j] + grid[row+1][j] + grid[row+2][j] != sum){\\n                return false;\\n            }\\n        }\\n\\n        // DIAG SUM :\\n        if(grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Complexity :\\nThe time complexity of the code is O(N^2), where N is the number of rows or columns in the grid. This is because the code iterates over each starting cell of the 3x3 grid, resulting in N^2 iterations in total.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3){\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n\\n    private boolean isMagicSquare(int[][] grid, int row, int col){\\n        boolean[] seen = new boolean[10];\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n\\n        //ROW SUM :\\n        for(int i = row; i <= row+2; i++){\\n            tempSum = 0;\\n            for(int j = col; j <= col+2; j++){\\n                if(grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]){\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if(tempSum != sum){\\n                return false;\\n            }\\n        }\\n\\n        // COL SUM :\\n        for(int j = col; j <= col+2; j++){\\n            if(grid[row][j] + grid[row+1][j] + grid[row+2][j] != sum){\\n                return false;\\n            }\\n        }\\n\\n        // DIAG SUM :\\n        if(grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613670,
                "title": "easy-java-solution-0ms-with-explanation-o-1-space-complexity",
                "content": "# Intuition\\nMagic Square is a matrix square which has a size of n * n and only contains numbers from 1 to 9 (included). We should also keep in mind that the number 5 is always in the center of the matrix.\\n\\n# Approach\\nCheck every possible 3 * 3 matrix if it is a magic square.\\nWe will make use of an external method called (checker) to check whether the corresponding matrix is Magic or not.\\n\\n# Complexity\\n- Time complexity: Think it is Number of possible 3 * 3 matrix multiplied by 9.\\n\\n- Space complexity:Since we wont be creating any redundant matrix the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rowlen = grid.length;\\n        int collen = grid[0].length;\\n        int res = 0;\\n        for(int i = 0;i < rowlen - 2; i++){\\n            for(int j = 0; j < collen - 2; j++){\\n                //Check if middle element is 5\\n                if(grid[i + 1][j + 1] != 5) continue;\\n                if(checker(grid, i, j)) res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean checker(int[][] grid, int rowstart, int colstart){\\n        int[] counter = new int[10];\\n\\n        //row checking\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            int sum = 0;\\n            for(int j = colstart; j < (colstart + 3); j++){\\n                int number = grid[i][j];\\n                if(number > 9 || number < 1) return false;\\n                counter[number]++;\\n                if(counter[number] > 1) return false;\\n                sum += number;\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n\\n        //column checking\\n        for(int i = colstart; i < (colstart + 3); i++){\\n            int sum = 0;\\n            for(int j = rowstart; j < (rowstart + 3); j++){\\n                sum += grid[j][i];\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n        //diagonal (top left to bottom right)\\n        int tmpsum = 0;\\n        int tmpcol = colstart;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol++];\\n        }\\n        if(tmpsum != 15) return false;\\n\\n        //diagonal (top right to bottom left)\\n        tmpsum = 0;\\n        tmpcol = colstart + 2;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol--];\\n        }\\n        if(tmpsum != 15) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rowlen = grid.length;\\n        int collen = grid[0].length;\\n        int res = 0;\\n        for(int i = 0;i < rowlen - 2; i++){\\n            for(int j = 0; j < collen - 2; j++){\\n                //Check if middle element is 5\\n                if(grid[i + 1][j + 1] != 5) continue;\\n                if(checker(grid, i, j)) res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean checker(int[][] grid, int rowstart, int colstart){\\n        int[] counter = new int[10];\\n\\n        //row checking\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            int sum = 0;\\n            for(int j = colstart; j < (colstart + 3); j++){\\n                int number = grid[i][j];\\n                if(number > 9 || number < 1) return false;\\n                counter[number]++;\\n                if(counter[number] > 1) return false;\\n                sum += number;\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n\\n        //column checking\\n        for(int i = colstart; i < (colstart + 3); i++){\\n            int sum = 0;\\n            for(int j = rowstart; j < (rowstart + 3); j++){\\n                sum += grid[j][i];\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n        //diagonal (top left to bottom right)\\n        int tmpsum = 0;\\n        int tmpcol = colstart;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol++];\\n        }\\n        if(tmpsum != 15) return false;\\n\\n        //diagonal (top right to bottom left)\\n        tmpsum = 0;\\n        tmpcol = colstart + 2;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol--];\\n        }\\n        if(tmpsum != 15) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517690,
                "title": "easy-and-understandable-cpp-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if (grid.size()<3 || grid[0].size()<3)\\n        {\\n            return 0;\\n        }\\n\\n        // Counter = 0\\n        int c = 0;\\n\\n        // NEsted for loop for iterating through each point\\n        for (int i=0; i<grid.size()-2; i++)\\n        {\\n            for (int j=0; j<grid[i].size()-2; j++)\\n            {\\n                // Making the square matrix of 3x3\\n                vector<vector<int>> mat;\\n                for (int k=0; k<3; k++)\\n                {\\n                    vector<int> v;\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        v.push_back(0);\\n                    }\\n                    mat.push_back(v);   \\n                }\\n\\n                // Adding the values of grid into 3x3 matrix\\n                int cr = 0;\\n                for (int k=i; k<i+3; k++)\\n                {\\n                    int cc=0;\\n                    for (int m=j; m<j+3; m++)\\n                    {\\n                        mat[cr][cc] = grid[k][m];\\n                        cc++;\\n                    }\\n                    cr++;\\n                }\\n\\n                // Declaring a set\\n                // Erase all the elements which occured in the set\\n                // It helps us to identify whether all integers from 1 to 9 is present or not\\n                set <int> s ({1, 2, 3, 4, 5, 6, 7, 8, 9});\\n                for (int k=0; k<3; k++)\\n                {\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        s.erase(mat[k][m]);\\n                    }   \\n                }\\n\\n                // Finding all the required sums need to be checked\\n                int r1s = mat[0][0] + mat[0][1] + mat[0][2];\\n                int r2s = mat[1][0] + mat[1][1] + mat[1][2];\\n                int r3s = mat[2][0] + mat[2][1] + mat[2][2];\\n                int c1s = mat[0][0] + mat[1][0] + mat[2][0];\\n                int c2s = mat[0][1] + mat[1][1] + mat[2][1];\\n                int c3s = mat[0][2] + mat[1][2] + mat[2][2];\\n                int d1s = mat[0][0] + mat[1][1] + mat[2][2];\\n                int d2s = mat[0][2] + mat[1][1] + mat[2][0];\\n\\n                // If the set is empty and all sums are same it means we have found the magic square\\n                if (s.empty())\\n                {\\n                    if (r1s==r2s && r1s==r3s && r1s==c1s && r1s==c2s && r1s==c3s && r1s==d1s && r1s==d2s)\\n                    {\\n                        c++;\\n                    }\\n                }\\n\\n                cout << endl;\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if (grid.size()<3 || grid[0].size()<3)\\n        {\\n            return 0;\\n        }\\n\\n        // Counter = 0\\n        int c = 0;\\n\\n        // NEsted for loop for iterating through each point\\n        for (int i=0; i<grid.size()-2; i++)\\n        {\\n            for (int j=0; j<grid[i].size()-2; j++)\\n            {\\n                // Making the square matrix of 3x3\\n                vector<vector<int>> mat;\\n                for (int k=0; k<3; k++)\\n                {\\n                    vector<int> v;\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        v.push_back(0);\\n                    }\\n                    mat.push_back(v);   \\n                }\\n\\n                // Adding the values of grid into 3x3 matrix\\n                int cr = 0;\\n                for (int k=i; k<i+3; k++)\\n                {\\n                    int cc=0;\\n                    for (int m=j; m<j+3; m++)\\n                    {\\n                        mat[cr][cc] = grid[k][m];\\n                        cc++;\\n                    }\\n                    cr++;\\n                }\\n\\n                // Declaring a set\\n                // Erase all the elements which occured in the set\\n                // It helps us to identify whether all integers from 1 to 9 is present or not\\n                set <int> s ({1, 2, 3, 4, 5, 6, 7, 8, 9});\\n                for (int k=0; k<3; k++)\\n                {\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        s.erase(mat[k][m]);\\n                    }   \\n                }\\n\\n                // Finding all the required sums need to be checked\\n                int r1s = mat[0][0] + mat[0][1] + mat[0][2];\\n                int r2s = mat[1][0] + mat[1][1] + mat[1][2];\\n                int r3s = mat[2][0] + mat[2][1] + mat[2][2];\\n                int c1s = mat[0][0] + mat[1][0] + mat[2][0];\\n                int c2s = mat[0][1] + mat[1][1] + mat[2][1];\\n                int c3s = mat[0][2] + mat[1][2] + mat[2][2];\\n                int d1s = mat[0][0] + mat[1][1] + mat[2][2];\\n                int d2s = mat[0][2] + mat[1][1] + mat[2][0];\\n\\n                // If the set is empty and all sums are same it means we have found the magic square\\n                if (s.empty())\\n                {\\n                    if (r1s==r2s && r1s==r3s && r1s==c1s && r1s==c2s && r1s==c3s && r1s==d1s && r1s==d2s)\\n                    {\\n                        c++;\\n                    }\\n                }\\n\\n                cout << endl;\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3515978,
                "title": "brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        res = 0\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                r = [0, 0, 0]\\n                c = [0, 0, 0]\\n                a = b = 0\\n                used = [0] * 9\\n                for x in range(i - 1, i + 2):\\n                    a += grid[x][j + x - i]\\n                    b += grid[x][j - x + i]\\n                    for y in range(j - 1, j + 2):\\n                        if 1 <= grid[x][y] <= 9:\\n                            used[grid[x][y] - 1] = 1\\n                        r[x - i + 1] += grid[x][y]\\n                        c[y - j + 1] += grid[x][y]\\n                if sum(used) == 9 and r[0] == r[1] == r[2] == c[0] == c[1] == c[2] == a == b:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        res = 0\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                r = [0, 0, 0]\\n                c = [0, 0, 0]\\n                a = b = 0\\n                used = [0] * 9\\n                for x in range(i - 1, i + 2):\\n                    a += grid[x][j + x - i]\\n                    b += grid[x][j - x + i]\\n                    for y in range(j - 1, j + 2):\\n                        if 1 <= grid[x][y] <= 9:\\n                            used[grid[x][y] - 1] = 1\\n                        r[x - i + 1] += grid[x][y]\\n                        c[y - j + 1] += grid[x][y]\\n                if sum(used) == 9 and r[0] == r[1] == r[2] == c[0] == c[1] == c[2] == a == b:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513705,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int dir[] = new int []{0,1,-1};\\n        int count= 0;\\n        for (int i=1;i<grid.length-1;i++){\\n            outer:\\n            for (int j=1;j<grid[0].length-1;j++){\\n                int sum =grid [i-1][j-1] + grid[i][j] + grid[i+1][j+1];\\n                if (sum!=grid [i+1][j-1] + grid[i][j] + grid[i-1][j+1]) continue;\\n                for (int d :dir){\\n                    if(sum != grid [i+d][j-1] + grid[i+d][j] + grid[i+d][j+1]) continue outer;\\n                    if(sum != grid [i+1][j+d] + grid[i][j+d] + grid[i-1][j+d]) continue outer;\\n                }\\n                boolean[] includesZtoN = new boolean[9];\\n                for (int d1:dir)\\n                    for (int d2:dir){ \\n                        int cur = grid[i+d1][j+d2];\\n                        if (cur>9 || cur <1 ||includesZtoN[cur-1]) continue outer;\\n                        includesZtoN[cur-1] = true;\\n                    }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int dir[] = new int []{0,1,-1};\\n        int count= 0;\\n        for (int i=1;i<grid.length-1;i++){\\n            outer:\\n            for (int j=1;j<grid[0].length-1;j++){\\n                int sum =grid [i-1][j-1] + grid[i][j] + grid[i+1][j+1];\\n                if (sum!=grid [i+1][j-1] + grid[i][j] + grid[i-1][j+1]) continue;\\n                for (int d :dir){\\n                    if(sum != grid [i+d][j-1] + grid[i+d][j] + grid[i+d][j+1]) continue outer;\\n                    if(sum != grid [i+1][j+d] + grid[i][j+d] + grid[i-1][j+d]) continue outer;\\n                }\\n                boolean[] includesZtoN = new boolean[9];\\n                for (int d1:dir)\\n                    for (int d2:dir){ \\n                        int cur = grid[i+d1][j+d2];\\n                        if (cur>9 || cur <1 ||includesZtoN[cur-1]) continue outer;\\n                        includesZtoN[cur-1] = true;\\n                    }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482975,
                "title": "java-correct-this-problem",
                "content": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int sum = 0;\\n        for(int col = 0; col <n; col++) {\\n            sum = sum+grid[0][col];\\n        }\\n        \\n        \\n        for(int row = 0; row<n; row++) {\\n            int rSum = 0;\\n            for(int col = 0; col <n;col++) {\\n                rSum = rSum+grid[row][col];\\n            }\\n            if(rSum != sum) {\\n                return 0;\\n            }\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int cSum = 0;\\n            for(int row = 0; row <n;row++) {\\n                cSum = cSum+grid[row][col];\\n            }\\n            if(cSum != sum) {\\n                return 0;\\n            }\\n        }\\n        \\n        int dSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            dSum = dSum+grid[i][i];\\n        }\\n        \\n        if(dSum != sum) {\\n                return 0;\\n            }\\n        \\n        int Adsum = 0;\\n        for(int i = 0; i<n; i++) {\\n            Adsum = Adsum+grid[i][n-1-i];\\n        }\\n        if(Adsum != sum) {\\n                return 0;\\n            }\\n        \\n        return 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int sum = 0;\\n        for(int col = 0; col <n; col++) {\\n            sum = sum+grid[0][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3463529,
                "title": "shortest-code",
                "content": "your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462864,
                "title": "javascripts-with-3x3-subarrays",
                "content": "Algorithm\\n1. Find 3x3 subgrid in grid\\n2. Check if it is magic squar:\\na) calculate sum on diagonals, rows and columns\\nor\\nb) there is a finite number of magic squares 3x3, so u can just put them into array and check it\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    \\n    let count = 0;\\n\\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n\\n            // get 3x3 subgrid\\n            arr = getSubGrid(grid,i,j)\\n           \\n            if (magicSquares.has(arr.flat(Infinity).join(\"\"))) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n  \\n};\\n\\nfunction getSubGrid(grid,i,j) {\\n    arr = []\\n    for (let k = 0; k < 3; k++) { \\n        arr1 = []\\n        for (let l = 0; l < 3; l++) {\\n            const num = grid[i + k][j + l];\\n            arr1.push(num)\\n        }\\n        arr.push(arr1)\\n    }\\n\\n    return arr;\\n}\\n\\nconst magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    \\n    let count = 0;\\n\\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n\\n            // get 3x3 subgrid\\n            arr = getSubGrid(grid,i,j)\\n           \\n            if (magicSquares.has(arr.flat(Infinity).join(\"\"))) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n  \\n};\\n\\nfunction getSubGrid(grid,i,j) {\\n    arr = []\\n    for (let k = 0; k < 3; k++) { \\n        arr1 = []\\n        for (let l = 0; l < 3; l++) {\\n            const num = grid[i + k][j + l];\\n            arr1.push(num)\\n        }\\n        arr.push(arr1)\\n    }\\n\\n    return arr;\\n}\\n\\nconst magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462860,
                "title": "c-note",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n         if(grid.Length < 3 || grid[0].Length < 3) return 0;\\n         int result=0;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; j++)\\n                {List<int> ks1 = new List<int>();\\n\\n                    ks1.Add(grid[i][j]);\\n                    ks1.Add(grid[i][j + 1]);\\n                    ks1.Add(grid[i][j + 2]);\\n                    ks1.Add(grid[i + 1][j]);\\n                    ks1.Add(grid[i + 1][j + 1]);\\n                    ks1.Add(grid[i + 1][j + 2]);\\n                    ks1.Add(grid[i + 2][j]);\\n                    ks1.Add(grid[i + 2][j + 1]);\\n                    ks1.Add(grid[i + 2][j + 2]);\\n                    var numberGroups = ks1.GroupBy(LL => LL)\\n                               .Select(grp => new\\n                               {\\n                                   number = grp.Key,\\n                                   total = grp.Count()\\n                               })\\n                   .ToArray();\\n                    if (numberGroups.Where(w => w.total > 1||w.number>9).Count() == 0)\\n                    {\\n                        int ans =15;\\n                        if (\\n                           (grid[i][j] + grid[i][j + 1] + grid[i][j + 2]) == ans &&\\n                           (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j] + grid[i + 2][j]) == ans &&\\n                           (grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1]) == ans &&\\n                           (grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 1][j + 1] + grid[i][j + 2]) == ans\\n                            )\\n                        {\\n                            result = result + 1;\\n                        }\\n                    }\\n\\n                }\\n            }\\nreturn result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n         if(grid.Length < 3 || grid[0].Length < 3) return 0;\\n         int result=0;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; j++)\\n                {List<int> ks1 = new List<int>();\\n\\n                    ks1.Add(grid[i][j]);\\n                    ks1.Add(grid[i][j + 1]);\\n                    ks1.Add(grid[i][j + 2]);\\n                    ks1.Add(grid[i + 1][j]);\\n                    ks1.Add(grid[i + 1][j + 1]);\\n                    ks1.Add(grid[i + 1][j + 2]);\\n                    ks1.Add(grid[i + 2][j]);\\n                    ks1.Add(grid[i + 2][j + 1]);\\n                    ks1.Add(grid[i + 2][j + 2]);\\n                    var numberGroups = ks1.GroupBy(LL => LL)\\n                               .Select(grp => new\\n                               {\\n                                   number = grp.Key,\\n                                   total = grp.Count()\\n                               })\\n                   .ToArray();\\n                    if (numberGroups.Where(w => w.total > 1||w.number>9).Count() == 0)\\n                    {\\n                        int ans =15;\\n                        if (\\n                           (grid[i][j] + grid[i][j + 1] + grid[i][j + 2]) == ans &&\\n                           (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j] + grid[i + 2][j]) == ans &&\\n                           (grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1]) == ans &&\\n                           (grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 1][j + 1] + grid[i][j + 2]) == ans\\n                            )\\n                        {\\n                            result = result + 1;\\n                        }\\n                    }\\n\\n                }\\n            }\\nreturn result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460742,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        if(3>grid.length || 3>grid[0].length)\\n            return 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) \\n                if (magicSquare(i, j, 3, grid)) \\n                    count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean magicSquare(int row, int col, int k, int[][]grid) {\\n        int sumDiag1 = 0;\\n        int sumDiag2 = 0; \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = row; i<row+k; i++)\\n            for(int j = col; j<col+k; j++){\\n                if(grid[i][j]>9 || grid[i][j]< 1 || map.getOrDefault(grid[i][j], 0)>=1)\\n                    return false;\\n                map.put(grid[i][j], 1);\\n            }\\n        for (int i = 0; i < k; i++) {\\n            sumDiag1 += grid[row + i][col + i];\\n            sumDiag2 += grid[row + i][col + k - 1 - i];\\n        }\\n        if (sumDiag1 != sumDiag2) \\n            return false;\\n        for (int i = 0; i < k; i++) {\\n            int sumRow = 0;\\n            int sumCol = 0;\\n            for (int j = 0; j < k; j++) {\\n                sumRow += grid[row + i][col + j];\\n                sumCol += grid[row + j][col + i];\\n            }\\n            if (sumRow != sumDiag1 || sumCol != sumDiag1) \\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        if(3>grid.length || 3>grid[0].length)\\n            return 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) \\n                if (magicSquare(i, j, 3, grid)) \\n                    count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean magicSquare(int row, int col, int k, int[][]grid) {\\n        int sumDiag1 = 0;\\n        int sumDiag2 = 0; \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = row; i<row+k; i++)\\n            for(int j = col; j<col+k; j++){\\n                if(grid[i][j]>9 || grid[i][j]< 1 || map.getOrDefault(grid[i][j], 0)>=1)\\n                    return false;\\n                map.put(grid[i][j], 1);\\n            }\\n        for (int i = 0; i < k; i++) {\\n            sumDiag1 += grid[row + i][col + i];\\n            sumDiag2 += grid[row + i][col + k - 1 - i];\\n        }\\n        if (sumDiag1 != sumDiag2) \\n            return false;\\n        for (int i = 0; i < k; i++) {\\n            int sumRow = 0;\\n            int sumCol = 0;\\n            for (int j = 0; j < k; j++) {\\n                sumRow += grid[row + i][col + j];\\n                sumCol += grid[row + j][col + i];\\n            }\\n            if (sumRow != sumDiag1 || sumCol != sumDiag1) \\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441483,
                "title": "java-step-by-step-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391886,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n            \\n            row_sums = [sum(r) for r in sub_grid]\\n            if len(set(row_sums)) > 1:\\n                return False\\n\\n            col_sums = [sum([row[i] for row in sub_grid]) for i in range(3)]\\n            if len(set(col_sums)) > 1 and row_sums[0] != col_sums[0]:\\n                return False\\n            \\n            diag_sums = sum([sub_grid[i][i] for i in range(3)])\\n            return diag_sums == row_sums[0]\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n            \\n            row_sums = [sum(r) for r in sub_grid]\\n            if len(set(row_sums)) > 1:\\n                return False\\n\\n            col_sums = [sum([row[i] for row in sub_grid]) for i in range(3)]\\n            if len(set(col_sums)) > 1 and row_sums[0] != col_sums[0]:\\n                return False\\n            \\n            diag_sums = sum([sub_grid[i][i] for i in range(3)])\\n            return diag_sums == row_sums[0]\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391817,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n\\n            if sum(sub_grid[0]) != sum(sub_grid[1]) != sum(sub_grid[2]):\\n                return False\\n            r_sum = sum(sub_grid[0])\\n\\n            if r_sum != (sub_grid[0][0] + sub_grid[1][0] + sub_grid[2][0]) != (sub_grid[0][1] + sub_grid[1][1] + sub_grid[2][1]) != (sub_grid[0][2] + sub_grid[1][2] + sub_grid[2][2]):\\n                return False\\n            \\n            if r_sum != (sub_grid[0][0] + sub_grid[1][1] + sub_grid[2][2]):\\n                return False\\n            \\n            return True\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n\\n            if sum(sub_grid[0]) != sum(sub_grid[1]) != sum(sub_grid[2]):\\n                return False\\n            r_sum = sum(sub_grid[0])\\n\\n            if r_sum != (sub_grid[0][0] + sub_grid[1][0] + sub_grid[2][0]) != (sub_grid[0][1] + sub_grid[1][1] + sub_grid[2][1]) != (sub_grid[0][2] + sub_grid[1][2] + sub_grid[2][2]):\\n                return False\\n            \\n            if r_sum != (sub_grid[0][0] + sub_grid[1][1] + sub_grid[2][2]):\\n                return False\\n            \\n            return True\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382869,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int r,int c,vector<vector<int>>& grid)\\n    {\\n      vector<int>vis(16,0);\\n      int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n      for (int i=r;i<r+3;i++)\\n      {\\n          int cnt=0;\\n          for (int j=c;j<c+3;j++)\\n          {\\n             vis[grid[i][j]]=1;\\n             cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n       for (int i=1;i<=9;i++) \\n      {\\n          if (!vis[i]) return false;\\n      }\\n     \\n      for (int j=c;j<c+3;j++)\\n      {\\n          int cnt=0;\\n          for (int i=r;i<r+3;i++)\\n          {\\n            cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n      if (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2]!=sum) return false;\\n      if (grid[r][c+2]+grid[r+1][c+1]+grid[r+2][c]!=sum) return false;\\n      return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<=n-3;i++)\\n        {\\n            for (int j=0;j<=m-3;j++)\\n            {\\n               if (check(i,j,grid)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int r,int c,vector<vector<int>>& grid)\\n    {\\n      vector<int>vis(16,0);\\n      int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n      for (int i=r;i<r+3;i++)\\n      {\\n          int cnt=0;\\n          for (int j=c;j<c+3;j++)\\n          {\\n             vis[grid[i][j]]=1;\\n             cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n       for (int i=1;i<=9;i++) \\n      {\\n          if (!vis[i]) return false;\\n      }\\n     \\n      for (int j=c;j<c+3;j++)\\n      {\\n          int cnt=0;\\n          for (int i=r;i<r+3;i++)\\n          {\\n            cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n      if (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2]!=sum) return false;\\n      if (grid[r][c+2]+grid[r+1][c+1]+grid[r+2][c]!=sum) return false;\\n      return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<=n-3;i++)\\n        {\\n            for (int j=0;j<=m-3;j++)\\n            {\\n               if (check(i,j,grid)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373384,
                "title": "easy-python",
                "content": "\\tclass Solution:\\n\\t\\tdef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(len(grid)-2):\\n\\t\\t\\t\\tfor j in range(len(grid)-2):\\n\\t\\t\\t\\t\\tcoll=set()\\n\\t\\t\\t\\t\\tnumSet = set()\\n\\t\\t\\t\\t\\tfor r in range(3):\\n\\t\\t\\t\\t\\t\\tfor c in range(3):\\n\\t\\t\\t\\t\\t\\t\\tnum = grid[r+i][c+j]\\n\\t\\t\\t\\t\\t\\t\\tnumSet.add(num)\\n\\t\\t\\t\\t\\tif list(numSet)!=[1,2,3,4,5,6,7,8,9]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tsumall=sum(grid[i][j:j+3])\\n\\t\\t\\t\\t\\tif (sumall!=sum(grid[i+1][j:j+3]))or(sumall!=sum(grid[i+2][j:j+3])):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j]+grid[i+2][j] or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1])or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2] or sumall!=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn count\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(len(grid)-2):\\n\\t\\t\\t\\tfor j in range(len(grid)-2):\\n\\t\\t\\t\\t\\tcoll=set()\\n\\t\\t\\t\\t\\tnumSet = set()\\n\\t\\t\\t\\t\\tfor r in range(3):\\n\\t\\t\\t\\t\\t\\tfor c in range(3):\\n\\t\\t\\t\\t\\t\\t\\tnum = grid[r+i][c+j]\\n\\t\\t\\t\\t\\t\\t\\tnumSet.add(num)\\n\\t\\t\\t\\t\\tif list(numSet)!=[1,2,3,4,5,6,7,8,9]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tsumall=sum(grid[i][j:j+3])\\n\\t\\t\\t\\t\\tif (sumall!=sum(grid[i+1][j:j+3]))or(sumall!=sum(grid[i+2][j:j+3])):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j]+grid[i+2][j] or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1])or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2] or sumall!=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn count\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3214736,
                "title": "simple-solution-just-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(rows*column)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(3*3)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0,m=grid.length,n=grid[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2>=m || j+2>=n ) continue;\\n                int reqsum=-1;\\n                boolean valid=true;\\n                Set<Integer>set=new HashSet<>();\\n\\n                //checking if 3x3 contains any duplicate element or element greater than 9 or element less than 1\\n                //if thats the case we will simply continue to our next 3x3 matrix\\n                 for(int k=i;k<=i+2;k++)\\n                {\\n                   \\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        if(set.contains(grid[k][l]) || grid[k][l] > 9 || grid [k][l] < 1) {valid=false;}\\n                        set.add(grid[i][j]);\\n                    }\\n                }\\n\\n                if(!valid) continue;\\n\\n                // checking all rows\\n                for(int k=i;k<=i+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        sum+=grid[k][l];\\n                    }\\n                  //  System.out.println(sum+\"R\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) { valid=false; break;}\\n                }\\n                if(!valid) continue;\\n\\n                //checking all columns\\n                for(int k=j;k<=j+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=i;l<=i+2;l++)\\n                    {\\n                        sum+=grid[l][k];\\n                    }\\n                  //  System.out.println(sum+\"C\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) {valid=false; break;}\\n                }\\n                 if(!valid) continue;\\n\\n                // checking top left diagnol\\n                int sum=0;\\n                for(int k=i,l=j;k<=i+2 && l<=j+2 ;k++,l++)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DL\");\\n\\n                \\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                sum=0;\\n                // checking top right dagnol;\\n                for(int k=i,l=j+2;k<=i+2 && l>=j ;k++,l--)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DR\");\\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                if(valid) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//[[5,5,5],[5,5,5],[5,5,5]]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0,m=grid.length,n=grid[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2>=m || j+2>=n ) continue;\\n                int reqsum=-1;\\n                boolean valid=true;\\n                Set<Integer>set=new HashSet<>();\\n\\n                //checking if 3x3 contains any duplicate element or element greater than 9 or element less than 1\\n                //if thats the case we will simply continue to our next 3x3 matrix\\n                 for(int k=i;k<=i+2;k++)\\n                {\\n                   \\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        if(set.contains(grid[k][l]) || grid[k][l] > 9 || grid [k][l] < 1) {valid=false;}\\n                        set.add(grid[i][j]);\\n                    }\\n                }\\n\\n                if(!valid) continue;\\n\\n                // checking all rows\\n                for(int k=i;k<=i+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        sum+=grid[k][l];\\n                    }\\n                  //  System.out.println(sum+\"R\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) { valid=false; break;}\\n                }\\n                if(!valid) continue;\\n\\n                //checking all columns\\n                for(int k=j;k<=j+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=i;l<=i+2;l++)\\n                    {\\n                        sum+=grid[l][k];\\n                    }\\n                  //  System.out.println(sum+\"C\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) {valid=false; break;}\\n                }\\n                 if(!valid) continue;\\n\\n                // checking top left diagnol\\n                int sum=0;\\n                for(int k=i,l=j;k<=i+2 && l<=j+2 ;k++,l++)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DL\");\\n\\n                \\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                sum=0;\\n                // checking top right dagnol;\\n                for(int k=i,l=j+2;k<=i+2 && l>=j ;k++,l--)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DR\");\\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                if(valid) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//[[5,5,5],[5,5,5],[5,5,5]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152935,
                "title": "c-easy-understanding-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(int row,int col,vector<vector<int>>&arr){\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        if(row+2>=n || col+2>=m){\\n            return false;\\n        }\\n        set<int> s;\\n        bool flag=1;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(arr[row+i][col+j]>9 || arr[row+i][col+j]<1){\\n                    return false;\\n                }\\n                s.insert(arr[row+i][col+j]);\\n            }\\n        }\\n        if(s.size()<9 || flag==0){\\n            return false;\\n        }\\n        long long sum1=0;\\n        long long sum2=0;\\n        sum1=sum1+arr[row][col]+arr[row+2][col+2]+arr[row+1][col+1];\\n        sum2=sum2+arr[row][col+2]+arr[row+2][col]+arr[row+1][col+1];\\n        s.clear();\\n        s.insert(sum1);\\n        s.insert(sum2);\\n        for(int i=0;i<3;i++){\\n            long long sum=0;\\n            for(int j=0;j<3;j++){\\n                sum=sum+arr[row+i][col+j];\\n            }\\n            s.insert(sum);\\n            if(s.size()>1){\\n                return false;\\n            }\\n        }\\n        for(int j=0;j<3;j++){\\n            long long sum=0;\\n            for(int i=0;i<3;i++){\\n                sum=sum+arr[row+i][col+j];\\n            }\\n            s.insert(sum);\\n            if(s.size()>1){\\n                return false;\\n            }\\n        }\\n        if(s.size()>1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(ispossible(i,j,grid)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool ispossible(int row,int col,vector<vector<int>>&arr){\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        if(row+2>=n || col+2>=m){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3150556,
                "title": "python-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        # Helper function to check if a 3x3 subgrid is a magic square\\n        def is_magic_square(subgrid):\\n            # Flatten the subgrid into a single list\\n            flattened_subgrid = [num for row in subgrid for num in row]\\n            \\n            # Check if all numbers from 1 to 9 are present in the subgrid\\n            if sorted(flattened_subgrid) != [x for x in range(1, 10)]:\\n                return False\\n            \\n            # Check if all rows and columns have the same sum\\n            sum_of_first_row = sum(subgrid[0])\\n            for row in subgrid:\\n                if sum(row) != sum_of_first_row:\\n                    return False\\n            \\n            column1 = [row[0] for row in subgrid]\\n            column2 = [row[1] for row in subgrid]\\n            column3 = [row[2] for row in subgrid]\\n            if sum(column1) != sum_of_first_row or sum(column2) != sum_of_first_row or sum(column3) != sum_of_first_row:\\n                return False\\n            \\n            # Check if both diagonals have the same sum\\n            sum_of_main_diagonal = sum([subgrid[i][i] for i in range(3)])\\n            sum_of_other_diagonal = sum([subgrid[i][2-i] for i in range(3)])\\n            if sum_of_main_diagonal != sum_of_first_row or sum_of_other_diagonal != sum_of_first_row:\\n                return False\\n            \\n            return True\\n        \\n        # Counter for magic squares found in the grid\\n        magic_squares_count = 0\\n        \\n        # Get the number of rows and columns in the grid\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        \\n        # Iterate over each 3x3 subgrid\\n        for row in range(rows - 2):\\n            for col in range(columns - 2):\\n                subgrid = [grid[row][col:col+3], grid[row+1][col:col+3], grid[row+2][col:col+3]]\\n                if is_magic_square(subgrid):\\n                    magic_squares_count += 1\\n        \\n        return magic_squares_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        # Helper function to check if a 3x3 subgrid is a magic square\\n        def is_magic_square(subgrid):\\n            # Flatten the subgrid into a single list\\n            flattened_subgrid = [num for row in subgrid for num in row]\\n            \\n            # Check if all numbers from 1 to 9 are present in the subgrid\\n            if sorted(flattened_subgrid) != [x for x in range(1, 10)]:\\n                return False\\n            \\n            # Check if all rows and columns have the same sum\\n            sum_of_first_row = sum(subgrid[0])\\n            for row in subgrid:\\n                if sum(row) != sum_of_first_row:\\n                    return False\\n            \\n            column1 = [row[0] for row in subgrid]\\n            column2 = [row[1] for row in subgrid]\\n            column3 = [row[2] for row in subgrid]\\n            if sum(column1) != sum_of_first_row or sum(column2) != sum_of_first_row or sum(column3) != sum_of_first_row:\\n                return False\\n            \\n            # Check if both diagonals have the same sum\\n            sum_of_main_diagonal = sum([subgrid[i][i] for i in range(3)])\\n            sum_of_other_diagonal = sum([subgrid[i][2-i] for i in range(3)])\\n            if sum_of_main_diagonal != sum_of_first_row or sum_of_other_diagonal != sum_of_first_row:\\n                return False\\n            \\n            return True\\n        \\n        # Counter for magic squares found in the grid\\n        magic_squares_count = 0\\n        \\n        # Get the number of rows and columns in the grid\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        \\n        # Iterate over each 3x3 subgrid\\n        for row in range(rows - 2):\\n            for col in range(columns - 2):\\n                subgrid = [grid[row][col:col+3], grid[row+1][col:col+3], grid[row+2][col:col+3]]\\n                if is_magic_square(subgrid):\\n                    magic_squares_count += 1\\n        \\n        return magic_squares_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086436,
                "title": "c",
                "content": "```\\n//center have to be 5\\n//other can\\' be 5\\n//itmes can\\'t bigger than 9, or less than 1\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if( m < 3 || n < 3)\\n        return 0 ;\\n    int ans = 0;\\n    for(int i = 0 ; i <= m-3; i++){\\n        for(int j = 0; j <= n-3; j++){\\n            if(grid[i+1][j+1] != 5)\\n                continue ;\\n            //row\\n            if(grid[i][j] == 5)\\n                continue ;\\n            for(int p = i; p < i+3; p++){\\n                int sum = 0;\\n                for(int q = j; q < j+3; q++){\\n                    if(grid[p][q] > 9 || grid[p][q] < 1)\\n                        goto next ;\\n                    sum += grid[p][q] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //col\\n            for(int p = j; p < j+3; p++){\\n                int sum = 0;\\n                for(int q = i; q < i+3; q++){\\n                    sum += grid[q][p] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //diag\\n            int sum = 0;\\n            sum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] ;\\n            if(sum != 15)\\n                goto next ;\\n            sum = 0;\\n            sum = grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] ;\\n            if(sum != 15)\\n                goto next ;\\n            ans++;\\n            next :\\n                continue ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//center have to be 5\\n//other can\\' be 5\\n//itmes can\\'t bigger than 9, or less than 1\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if( m < 3 || n < 3)\\n        return 0 ;\\n    int ans = 0;\\n    for(int i = 0 ; i <= m-3; i++){\\n        for(int j = 0; j <= n-3; j++){\\n            if(grid[i+1][j+1] != 5)\\n                continue ;\\n            //row\\n            if(grid[i][j] == 5)\\n                continue ;\\n            for(int p = i; p < i+3; p++){\\n                int sum = 0;\\n                for(int q = j; q < j+3; q++){\\n                    if(grid[p][q] > 9 || grid[p][q] < 1)\\n                        goto next ;\\n                    sum += grid[p][q] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //col\\n            for(int p = j; p < j+3; p++){\\n                int sum = 0;\\n                for(int q = i; q < i+3; q++){\\n                    sum += grid[q][p] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //diag\\n            int sum = 0;\\n            sum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] ;\\n            if(sum != 15)\\n                goto next ;\\n            sum = 0;\\n            sum = grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] ;\\n            if(sum != 15)\\n                goto next ;\\n            ans++;\\n            next :\\n                continue ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998910,
                "title": "c-brut-force-easy-to-understand",
                "content": "\\n\\n# Approach\\nBrut Force\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int row, int col, int sum,vector<vector<int>> arr, int &res){\\n        for(int i=row+1; i < row+3; i++){\\n            int colsum =0;\\n            for(int k=col; k<col+3; k++) colsum += arr[i][k];\\n            if(colsum != sum) return;\\n        }\\n        for(int k= col; k< col+3; k++){\\n            int rowsum = 0;\\n            for(int i=row; i<row+3; i++) rowsum += arr[i][k];\\n            if(rowsum != sum) return;\\n        }\\n        int digsum =0;\\n        for(int i=row, j=col; i< row+3, j<col+3; i++, j++){\\n            digsum += arr[i][j];\\n        }\\n        if(digsum != sum) return;\\n        digsum =0;\\n        for(int i=row+2, j=col; i>= row, j<col+3; i--, j++){\\n           digsum += arr[i][j]; \\n        }\\n        if(digsum != sum) return;\\n        res++;\\n    }\\n\\n    bool isdist(int row, int col,vector<vector<int>> arr){\\n        unordered_map<int,int>m;\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                if(m.find(arr[i][j]) != m.end()) return false;\\n                else if(arr[i][j] < 1 || arr[i][j] > 9) return false;\\n                m[arr[i][j]]++;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if(grid.size() < 3 || grid[0].size() < 3) return 0;\\n        int res=0;\\n        for(int i=0; i <= grid.size()-3; i++){\\n            for(int j=0; j<= grid[0].size()-3; j++){\\n                int sum=0;\\n                for(int k=i; k< i+3; k++) sum+= grid[k][j];\\n                if(isdist(i,j,grid))solve(i,j,sum,grid,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int row, int col, int sum,vector<vector<int>> arr, int &res){\\n        for(int i=row+1; i < row+3; i++){\\n            int colsum =0;\\n            for(int k=col; k<col+3; k++) colsum += arr[i][k];\\n            if(colsum != sum) return;\\n        }\\n        for(int k= col; k< col+3; k++){\\n            int rowsum = 0;\\n            for(int i=row; i<row+3; i++) rowsum += arr[i][k];\\n            if(rowsum != sum) return;\\n        }\\n        int digsum =0;\\n        for(int i=row, j=col; i< row+3, j<col+3; i++, j++){\\n            digsum += arr[i][j];\\n        }\\n        if(digsum != sum) return;\\n        digsum =0;\\n        for(int i=row+2, j=col; i>= row, j<col+3; i--, j++){\\n           digsum += arr[i][j]; \\n        }\\n        if(digsum != sum) return;\\n        res++;\\n    }\\n\\n    bool isdist(int row, int col,vector<vector<int>> arr){\\n        unordered_map<int,int>m;\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                if(m.find(arr[i][j]) != m.end()) return false;\\n                else if(arr[i][j] < 1 || arr[i][j] > 9) return false;\\n                m[arr[i][j]]++;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if(grid.size() < 3 || grid[0].size() < 3) return 0;\\n        int res=0;\\n        for(int i=0; i <= grid.size()-3; i++){\\n            for(int j=0; j<= grid[0].size()-3; j++){\\n                int sum=0;\\n                for(int k=i; k< i+3; k++) sum+= grid[k][j];\\n                if(isdist(i,j,grid))solve(i,j,sum,grid,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971792,
                "title": "java-check-each-3-3-square-to-see-if-it-is-magical",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) {\\n                Map<String, Integer> prefixSum = new HashMap<>();\\n                Set<Integer> seen = new HashSet<>();\\n                boolean hasInvalidValues = false;\\n                for (int r = i, nr = 0; r < i + 3; r++, nr++) {\\n                    for (int c = j, nc = 0; c < j + 3; c++, nc++) {\\n                        if (seen.contains(grid[r][c]) || grid[r][c] < 1 || grid[r][c] > 9 ) {\\n                            hasInvalidValues = true;\\n                            break;\\n                        }\\n                        seen.add(grid[r][c]);\\n                        String key = \"r\" + nr;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        key = \"c\" + nc;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        if (nr == nc) {\\n                           key = \"d0\";\\n                           prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        } \\n                        if (nr + nc == 2) {\\n                            key = \"d1\";\\n                            prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        }\\n                    }\\n                    if (hasInvalidValues) break;\\n                }\\n                if (!hasInvalidValues) {\\n                    Integer val = null;\\n                    boolean isMagic = true;\\n                    for (String key : prefixSum.keySet()) {\\n                        if (val == null) {\\n                            val = prefixSum.get(key);\\n                        } else if (val != prefixSum.get(key)) {\\n                            isMagic = false;\\n                            break;\\n                        }\\n                    }\\n                    if (isMagic) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) {\\n                Map<String, Integer> prefixSum = new HashMap<>();\\n                Set<Integer> seen = new HashSet<>();\\n                boolean hasInvalidValues = false;\\n                for (int r = i, nr = 0; r < i + 3; r++, nr++) {\\n                    for (int c = j, nc = 0; c < j + 3; c++, nc++) {\\n                        if (seen.contains(grid[r][c]) || grid[r][c] < 1 || grid[r][c] > 9 ) {\\n                            hasInvalidValues = true;\\n                            break;\\n                        }\\n                        seen.add(grid[r][c]);\\n                        String key = \"r\" + nr;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        key = \"c\" + nc;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        if (nr == nc) {\\n                           key = \"d0\";\\n                           prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        } \\n                        if (nr + nc == 2) {\\n                            key = \"d1\";\\n                            prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        }\\n                    }\\n                    if (hasInvalidValues) break;\\n                }\\n                if (!hasInvalidValues) {\\n                    Integer val = null;\\n                    boolean isMagic = true;\\n                    for (String key : prefixSum.keySet()) {\\n                        if (val == null) {\\n                            val = prefixSum.get(key);\\n                        } else if (val != prefixSum.get(key)) {\\n                            isMagic = false;\\n                            break;\\n                        }\\n                    }\\n                    if (isMagic) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937540,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {\\n        fn check(i: usize, j: usize, grid: &[Vec<i32>]) -> bool {\\n            let mut mp = std::collections::HashMap::new();\\n            for item in grid.iter().skip(i).take(3) {\\n                for &point in item.iter().skip(j).take(3) {\\n                    if mp.contains_key(&point) || !(1..=9).contains(&point) {\\n                        return false;\\n                    } else {\\n                        mp.insert(point, 1);\\n                    }\\n                }\\n            }\\n            if mp.len() != 9 {\\n                return false;\\n            }\\n            let sum = grid[i][j] + grid[i + 1][j] + grid[i + 2][j];\\n\\n            if sum != grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n            if sum != grid[i][j] + grid[i][j + 1] + grid[i][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] {\\n                return false;\\n            }\\n            true\\n        }\\n\\n        let mut count = 0;\\n        if grid.len() < 3 || grid[0].len() < 3 {\\n            return 0;\\n        }\\n        for i in 0..grid.len() - 2 {\\n            for j in 0..grid[0].len() - 2 {\\n                if check(i, j, &grid) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {\\n        fn check(i: usize, j: usize, grid: &[Vec<i32>]) -> bool {\\n            let mut mp = std::collections::HashMap::new();\\n            for item in grid.iter().skip(i).take(3) {\\n                for &point in item.iter().skip(j).take(3) {\\n                    if mp.contains_key(&point) || !(1..=9).contains(&point) {\\n                        return false;\\n                    } else {\\n                        mp.insert(point, 1);\\n                    }\\n                }\\n            }\\n            if mp.len() != 9 {\\n                return false;\\n            }\\n            let sum = grid[i][j] + grid[i + 1][j] + grid[i + 2][j];\\n\\n            if sum != grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n            if sum != grid[i][j] + grid[i][j + 1] + grid[i][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] {\\n                return false;\\n            }\\n            true\\n        }\\n\\n        let mut count = 0;\\n        if grid.len() < 3 || grid[0].len() < 3 {\\n            return 0;\\n        }\\n        for i in 0..grid.len() - 2 {\\n            for j in 0..grid[0].len() - 2 {\\n                if check(i, j, &grid) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922180,
                "title": "python3-brutal-force",
                "content": "```\\nclass Solution:\\n    def helper(self, r, c, grid):\\n        res = all(1<=grid[i][j]<=9 for i in range(r,r+3) for j in range(c,c+3))\\n        res &= len({grid[i][j] for i in range(r,r+3) for j in range(c,c+3)})==9\\n        for i in range(r,r+3):\\n            res &= sum(grid[i][j] for j in range(c,c+3))==15\\n        for j in range(c,c+3):\\n            res &= sum(grid[i][j] for i in range(r,r+3))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c,c+3)))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c+2,c-1,-1)))==15\\n        return res\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        return sum(self.helper(r,c,grid) for r in range(m-2) for c in range(n-2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, r, c, grid):\\n        res = all(1<=grid[i][j]<=9 for i in range(r,r+3) for j in range(c,c+3))\\n        res &= len({grid[i][j] for i in range(r,r+3) for j in range(c,c+3)})==9\\n        for i in range(r,r+3):\\n            res &= sum(grid[i][j] for j in range(c,c+3))==15\\n        for j in range(c,c+3):\\n            res &= sum(grid[i][j] for i in range(r,r+3))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c,c+3)))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c+2,c-1,-1)))==15\\n        return res\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        return sum(self.helper(r,c,grid) for r in range(m-2) for c in range(n-2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913688,
                "title": "all-conditions-checked-finally-c-solution",
                "content": "# Intuition\\nno other alternative than to check all their mentioned conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnote: greaterthan9 variable also checks for 0\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool jaadu(vector<vector<int>> a){\\n        int row1s = 0, row2s = 0, row3s = 0, col1s = 0, col2s = 0, col3s = 0, diagse = 0, diagsh = 0;\\n        int b = 3;\\n        map<int, int> mp;\\n        bool greaterthan9 = false;\\n        for(int g = 0; g < b; g++){\\n            for(int h = 0; h < b; h++){\\n                mp[a[g][h]]++;\\n                if(a[g][h] > 9){\\n                    greaterthan9 = true;\\n                }\\n                if(a[g][h] == 0){\\n                    greaterthan9 = true;\\n                }\\n                if(g == 0) row1s += a[g][h];\\n                if(g == 1) row2s += a[g][h];\\n                if(g == 2) row3s += a[g][h];\\n\\n                if(h == 0) col1s += a[g][h];\\n                if(h == 1) col2s += a[g][h];\\n                if(h == 2) col3s += a[g][h];\\n\\n                if(g == h) diagse += a[g][h];\\n\\n                if(g == 0 && h == 2 || g == 1 && h == 1 || g == 2 && h == 0) diagsh += a[g][h];\\n            }\\n        }\\n        \\n        bool kya = false;\\n        if(mp.size() != 9){\\n            kya = false;\\n        }\\n        else if(row1s == row2s && row1s == row3s && row1s == col1s  && row1s == col2s  && row1s == col3s  && row1s == diagse && row1s == diagsh && greaterthan9 == false){\\n            kya = true;\\n        }\\n        return kya;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size(), c = grid[0].size();\\n        int i = 0, j = 0;\\n        while(i+2 < r && j+2 < c){\\n            vector<vector<int>> now;\\n            for(int k = i; k <= (i+2); k++){\\n                vector<int> v;\\n                for(int l =  j; l <=(j+2); l++){\\n                    v.push_back(grid[k][l]);\\n                }\\n                now.push_back(v);\\n            }\\n            bool check = jaadu(now);\\n            if(check) ans += 1;\\n\\n            j += 1;\\n            int val = c-3;\\n            if(j == val + 1){\\n                i += 1;\\n                j = 0;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool jaadu(vector<vector<int>> a){\\n        int row1s = 0, row2s = 0, row3s = 0, col1s = 0, col2s = 0, col3s = 0, diagse = 0, diagsh = 0;\\n        int b = 3;\\n        map<int, int> mp;\\n        bool greaterthan9 = false;\\n        for(int g = 0; g < b; g++){\\n            for(int h = 0; h < b; h++){\\n                mp[a[g][h]]++;\\n                if(a[g][h] > 9){\\n                    greaterthan9 = true;\\n                }\\n                if(a[g][h] == 0){\\n                    greaterthan9 = true;\\n                }\\n                if(g == 0) row1s += a[g][h];\\n                if(g == 1) row2s += a[g][h];\\n                if(g == 2) row3s += a[g][h];\\n\\n                if(h == 0) col1s += a[g][h];\\n                if(h == 1) col2s += a[g][h];\\n                if(h == 2) col3s += a[g][h];\\n\\n                if(g == h) diagse += a[g][h];\\n\\n                if(g == 0 && h == 2 || g == 1 && h == 1 || g == 2 && h == 0) diagsh += a[g][h];\\n            }\\n        }\\n        \\n        bool kya = false;\\n        if(mp.size() != 9){\\n            kya = false;\\n        }\\n        else if(row1s == row2s && row1s == row3s && row1s == col1s  && row1s == col2s  && row1s == col3s  && row1s == diagse && row1s == diagsh && greaterthan9 == false){\\n            kya = true;\\n        }\\n        return kya;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size(), c = grid[0].size();\\n        int i = 0, j = 0;\\n        while(i+2 < r && j+2 < c){\\n            vector<vector<int>> now;\\n            for(int k = i; k <= (i+2); k++){\\n                vector<int> v;\\n                for(int l =  j; l <=(j+2); l++){\\n                    v.push_back(grid[k][l]);\\n                }\\n                now.push_back(v);\\n            }\\n            bool check = jaadu(now);\\n            if(check) ans += 1;\\n\\n            j += 1;\\n            int val = c-3;\\n            if(j == val + 1){\\n                i += 1;\\n                j = 0;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898273,
                "title": "easiest-java-solution",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        int count=0;\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(check(grid,i,j,m,n))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public boolean check(int[][] grid, int i, int j, int m, int n)\\n    {\\n        if((i+2)>=m || (j+2)>=n)\\n        {\\n            return false;\\n        }\\n        \\n        int row=i;\\n        int col=j;\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int r=row;r<row+3;r++)\\n        {\\n            for(int c=col;c<col+3;c++)\\n            {\\n                if(grid[r][c]>0 && grid[r][c]<10)\\n                {\\n                    set.add(grid[r][c]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(set.size()!=9)\\n        {\\n            return false;\\n        }\\n        int row1=grid[row][col]+grid[row][col+1]+grid[row][col+2];\\n        int row2=grid[row+1][col]+grid[row+1][col+1]+grid[row+1][col+2];\\n        int row3=grid[row+2][col]+grid[row+2][col+1]+grid[row+2][col+2];\\n        \\n        if((row1!=row2) || (row2!=row3) || (row1!=row3))\\n        {\\n            return false;\\n        }\\n        \\n        int col1=grid[row][col]+grid[row+1][col]+grid[row+2][col];\\n        int col2=grid[row][col+1]+grid[row+1][col+1]+grid[row+2][col+1];\\n        int col3=grid[row][col+2]+grid[row+1][col+2]+grid[row+2][col+2];\\n        \\n        if((col1!=col2) || (col2!=col3) || (col3!=col1))\\n        {\\n            return false;\\n        }\\n        \\n        int diag1=grid[row][col]+grid[row+1][col+1]+grid[row+2][col+2];\\n        int diag2=grid[row][col+2]+grid[row+1][col+1]+grid[row+2][col];\\n        \\n        if(diag1!=diag2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        int count=0;\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(check(grid,i,j,m,n))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public boolean check(int[][] grid, int i, int j, int m, int n)\\n    {\\n        if((i+2)>=m || (j+2)>=n)\\n        {\\n            return false;\\n        }\\n        \\n        int row=i;\\n        int col=j;\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int r=row;r<row+3;r++)\\n        {\\n            for(int c=col;c<col+3;c++)\\n            {\\n                if(grid[r][c]>0 && grid[r][c]<10)\\n                {\\n                    set.add(grid[r][c]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(set.size()!=9)\\n        {\\n            return false;\\n        }\\n        int row1=grid[row][col]+grid[row][col+1]+grid[row][col+2];\\n        int row2=grid[row+1][col]+grid[row+1][col+1]+grid[row+1][col+2];\\n        int row3=grid[row+2][col]+grid[row+2][col+1]+grid[row+2][col+2];\\n        \\n        if((row1!=row2) || (row2!=row3) || (row1!=row3))\\n        {\\n            return false;\\n        }\\n        \\n        int col1=grid[row][col]+grid[row+1][col]+grid[row+2][col];\\n        int col2=grid[row][col+1]+grid[row+1][col+1]+grid[row+2][col+1];\\n        int col3=grid[row][col+2]+grid[row+1][col+2]+grid[row+2][col+2];\\n        \\n        if((col1!=col2) || (col2!=col3) || (col3!=col1))\\n        {\\n            return false;\\n        }\\n        \\n        int diag1=grid[row][col]+grid[row+1][col+1]+grid[row+2][col+2];\\n        int diag2=grid[row][col+2]+grid[row+1][col+1]+grid[row+2][col];\\n        \\n        if(diag1!=diag2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842286,
                "title": "c-easy-simple-solution",
                "content": "\\'\\'\\'\\n\\n\\n\\n bool check( int i , int j , vector<vector<int>>& grid )\\n    {\\n        unordered_map< int , int >mp ;\\n        \\n        for( int r = i ; r <= i + 2 ; r++ )\\n        {\\n            for( int c = j ; c <= j + 2 ; c++ )\\n            {\\n                if( mp.find(grid[r][c]) != mp.end() || grid[r][c] > 9 || grid[r][c] < 1)\\n                {\\n                  return false ;  \\n                }\\n                else{\\n                    mp[grid[r][c]]++ ;\\n                }\\n            }\\n        }\\n        \\n        if( mp.size() != 9 ) return false ;\\n        \\n        int sum = grid[i][j] + grid[i+1][j] + grid[i+2][j] ;\\n        \\n        if( sum != grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i][j+1] + grid[i][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]  ) return false ;\\n        \\n        \\n        \\n        \\n        return true ;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int count = 0 ;\\n        \\n        if( grid.size() < 3 || grid[0].size() < 3 ) return 0 ;\\n        for( int i = 0 ; i < grid.size() -2 ; i++ )\\n        {\\n            for( int j = 0 ; j < grid[0].size() - 2 ; j++ )\\n            {\\n                if( check( i , j , grid ))\\n                {\\n                    count++ ;\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n bool check( int i , int j , vector<vector<int>>& grid )\\n    {\\n        unordered_map< int , int >mp ;\\n        \\n        for( int r = i ; r <= i + 2 ; r++ )\\n        {\\n            for( int c = j ; c <= j + 2 ; c++ )\\n            {\\n                if( mp.find(grid[r][c]) != mp.end() || grid[r][c] > 9 || grid[r][c] < 1)\\n                {\\n                  return false ;  \\n                }\\n                else{\\n                    mp[grid[r][c]]++ ;\\n                }\\n            }\\n        }\\n        \\n        if( mp.size() != 9 ) return false ;\\n        \\n        int sum = grid[i][j] + grid[i+1][j] + grid[i+2][j] ;\\n        \\n        if( sum != grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i][j+1] + grid[i][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]  ) return false ;\\n        \\n        \\n        \\n        \\n        return true ;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int count = 0 ;\\n        \\n        if( grid.size() < 3 || grid[0].size() < 3 ) return 0 ;\\n        for( int i = 0 ; i < grid.size() -2 ; i++ )\\n        {\\n            for( int j = 0 ; j < grid[0].size() - 2 ; j++ )\\n            {\\n                if( check( i , j , grid ))\\n                {\\n                    count++ ;\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2835418,
                "title": "c-brute-force-code-joining-the-party",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int G[4][14][14];\\n    int mk[16];\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        memset(G, 0, sizeof(G));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                G[0][i+1][j+1] = G[0][i+1][j] + grid[i][j];\\n                G[1][i+1][j+1] = G[1][i][j+1] + grid[i][j];\\n                G[2][i+1][j+1] = G[2][i][j] + grid[i][j];\\n                G[3][i+1][j+1] = G[3][i][j+2] + grid[i][j];\\n            }\\n        }\\n        int gi, gj;\\n        for (int i = 0; i <= r - 3; i++) {\\n            for (int j = 0; j <= c - 3; j++) {\\n                memset(mk, false, sizeof(mk));\\n                gi = i + 1;\\n                gj = j + 1;\\n                for (int k = i; k < i + 3; k++) {\\n                    for (int l = j; l < j + 3; l++) {\\n                        mk[grid[k][l]] = true;\\n                    }\\n                }\\n                int v = 1;\\n                for (; v <= 9; v++) {\\n                    if (!mk[v])\\n                        break;\\n                }\\n                if (v > 9) {\\n                    int s = G[0][gi][gj+2] - G[0][gi][gj-1];\\n                    if (s != G[0][gi+1][gj+2] - G[0][gi+1][gj-1] ||\\n                       s != G[0][gi+2][gj+2] - G[0][gi+2][gj-1] ||\\n                       s != G[1][gi+2][gj] - G[1][gi-1][gj] ||\\n                       s != G[1][gi+2][gj+1] - G[1][gi-1][gj+1] ||\\n                       s != G[1][gi+2][gj+2] - G[1][gi-1][gj+2] ||\\n                       s != G[2][gi+2][gj+2] - G[2][gi-1][gj-1] ||\\n                       s != G[3][gi+2][gj] - G[3][gi-1][gj+3]) {\\n                        \\n                    }\\n                    else {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int G[4][14][14];\\n    int mk[16];\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        memset(G, 0, sizeof(G));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                G[0][i+1][j+1] = G[0][i+1][j] + grid[i][j];\\n                G[1][i+1][j+1] = G[1][i][j+1] + grid[i][j];\\n                G[2][i+1][j+1] = G[2][i][j] + grid[i][j];\\n                G[3][i+1][j+1] = G[3][i][j+2] + grid[i][j];\\n            }\\n        }\\n        int gi, gj;\\n        for (int i = 0; i <= r - 3; i++) {\\n            for (int j = 0; j <= c - 3; j++) {\\n                memset(mk, false, sizeof(mk));\\n                gi = i + 1;\\n                gj = j + 1;\\n                for (int k = i; k < i + 3; k++) {\\n                    for (int l = j; l < j + 3; l++) {\\n                        mk[grid[k][l]] = true;\\n                    }\\n                }\\n                int v = 1;\\n                for (; v <= 9; v++) {\\n                    if (!mk[v])\\n                        break;\\n                }\\n                if (v > 9) {\\n                    int s = G[0][gi][gj+2] - G[0][gi][gj-1];\\n                    if (s != G[0][gi+1][gj+2] - G[0][gi+1][gj-1] ||\\n                       s != G[0][gi+2][gj+2] - G[0][gi+2][gj-1] ||\\n                       s != G[1][gi+2][gj] - G[1][gi-1][gj] ||\\n                       s != G[1][gi+2][gj+1] - G[1][gi-1][gj+1] ||\\n                       s != G[1][gi+2][gj+2] - G[1][gi-1][gj+2] ||\\n                       s != G[2][gi+2][gj+2] - G[2][gi-1][gj-1] ||\\n                       s != G[3][gi+2][gj] - G[3][gi-1][gj+3]) {\\n                        \\n                    }\\n                    else {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799304,
                "title": "c-solution-beats-100-matrix-brute",
                "content": "\\n# Complexity\\n- Time complexity:O(n*m*3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass sam{\\n    public:\\n    int col = 0;\\n    int row = 0;\\n    int dia = 0;\\n\\n};\\nclass Solution {\\nprivate:\\n    bool is_magic(vector<vector<int>>&grid, int x, int y){\\n\\n        // check all integers are different\\n        vector<int>vis(10,0);\\n        for(int i=x;i<x+3;i++){\\n            for(int j=y;j<y+3;j++){\\n                if(grid[i][j] > 9 || grid[i][j] == 0 || vis[grid[i][j]] == 1) return false;\\n                vis[grid[i][j]] = 1;\\n            }\\n        }\\n\\n        // diagonal\\n        int dia1 = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n        int dia2 = grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y];\\n\\n        if(dia1 != dia2) return false;\\n\\n        // row and col sum must be 15 else return false\\n        for(int i=0;i<3;i++){\\n            if(grid[x][y+i] + grid[x+1][y+i] + grid[x+2][y+i] != dia1) return false;\\n            if(grid[x+i][y] + grid[x+i][y+1] + grid[x+i][y+2] != dia1) return false;   \\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                if(is_magic(grid,i,j)){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass sam{\\n    public:\\n    int col = 0;\\n    int row = 0;\\n    int dia = 0;\\n\\n};\\nclass Solution {\\nprivate:\\n    bool is_magic(vector<vector<int>>&grid, int x, int y){\\n\\n        // check all integers are different\\n        vector<int>vis(10,0);\\n        for(int i=x;i<x+3;i++){\\n            for(int j=y;j<y+3;j++){\\n                if(grid[i][j] > 9 || grid[i][j] == 0 || vis[grid[i][j]] == 1) return false;\\n                vis[grid[i][j]] = 1;\\n            }\\n        }\\n\\n        // diagonal\\n        int dia1 = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n        int dia2 = grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y];\\n\\n        if(dia1 != dia2) return false;\\n\\n        // row and col sum must be 15 else return false\\n        for(int i=0;i<3;i++){\\n            if(grid[x][y+i] + grid[x+1][y+i] + grid[x+2][y+i] != dia1) return false;\\n            if(grid[x+i][y] + grid[x+i][y+1] + grid[x+i][y+2] != dia1) return false;   \\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                if(is_magic(grid,i,j)){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767666,
                "title": "c-tc-o-m-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool solve(vector<vector<int>> &grid, int row, int col) {\\n\\t\\t\\tint count[10] = {0};\\n\\t\\t\\tint rowSum[3] = {0};\\n\\t\\t\\tint colSum[3] = {0};\\n\\t\\t\\tint ld = 0, rd = 0;\\n\\t\\t\\tfor(int i = 0; i < 3; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < 3; j++) {\\n\\t\\t\\t\\t\\tint r = row + i;\\n\\t\\t\\t\\t\\tint c = col + j;\\n\\t\\t\\t\\t\\tif(grid[r][c] >= 10 || grid[r][c] < 1 || count[grid[r][c]])\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tcount[grid[r][c]]++;\\n\\t\\t\\t\\t\\trowSum[i] += grid[r][c];\\n\\t\\t\\t\\t\\tcolSum[j] += grid[r][c];\\n\\t\\t\\t\\t\\tif(i == j) ld += grid[r][c];\\n\\t\\t\\t\\t\\tif(i + j == 2) rd += grid[r][c];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn rowSum[0] == 15 && rowSum[1] == 15 && rowSum[2] == 15 && colSum[0] == 15 && colSum[1] == 15 && colSum[2] == 15 && ld == 15 && rd == 15;\\n\\t\\t}\\n\\t\\tint numMagicSquaresInside(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m - 2; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n - 2; j++) {\\n\\t\\t\\t\\t\\tif(solve(grid, i, j)) ans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool solve(vector<vector<int>> &grid, int row, int col) {\\n\\t\\t\\tint count[10] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2753085,
                "title": "kotlin-solution",
                "content": "Solution may be long, but intuitive i think :)\\n\\n```\\nclass Solution {\\n    fun numMagicSquaresInside(grid: Array<IntArray>): Int {\\n    if(grid.size<3 || grid[0].size<3) { return 0 }\\n\\n    var row_size = grid[0].size-1\\n    var col_size = grid.size-1\\n    var i = 0\\n    var j = 0\\n    var res = 0\\n    var ij_res: IntArray\\n\\n    while (i<=row_size-2 && j<=col_size-2) {\\n        if (!row_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!col_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!diag_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!unique_numbers(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        res++\\n        ij_res = ij_count(i,j,row_size,col_size)\\n        i=ij_res[0]\\n        j=ij_res[1]\\n    }\\n    return res\\n}\\n\\nfun ij_count(i: Int, j: Int, row_size: Int, col_size: Int): IntArray {\\n    var i = i\\n    var j = j\\n    if (i==row_size-2 && j!=col_size-2) {\\n        i=0\\n        j++\\n    } else {\\n        i++\\n    }\\n    return intArrayOf(i,j)\\n}\\n\\nfun row_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i]+grid[j+2][i]\\n    val second = grid[j][i+1]+grid[j+1][i+1]+grid[j+2][i+1]\\n    val third = grid[j][i+2]+grid[j+1][i+2]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun col_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j][i+1]+grid[j][i+2]\\n    val second = grid[j+1][i]+grid[j+1][i+1]+grid[j+1][i+2]\\n    val third = grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun diag_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i+1]+grid[j+2][i+2]\\n    val second = grid[j][i+2]+grid[j+1][i+1]+grid[j+2][i]\\n    return first==second\\n}\\n\\nfun unique_numbers(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    var numbers = arrayOf(1,2,3,4,5,6,7,8,9)\\n    var f = true\\n    var g = arrayOf(grid[j][i],grid[j][i+1],grid[j][i+2],\\n                grid[j+1][i],grid[j+1][i+1],grid[j+1][i+2],\\n                grid[j+2][i],grid[j+2][i+1],grid[j+2][i+2])\\n    for (n in 0..numbers.size-1) {\\n        if(numbers.contains(g[n])) {\\n            numbers[g[n]-1] = -1\\n        } else {\\n            f=false\\n        }\\n    }\\n    return f\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numMagicSquaresInside(grid: Array<IntArray>): Int {\\n    if(grid.size<3 || grid[0].size<3) { return 0 }\\n\\n    var row_size = grid[0].size-1\\n    var col_size = grid.size-1\\n    var i = 0\\n    var j = 0\\n    var res = 0\\n    var ij_res: IntArray\\n\\n    while (i<=row_size-2 && j<=col_size-2) {\\n        if (!row_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!col_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!diag_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!unique_numbers(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        res++\\n        ij_res = ij_count(i,j,row_size,col_size)\\n        i=ij_res[0]\\n        j=ij_res[1]\\n    }\\n    return res\\n}\\n\\nfun ij_count(i: Int, j: Int, row_size: Int, col_size: Int): IntArray {\\n    var i = i\\n    var j = j\\n    if (i==row_size-2 && j!=col_size-2) {\\n        i=0\\n        j++\\n    } else {\\n        i++\\n    }\\n    return intArrayOf(i,j)\\n}\\n\\nfun row_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i]+grid[j+2][i]\\n    val second = grid[j][i+1]+grid[j+1][i+1]+grid[j+2][i+1]\\n    val third = grid[j][i+2]+grid[j+1][i+2]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun col_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j][i+1]+grid[j][i+2]\\n    val second = grid[j+1][i]+grid[j+1][i+1]+grid[j+1][i+2]\\n    val third = grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun diag_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i+1]+grid[j+2][i+2]\\n    val second = grid[j][i+2]+grid[j+1][i+1]+grid[j+2][i]\\n    return first==second\\n}\\n\\nfun unique_numbers(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    var numbers = arrayOf(1,2,3,4,5,6,7,8,9)\\n    var f = true\\n    var g = arrayOf(grid[j][i],grid[j][i+1],grid[j][i+2],\\n                grid[j+1][i],grid[j+1][i+1],grid[j+1][i+2],\\n                grid[j+2][i],grid[j+2][i+1],grid[j+2][i+2])\\n    for (n in 0..numbers.size-1) {\\n        if(numbers.contains(g[n])) {\\n            numbers[g[n]-1] = -1\\n        } else {\\n            f=false\\n        }\\n    }\\n    return f\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751435,
                "title": "straightforward-code-c-with-comment",
                "content": "```\\n*class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            vector<vector<int>> add; // store 3 full row\\n            vector<int> v;\\n            for (int j = i; j < n; j++) {\\n                row++;\\n                add.push_back(grid[j]);\\n                if (row >= 3) break;\\n            }\\n            if (add.size() >= 3) {\\n                for (int a = 0; a < m; a++) {                     \\n                    vector<vector<int>> store; // store every 3 * 3 matrix from 3 rows\\n                    for (int row = 0; row < 3; row++) {\\n                        vector<int> va;\\n                        for (int col = a; col < m; col++) { // traverse every 3 element from every row and add them\\n                            va.push_back(add[row][col]);\\n                            if (va.size() >= 3) break;\\n                        }\\n                        store.push_back(va);\\n                    }\\n                    if (store.size() < 3 or store[0].size() < 3) continue;\\n                    set<int> s, dist;\\n                    int ok = 1;\\n                    for (int i = 0; i < 3; i++) {\\n                        int row_sum = 0, col_sum = 0;\\n                        for (int j = 0; j < 3; j++) {\\n                            row_sum += store[i][j];// sum of row element\\n                            col_sum += store[j][i];//sum of column element\\n                            int val = store[i][j];\\n                            if (val > 0 and val < 10) dist.insert(val); // base case to check the value in range(1 - 9);\\n                            else ok = 0;\\n                        }\\n                        if (!ok) break;\\n                        s.insert(row_sum);\\n                        s.insert(col_sum);\\n                    }\\n                    if (!ok) continue;\\n                    \\n                    int ld = store[0][0] + store[1][1] + store[2][2]; // sum of left diagonal\\n                    int rd = store[0][2] + store[1][1] + store[2][0]; // sum of right diagonal\\n                    s.insert(ld);\\n                    s.insert(rd);\\n                    cnt += (s.size() == 1 and dist.size() == 9);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};*\\n```",
                "solutionTags": [],
                "code": "```\\n*class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            vector<vector<int>> add; // store 3 full row\\n            vector<int> v;\\n            for (int j = i; j < n; j++) {\\n                row++;\\n                add.push_back(grid[j]);\\n                if (row >= 3) break;\\n            }\\n            if (add.size() >= 3) {\\n                for (int a = 0; a < m; a++) {                     \\n                    vector<vector<int>> store; // store every 3 * 3 matrix from 3 rows\\n                    for (int row = 0; row < 3; row++) {\\n                        vector<int> va;\\n                        for (int col = a; col < m; col++) { // traverse every 3 element from every row and add them\\n                            va.push_back(add[row][col]);\\n                            if (va.size() >= 3) break;\\n                        }\\n                        store.push_back(va);\\n                    }\\n                    if (store.size() < 3 or store[0].size() < 3) continue;\\n                    set<int> s, dist;\\n                    int ok = 1;\\n                    for (int i = 0; i < 3; i++) {\\n                        int row_sum = 0, col_sum = 0;\\n                        for (int j = 0; j < 3; j++) {\\n                            row_sum += store[i][j];// sum of row element\\n                            col_sum += store[j][i];//sum of column element\\n                            int val = store[i][j];\\n                            if (val > 0 and val < 10) dist.insert(val); // base case to check the value in range(1 - 9);\\n                            else ok = 0;\\n                        }\\n                        if (!ok) break;\\n                        s.insert(row_sum);\\n                        s.insert(col_sum);\\n                    }\\n                    if (!ok) continue;\\n                    \\n                    int ld = store[0][0] + store[1][1] + store[2][2]; // sum of left diagonal\\n                    int rd = store[0][2] + store[1][1] + store[2][0]; // sum of right diagonal\\n                    s.insert(ld);\\n                    s.insert(rd);\\n                    cnt += (s.size() == 1 and dist.size() == 9);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};*\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721432,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\\n        \\n        guard grid.count >= 3, grid[0].count >= 3 else { return 0 }\\n        \\n        var result = 0\\n        \\n        for i in 0..<grid.count - 2 {\\n            \\n            for j in 0..<grid[0].count - 2 {\\n                if isMagic(i, j, grid) {\\n                    result += 1\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func isMagic(_ i: Int, _ j: Int, _ grid: [[Int]]) -> Bool {\\n        var sumSet: Set<Int> = []\\n        \\n        var numberSet: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        var arraySet: Set<Int> = []\\n        \\n        for r in 0..<3 {\\n            for c in 0..<3 {\\n                arraySet.insert(grid[i+r][j+c])\\n            }\\n        }\\n        \\n        if arraySet != numberSet {\\n            return false\\n        }\\n        \\n        let row1 = grid[i+0][j+0] + grid[i+0][j+1] + grid[i+0][j+2]\\n        let row2 = grid[i+1][j+0] + grid[i+1][j+1] + grid[i+1][j+2]\\n        let row3 = grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2]\\n        \\n        let col1 = grid[i+0][j+0] + grid[i+1][j+0] + grid[i+2][j+0]\\n        let col2 = grid[i+0][j+1] + grid[i+1][j+1] + grid[i+2][j+1]\\n        let col3 = grid[i+0][j+2] + grid[i+1][j+2] + grid[i+2][j+2]\\n        \\n        let dg1 = grid[i+0][j+0] + grid[i+1][j+1] + grid[i+2][j+2]\\n        let dg2 = grid[i+0][j+2] + grid[i+1][j+1] + grid[i+2][j+0]\\n        sumSet = [row1, row2, row3, col1, col2, col3, dg1, dg2]\\n        return sumSet.contains(15) && sumSet.count == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\\n        \\n        guard grid.count >= 3, grid[0].count >= 3 else { return 0 }\\n        \\n        var result = 0\\n        \\n        for i in 0..<grid.count - 2 {\\n            \\n            for j in 0..<grid[0].count - 2 {\\n                if isMagic(i, j, grid) {\\n                    result += 1\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func isMagic(_ i: Int, _ j: Int, _ grid: [[Int]]) -> Bool {\\n        var sumSet: Set<Int> = []\\n        \\n        var numberSet: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        var arraySet: Set<Int> = []\\n        \\n        for r in 0..<3 {\\n            for c in 0..<3 {\\n                arraySet.insert(grid[i+r][j+c])\\n            }\\n        }\\n        \\n        if arraySet != numberSet {\\n            return false\\n        }\\n        \\n        let row1 = grid[i+0][j+0] + grid[i+0][j+1] + grid[i+0][j+2]\\n        let row2 = grid[i+1][j+0] + grid[i+1][j+1] + grid[i+1][j+2]\\n        let row3 = grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2]\\n        \\n        let col1 = grid[i+0][j+0] + grid[i+1][j+0] + grid[i+2][j+0]\\n        let col2 = grid[i+0][j+1] + grid[i+1][j+1] + grid[i+2][j+1]\\n        let col3 = grid[i+0][j+2] + grid[i+1][j+2] + grid[i+2][j+2]\\n        \\n        let dg1 = grid[i+0][j+0] + grid[i+1][j+1] + grid[i+2][j+2]\\n        let dg2 = grid[i+0][j+2] + grid[i+1][j+1] + grid[i+2][j+0]\\n        sumSet = [row1, row2, row3, col1, col2, col3, dg1, dg2]\\n        return sumSet.contains(15) && sumSet.count == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680399,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar numMagicSquaresInside = function(grid) {\\n\\t\\tlet result = 0;\\n\\t\\tconst isMagic = (row, col) => {\\n\\t\\t\\tif (grid[row + 1][col + 1] !== 5) return false;\\n\\t\\t\\tconst visited = new Set();\\n\\t\\t\\tconst nums = [[], [], []];\\n\\n\\t\\t\\tfor (let m = row; m <= row + 2; m++) {\\n\\t\\t\\t\\tfor (let n = col; n <= col + 2; n++) {\\n\\t\\t\\t\\t\\tconst num = grid[m][n];\\n\\t\\t\\t\\t\\tif (num === 0 || num > 9 || visited.has(num)) return false;\\n\\t\\t\\t\\t\\tvisited.add(num);\\n\\t\\t\\t\\t\\tnums[m - row][n - col] = num;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let index = 0; index < 3; index++) {\\n\\t\\t\\t\\tif (nums[index][0] + nums[index][1] + nums[index][2] !== 15) return false;\\n\\t\\t\\t\\tif (nums[0][index] + nums[1][index] + nums[2][index] !== 15) return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[0][0] + nums[1][1] + nums[2][2] !== 15) return false;\\n\\t\\t\\tif (nums[0][2] + nums[1][1] + nums[2][0] !== 15) return false;\\n\\t\\t\\treturn true;\\n\\t\\t};\\n\\n\\t\\tfor (let row = 0; row < grid.length - 2; row++) {\\n\\t\\t\\tfor (let col = 0; col < grid[0].length - 2; col++) {\\n\\t\\t\\t\\tisMagic(row, col) && result++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numMagicSquaresInside = function(grid) {\\n\\t\\tlet result = 0;\\n\\t\\tconst isMagic = (row, col) => {\\n\\t\\t\\tif (grid[row + 1][col + 1] !== 5) return false;\\n\\t\\t\\tconst visited = new Set();\\n\\t\\t\\tconst nums = [[], [], []];\\n\\n\\t\\t\\tfor (let m = row; m <= row + 2; m++) {\\n\\t\\t\\t\\tfor (let n = col; n <= col + 2; n++) {\\n\\t\\t\\t\\t\\tconst num = grid[m][n];\\n\\t\\t\\t\\t\\tif (num === 0 || num > 9 || visited.has(num)) return false;\\n\\t\\t\\t\\t\\tvisited.add(num);\\n\\t\\t\\t\\t\\tnums[m - row][n - col] = num;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let index = 0; index < 3; index++) {\\n\\t\\t\\t\\tif (nums[index][0] + nums[index][1] + nums[index][2] !== 15) return false;\\n\\t\\t\\t\\tif (nums[0][index] + nums[1][index] + nums[2][index] !== 15) return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[0][0] + nums[1][1] + nums[2][2] !== 15) return false;\\n\\t\\t\\tif (nums[0][2] + nums[1][1] + nums[2][0] !== 15) return false;\\n\\t\\t\\treturn true;\\n\\t\\t};\\n\\n\\t\\tfor (let row = 0; row < grid.length - 2; row++) {\\n\\t\\t\\tfor (let col = 0; col < grid[0].length - 2; col++) {\\n\\t\\t\\t\\tisMagic(row, col) && result++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2678040,
                "title": "ts-js-solution",
                "content": "```\\nfunction numMagicSquaresInside(grid: number[][]): number {\\n  let count = 0;\\n\\n  if (grid.length < 3 || grid?.[0]?.length < 0) {\\n    return count;\\n  }\\n\\n  const checkMagicSquare = (i: number, j: number): void => {\\n    const get3x3Numbers = (): number[][] => {\\n      const numbers = [[], [], []];\\n\\n      for (let k = 0; k < 3; k++) {\\n        for (let l = 0; l < 3; l++) {\\n          numbers[k][l] = grid[i + k][j + l];\\n        }\\n      }\\n\\n      return numbers;\\n    };\\n\\n    const isAllDistinctNumbers = (): boolean => {\\n      return new Set(numbers.reduce((acc, row) => {\\n        row.forEach(num => {\\n          if (num >= 1 && num <= 9) {\\n            acc.push(num);\\n          }\\n        });\\n\\n        return acc;\\n      }, [])).size === 9;\\n    };\\n\\n    const haveAllSameSum = (): boolean => {\\n      return new Set([\\n        // rows\\n        numbers[0][0] + numbers[0][1] + numbers[0][2],\\n        numbers[1][0] + numbers[1][1] + numbers[1][2],\\n        numbers[2][0] + numbers[2][1] + numbers[2][2],\\n\\n        // cols\\n        numbers[0][0] + numbers[1][0] + numbers[2][0],\\n        numbers[0][1] + numbers[1][1] + numbers[2][1],\\n        numbers[0][2] + numbers[1][2] + numbers[2][2],\\n\\n        // diagonals\\n        numbers[0][0] + numbers[1][1] + numbers[2][2],\\n        numbers[0][2] + numbers[1][1] + numbers[2][0],\\n      ]).size === 1;\\n    };\\n\\n    const numbers = get3x3Numbers();\\n\\n    if (isAllDistinctNumbers() && haveAllSameSum()) {\\n      count++;\\n    }\\n  };\\n\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i + 2]?.[j + 2] === undefined) {\\n        break;\\n      }\\n\\n      checkMagicSquare(i, j);\\n    }\\n  }\\n\\n  return count;\\n};\\n```\\n\\n```\\nRuntime: 100 ms, faster than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\nMemory Usage: 45.8 MB, less than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numMagicSquaresInside(grid: number[][]): number {\\n  let count = 0;\\n\\n  if (grid.length < 3 || grid?.[0]?.length < 0) {\\n    return count;\\n  }\\n\\n  const checkMagicSquare = (i: number, j: number): void => {\\n    const get3x3Numbers = (): number[][] => {\\n      const numbers = [[], [], []];\\n\\n      for (let k = 0; k < 3; k++) {\\n        for (let l = 0; l < 3; l++) {\\n          numbers[k][l] = grid[i + k][j + l];\\n        }\\n      }\\n\\n      return numbers;\\n    };\\n\\n    const isAllDistinctNumbers = (): boolean => {\\n      return new Set(numbers.reduce((acc, row) => {\\n        row.forEach(num => {\\n          if (num >= 1 && num <= 9) {\\n            acc.push(num);\\n          }\\n        });\\n\\n        return acc;\\n      }, [])).size === 9;\\n    };\\n\\n    const haveAllSameSum = (): boolean => {\\n      return new Set([\\n        // rows\\n        numbers[0][0] + numbers[0][1] + numbers[0][2],\\n        numbers[1][0] + numbers[1][1] + numbers[1][2],\\n        numbers[2][0] + numbers[2][1] + numbers[2][2],\\n\\n        // cols\\n        numbers[0][0] + numbers[1][0] + numbers[2][0],\\n        numbers[0][1] + numbers[1][1] + numbers[2][1],\\n        numbers[0][2] + numbers[1][2] + numbers[2][2],\\n\\n        // diagonals\\n        numbers[0][0] + numbers[1][1] + numbers[2][2],\\n        numbers[0][2] + numbers[1][1] + numbers[2][0],\\n      ]).size === 1;\\n    };\\n\\n    const numbers = get3x3Numbers();\\n\\n    if (isAllDistinctNumbers() && haveAllSameSum()) {\\n      count++;\\n    }\\n  };\\n\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i + 2]?.[j + 2] === undefined) {\\n        break;\\n      }\\n\\n      checkMagicSquare(i, j);\\n    }\\n  }\\n\\n  return count;\\n};\\n```\n```\\nRuntime: 100 ms, faster than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\nMemory Usage: 45.8 MB, less than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674804,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        numbers = set([i for i in range(1,10)])\\n        def check(i, j):\\n            if numbers != set([grid[i+di][j+dj] for di in range(3) for dj in range(3)]):\\n                return False\\n            s = sum(grid[i][j+k] for k in range(3))\\n            for di in range(3):\\n                if s != sum(grid[i+di][j+k] for k in range(3)): return False\\n            for dj in range(3):\\n                if s != sum(grid[i+k][j+dj] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+k] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+2-k] for k in range(3)): return False\\n            return True\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                res += check(i,j)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        numbers = set([i for i in range(1,10)])\\n        def check(i, j):\\n            if numbers != set([grid[i+di][j+dj] for di in range(3) for dj in range(3)]):\\n                return False\\n            s = sum(grid[i][j+k] for k in range(3))\\n            for di in range(3):\\n                if s != sum(grid[i+di][j+k] for k in range(3)): return False\\n            for dj in range(3):\\n                if s != sum(grid[i+k][j+dj] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+k] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+2-k] for k in range(3)): return False\\n            return True\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                res += check(i,j)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2657442,
                "title": "0ms-easy-understandable-solution",
                "content": "```\\nclass Solution {\\n     Set<Integer> set = new HashSet<>();\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i + 2 < grid.length && j + 2 < grid[0].length) {\\n                    if (isMagicSquare(grid, i, i + 2, j, j + 2))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int rs, int re, int cs, int ce) {\\n        \\n       \\n        set.clear();\\n        for (int i = rs; i <= re; i++) {\\n            for (int j = cs; j <= ce; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9) return false;\\n                if (set.contains(grid[i][j]))\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n\\n        int row1Sum = 0, col1Sum = 0, row2Sum = 0, col2Sum = 0, row3Sum = 0, col3Sum = 0;\\n        row1Sum = grid[rs][cs] + grid[rs][cs + 1] + grid[rs][cs + 2];\\n        row2Sum = grid[rs + 1][cs] + grid[rs + 1][cs + 1] + grid[rs + 1][cs + 2];\\n        row3Sum = grid[rs + 2][cs] + grid[rs + 2][cs + 1] + grid[rs + 2][cs + 2];\\n\\n        col1Sum = grid[rs][cs] + grid[rs + 1][cs] + grid[rs + 2][cs];\\n        col2Sum = grid[rs][cs + 1] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 1];\\n        col3Sum = grid[rs][cs + 2] + grid[rs + 1][cs + 2] + grid[rs + 2][cs + 2];\\n\\n        if ((row1Sum == row2Sum) && (row1Sum == row3Sum) && (row1Sum == col1Sum) && (col1Sum == col2Sum) && (col2Sum == col3Sum)) {\\n            int diag1Sum = 0, diag2Sum = 0;\\n            diag1Sum = grid[rs][cs] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 2];\\n            diag2Sum = grid[rs][ce] + grid[rs + 1][ce - 1] + grid[rs + 2][ce - 2];\\n            return diag1Sum == diag2Sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n     Set<Integer> set = new HashSet<>();\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i + 2 < grid.length && j + 2 < grid[0].length) {\\n                    if (isMagicSquare(grid, i, i + 2, j, j + 2))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int rs, int re, int cs, int ce) {\\n        \\n       \\n        set.clear();\\n        for (int i = rs; i <= re; i++) {\\n            for (int j = cs; j <= ce; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9) return false;\\n                if (set.contains(grid[i][j]))\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n\\n        int row1Sum = 0, col1Sum = 0, row2Sum = 0, col2Sum = 0, row3Sum = 0, col3Sum = 0;\\n        row1Sum = grid[rs][cs] + grid[rs][cs + 1] + grid[rs][cs + 2];\\n        row2Sum = grid[rs + 1][cs] + grid[rs + 1][cs + 1] + grid[rs + 1][cs + 2];\\n        row3Sum = grid[rs + 2][cs] + grid[rs + 2][cs + 1] + grid[rs + 2][cs + 2];\\n\\n        col1Sum = grid[rs][cs] + grid[rs + 1][cs] + grid[rs + 2][cs];\\n        col2Sum = grid[rs][cs + 1] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 1];\\n        col3Sum = grid[rs][cs + 2] + grid[rs + 1][cs + 2] + grid[rs + 2][cs + 2];\\n\\n        if ((row1Sum == row2Sum) && (row1Sum == row3Sum) && (row1Sum == col1Sum) && (col1Sum == col2Sum) && (col2Sum == col3Sum)) {\\n            int diag1Sum = 0, diag2Sum = 0;\\n            diag1Sum = grid[rs][cs] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 2];\\n            diag2Sum = grid[rs][ce] + grid[rs + 1][ce - 1] + grid[rs + 2][ce - 2];\\n            return diag1Sum == diag2Sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656508,
                "title": "python-clean-solution",
                "content": "```\\ndef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\tdef valid(m):\\n\\t\\tif sorted(m)!=list(range(1, 10)):\\n\\t\\t\\treturn 0\\n\\t\\tif not (m[0]+m[1]+m[2]==m[3]+m[4]+m[5]==m[6]+m[7]+m[8]==15):\\n\\t\\t\\treturn 0    # row-base\\n\\t\\tif not (m[0]+m[3]+m[6]==m[1]+m[4]+m[7]==m[2]+m[5]+m[8]==15):\\n\\t\\t\\treturn 0   # col-base\\n\\t\\tif not (m[0]+m[4]+m[8]==m[2]+m[4]+m[6]==15):\\n\\t\\t\\treturn 0   # diag and anti-diag\\n\\t\\treturn 1\\n\\n\\tx, y, ans = len(grid), len(grid[0]), 0\\n\\tfor i in range(x-2):\\n\\t\\tfor j in range(y-2):\\n\\t\\t\\tmat = grid[i][j:j+3]+grid[i+1][j:j+3]+grid[i+2][j:j+3]\\n\\t\\t\\tans += valid(mat)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\tdef valid(m):\\n\\t\\tif sorted(m)!=list(range(1, 10)):\\n\\t\\t\\treturn 0\\n\\t\\tif not (m[0]+m[1]+m[2]==m[3]+m[4]+m[5]==m[6]+m[7]+m[8]==15):\\n\\t\\t\\treturn 0    # row-base\\n\\t\\tif not (m[0]+m[3]+m[6]==m[1]+m[4]+m[7]==m[2]+m[5]+m[8]==15):\\n\\t\\t\\treturn 0   # col-base\\n\\t\\tif not (m[0]+m[4]+m[8]==m[2]+m[4]+m[6]==15):\\n\\t\\t\\treturn 0   # diag and anti-diag\\n\\t\\treturn 1\\n\\n\\tx, y, ans = len(grid), len(grid[0]), 0\\n\\tfor i in range(x-2):\\n\\t\\tfor j in range(y-2):\\n\\t\\t\\tmat = grid[i][j:j+3]+grid[i+1][j:j+3]+grid[i+2][j:j+3]\\n\\t\\t\\tans += valid(mat)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2617493,
                "title": "c-simple-and-straightforward-solution",
                "content": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<row-2; i++){\\n            for(int j=0; j<col-2; j++){\\n                if(magic_square(i,j,grid)){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    bool magic_square(int a, int b, vector<vector<int>>& grid){\\n        \\n        int s[3][3];\\n        set<int> st;\\n        \\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                s[i][j] = grid[a+i][b+j];\\n                st.insert(s[i][j]);\\n            }\\n        }\\n        \\n        //9 Unique Element\\n        if(st.size()!=9) return false;\\n        \\n        //Checking Numbers from 1 to 9. \\n        int n = 1;\\n        for(auto x: st){\\n            if(x!=n) return false;\\n            n++;\\n        }\\n        \\n        \\n        //Checking R1, R2, R3, C1, C2, C3, D1, D2 Sum. \\n        int SUM[8] = {0};\\n        \\n        //Rows\\n        SUM[0] = s[0][0] + s[0][1] + s[0][2];\\n        SUM[1] = s[1][0] + s[1][1] + s[1][2];\\n        SUM[2] = s[2][0] + s[2][1] + s[2][2];\\n        \\n        //Column\\n        SUM[3] = s[0][0] + s[1][0] + s[2][0];\\n        SUM[4] = s[0][1] + s[1][1] + s[2][1];\\n        SUM[5] = s[0][2] + s[1][2] + s[2][2];\\n        \\n        //Diagonal\\n        SUM[6] = s[0][0] + s[1][1] + s[2][2];\\n        SUM[7] = s[0][2] + s[1][1] + s[2][0];\\n        \\n        \\n        for(int i=0; i<8; i++){\\n            if(SUM[i]!=15) return false;\\n        }\\n\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<row-2; i++){\\n            for(int j=0; j<col-2; j++){\\n                if(magic_square(i,j,grid)){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2546545,
                "title": "java-simple-solution-7ms",
                "content": "Runtime: 7 ms, faster than 11.97% of Java online submissions for Magic Squares In Grid.\\nMemory Usage: 42.6 MB, less than 14.53% of Java online submissions for Magic Squares In Grid.\\n\\n```\\nclass Solution {\\n    static boolean colMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = b; i < b + 3; i++) {\\n            for (int j = a; j < a + 3; j++) {\\n                sum = sum + grid[j][i];\\n             }\\n            set.add(sum);\\n            sum = 0;\\n        }\\n        return (set.size() == 1);\\n    }\\n\\n    static boolean rowMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = a; i < a + 3; i++) {\\n            for (int j = b; j < b + 3; j++) {\\n                sum = sum + grid[i][j];\\n            }\\n            set.add(sum);\\n            sum = 0;\\n        }\\n        return (set.size() == 1);\\n    }\\n\\n    static boolean checkMat(int[][] grid, int a, int b) {\\n        ArrayList<Integer> lis = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            lis.add(i);\\n        }\\n        if ((a + 3) <= grid.length && (b + 3) <= grid[0].length) {\\n            for (int i = a; i < a + 3; i++) {\\n                for (int j = b; j < b + 3; j++) {\\n                    if (lis.contains(grid[i][j])) {\\n                        lis.remove(Integer.valueOf(grid[i][j]));\\n                    }\\n                }\\n            }\\n        }\\n        int a1 = 0;\\n        int b1 = 0;\\n        if (lis.size() == 0) {\\n            a1 = grid[a][b] + grid[a + 2][b + 2];\\n            b1 = grid[a][b + 2] + grid[a + 2][b];\\n            return (a1 == b1);\\n        }\\n        return false;\\n    }\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[i].length - 3; j++) {\\n                if (checkMat(grid, i, j)) {\\n                    if (rowMat(grid, i, j)) {\\n                        if (colMat(grid, i, j)) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    static boolean colMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = b; i < b + 3; i++) {\\n            for (int j = a; j < a + 3; j++) {\\n                sum = sum + grid[j][i];\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2517668,
                "title": "c-best-solution",
                "content": "**C Best Solution Basics Beats 100% 100%**\\n\\n```\\nbool chk(int **a, int i, int j)\\n{\\n    int map[10]={0};\\n    for(int n=i;n<=i+2;n++)\\n    {\\n        for(int m=j;m<=j+2;m++)\\n        {\\n            if(a[n][m]>9)return false;\\n            map[a[n][m]]++;\\n        } \\n    }\\n    for(int n=1;n<10;n++)if(map[n]==0)return false;\\n    int s=a[i][j]+a[i][j+1]+a[i][j+2];\\n    if(a[i+1][j]+a[i+1][j+1]+a[i+1][j+2]==s &&\\n       a[i+2][j]+a[i+2][j+1]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j]+a[i+2][j]==s &&\\n       a[i][j+1]+a[i+1][j+1]+a[i+2][j+1]==s &&\\n       a[i][j+2]+a[i+1][j+2]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j+1]+a[i+2][j+2]==s &&\\n       a[i+2][j]+a[i+1][j+1]+a[i][j+2]==s)return true;\\n    return false;\\n}\\n        \\nint numMagicSquaresInside(int** a, int n, int* nl)\\n{\\n    int k=0;\\n    for(int i=0;i<n-2;i++)\\n        for(int j=0;j<*nl-2;j++)if(chk(a,i,j))k++;\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool chk(int **a, int i, int j)\\n{\\n    int map[10]={0};\\n    for(int n=i;n<=i+2;n++)\\n    {\\n        for(int m=j;m<=j+2;m++)\\n        {\\n            if(a[n][m]>9)return false;\\n            map[a[n][m]]++;\\n        } \\n    }\\n    for(int n=1;n<10;n++)if(map[n]==0)return false;\\n    int s=a[i][j]+a[i][j+1]+a[i][j+2];\\n    if(a[i+1][j]+a[i+1][j+1]+a[i+1][j+2]==s &&\\n       a[i+2][j]+a[i+2][j+1]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j]+a[i+2][j]==s &&\\n       a[i][j+1]+a[i+1][j+1]+a[i+2][j+1]==s &&\\n       a[i][j+2]+a[i+1][j+2]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j+1]+a[i+2][j+2]==s &&\\n       a[i+2][j]+a[i+1][j+1]+a[i][j+2]==s)return true;\\n    return false;\\n}\\n        \\nint numMagicSquaresInside(int** a, int n, int* nl)\\n{\\n    int k=0;\\n    for(int i=0;i<n-2;i++)\\n        for(int j=0;j<*nl-2;j++)if(chk(a,i,j))k++;\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2475106,
                "title": "javascript-solution-that-works",
                "content": "```\\nvar numMagicSquaresInside = function(grid) {\\n    if (grid.length < 3){\\n        return 0\\n    }\\n    \\n    let total = 0\\n    \\n    for(let row = 0; row < grid.length - 2; row++){\\n        for(let col = 0; col < grid[0].length - 2; col++){\\n            if(numsDiff(row, col, grid) === true && rowCheck(row, col, grid) === true && colCheck(row, col, grid) === true && diagCheck(row, col, grid)  === true){\\n                total++\\n            }\\n        }\\n    }\\n    \\n    return total\\n};\\n\\nfunction numsDiff(row, col, grid){\\n    let mySet = new Set()\\n    for(let i = row; i < row+3; i++){\\n        for(let j = col; j < col+3; j++){\\n            if (grid[i][j] > 9){\\n                return false\\n            }\\n            mySet.add(grid[i][j])\\n        }\\n    }\\n   return mySet.size === 9 ? true : false\\n}\\n\\nfunction rowCheck(row, col, grid){\\n    let check = true\\n    for(let i = row; i < row+3; i++){\\n        let total = grid[row][col] + grid[row][col + 1] + grid[row][col + 2]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction colCheck(row, col, grid){\\n    let check = true\\n    for(let i = col; i < col+3; i++){\\n        let total = grid[row][col] + grid[row+1][col] + grid[row+2][col]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction diagCheck(row, col, grid){\\n    let check = false\\n    if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] === 15 && grid[row+2][col] + grid[row+1][col+1] + grid[row][col+2] === 15){\\n        check = true\\n    }\\n   return check\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    if (grid.length < 3){\\n        return 0\\n    }\\n    \\n    let total = 0\\n    \\n    for(let row = 0; row < grid.length - 2; row++){\\n        for(let col = 0; col < grid[0].length - 2; col++){\\n            if(numsDiff(row, col, grid) === true && rowCheck(row, col, grid) === true && colCheck(row, col, grid) === true && diagCheck(row, col, grid)  === true){\\n                total++\\n            }\\n        }\\n    }\\n    \\n    return total\\n};\\n\\nfunction numsDiff(row, col, grid){\\n    let mySet = new Set()\\n    for(let i = row; i < row+3; i++){\\n        for(let j = col; j < col+3; j++){\\n            if (grid[i][j] > 9){\\n                return false\\n            }\\n            mySet.add(grid[i][j])\\n        }\\n    }\\n   return mySet.size === 9 ? true : false\\n}\\n\\nfunction rowCheck(row, col, grid){\\n    let check = true\\n    for(let i = row; i < row+3; i++){\\n        let total = grid[row][col] + grid[row][col + 1] + grid[row][col + 2]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction colCheck(row, col, grid){\\n    let check = true\\n    for(let i = col; i < col+3; i++){\\n        let total = grid[row][col] + grid[row+1][col] + grid[row+2][col]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction diagCheck(row, col, grid){\\n    let check = false\\n    if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] === 15 && grid[row+2][col] + grid[row+1][col+1] + grid[row][col+2] === 15){\\n        check = true\\n    }\\n   return check\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446125,
                "title": "c-easy-to-understand-painfull-question",
                "content": "```\\nclass Solution {\\npublic:\\n     int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                int check = 0;\\n                int flag = 0;\\n                int sum = 0;\\n                for(int p = 0;p<3;p++){\\n                    for(int q=0;q<3;q++){\\n                        sum+=grid[i+p][j+q];\\n                        if(check == grid[i+p][j+q] || grid[i+p][j+q]>9 || grid[i+p][j+q]<1){\\n                            flag = 1;\\n                        }\\n                        check = grid[i+p][j+q];\\n                    }\\n                }\\n                if(sum != 45) flag = 1;\\n                return flag == 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                int check = 0;\\n                int flag = 0;\\n                int sum = 0;\\n                for(int p = 0;p<3;p++){\\n                    for(int q=0;q<3;q++){\\n                        sum+=grid[i+p][j+q];\\n                        if(check == grid[i+p][j+q] || grid[i+p][j+q]>9 || grid[i+p][j+q]<1){\\n                            flag = 1;\\n                        }\\n                        check = grid[i+p][j+q];\\n                    }\\n                }\\n                if(sum != 45) flag = 1;\\n                return flag == 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421185,
                "title": "crisp-n-clear-o-n-javascript-runtime-90-meaningful-vars",
                "content": "Runtime: 70 ms, faster than 90.00% of JavaScript online submissions for Magic Squares In Grid.\\nMemory Usage: 42.4 MB, less than 85.00% of JavaScript online submissions for Magic Squares In Grid.\\n\\n```\\nfunction areNumbersDistinct(grid, rowIndex, columnIndex) {\\n  const obj = {};\\n  for (let childRowIndex = rowIndex; childRowIndex <= rowIndex + 2; childRowIndex++) {\\n    for (\\n      let childColumnIndex = columnIndex;\\n      childColumnIndex <= columnIndex + 2;\\n      childColumnIndex++\\n    ) {\\n      const currentNum = grid[childRowIndex][childColumnIndex];\\n      if (currentNum < 1 || currentNum > 9) {\\n        return false;\\n      }\\n      if (!obj[grid[childRowIndex][childColumnIndex]]) {\\n        obj[grid[childRowIndex][childColumnIndex]] = 1;\\n      } else {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nfunction areAllRowsEqual(grid, rowIndex, columnIndex) {\\n  const firstRowSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex][columnIndex + 1] + grid[rowIndex][columnIndex + 2];\\n  const secondRowSum =\\n    grid[rowIndex + 1][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 2];\\n  const thirdRowSum =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 2][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstRowSum === secondRowSum && secondRowSum === thirdRowSum;\\n}\\n\\nfunction areAllColumnsEqual(grid, rowIndex, columnIndex) {\\n  const firstColumnSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex + 1][columnIndex] + grid[rowIndex + 2][columnIndex];\\n  const secondColumnSum =\\n    grid[rowIndex][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 1];\\n  const thirdColumnSum =\\n    grid[rowIndex][columnIndex + 2] +\\n    grid[rowIndex + 1][columnIndex + 2] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstColumnSum === secondColumnSum && secondColumnSum === thirdColumnSum;\\n}\\nfunction areAllDiagonalsEqual(grid, rowIndex, columnIndex) {\\n  const firstDiagonal =\\n    grid[rowIndex][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  const secondDiagonal =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex][columnIndex + 2];\\n  return firstDiagonal === secondDiagonal;\\n}\\n\\nvar numMagicSquaresInside = function (grid) {\\n  let count = 0;\\n  for (let rowIndex = 0; rowIndex < grid.length - 2; rowIndex++) {\\n    for (let columnIndex = 0; columnIndex < grid.length - 2; columnIndex++) {\\n      if (\\n        areAllRowsEqual(grid, rowIndex, columnIndex) &&\\n        areAllColumnsEqual(grid, rowIndex, columnIndex) &&\\n        areAllDiagonalsEqual(grid, rowIndex, columnIndex) &&\\n        areNumbersDistinct(grid, rowIndex, columnIndex)\\n      ) {\\n        count += 1;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction areNumbersDistinct(grid, rowIndex, columnIndex) {\\n  const obj = {};\\n  for (let childRowIndex = rowIndex; childRowIndex <= rowIndex + 2; childRowIndex++) {\\n    for (\\n      let childColumnIndex = columnIndex;\\n      childColumnIndex <= columnIndex + 2;\\n      childColumnIndex++\\n    ) {\\n      const currentNum = grid[childRowIndex][childColumnIndex];\\n      if (currentNum < 1 || currentNum > 9) {\\n        return false;\\n      }\\n      if (!obj[grid[childRowIndex][childColumnIndex]]) {\\n        obj[grid[childRowIndex][childColumnIndex]] = 1;\\n      } else {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nfunction areAllRowsEqual(grid, rowIndex, columnIndex) {\\n  const firstRowSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex][columnIndex + 1] + grid[rowIndex][columnIndex + 2];\\n  const secondRowSum =\\n    grid[rowIndex + 1][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 2];\\n  const thirdRowSum =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 2][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstRowSum === secondRowSum && secondRowSum === thirdRowSum;\\n}\\n\\nfunction areAllColumnsEqual(grid, rowIndex, columnIndex) {\\n  const firstColumnSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex + 1][columnIndex] + grid[rowIndex + 2][columnIndex];\\n  const secondColumnSum =\\n    grid[rowIndex][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 1];\\n  const thirdColumnSum =\\n    grid[rowIndex][columnIndex + 2] +\\n    grid[rowIndex + 1][columnIndex + 2] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstColumnSum === secondColumnSum && secondColumnSum === thirdColumnSum;\\n}\\nfunction areAllDiagonalsEqual(grid, rowIndex, columnIndex) {\\n  const firstDiagonal =\\n    grid[rowIndex][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  const secondDiagonal =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex][columnIndex + 2];\\n  return firstDiagonal === secondDiagonal;\\n}\\n\\nvar numMagicSquaresInside = function (grid) {\\n  let count = 0;\\n  for (let rowIndex = 0; rowIndex < grid.length - 2; rowIndex++) {\\n    for (let columnIndex = 0; columnIndex < grid.length - 2; columnIndex++) {\\n      if (\\n        areAllRowsEqual(grid, rowIndex, columnIndex) &&\\n        areAllColumnsEqual(grid, rowIndex, columnIndex) &&\\n        areAllDiagonalsEqual(grid, rowIndex, columnIndex) &&\\n        areNumbersDistinct(grid, rowIndex, columnIndex)\\n      ) {\\n        count += 1;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401915,
                "title": "java-expensive-but-still-runs-8ms-to-15ms-detailed-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\t// hashset for checking if grid is filled with 1 to 9\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\t\\t// initialize hashset (fill it 1 to 9 values)\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\t// brute force loop, subtract 3 to avoid out ouf bounds\\n\\t\\t\\tfor (int i = 0 ; i <= grid.length - 3; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <= grid[0].length - 3; j++) {\\n\\n\\t\\t\\t\\t\\t// make new 3x3 grid\\n\\t\\t\\t\\t\\tint[][] newGrid = new int[3][3];\\n\\n\\t\\t\\t\\t\\t// fill the grid (see function below)\\n\\t\\t\\t\\t\\tfillGrid(grid, newGrid, i, j);\\n\\n\\t\\t\\t\\t\\t// check the requirements to confirm that it is a magic square (see function below)\\n\\t\\t\\t\\t\\tif (oneToNine(newGrid) && matchingSum (newGrid)) {\\n\\t\\t\\t\\t\\t\\tans += 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic void fillGrid(int[][] grid, int[][] newGrid, int i, int j) {\\n\\n\\t\\t\\t// save the original j value because we will use this for the new row such as (i + 1 row will turn back the incremented j to originalJ)\\n\\t\\t\\tint origJ = j;\\n\\n\\t\\t\\tfor (int r = 0; r < 3; r++) {\\n\\t\\t\\t\\tfor (int c = 0; c < 3; c++) {\\n\\t\\t\\t\\t\\tnewGrid[r][c] = grid[i][j]; // place the values from main grid to the new grid\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += 1;  // increment row of main grid\\n\\t\\t\\t\\tj = origJ; // turn j to original j to match the main grid\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean matchingSum(int[][] mat) {\\n\\n\\t\\t\\tint allSum = 0;\\n\\n\\t\\t\\t// get the general sum for row col and diagonal\\n\\t\\t\\tfor (int i = 0; i < 3; i++) {\\n\\t\\t\\t\\tallSum += mat[0][i];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// start at 1 because you already used 0 from general sum (allSum variable)\\n\\t\\t\\tfor (int i = 1; i < 3; i++) {\\n\\t\\t\\t\\t// make variable for row and col sum\\n\\t\\t\\t\\tint rowCurr = 0;\\n\\t\\t\\t\\tint colCurr = 0;\\n\\t\\t\\t\\tfor (int j = 0; j < 3; j++) {\\n\\t\\t\\t\\t\\trowCurr += mat[i][j]; // increment current row sum\\n\\t\\t\\t\\t\\tcolCurr += mat[j][i]; // increment current col sum\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// do the checking for row and col sum\\n\\t\\t\\t\\tif (allSum != rowCurr || allSum != colCurr) return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// diagonal\\n\\n\\t\\t\\tfor (int i = 2; i >= 0; i--) {\\n\\t\\t\\t\\tallSum -= mat[i][i]; // subtract the value of allSum from the opposite diagonal values\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if it is 0, if zero then it is matched, else false\\n\\t\\t\\tif (allSum != 0) return false;\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean oneToNine(int[][] mat) {\\n\\n\\t\\t\\t// variable to count that we have 1 to 9 values\\n\\t\\t\\tint nineCounts = 0;\\n\\n\\t\\t\\tfor (int[] ar : mat) {\\n\\t\\t\\t\\tfor (int n : ar) {\\n\\t\\t\\t\\t\\tif (set.contains(n)) { // check if set contains the value from the newly made grid\\n\\t\\t\\t\\t\\t\\tset.remove(n); // remove from set\\n\\t\\t\\t\\t\\t\\tnineCounts += 1; // increment nineCounts variable\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i); // fill up set once again from 1 to 9\\n\\t\\t\\t}\\n\\t\\t\\treturn nineCounts == 9; // check if nineCounts == 9\\n\\t\\t} \\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\t\\t// hashset for checking if grid is filled with 1 to 9\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\t\\t// initialize hashset (fill it 1 to 9 values)\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2378722,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359322,
                "title": "straightforward-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\t\\t\\tint n=grid.length,m=grid[0].length,count=0;\\n\\t\\t\\tfor(int i=0;i<n-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m-2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(sum(i,j,grid))\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tpublic boolean sum(int x,int y,int[][] grid)\\n\\t\\t{\\n\\t\\t\\tint sum=grid[x][y]+grid[x][y+1]+grid[x][y+2],sum1=0,sum2=0;\\n\\t\\t\\tint []count=new int[10];\\n\\t\\t\\tfor(int i=0;i<3;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum1=0;\\n\\t\\t\\t\\tsum2=0;   \\n\\t\\t\\t\\tfor(int j=0;j<3;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum1+=grid[x+i][y+j];\\n\\t\\t\\t\\t\\tsum2+=grid[x+j][y+i];\\n\\t\\t\\t\\t\\tif(grid[x+i][y+j]<1 ||grid[x+i][y+j]>9 ||count[grid[x+i][y+j]]!=0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tcount[grid[x+i][y+j]]=1;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(sum1!=sum || sum!=sum2 || sum1!=sum2)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tsum1=grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2];\\n\\t\\t\\tsum2=grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y];\\n\\t\\t\\tif(sum1!=sum2 || sum1!=sum)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\t\\t\\tint n=grid.length,m=grid[0].length,count=0;\\n\\t\\t\\tfor(int i=0;i<n-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m-2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(sum(i,j,grid))\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2319604,
                "title": "c-85-faster-easy-to-understand-using-unordered-set-added-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\t\\t// 3x3 cannot exist here as matrix itself is smaller\\n        if (row < 3 or col < 3) return 0;\\n        int magicSquares = 0;\\n        \\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n                unordered_set<int> s;\\n                // first check if all numbers are distinct\\n                s.insert(grid[i-1][j-1]);\\n                s.insert(grid[i-1][j]);\\n                s.insert(grid[i-1][j+1]);\\n                s.insert(grid[i][j-1]);\\n                s.insert(grid[i][j]);\\n                s.insert(grid[i][j+1]);\\n                s.insert(grid[i+1][j-1]);\\n                s.insert(grid[i+1][j]);\\n                s.insert(grid[i+1][j+1]);\\n                \\n\\t\\t\\t\\t// we need exactly 9 numbers\\n                if (s.size() != 9) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We only need numbers from 1-9\\n                bool wrongNum = false;\\n                for (auto val : s) {\\n                    if (val < 1 or val > 9) {\\n                        wrongNum = true;\\n                        break;\\n                    }\\n                }\\n                if (wrongNum) continue;\\n                s.clear();\\n                \\n\\t\\t\\t\\t// After adding all the sums here there should be only one sum in the set\\n\\t\\t\\t\\t// anywhere we see more we can just move to next iteration\\n                s.insert(grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]);\\n                s.insert(grid[i][j-1] + grid[i][j] + grid[i][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j-1] + grid[i+1][j-1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j] + grid[i][j] + grid[i+1][j]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j+1] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1]);\\n                if (s.size() == 1) magicSquares++;\\n            }\\n        }\\n        \\n        return magicSquares;\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\t\\t// 3x3 cannot exist here as matrix itself is smaller\\n        if (row < 3 or col < 3) return 0;\\n        int magicSquares = 0;\\n        \\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n                unordered_set<int> s;\\n                // first check if all numbers are distinct\\n                s.insert(grid[i-1][j-1]);\\n                s.insert(grid[i-1][j]);\\n                s.insert(grid[i-1][j+1]);\\n                s.insert(grid[i][j-1]);\\n                s.insert(grid[i][j]);\\n                s.insert(grid[i][j+1]);\\n                s.insert(grid[i+1][j-1]);\\n                s.insert(grid[i+1][j]);\\n                s.insert(grid[i+1][j+1]);\\n                \\n\\t\\t\\t\\t// we need exactly 9 numbers\\n                if (s.size() != 9) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We only need numbers from 1-9\\n                bool wrongNum = false;\\n                for (auto val : s) {\\n                    if (val < 1 or val > 9) {\\n                        wrongNum = true;\\n                        break;\\n                    }\\n                }\\n                if (wrongNum) continue;\\n                s.clear();\\n                \\n\\t\\t\\t\\t// After adding all the sums here there should be only one sum in the set\\n\\t\\t\\t\\t// anywhere we see more we can just move to next iteration\\n                s.insert(grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]);\\n                s.insert(grid[i][j-1] + grid[i][j] + grid[i][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j-1] + grid[i+1][j-1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j] + grid[i][j] + grid[i+1][j]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j+1] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1]);\\n                if (s.size() == 1) magicSquares++;\\n            }\\n        }\\n        \\n        return magicSquares;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290500,
                "title": "java-with-beautiful-solution-explained",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n       int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n       int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2276425,
                "title": "easy-c-solution-using-helper-function",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    bool check(vector<vector<int>>& grid,int r,int c){\\n        int row_sum=0;\\n        int sum = 0;\\n        for(int j=c;j<c+3;j++)\\n            sum += grid[r][j];\\n        // check row\\n        for(int i=r;i<r+3;i++){\\n            row_sum = 0;\\n            for(int j=c;j<c+3;j++){\\n                if(grid[i][j]>9 or grid[i][j] < 1) return false;\\n                row_sum += grid[i][j]; s.insert(grid[i][j]);\\n            }\\n            if(row_sum != sum) return false;\\n        }\\n        if(s.size() == 1) return false;\\n        s.clear();\\n        // check row\\n        for(int i=c;i<c+3;i++){\\n            row_sum = 0;\\n            for(int j=r;j<r+3;j++)\\n                row_sum += grid[j][i];\\n            if(row_sum != sum) return false;\\n        }\\n        //check for dia\\n        row_sum = 0;\\n        int i=r,j=c;\\n        while(i<r+3)\\n            row_sum += grid[i++][j++];\\n        if(row_sum != sum) return false;\\n        i = r,j = c+2;\\n        row_sum = 0;\\n        while(i<r+3)\\n            row_sum += grid[i++][j--];\\n        if(row_sum != sum) return false;\\n        return true;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(n<3 || m<3) return 0;\\n        int ans = 0;\\n        for(int i =0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++)\\n                if(check(grid,i,j)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    bool check(vector<vector<int>>& grid,int r,int c){\\n        int row_sum=0;\\n        int sum = 0;\\n        for(int j=c;j<c+3;j++)\\n            sum += grid[r][j];\\n        // check row\\n        for(int i=r;i<r+3;i++){\\n            row_sum = 0;\\n            for(int j=c;j<c+3;j++){\\n                if(grid[i][j]>9 or grid[i][j] < 1) return false;\\n                row_sum += grid[i][j]; s.insert(grid[i][j]);\\n            }\\n            if(row_sum != sum) return false;\\n        }\\n        if(s.size() == 1) return false;\\n        s.clear();\\n        // check row\\n        for(int i=c;i<c+3;i++){\\n            row_sum = 0;\\n            for(int j=r;j<r+3;j++)\\n                row_sum += grid[j][i];\\n            if(row_sum != sum) return false;\\n        }\\n        //check for dia\\n        row_sum = 0;\\n        int i=r,j=c;\\n        while(i<r+3)\\n            row_sum += grid[i++][j++];\\n        if(row_sum != sum) return false;\\n        i = r,j = c+2;\\n        row_sum = 0;\\n        while(i<r+3)\\n            row_sum += grid[i++][j--];\\n        if(row_sum != sum) return false;\\n        return true;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(n<3 || m<3) return 0;\\n        int ans = 0;\\n        for(int i =0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++)\\n                if(check(grid,i,j)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222691,
                "title": "c",
                "content": "```\\n// BF\\nbool check(int** grid, int row, int col, int* map) {\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            map[grid[row+i][col+j]]++;\\n            if (map[grid[row+i][col+j]] > 1 || grid[row+i][col+j] > 9 || grid[row+i][col+j] == 0) return false;\\n        }\\n    }\\n    int a = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n    int b = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n    int c = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n    if (a != 15 || b != 15 || c != 15) return false;\\n    \\n    int d = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n    int e = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n    int f = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n    if (d != 15 || e != 15 || f != 15) return false;\\n    \\n    int g = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n    int h = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n    if (g != 15 || h != 15) return false;\\n    return true;\\n}\\n\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize) {\\n    if (gridSize < 3 || gridColSize[0] < 3) return 0;\\n    int* map = (int*) calloc(16, sizeof(int));\\n    int cnt = 0;\\n    for (int i = 0; i + 2 < gridSize; i++) {\\n        for (int j = 0; j + 2 < gridColSize[0]; j++) {\\n            if (check(grid, i, j, map)) cnt++;\\n            memset(map, 0, 16 * sizeof(int));\\n        }\\n    }\\n    free(map);\\n    return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// BF\\nbool check(int** grid, int row, int col, int* map) {\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            map[grid[row+i][col+j]]++;\\n            if (map[grid[row+i][col+j]] > 1 || grid[row+i][col+j] > 9 || grid[row+i][col+j] == 0) return false;\\n        }\\n    }\\n    int a = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n    int b = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n    int c = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n    if (a != 15 || b != 15 || c != 15) return false;\\n    \\n    int d = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n    int e = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n    int f = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n    if (d != 15 || e != 15 || f != 15) return false;\\n    \\n    int g = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n    int h = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n    if (g != 15 || h != 15) return false;\\n    return true;\\n}\\n\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize) {\\n    if (gridSize < 3 || gridColSize[0] < 3) return 0;\\n    int* map = (int*) calloc(16, sizeof(int));\\n    int cnt = 0;\\n    for (int i = 0; i + 2 < gridSize; i++) {\\n        for (int j = 0; j + 2 < gridColSize[0]; j++) {\\n            if (check(grid, i, j, map)) cnt++;\\n            memset(map, 0, 16 * sizeof(int));\\n        }\\n    }\\n    free(map);\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055385,
                "title": "scala",
                "content": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val OneToNine = (1 to 9).to(BitSet)\\n  \\n  def numMagicSquaresInside(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n\\n    Iterator\\n      .range(0, m - 2)\\n      .flatMap(row => Iterator.tabulate(n - 2)(row -> _))\\n      .count { case (row, col) =>\\n        (for {\\n          i <- (row until row + 3).to(BitSet)\\n          j <- col until col + 3\\n        } yield {\\n          grid(i)(j)\\n        }) == OneToNine && {\\n          val sum = Iterator.range(0, 3).map(k => grid(row + k)(col + 2 - k)).sum\\n\\n          Iterator(Iterator.range(0, 3).map(k => grid(row + k)(col + k)).sum)\\n            .concat(Iterator.range(row, row + 3).map(i => Iterator.range(col, col + 3).map(grid(i)(_)).sum))\\n            .concat(Iterator.range(col, col + 3).map(j => Iterator.range(row, row + 3).map(grid(_)(j)).sum))\\n            .forall(_ == sum)\\n        }\\n      }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val OneToNine = (1 to 9).to(BitSet)\\n  \\n  def numMagicSquaresInside(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n\\n    Iterator\\n      .range(0, m - 2)\\n      .flatMap(row => Iterator.tabulate(n - 2)(row -> _))\\n      .count { case (row, col) =>\\n        (for {\\n          i <- (row until row + 3).to(BitSet)\\n          j <- col until col + 3\\n        } yield {\\n          grid(i)(j)\\n        }) == OneToNine && {\\n          val sum = Iterator.range(0, 3).map(k => grid(row + k)(col + 2 - k)).sum\\n\\n          Iterator(Iterator.range(0, 3).map(k => grid(row + k)(col + k)).sum)\\n            .concat(Iterator.range(row, row + 3).map(i => Iterator.range(col, col + 3).map(grid(i)(_)).sum))\\n            .concat(Iterator.range(col, col + 3).map(j => Iterator.range(row, row + 3).map(grid(_)(j)).sum))\\n            .forall(_ == sum)\\n        }\\n      }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2053996,
                "title": "python-brute-force-check-all-3x3-matrices",
                "content": "My slightly verbose python solution:\\n\\n```\\nclass Solution:\\n    # Helper function to check if 3x3 matrix is a magic square\\n    def check_magic(self, mat):\\n        nums = set(range(1, 10))\\n        numbers = []\\n        # Row check\\n        for row in mat:\\n            # Ensuring all numbers are in range 1-9\\n            numbers.extend(row)\\n            if sum(row) != 15:\\n                return False\\n        # Col check\\n        for row in zip(*mat):\\n            if sum(row) != 15:\\n                return False      \\n        # Diagonal checks\\n        if mat[0][0] + mat[1][1] + mat[2][2] != 15:\\n            return False  \\n        if mat[2][0] + mat[1][1] + mat[0][2] != 15:\\n            return False\\n        # Final check to ensure all numbers are 1-9\\n        return nums == set(numbers)\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        # Returns if row/col length is less than 3\\n        if m < 3 or n < 3:\\n            return 0\\n        \\n        # Constructing all 3x3 squares\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                mat = []\\n                for x in range(3):\\n                    row = []\\n                    for y in range(3):\\n                        row.append(grid[x+i][y+j])\\n                    mat.append(row)\\n                if self.check_magic(mat):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Helper function to check if 3x3 matrix is a magic square\\n    def check_magic(self, mat):\\n        nums = set(range(1, 10))\\n        numbers = []\\n        # Row check\\n        for row in mat:\\n            # Ensuring all numbers are in range 1-9\\n            numbers.extend(row)\\n            if sum(row) != 15:\\n                return False\\n        # Col check\\n        for row in zip(*mat):\\n            if sum(row) != 15:\\n                return False      \\n        # Diagonal checks\\n        if mat[0][0] + mat[1][1] + mat[2][2] != 15:\\n            return False  \\n        if mat[2][0] + mat[1][1] + mat[0][2] != 15:\\n            return False\\n        # Final check to ensure all numbers are 1-9\\n        return nums == set(numbers)\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        # Returns if row/col length is less than 3\\n        if m < 3 or n < 3:\\n            return 0\\n        \\n        # Constructing all 3x3 squares\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                mat = []\\n                for x in range(3):\\n                    row = []\\n                    for y in range(3):\\n                        row.append(grid[x+i][y+j])\\n                    mat.append(row)\\n                if self.check_magic(mat):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000921,
                "title": "javascript-memo-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function (grid) {\\n  if (grid.length < 3 || grid[0].length < 3) return 0\\n  const SUM_ROW = 15\\n  let rtn = 0\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length; j++) {\\n      if (isMagic(i, j)) rtn += 1\\n    }\\n  }\\n  return rtn\\n\\n  function isMagic(i, j) {\\n    let [row, column, diagnoal1, diagnoal2] = [isRow, isColumn, isDiagonal1, isDiagonal2].map(x => memo(x))\\n    return row(i, j) && row(i + 1, j) && row(i + 2, j)\\n      && column(i, j) && column(i, j + 1) && column(i, j + 2)\\n      && diagnoal1(i, j) && diagnoal2(i, j) && numCheck(i, j)\\n  }\\n\\n  function numCheck(i, j) {\\n    let arr = new Array(9).fill(0)\\n      ;[0, 1, 2].forEach(x => [0, 1, 2].forEach(y => arr[grid[i + x][j + y] - 1] = 1))\\n    return !arr.some(x => !x)\\n  }\\n\\n  function isRow(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i][j + next], 0)\\n  }\\n\\n  function isColumn(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j], 0)\\n  }\\n\\n\\n  function isDiagonal1(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j + next], 0)\\n  }\\n\\n\\n  function isDiagonal2(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + 2 - next][j + next], 0)\\n  }\\n\\n  function memo(fn) {\\n    let cache = grid.map(x => x.map(y => undefined))\\n    return (i, j) => {\\n      if (cache[i][j] === undefined) cache[i][j] = fn(i, j)\\n      return cache[i][j]\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function (grid) {\\n  if (grid.length < 3 || grid[0].length < 3) return 0\\n  const SUM_ROW = 15\\n  let rtn = 0\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length; j++) {\\n      if (isMagic(i, j)) rtn += 1\\n    }\\n  }\\n  return rtn\\n\\n  function isMagic(i, j) {\\n    let [row, column, diagnoal1, diagnoal2] = [isRow, isColumn, isDiagonal1, isDiagonal2].map(x => memo(x))\\n    return row(i, j) && row(i + 1, j) && row(i + 2, j)\\n      && column(i, j) && column(i, j + 1) && column(i, j + 2)\\n      && diagnoal1(i, j) && diagnoal2(i, j) && numCheck(i, j)\\n  }\\n\\n  function numCheck(i, j) {\\n    let arr = new Array(9).fill(0)\\n      ;[0, 1, 2].forEach(x => [0, 1, 2].forEach(y => arr[grid[i + x][j + y] - 1] = 1))\\n    return !arr.some(x => !x)\\n  }\\n\\n  function isRow(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i][j + next], 0)\\n  }\\n\\n  function isColumn(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j], 0)\\n  }\\n\\n\\n  function isDiagonal1(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j + next], 0)\\n  }\\n\\n\\n  function isDiagonal2(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + 2 - next][j + next], 0)\\n  }\\n\\n  function memo(fn) {\\n    let cache = grid.map(x => x.map(y => undefined))\\n    return (i, j) => {\\n      if (cache[i][j] === undefined) cache[i][j] = fn(i, j)\\n      return cache[i][j]\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988475,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int res = 0;\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j ++){\\n                if(checkMagic(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean checkMagic(int[][] grid, int top, int left){\\n        int sum = 0;\\n        for(int i = 0; i < 3; i ++){\\n            sum += grid[top + i][left+i];\\n        }\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i = 0; i < 3; i++){\\n            int dig = 0, row = 0, col = 0;\\n            for(int j = 0; j < 3; j++){\\n                if(grid[top+i][left+j] > 9 || grid[top+i][left+j] < 1) return false;       \\n                set.add(grid[top+i][left+j]);\\n                dig += grid[top + j][left + 2 - j];\\n                row += grid[top + i][left + j];\\n                col += grid[top + j][left + i];\\n            }\\n            if(dig != sum || row != sum || col != sum) return false;\\n        }\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int res = 0;\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j ++){\\n                if(checkMagic(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean checkMagic(int[][] grid, int top, int left){\\n        int sum = 0;\\n        for(int i = 0; i < 3; i ++){\\n            sum += grid[top + i][left+i];\\n        }\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i = 0; i < 3; i++){\\n            int dig = 0, row = 0, col = 0;\\n            for(int j = 0; j < 3; j++){\\n                if(grid[top+i][left+j] > 9 || grid[top+i][left+j] < 1) return false;       \\n                set.add(grid[top+i][left+j]);\\n                dig += grid[top + j][left + 2 - j];\\n                row += grid[top + i][left + j];\\n                col += grid[top + j][left + i];\\n            }\\n            if(dig != sum || row != sum || col != sum) return false;\\n        }\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955008,
                "title": "c-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int row, col;\\n    bool isMagicSquare(vector<vector<int>>& grid, int r, int c) {\\n        if (r+2>=row || c+2>=col) return false;\\n        \\n        // check if there are unique number from 1 to 9\\n        vector<int> n(10, 0);\\n        for (int i=0; i<3; i++) {\\n            for (int j=0; j<3; j++) {\\n                int idx = grid[r+i][c+j];\\n                if (idx>9 || idx<1 || n[idx]==1) return false;\\n                n[idx]++;\\n            }\\n        }\\n        \\n        // check sum on each row, column and diagnal\\n        vector<int> sumByRow(3, 0), sumByCol(3, 0), sumDiagnal(2, 0);\\n        for (int i=0; i<3; i++) {\\n            sumByRow[i] = accumulate(grid[r+i].begin()+c, grid[r+i].begin()+c+3, 0);\\n            for (int j=0; j<3; j++) {\\n                sumByCol[i] += grid[r+j][c+i];\\n                if (i==j) {\\n                    sumDiagnal[0] += grid[r+i][c+j];\\n                }\\n                if (i+j==2) {\\n                    sumDiagnal[1] += grid[r+i][c+j];\\n                }\\n            }\\n        }\\n        \\n        // since magic square contains unique numbers from 1 to 9, sum for each row, column or diagnose should be 15\\n        for (int i=0; i<3; i++) {\\n            if (sumByRow[i]!=15 || sumByCol[i]!=15) return false;\\n        }\\n        if (sumDiagnal[0]!=15 || sumDiagnal[1]!=15) return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        row = grid.size();\\n        col = grid[0].size();\\n        int cnt = 0;\\n        if (row<3 || col<3) return 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int row, col;\\n    bool isMagicSquare(vector<vector<int>>& grid, int r, int c) {\\n        if (r+2>=row || c+2>=col) return false;\\n        \\n        // check if there are unique number from 1 to 9\\n        vector<int> n(10, 0);\\n        for (int i=0; i<3; i++) {\\n            for (int j=0; j<3; j++) {\\n                int idx = grid[r+i][c+j];\\n                if (idx>9 || idx<1 || n[idx]==1) return false;\\n                n[idx]++;\\n            }\\n        }\\n        \\n        // check sum on each row, column and diagnal\\n        vector<int> sumByRow(3, 0), sumByCol(3, 0), sumDiagnal(2, 0);\\n        for (int i=0; i<3; i++) {\\n            sumByRow[i] = accumulate(grid[r+i].begin()+c, grid[r+i].begin()+c+3, 0);\\n            for (int j=0; j<3; j++) {\\n                sumByCol[i] += grid[r+j][c+i];\\n                if (i==j) {\\n                    sumDiagnal[0] += grid[r+i][c+j];\\n                }\\n                if (i+j==2) {\\n                    sumDiagnal[1] += grid[r+i][c+j];\\n                }\\n            }\\n        }\\n        \\n        // since magic square contains unique numbers from 1 to 9, sum for each row, column or diagnose should be 15\\n        for (int i=0; i<3; i++) {\\n            if (sumByRow[i]!=15 || sumByCol[i]!=15) return false;\\n        }\\n        if (sumDiagnal[0]!=15 || sumDiagnal[1]!=15) return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        row = grid.size();\\n        col = grid[0].size();\\n        int cnt = 0;\\n        if (row<3 || col<3) return 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931692,
                "title": "100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        \\n        int n=g.size();\\n        int m=g[0].size();\\n        \\n        if(n<3 || m<3)\\n            return 0;\\n        \\n        int count=0;\\n        int r1,r2,r3,c1,c2,c3,d1,d2;\\n        int r,c,d;\\n        for(int i=0;i<n;i++){\\n            if(i+2>=n)\\n                break;\\n            for(int j=0;j<m;j++){\\n              if(j+2>=m)\\n                  break;\\n            \\n                // each row sum of 3*3 matrix whose top left cell=(i,j)\\n                 r1=g[i][j]+g[i][j+1]+g[i][j+2];\\n                 r2=g[i+1][j]+g[i+1][j+1]+g[i+1][j+2];\\n                 r3=g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n        \\n                 // each column sum of 3*3 matrix whose top left cell=(i,j)\\n\\n                c1=g[i][j]+g[i+1][j]+g[i+2][j];\\n                c2=g[i][j+1]+g[i+1][j+1]+g[i+2][j+1];\\n                c3=g[i][j+2]+g[i+1][j+2]+g[i+2][j+2];\\n               \\n                //diagonal sum\\n                d1=g[i][j]+g[i+1][j+1]+g[i+2][j+2];\\n                d2=g[i][j+2]+g[i+1][j+1]+g[i+2][j];\\n                \\n               //checking sum equality\\n                \\n           bool f=false;     \\nif((r1==r2)&&(r1==r3)&&(r1==c1)&&(r1==c2)&&(r1==c3)&&(r1==d1)&&(r1==d2))\\n                  f=true;\\n                else\\n                    continue;\\n                \\n      // checking duplicacy of no\\'s and range of no\\'s [1,9]      \\n                \\n                set<int>st;\\n                \\n                for(int k1=i;k1<=i+2;k1++){\\n                    for(int k2=j;k2<=j+2;k2++){\\n                        if(g[k1][k2]>9 || g[k1][k2]==0){\\n                            f=false;\\n                            break;\\n                        }\\n                        st.insert(g[k1][k2]);\\n                    }\\n                    if(f==false)\\n                        break;\\n                }\\n                \\n                if(f && (st.size()==9))\\n                    count++;\\n\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        \\n        int n=g.size();\\n        int m=g[0].size();\\n        \\n        if(n<3 || m<3)\\n            return 0;\\n        \\n        int count=0;\\n        int r1,r2,r3,c1,c2,c3,d1,d2;\\n        int r,c,d;\\n        for(int i=0;i<n;i++){\\n            if(i+2>=n)\\n                break;\\n            for(int j=0;j<m;j++){\\n              if(j+2>=m)\\n                  break;\\n            \\n                // each row sum of 3*3 matrix whose top left cell=(i,j)\\n                 r1=g[i][j]+g[i][j+1]+g[i][j+2];\\n                 r2=g[i+1][j]+g[i+1][j+1]+g[i+1][j+2];\\n                 r3=g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n        \\n                 // each column sum of 3*3 matrix whose top left cell=(i,j)\\n\\n                c1=g[i][j]+g[i+1][j]+g[i+2][j];\\n                c2=g[i][j+1]+g[i+1][j+1]+g[i+2][j+1];\\n                c3=g[i][j+2]+g[i+1][j+2]+g[i+2][j+2];\\n               \\n                //diagonal sum\\n                d1=g[i][j]+g[i+1][j+1]+g[i+2][j+2];\\n                d2=g[i][j+2]+g[i+1][j+1]+g[i+2][j];\\n                \\n               //checking sum equality\\n                \\n           bool f=false;     \\nif((r1==r2)&&(r1==r3)&&(r1==c1)&&(r1==c2)&&(r1==c3)&&(r1==d1)&&(r1==d2))\\n                  f=true;\\n                else\\n                    continue;\\n                \\n      // checking duplicacy of no\\'s and range of no\\'s [1,9]      \\n                \\n                set<int>st;\\n                \\n                for(int k1=i;k1<=i+2;k1++){\\n                    for(int k2=j;k2<=j+2;k2++){\\n                        if(g[k1][k2]>9 || g[k1][k2]==0){\\n                            f=false;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1910414,
                "title": "java",
                "content": "```\\nclass Solution {\\n    boolean isMagic(int[][] grid, int row, int col) {\\n        if(row + 2 >= grid.length || col + 2 >= grid[0].length)\\n            return false;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                boolean add = set.add(grid[i][j]);\\n                if(!add || grid[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        int dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + i - row];\\n        }\\n        if (dSum != 15)\\n            return false;\\n        dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + row + 2 - i];\\n        }\\n        if (dSum != 15)\\n            return false;\\n\\n        for (int i = row; i < row + 3; i++) {\\n            int sum = grid[i][col] + grid[i][col + 1] + grid[i][col + 2];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        for (int i = col; i < col + 3; i++) {\\n            int sum = grid[row][i] + grid[row + 1][i] + grid[row + 2][i];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSqaures = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isMagic(grid, i, j))\\n                    magicSqaures++;\\n            }\\n        }\\n        return magicSqaures;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean isMagic(int[][] grid, int row, int col) {\\n        if(row + 2 >= grid.length || col + 2 >= grid[0].length)\\n            return false;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                boolean add = set.add(grid[i][j]);\\n                if(!add || grid[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        int dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + i - row];\\n        }\\n        if (dSum != 15)\\n            return false;\\n        dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + row + 2 - i];\\n        }\\n        if (dSum != 15)\\n            return false;\\n\\n        for (int i = row; i < row + 3; i++) {\\n            int sum = grid[i][col] + grid[i][col + 1] + grid[i][col + 2];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        for (int i = col; i < col + 3; i++) {\\n            int sum = grid[row][i] + grid[row + 1][i] + grid[row + 2][i];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSqaures = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isMagic(grid, i, j))\\n                    magicSqaures++;\\n            }\\n        }\\n        return magicSqaures;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896970,
                "title": "c-solution-easy-to-understand",
                "content": "```C\\nbool checkarr(int **grid, int i, int j)//helper function to check conditions set by problem statement\\n{\\n    int H[16]={-1};//using hashmap, problem constraint says 0 <= grid[i][j] <= 15\\n    for(int k = 0; k<9; k++)//loop to find any duplicate, or any zero element or element >9\\n    {\\n        if(H[grid[i+k/3][j+k%3]]==grid[i+k/3][j+k%3] || grid[i+k/3][j+k%3]==0 || grid[i+k/3][j+k%3]>9)\\n        {\\n            return false;\\n        }\\n        H[grid[i+k/3][j+k%3]] = grid[i+k/3][j+k%3];\\n    }\\n    \\n    int arr[8] = {0};//array to store all the column, row and diagonal sums\\n    for(int k = 0; k <3;k++)\\n    {\\n        arr[6] += grid[i+k][j+k]; //first diagonal sum\\n        arr[7] +=grid[i+k][j+2-k];//second diagonal sum\\n        arr[k]=grid[i+k][j]+grid[i+k][j+1]+grid[i+k][j+2];//row sum\\n        arr[3+k] = grid[i][j+k]+grid[i+1][j+k]+grid[i+2][j+k];//column sum\\n    }\\n    int check = arr[0];\\n    for(int x=0; x<8; x++)// loop to check if all column, row, diagonal sums are same\\n    {\\n        if(arr[x]!=check){return false;}\\n    }\\n    return true;\\n}\\n        \\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    if(gridSize < 3 || *gridColSize < 3){return 0;}\\n    int m = gridSize-2; \\n    int n = *gridColSize-2; // each(m,n) conveys starting element of single 3x3 matrix in the given grid\\n    int count = 0;\\n    for(int i=0; i <m; i++)\\n    {\\n        for(int j = 0; j< n;j++)//loop to pass each 3x3 arr from grid to helper function\\n        {\\n            if(checkarr(grid,i,j)){count++;}//using helper function to check if the 3x3 array passed to it meets all the criteria of the problem.\\n        }\\n    }\\n    return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nbool checkarr(int **grid, int i, int j)//helper function to check conditions set by problem statement\\n{\\n    int H[16]={-1};//using hashmap, problem constraint says 0 <= grid[i][j] <= 15\\n    for(int k = 0; k<9; k++)//loop to find any duplicate, or any zero element or element >9\\n    {\\n        if(H[grid[i+k/3][j+k%3]]==grid[i+k/3][j+k%3] || grid[i+k/3][j+k%3]==0 || grid[i+k/3][j+k%3]>9)\\n        {\\n            return false;\\n        }\\n        H[grid[i+k/3][j+k%3]] = grid[i+k/3][j+k%3];\\n    }\\n    \\n    int arr[8] = {0};//array to store all the column, row and diagonal sums\\n    for(int k = 0; k <3;k++)\\n    {\\n        arr[6] += grid[i+k][j+k]; //first diagonal sum\\n        arr[7] +=grid[i+k][j+2-k];//second diagonal sum\\n        arr[k]=grid[i+k][j]+grid[i+k][j+1]+grid[i+k][j+2];//row sum\\n        arr[3+k] = grid[i][j+k]+grid[i+1][j+k]+grid[i+2][j+k];//column sum\\n    }\\n    int check = arr[0];\\n    for(int x=0; x<8; x++)// loop to check if all column, row, diagonal sums are same\\n    {\\n        if(arr[x]!=check){return false;}\\n    }\\n    return true;\\n}\\n        \\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    if(gridSize < 3 || *gridColSize < 3){return 0;}\\n    int m = gridSize-2; \\n    int n = *gridColSize-2; // each(m,n) conveys starting element of single 3x3 matrix in the given grid\\n    int count = 0;\\n    for(int i=0; i <m; i++)\\n    {\\n        for(int j = 0; j< n;j++)//loop to pass each 3x3 arr from grid to helper function\\n        {\\n            if(checkarr(grid,i,j)){count++;}//using helper function to check if the 3x3 array passed to it meets all the criteria of the problem.\\n        }\\n    }\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1856843,
                "title": "java-solution-fast-with-math",
                "content": "```\\n//The trick is that in every sub-grid, the middlemost element should be \\'5\\'.\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\n//The trick is that in every sub-grid, the middlemost element should be \\'5\\'.\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805859,
                "title": "magic-squares-in-layman-terms",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        //matrix must > 3x3\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(isMagic(grid, i,j))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    boolean isMagic(int [][] grid, int x, int y){\\n        //no overflow \\n        if(x+2 > grid.length || y+2 > grid[0].length){\\n            return false;\\n        }\\n        \\n        //check if middle number is 5 or not \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                if(grid[x + 1][y + 1] != 5){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        //no number must repeat and each grid number must be <= 9 and > 0\\n        HashSet <Integer> set = new HashSet<>();\\n        for(int i = x; i <= x + 2; i++){\\n            for(int j = y; j <= y + 2;j++){\\n                if(set.contains(grid[i][j]) || grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n                \\n        //check if sum of diagonals are equal,rows and columns are equal \\n        int row[] = new int[3];\\n        int col[] = new int[3];\\n        int diagonal[] = new int[2];\\n        \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                row[i-x] += grid[i][j];\\n                col[j-y] += grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n            }\\n        }\\n        \\n        \\n        //checking if all rows cum is equal \\n        int row_val = row[0];\\n        for(int ele : row){\\n            if(ele != row_val) return false;\\n        }\\n        \\n        //checking if all colums sum is equal \\n        int col_val = row[0];\\n        for(int ele : col){\\n            if(ele != col_val) return false;\\n        }\\n        \\n        \\n        // checking if all diagonals sum is equal \\n        \\n        int dig = row[0];\\n        for(int ele : diagonal){\\n            if(ele != dig) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        //matrix must > 3x3\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(isMagic(grid, i,j))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    boolean isMagic(int [][] grid, int x, int y){\\n        //no overflow \\n        if(x+2 > grid.length || y+2 > grid[0].length){\\n            return false;\\n        }\\n        \\n        //check if middle number is 5 or not \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                if(grid[x + 1][y + 1] != 5){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        //no number must repeat and each grid number must be <= 9 and > 0\\n        HashSet <Integer> set = new HashSet<>();\\n        for(int i = x; i <= x + 2; i++){\\n            for(int j = y; j <= y + 2;j++){\\n                if(set.contains(grid[i][j]) || grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n                \\n        //check if sum of diagonals are equal,rows and columns are equal \\n        int row[] = new int[3];\\n        int col[] = new int[3];\\n        int diagonal[] = new int[2];\\n        \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                row[i-x] += grid[i][j];\\n                col[j-y] += grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n            }\\n        }\\n        \\n        \\n        //checking if all rows cum is equal \\n        int row_val = row[0];\\n        for(int ele : row){\\n            if(ele != row_val) return false;\\n        }\\n        \\n        //checking if all colums sum is equal \\n        int col_val = row[0];\\n        for(int ele : col){\\n            if(ele != col_val) return false;\\n        }\\n        \\n        \\n        // checking if all diagonals sum is equal \\n        \\n        int dig = row[0];\\n        for(int ele : diagonal){\\n            if(ele != dig) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757619,
                "title": "c-brute-force-time-o-w-h-space-o-1",
                "content": "Checks all magic squares in the grid. The check is constant in time complexity since the cost for verifying a 3 x 3 magic square does not increase as the dimension of the grid increases.\\n```\\nint32_t numMagicSquaresInside(\\n\\tvector<vector<int32_t>>& grid)\\n{\\n\\tint32_t answer = 0;\\n\\tif (grid.size() && grid[0].size())\\n\\t{\\n\\t\\tuint32_t rows = grid.size();\\n\\t\\tuint32_t columns = grid[0].size();\\n\\t\\tuint8_t unique[9];\\n\\t\\tif (rows >= 3 && columns >= 3)\\n\\t\\t{\\n\\t\\t\\tfor (uint32_t x = 0; x < columns - 2; x++)\\n\\t\\t\\tfor (uint32_t y = 0; y < rows - 2; y++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemset(unique, 0, sizeof(unique));\\n\\t\\t\\t\\tuint8_t g00 = grid[y+0][x+0];\\n\\t\\t\\t\\tuint8_t g01 = grid[y+0][x+1];\\n\\t\\t\\t\\tuint8_t g02 = grid[y+0][x+2];\\n\\t\\t\\t\\tuint8_t g10 = grid[y+1][x+0];\\n\\t\\t\\t\\tuint8_t g11 = grid[y+1][x+1];\\n\\t\\t\\t\\tuint8_t g12 = grid[y+1][x+2];\\n\\t\\t\\t\\tuint8_t g20 = grid[y+2][x+0];\\n\\t\\t\\t\\tuint8_t g21 = grid[y+2][x+1];\\n\\t\\t\\t\\tuint8_t g22 = grid[y+2][x+2];\\n\\t\\t\\t\\tif (g00 >= 1 && g01 >= 1 && g02 >= 1 &&\\n\\t\\t\\t\\t\\tg10 >= 1 && g11 >= 1 && g12 >= 1 &&\\n\\t\\t\\t\\t\\tg20 >= 1 && g21 >= 1 && g22 >= 1 &&\\n\\t\\t\\t\\t\\tg00 <= 9 && g01 <= 9 && g02 <= 9 &&\\n\\t\\t\\t\\t\\tg10 <= 9 && g11 <= 9 && g12 <= 9 &&\\n\\t\\t\\t\\t\\tg20 <= 9 && g21 <= 9 && g22 <= 9)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuint8_t r1 = g00 + g01 + g02;\\n\\t\\t\\t\\t\\tuint8_t r2 = g10 + g11 + g12;\\n\\t\\t\\t\\t\\tuint8_t r3 = g20 + g21 + g22;\\n\\t\\t\\t\\t\\tuint8_t c1 = g00 + g10 + g20;\\n\\t\\t\\t\\t\\tuint8_t c2 = g01 + g11 + g21;\\n\\t\\t\\t\\t\\tuint8_t c3 = g02 + g12 + g22;\\n\\t\\t\\t\\t\\tuint8_t dl = g00 + g11 + g22;\\n\\t\\t\\t\\t\\tuint8_t dr = g20 + g11 + g02;\\n\\t\\t\\t\\t\\tunique[g00 - 1]++;\\n\\t\\t\\t\\t\\tunique[g01 - 1]++;\\n\\t\\t\\t\\t\\tunique[g02 - 1]++;\\n\\t\\t\\t\\t\\tunique[g10 - 1]++;\\n\\t\\t\\t\\t\\tunique[g11 - 1]++;\\n\\t\\t\\t\\t\\tunique[g12 - 1]++;\\n\\t\\t\\t\\t\\tunique[g20 - 1]++;\\n\\t\\t\\t\\t\\tunique[g21 - 1]++;\\n\\t\\t\\t\\t\\tunique[g22 - 1]++;\\n\\t\\t\\t\\t\\tanswer +=\\n\\t\\t\\t\\t\\t\\tunique[ 0] <= 1 && unique[ 1] <= 1 && unique[ 2] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 3] <= 1 && unique[ 4] <= 1 && unique[ 5] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 6] <= 1 && unique[ 7] <= 1 && unique[ 8] <= 1 &&\\n\\t\\t\\t\\t\\t\\tc1 == c2 && c2 == c3 && c3 == r1 &&\\n\\t\\t\\t\\t\\t\\tr1 == r2 && r2 == r3 && r3 == dl &&\\n\\t\\t\\t\\t\\t\\tdl == dr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint32_t numMagicSquaresInside(\\n\\tvector<vector<int32_t>>& grid)\\n{\\n\\tint32_t answer = 0;\\n\\tif (grid.size() && grid[0].size())\\n\\t{\\n\\t\\tuint32_t rows = grid.size();\\n\\t\\tuint32_t columns = grid[0].size();\\n\\t\\tuint8_t unique[9];\\n\\t\\tif (rows >= 3 && columns >= 3)\\n\\t\\t{\\n\\t\\t\\tfor (uint32_t x = 0; x < columns - 2; x++)\\n\\t\\t\\tfor (uint32_t y = 0; y < rows - 2; y++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemset(unique, 0, sizeof(unique));\\n\\t\\t\\t\\tuint8_t g00 = grid[y+0][x+0];\\n\\t\\t\\t\\tuint8_t g01 = grid[y+0][x+1];\\n\\t\\t\\t\\tuint8_t g02 = grid[y+0][x+2];\\n\\t\\t\\t\\tuint8_t g10 = grid[y+1][x+0];\\n\\t\\t\\t\\tuint8_t g11 = grid[y+1][x+1];\\n\\t\\t\\t\\tuint8_t g12 = grid[y+1][x+2];\\n\\t\\t\\t\\tuint8_t g20 = grid[y+2][x+0];\\n\\t\\t\\t\\tuint8_t g21 = grid[y+2][x+1];\\n\\t\\t\\t\\tuint8_t g22 = grid[y+2][x+2];\\n\\t\\t\\t\\tif (g00 >= 1 && g01 >= 1 && g02 >= 1 &&\\n\\t\\t\\t\\t\\tg10 >= 1 && g11 >= 1 && g12 >= 1 &&\\n\\t\\t\\t\\t\\tg20 >= 1 && g21 >= 1 && g22 >= 1 &&\\n\\t\\t\\t\\t\\tg00 <= 9 && g01 <= 9 && g02 <= 9 &&\\n\\t\\t\\t\\t\\tg10 <= 9 && g11 <= 9 && g12 <= 9 &&\\n\\t\\t\\t\\t\\tg20 <= 9 && g21 <= 9 && g22 <= 9)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuint8_t r1 = g00 + g01 + g02;\\n\\t\\t\\t\\t\\tuint8_t r2 = g10 + g11 + g12;\\n\\t\\t\\t\\t\\tuint8_t r3 = g20 + g21 + g22;\\n\\t\\t\\t\\t\\tuint8_t c1 = g00 + g10 + g20;\\n\\t\\t\\t\\t\\tuint8_t c2 = g01 + g11 + g21;\\n\\t\\t\\t\\t\\tuint8_t c3 = g02 + g12 + g22;\\n\\t\\t\\t\\t\\tuint8_t dl = g00 + g11 + g22;\\n\\t\\t\\t\\t\\tuint8_t dr = g20 + g11 + g02;\\n\\t\\t\\t\\t\\tunique[g00 - 1]++;\\n\\t\\t\\t\\t\\tunique[g01 - 1]++;\\n\\t\\t\\t\\t\\tunique[g02 - 1]++;\\n\\t\\t\\t\\t\\tunique[g10 - 1]++;\\n\\t\\t\\t\\t\\tunique[g11 - 1]++;\\n\\t\\t\\t\\t\\tunique[g12 - 1]++;\\n\\t\\t\\t\\t\\tunique[g20 - 1]++;\\n\\t\\t\\t\\t\\tunique[g21 - 1]++;\\n\\t\\t\\t\\t\\tunique[g22 - 1]++;\\n\\t\\t\\t\\t\\tanswer +=\\n\\t\\t\\t\\t\\t\\tunique[ 0] <= 1 && unique[ 1] <= 1 && unique[ 2] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 3] <= 1 && unique[ 4] <= 1 && unique[ 5] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 6] <= 1 && unique[ 7] <= 1 && unique[ 8] <= 1 &&\\n\\t\\t\\t\\t\\t\\tc1 == c2 && c2 == c3 && c3 == r1 &&\\n\\t\\t\\t\\t\\t\\tr1 == r2 && r2 == r3 && r3 == dl &&\\n\\t\\t\\t\\t\\t\\tdl == dr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729470,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length - 2; i++)\\n            for (int j = 0; j < grid[0].length - 2; j++)\\n                 if (this.isMagicBox(grid, i, j)) \\n                     result++;\\n         return result;\\n    }\\n\\n    boolean isMagicBox(int[][] grid, int x, int y) {\\n        if (grid[x+1][y+1] != 5)\\n            return false;\\n        boolean flag = false;\\n        int rowSum = 0;\\n        for (int r = x; r < x + 3; r++) {\\n            rowSum = 0;\\n            for (int c = y; c < y + 3; c++) {\\n                rowSum += grid[r][c];\\n                flag = !flag;\\n                if (r == x+1 && c == y+1)\\n                    continue;\\n                if (this.isEven(grid[r][c]) != flag)\\n                    return false;\\n            }\\n            if (rowSum != 15)\\n                return false;\\n        }\\n        return grid[x][y] + grid[x+1][y] + grid[x+2][y] == 15;\\n    }\\n    \\n    boolean isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length - 2; i++)\\n            for (int j = 0; j < grid[0].length - 2; j++)\\n                 if (this.isMagicBox(grid, i, j)) \\n                     result++;\\n         return result;\\n    }\\n\\n    boolean isMagicBox(int[][] grid, int x, int y) {\\n        if (grid[x+1][y+1] != 5)\\n            return false;\\n        boolean flag = false;\\n        int rowSum = 0;\\n        for (int r = x; r < x + 3; r++) {\\n            rowSum = 0;\\n            for (int c = y; c < y + 3; c++) {\\n                rowSum += grid[r][c];\\n                flag = !flag;\\n                if (r == x+1 && c == y+1)\\n                    continue;\\n                if (this.isEven(grid[r][c]) != flag)\\n                    return false;\\n            }\\n            if (rowSum != 15)\\n                return false;\\n        }\\n        return grid[x][y] + grid[x+1][y] + grid[x+2][y] == 15;\\n    }\\n    \\n    boolean isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724617,
                "title": "magic-square-java-easy-to-understand-solution",
                "content": "//The only thing that you actually need to know is that a 3x3 magic square has 5 at it\\'s center.\\n\\n```\\nclass Solution {\\n  public int numMagicSquaresInside(int[][] grid) {\\n\\n\\n    int m = grid.length; //r\\n    int n = grid[0].length; //c\\n\\n    if (m < 3 || n < 3)\\n      return 0;\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < m - 2; i++)\\n    {\\n      for (int j = 0; j < n - 2; j++)\\n      {\\n        if (grid[i + 1][j + 1] == 5)\\n          if (isMagicGrid(i, j, grid) == true)\\n            count++;\\n      }\\n\\n    }\\n\\n    return count;\\n  }\\n  public static boolean isMagicGrid(int x, int y, int [][]grid) {\\n\\n\\n    int a = grid[x + 0][y + 0];\\n    int b = grid[x + 0][y + 1];\\n    int c = grid[x + 0][y + 2];\\n\\n    int d = grid[x + 1][y + 0];\\n    int e = grid[x + 1][y + 1];\\n    int f = grid[x + 1][y + 2];\\n\\n    int g = grid[x + 2][y + 0];\\n    int h = grid[x + 2][y + 1];\\n    int i = grid[x + 2][y + 2];\\n\\n\\n    HashSet<Integer> hmap = new HashSet<>();\\n\\n    int arr[] = {a, b, c, d, e, f, g, h, i};\\n    for (int p = 0; p < 9 ; p++)\\n    {\\n      if (arr[p] >= 1 && arr[p]  <= 9)\\n        hmap.add(arr[p]);\\n\\n    }\\n\\n    Boolean first = false;\\n    if (hmap.size() == 9)\\n      first = true;\\n\\n\\n\\n\\n\\n    Boolean second = false;\\n\\n\\n\\n\\n\\n\\n\\n\\n    if (a + b + c == 15 && d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 &&   c + f + i == 15 && a + e + i == 15 && c + e + g == 15  )\\n      second = true;\\n\\n\\n    return (first == true && second == true)  ;\\n\\n  }\\n\\n}\\n// please upvote so that others can see it too",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  public int numMagicSquaresInside(int[][] grid) {\\n\\n\\n    int m = grid.length; //r\\n    int n = grid[0].length; //c\\n\\n    if (m < 3 || n < 3)\\n      return 0;\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < m - 2; i++)\\n    {\\n      for (int j = 0; j < n - 2; j++)\\n      {\\n        if (grid[i + 1][j + 1] == 5)\\n          if (isMagicGrid(i, j, grid) == true)\\n            count++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1690285,
                "title": "edge-case-missed-by-leetcode",
                "content": "my code is accepted,but showing wrong ans for [[1,2,7,6],[4,9,5,1],[5,4,3,8]]\\n\\n ```\\n public static int numMagicSquaresInside(int[][] grid) {\\n  \\t  \\t  // Write your code here\\n  \\t  \\t   int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i+2<=grid.length-1 && j+2<=grid[0].length-1){\\n            int []record=new int[10];\\n            int ans=0;\\n            for(int a=i;a<i+3;a++){\\n                for(int b=j;b<j+3;b++){\\n                    if(grid[a][b]<1 || grid[a][b]>9 || record[grid[a][b]]>0){\\n                        ans=-1;\\n                    }\\n                    else{\\n                        record[grid[a][b]]=1;\\n                    }\\n                }\\n            }\\n            \\n            if(grid[i+1][j+1]!=5){\\n                if(j+2<grid.length-1){\\n                    j++;\\n                    continue;\\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                     continue;\\n                    \\n                }\\n               \\n            }\\n            else{\\n        \\n            int row1=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n            int row2=grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n            int row3=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n            int col1=grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n            int col2=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];\\n            int col3=grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n            int dia1=grid[i][j]+5+grid[i+2][j+2];\\n            int dia2=grid[i][j+2]+5+grid[i+2][j];\\n            if(row2==row1 && col1 == row1 && col2 == row1 && dia1==row1 && dia1==dia2 && ans==0){\\n                \\n                count++;\\n            }\\n             if(j+2<grid.length-1){\\n                    j++;\\n                   \\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                 }\\n        }\\n            \\n    }\\n     return count;   \\n  \\t  }\\n```\\n\\ni cant figure out where i am wrong . pls help",
                "solutionTags": [],
                "code": "```\\n public static int numMagicSquaresInside(int[][] grid) {\\n  \\t  \\t  // Write your code here\\n  \\t  \\t   int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i+2<=grid.length-1 && j+2<=grid[0].length-1){\\n            int []record=new int[10];\\n            int ans=0;\\n            for(int a=i;a<i+3;a++){\\n                for(int b=j;b<j+3;b++){\\n                    if(grid[a][b]<1 || grid[a][b]>9 || record[grid[a][b]]>0){\\n                        ans=-1;\\n                    }\\n                    else{\\n                        record[grid[a][b]]=1;\\n                    }\\n                }\\n            }\\n            \\n            if(grid[i+1][j+1]!=5){\\n                if(j+2<grid.length-1){\\n                    j++;\\n                    continue;\\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                     continue;\\n                    \\n                }\\n               \\n            }\\n            else{\\n        \\n            int row1=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n            int row2=grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n            int row3=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n            int col1=grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n            int col2=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];\\n            int col3=grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n            int dia1=grid[i][j]+5+grid[i+2][j+2];\\n            int dia2=grid[i][j+2]+5+grid[i+2][j];\\n            if(row2==row1 && col1 == row1 && col2 == row1 && dia1==row1 && dia1==dia2 && ans==0){\\n                \\n                count++;\\n            }\\n             if(j+2<grid.length-1){\\n                    j++;\\n                   \\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                 }\\n        }\\n            \\n    }\\n     return count;   \\n  \\t  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682225,
                "title": "magic-square-java",
                "content": "class Solution {\\n    public boolean check(int grid[][],int i,int j){\\n        \\n        int r1=grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1];\\n        int r2=grid[i][j-1]+grid[i][j]+grid[i][j+1];\\n        int r3=grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1];\\n        int c1=grid[i-1][j-1]+grid[i][j-1]+grid[i+1][j-1];\\n        int c2=grid[i-1][j]+grid[i][j]+grid[i+1][j];\\n        int c3=grid[i-1][j+1]+grid[i][j+1]+grid[i+1][j+1];\\n        int d1=grid[i][j]+grid[i-1][j-1]+grid[i+1][j+1];\\n        int d2=grid[i][j]+grid[i-1][j+1]+grid[i+1][j-1];\\n        // System.out.print(r1+\" \"+r2+\" \"+r3+\" \"+c1+\" \"+c2+\" \"+c3+\" \"+d1+\" \"+d2);\\n        HashSet<Integer> h=new HashSet<>();\\n        boolean flag=true;\\n        h.add(grid[i-1][j-1]);\\n        h.add(grid[i-1][j]);\\n        h.add(grid[i-1][j+1]);\\n        h.add(grid[i][j-1]);\\n        h.add(grid[i][j]);\\n        h.add(grid[i][j+1]);\\n        h.add(grid[i+1][j-1]);\\n        h.add(grid[i+1][j]);\\n        h.add(grid[i+1][j+1]);\\n        for(int n:h){\\n            if(n>=10){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(r1==r2&&r3==r2&&c1==r1&&c2==c1&&c3==c1&&d1==r1&&d2==d1&&h.size()==9&&flag==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length<3||grid[0].length<3){\\n            return 0;\\n        }\\n        int c=0;\\n        for(int i=1;i<grid.length-1;i++){\\n            for(int j=1;j<grid[0].length-1;j++){\\n                if(grid[i][j]==5){\\n                    boolean ans=check(grid,i,j);\\n                    // System.out.print(ans);\\n                    if(ans==true)c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean check(int grid[][],int i,int j){\\n        \\n        int r1=grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1];\\n        int r2=grid[i][j-1]+grid[i][j]+grid[i][j+1];\\n        int r3=grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1];\\n        int c1=grid[i-1][j-1]+grid[i][j-1]+grid[i+1][j-1];\\n        int c2=grid[i-1][j]+grid[i][j]+grid[i+1][j];\\n        int c3=grid[i-1][j+1]+grid[i][j+1]+grid[i+1][j+1];\\n        int d1=grid[i][j]+grid[i-1][j-1]+grid[i+1][j+1];\\n        int d2=grid[i][j]+grid[i-1][j+1]+grid[i+1][j-1];\\n        // System.out.print(r1+\" \"+r2+\" \"+r3+\" \"+c1+\" \"+c2+\" \"+c3+\" \"+d1+\" \"+d2);\\n        HashSet<Integer> h=new HashSet<>();\\n        boolean flag=true;\\n        h.add(grid[i-1][j-1]);\\n        h.add(grid[i-1][j]);\\n        h.add(grid[i-1][j+1]);\\n        h.add(grid[i][j-1]);\\n        h.add(grid[i][j]);\\n        h.add(grid[i][j+1]);\\n        h.add(grid[i+1][j-1]);\\n        h.add(grid[i+1][j]);\\n        h.add(grid[i+1][j+1]);\\n        for(int n:h){\\n            if(n>=10){\\n                flag=false;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1669102,
                "title": "with-hashset-and-system-out-println-for-easier-simulation",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int result = 0;\\n        \\n        for(int i=0;i<row-2;i++)\\n        {\\n            for(int j = 0 ; j< col-2;j++)\\n            {\\n                if(grid[i+1][j+1] == 5)\\n                {\\n                    if(isMagic(i,j,grid))\\n                    {\\n                        result++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n            \\n    }\\n    \\n    public boolean isMagic(int row , int col , int[][] grid)\\n    {\\n        Set<Integer> set = new HashSet();\\n        for(int i=row ; i<row+3 ; i++)\\n        {\\n            for(int j = col ; j<col+3 ; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n                set.add(grid[i][j]);\\n            }\\n        }\\n        \\n        if(set.size() != 9)\\n        {\\n            return false;\\n        }\\n            \\n        \\n        int sum1 = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        \\n        System.out.println(sum1 + \"----\");\\n        \\n        int sum2 = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n        \\n        System.out.println(sum2 + \"----\");\\n        int sum3 = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n        System.out.println(sum3 + \"----\");\\n        int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n        System.out.println(diag1 + \"----\");\\n        int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n        System.out.println(diag2 + \"----\");\\n        \\n        int col1 = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n        System.out.println(col1 + \"----\");\\n        int col2 = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n        System.out.println(col2 + \"----\");\\n        int col3 = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n        System.out.println(col3 + \"----\");\\n        \\n        \\n        if(sum1 == sum2 && sum2 == sum3 && diag1 == diag2 && col1==col2 && col2==col3)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int result = 0;\\n        \\n        for(int i=0;i<row-2;i++)\\n        {\\n            for(int j = 0 ; j< col-2;j++)\\n            {\\n                if(grid[i+1][j+1] == 5)\\n                {\\n                    if(isMagic(i,j,grid))\\n                    {\\n                        result++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n            \\n    }\\n    \\n    public boolean isMagic(int row , int col , int[][] grid)\\n    {\\n        Set<Integer> set = new HashSet();\\n        for(int i=row ; i<row+3 ; i++)\\n        {\\n            for(int j = col ; j<col+3 ; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n                set.add(grid[i][j]);\\n            }\\n        }\\n        \\n        if(set.size() != 9)\\n        {\\n            return false;\\n        }\\n            \\n        \\n        int sum1 = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        \\n        System.out.println(sum1 + \"----\");\\n        \\n        int sum2 = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n        \\n        System.out.println(sum2 + \"----\");\\n        int sum3 = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n        System.out.println(sum3 + \"----\");\\n        int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n        System.out.println(diag1 + \"----\");\\n        int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n        System.out.println(diag2 + \"----\");\\n        \\n        int col1 = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n        System.out.println(col1 + \"----\");\\n        int col2 = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n        System.out.println(col2 + \"----\");\\n        int col3 = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n        System.out.println(col3 + \"----\");\\n        \\n        \\n        if(sum1 == sum2 && sum2 == sum3 && diag1 == diag2 && col1==col2 && col2==col3)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642412,
                "title": "simple-and-clean-with-brute-force-approach",
                "content": "class Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def check(i,j):\\n            k=[grid[i][j],grid[i+1][j],grid[i+2][j],grid[i][j+1],grid[i+1][j+1],grid[i+2][j+1],grid[i][j+2],grid[i+1][j+2],grid[i+2][j+2]]\\n            k.sort()\\n            w1=list(range(1,10))\\n            if(w1!=k):\\n                return(0)\\n            w=[]\\n            t1=sum(grid[i][j:j+3])\\n            t2=sum(grid[i+1][j:j+3])\\n            t3=sum(grid[i+2][j:j+3])\\n            t4=grid[i][j]+grid[i+1][j]+grid[i+2][j]\\n            t5=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t6=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t7=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]\\n            t8=grid[i+1][j+1]+grid[i][j+2]+grid[i+2][j]\\n            # print(t1,t2,t3,t4,t5,t6,t7,t8)\\n            if(t1 == t2 and t2 == t3 and t3 == t4 and t4 == t5 and t5 == t6 and t6 == t7 and t7 == t8):\\n        \\n                return(1)\\n            return(0)\\n    \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[i])-2):\\n                count=count+ check(i,j)\\n        return(count)\\n                \\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def check(i,j):\\n            k=[grid[i][j],grid[i+1][j],grid[i+2][j],grid[i][j+1],grid[i+1][j+1],grid[i+2][j+1],grid[i][j+2],grid[i+1][j+2],grid[i+2][j+2]]\\n            k.sort()\\n            w1=list(range(1,10))\\n            if(w1!=k):\\n                return(0)\\n            w=[]\\n            t1=sum(grid[i][j:j+3])\\n            t2=sum(grid[i+1][j:j+3])\\n            t3=sum(grid[i+2][j:j+3])\\n            t4=grid[i][j]+grid[i+1][j]+grid[i+2][j]\\n            t5=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t6=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t7=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]\\n            t8=grid[i+1][j+1]+grid[i][j+2]+grid[i+2][j]\\n            # print(t1,t2,t3,t4,t5,t6,t7,t8)\\n            if(t1 == t2 and t2 == t3 and t3 == t4 and t4 == t5 and t5 == t6 and t6 == t7 and t7 == t8):\\n        \\n                return(1)\\n            return(0)\\n    \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[i])-2):\\n                count=count+ check(i,j)\\n        return(count)\\n                \\n\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1595645,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public static int numMagicSquaresInside(int[][] grid) {\\n       if(grid[0].length<3 || grid.length<3)\\n           return 0;\\n        int count=0;\\n            for(int i=0;i<=grid.length-3;i++){\\n                for(int j=0;j<=grid[0].length-3;j++){\\n                    if(isMagicSquare(i,j,grid))\\n                        count++;    \\n            }\\n        \\n        }\\n        return count;\\n    }\\n    public static boolean isMagicSquare(int i,int j,int[][]grid){\\n        Set<Integer> uniqueSet=new HashSet<>();\\n        //Map<Integer,Integer> rowMap=new HashMap<>();\\n        int rowSum=0;\\n        int rowTemp=0;\\n        int leftDiag=0;\\n        int rightDiag=0;\\n        Map<Integer,Integer>colMap=new HashMap<>();\\n        \\n        \\n        for(int a=i;a<i+3;a++){\\n            rowSum=0;\\n            for(int b=j;b<j+3;b++){\\n                if(uniqueSet.contains(grid[a][b])||grid[a][b]>9||grid[a][b]<1)\\n                    return false;\\n                else\\n                    uniqueSet.add(grid[a][b]);\\n                colMap.put(b-j,colMap.getOrDefault(b-j,0)+grid[a][b]);        \\n                rowSum=rowSum+grid[a][b];\\n                if((a-i)==(b-j))\\n                    leftDiag=leftDiag+grid[a][b];\\n                if(((a-i)==(2-(b-j))))\\n                    rightDiag=rightDiag+grid[a][b];\\n            }\\n            if(rowTemp==0)\\n                rowTemp=rowSum;\\n            else if(rowTemp!=rowSum)\\n                return false;\\n            \\n        }if(rightDiag!=leftDiag)\\n            return false;\\n        if(colMap.get(0)!=colMap.get(1)||colMap.get(1)!=colMap.get(2))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int numMagicSquaresInside(int[][] grid) {\\n       if(grid[0].length<3 || grid.length<3)\\n           return 0;\\n        int count=0;\\n            for(int i=0;i<=grid.length-3;i++){\\n                for(int j=0;j<=grid[0].length-3;j++){\\n                    if(isMagicSquare(i,j,grid))\\n                        count++;    \\n            }\\n        \\n        }\\n        return count;\\n    }\\n    public static boolean isMagicSquare(int i,int j,int[][]grid){\\n        Set<Integer> uniqueSet=new HashSet<>();\\n        //Map<Integer,Integer> rowMap=new HashMap<>();\\n        int rowSum=0;\\n        int rowTemp=0;\\n        int leftDiag=0;\\n        int rightDiag=0;\\n        Map<Integer,Integer>colMap=new HashMap<>();\\n        \\n        \\n        for(int a=i;a<i+3;a++){\\n            rowSum=0;\\n            for(int b=j;b<j+3;b++){\\n                if(uniqueSet.contains(grid[a][b])||grid[a][b]>9||grid[a][b]<1)\\n                    return false;\\n                else\\n                    uniqueSet.add(grid[a][b]);\\n                colMap.put(b-j,colMap.getOrDefault(b-j,0)+grid[a][b]);        \\n                rowSum=rowSum+grid[a][b];\\n                if((a-i)==(b-j))\\n                    leftDiag=leftDiag+grid[a][b];\\n                if(((a-i)==(2-(b-j))))\\n                    rightDiag=rightDiag+grid[a][b];\\n            }\\n            if(rowTemp==0)\\n                rowTemp=rowSum;\\n            else if(rowTemp!=rowSum)\\n                return false;\\n            \\n        }if(rightDiag!=leftDiag)\\n            return false;\\n        if(colMap.get(0)!=colMap.get(1)||colMap.get(1)!=colMap.get(2))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578281,
                "title": "java-brute-force-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\n    \\n    private int k = 3;\\n    \\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(isMagic(grid, i,j))\\n                    count++;\\n        return count;\\n    }\\n    \\n    public boolean isMagic(int[][] grid, int x, int y){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(n - x < k)\\n            return false;\\n        if(m - y < k)\\n            return false;\\n        int targetSum = 0;\\n        for(int i = x; i < x+k; i++)\\n            targetSum+=grid[i][y];\\n        \\n        int sum = 0;\\n        for(int i=y+1; i<y+k;i++){\\n            sum = 0;\\n            for(int j = x; j < x+k; j++)\\n                sum+=grid[j][i];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        for(int i=x; i<x+k;i++){\\n            sum=0;\\n            for(int j = y; j < y+k; j++)\\n                sum+=grid[i][j];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        int diagonalSum = 0;\\n        int antiDiagonalSum = 0;\\n        int sumOfDiagonalIndices = x + y + k - 1;\\n        \\n        Set<Integer> unique = new HashSet<>();\\n        \\n        for(int i=x; i<x+k;i++)\\n            for(int j=y;j<y+k;j++){\\n                if(grid[i][j] < 1 || grid[i][j] > 9)\\n                    return false;\\n                unique.add(grid[i][j]);\\n                if(i-x==j-y)\\n                    diagonalSum+=grid[i][j];\\n                if(i + j == sumOfDiagonalIndices)\\n                    antiDiagonalSum+=grid[i][j];  \\n            }\\n        \\n        if(unique.size() < k*k)\\n            return false;\\n        \\n        if(targetSum!=diagonalSum)\\n            return false;\\n        \\n        if(targetSum!=antiDiagonalSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int k = 3;\\n    \\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(isMagic(grid, i,j))\\n                    count++;\\n        return count;\\n    }\\n    \\n    public boolean isMagic(int[][] grid, int x, int y){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(n - x < k)\\n            return false;\\n        if(m - y < k)\\n            return false;\\n        int targetSum = 0;\\n        for(int i = x; i < x+k; i++)\\n            targetSum+=grid[i][y];\\n        \\n        int sum = 0;\\n        for(int i=y+1; i<y+k;i++){\\n            sum = 0;\\n            for(int j = x; j < x+k; j++)\\n                sum+=grid[j][i];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        for(int i=x; i<x+k;i++){\\n            sum=0;\\n            for(int j = y; j < y+k; j++)\\n                sum+=grid[i][j];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        int diagonalSum = 0;\\n        int antiDiagonalSum = 0;\\n        int sumOfDiagonalIndices = x + y + k - 1;\\n        \\n        Set<Integer> unique = new HashSet<>();\\n        \\n        for(int i=x; i<x+k;i++)\\n            for(int j=y;j<y+k;j++){\\n                if(grid[i][j] < 1 || grid[i][j] > 9)\\n                    return false;\\n                unique.add(grid[i][j]);\\n                if(i-x==j-y)\\n                    diagonalSum+=grid[i][j];\\n                if(i + j == sumOfDiagonalIndices)\\n                    antiDiagonalSum+=grid[i][j];  \\n            }\\n        \\n        if(unique.size() < k*k)\\n            return false;\\n        \\n        if(targetSum!=diagonalSum)\\n            return false;\\n        \\n        if(targetSum!=antiDiagonalSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549633,
                "title": "optimized-brute-force-javascript-with-comments-beats-85-95",
                "content": "\\n\\n\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\n// An enumerator class that allows for O(1)\\n// insertions and checks for completion (all numbers being present)\\nclass Enumerator {\\n    enum = {\\n        1: true,\\n        2: true,\\n        3: true,\\n        4: true,\\n        5: true,\\n        6: true,\\n        7: true,\\n        8: true,\\n        9: true\\n    }\\n    set = new Set();\\n\\n    isValid(item) {\\n        return item in this.enum;\\n    }\\n    insert(item) {\\n        if(this.isValid(item)) {\\n            this.set.add(item);\\n        }\\n    }\\n    get complete() {\\n        return this.set.size === 9;\\n    }\\n}\\n\\nclass Solution {\\n    constructor(grid) {\\n        this.total = 0;\\n        this.grid = grid;\\n        // cache the max indices that can serve as the top\\n        // left cell of a square and use them as outer\\n        // bounds for the initial loop\\n        this.maxHIndex = this.grid[0].length - 2;\\n        this.maxVIndex = this.grid.length - 2;\\n        // return early if the grid is too small\\n        if(this.maxHIndex < 0 || this.maxVIndex < 0) {\\n            return;\\n        }\\n        this.enumerator = new Enumerator();\\n        this.execute();\\n    }\\n    execute() {\\n        for(let i = 0; i < this.maxVIndex; i++) {\\n            for(let j = 0; j < this.maxHIndex; j++) {\\n                // search from a valid top-left position\\n                this.search(i, j);\\n                this.enumerator = new Enumerator();\\n            }\\n        }\\n    }\\n    search(y, x) {  \\n        // the middle cell must be a 5 to be a \"magic square\"\\n        if(this.grid[y + 1][x + 1] !== 5) {\\n            return false;\\n        }\\n        this.enumerator.insert(5);\\n        const topLeft = this.grid[y][x];\\n        // make sure your starting point is within the range 1-9\\n        if(!this.enumerator.isValid(topLeft)) {\\n            return;\\n        }\\n        // validate the square\\n        if(this.validate(y, x)) {\\n            this.total++;\\n        }\\n    }\\n    validate(y, x) {\\n        let HSum;\\n        let VSum;\\n        // check columns and rows\\n        for(let i = 0; i < 3; i++) {\\n            const horizontalSum = this.getHorizontalSum(y + i, x);\\n            if(!HSum) {\\n                HSum = horizontalSum;\\n            } else if(HSum !== horizontalSum) {\\n                return false;\\n            }\\n            const verticalSum = this.getVerticalSum(y, x + i);\\n            if(!VSum) {\\n                if(verticalSum !== HSum) {\\n                    return false;\\n                }\\n                VSum = verticalSum;\\n            } else if(VSum !== verticalSum) {\\n                return false;\\n            }\\n        }\\n        //check for numbers 1-9 each being present in the square\\n        if(!this.enumerator.complete) {\\n            return false;\\n        }\\n        //check diagonals from left to right and right to left\\n        if(\\n            !this.isDiagonalRightSumValid(y, x) ||\\n            !this.isDiagonalLeftSumValid(y, x + 2)\\n        ) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    // sums for grid[y][x] through grid[y][x + 2]\\n    // Also - memoize cell values while traversing rows\\n    // to validate against later\\n    getHorizontalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            const cur = this.grid[y][x + i];\\n            this.enumerator.insert(cur);\\n            sum += cur;\\n        }\\n        return sum;\\n    }\\n    //sums for grid[y][x] through grid[y + 2][x]\\n    getVerticalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            sum += this.grid[y + i][x];\\n        }\\n        return sum;\\n    }\\n    // sum from top left to bottom right assuming 5 is the middle cell\\n    isDiagonalRightSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x + 2] === 10;\\n    }\\n    // sum from top right to bottom left assuming 5 is the middle cell\\n    isDiagonalLeftSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x - 2] === 10;\\n    }\\n}\\n\\nvar numMagicSquaresInside = function(grid) {\\n    return new Solution(grid).total;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\n// An enumerator class that allows for O(1)\\n// insertions and checks for completion (all numbers being present)\\nclass Enumerator {\\n    enum = {\\n        1: true,\\n        2: true,\\n        3: true,\\n        4: true,\\n        5: true,\\n        6: true,\\n        7: true,\\n        8: true,\\n        9: true\\n    }\\n    set = new Set();\\n\\n    isValid(item) {\\n        return item in this.enum;\\n    }\\n    insert(item) {\\n        if(this.isValid(item)) {\\n            this.set.add(item);\\n        }\\n    }\\n    get complete() {\\n        return this.set.size === 9;\\n    }\\n}\\n\\nclass Solution {\\n    constructor(grid) {\\n        this.total = 0;\\n        this.grid = grid;\\n        // cache the max indices that can serve as the top\\n        // left cell of a square and use them as outer\\n        // bounds for the initial loop\\n        this.maxHIndex = this.grid[0].length - 2;\\n        this.maxVIndex = this.grid.length - 2;\\n        // return early if the grid is too small\\n        if(this.maxHIndex < 0 || this.maxVIndex < 0) {\\n            return;\\n        }\\n        this.enumerator = new Enumerator();\\n        this.execute();\\n    }\\n    execute() {\\n        for(let i = 0; i < this.maxVIndex; i++) {\\n            for(let j = 0; j < this.maxHIndex; j++) {\\n                // search from a valid top-left position\\n                this.search(i, j);\\n                this.enumerator = new Enumerator();\\n            }\\n        }\\n    }\\n    search(y, x) {  \\n        // the middle cell must be a 5 to be a \"magic square\"\\n        if(this.grid[y + 1][x + 1] !== 5) {\\n            return false;\\n        }\\n        this.enumerator.insert(5);\\n        const topLeft = this.grid[y][x];\\n        // make sure your starting point is within the range 1-9\\n        if(!this.enumerator.isValid(topLeft)) {\\n            return;\\n        }\\n        // validate the square\\n        if(this.validate(y, x)) {\\n            this.total++;\\n        }\\n    }\\n    validate(y, x) {\\n        let HSum;\\n        let VSum;\\n        // check columns and rows\\n        for(let i = 0; i < 3; i++) {\\n            const horizontalSum = this.getHorizontalSum(y + i, x);\\n            if(!HSum) {\\n                HSum = horizontalSum;\\n            } else if(HSum !== horizontalSum) {\\n                return false;\\n            }\\n            const verticalSum = this.getVerticalSum(y, x + i);\\n            if(!VSum) {\\n                if(verticalSum !== HSum) {\\n                    return false;\\n                }\\n                VSum = verticalSum;\\n            } else if(VSum !== verticalSum) {\\n                return false;\\n            }\\n        }\\n        //check for numbers 1-9 each being present in the square\\n        if(!this.enumerator.complete) {\\n            return false;\\n        }\\n        //check diagonals from left to right and right to left\\n        if(\\n            !this.isDiagonalRightSumValid(y, x) ||\\n            !this.isDiagonalLeftSumValid(y, x + 2)\\n        ) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    // sums for grid[y][x] through grid[y][x + 2]\\n    // Also - memoize cell values while traversing rows\\n    // to validate against later\\n    getHorizontalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            const cur = this.grid[y][x + i];\\n            this.enumerator.insert(cur);\\n            sum += cur;\\n        }\\n        return sum;\\n    }\\n    //sums for grid[y][x] through grid[y + 2][x]\\n    getVerticalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            sum += this.grid[y + i][x];\\n        }\\n        return sum;\\n    }\\n    // sum from top left to bottom right assuming 5 is the middle cell\\n    isDiagonalRightSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x + 2] === 10;\\n    }\\n    // sum from top right to bottom left assuming 5 is the middle cell\\n    isDiagonalLeftSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x - 2] === 10;\\n    }\\n}\\n\\nvar numMagicSquaresInside = function(grid) {\\n    return new Solution(grid).total;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537746,
                "title": "c-faster-than-100",
                "content": "\\n\\n\\n```\\nclass Solution {\\nprivate:    \\n    bool isMagicSquare(vector<vector<int>>& grid, int x, int y) {\\n        //! num in 3*3 grid should be 1 ~ 9\\n        map<int, int> dup;\\n        for(int i = x; i < x + 3; i ++) {\\n            for (int j = y; j < y + 3; j ++) {\\n                if(grid[i][j] < 1 || grid[i][j] > 9) {\\n                    return false;\\n                }\\n                else {\\n                    if(dup.count(grid[i][j]) > 0) {\\n                        return false;\\n                    }\\n                    else {\\n                        dup[grid[i][j]] = 3 * i + j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //! 3 row\\n        int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];\\n        if(sum != grid[x+1][y] + grid[x+1][y+1] + grid[x+1][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2])\\n            return false;\\n        //! 3 column\\n        if(sum != grid[x][y] + grid[x+1][y] + grid[x+2][y])\\n            return false;\\n        if(sum != grid[x][y+1] + grid[x+1][y+1] + grid[x+2][y+1])\\n            return false;\\n        if(sum != grid[x][y+2] + grid[x+1][y+2] + grid[x+2][y+2])\\n            return false;\\n        //! two disgonals\\n        if(sum != grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+1][y+1] + grid[x][y+2])\\n            return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int iCount = 0;\\n        \\n        for (int x = 1; x < m - 1; x ++) {\\n            for (int y = 1; y < n - 1; y ++) {\\n                if(grid[x][y] == 5) {\\n                    if(isMagicSquare(grid, x-1, y-1))\\n                        iCount ++;\\n                }\\n            }\\n        }\\n        \\n        return iCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:    \\n    bool isMagicSquare(vector<vector<int>>& grid, int x, int y) {\\n        //! num in 3*3 grid should be 1 ~ 9\\n        map<int, int> dup;\\n        for(int i = x; i < x + 3; i ++) {\\n            for (int j = y; j < y + 3; j ++) {\\n                if(grid[i][j] < 1 || grid[i][j] > 9) {\\n                    return false;\\n                }\\n                else {\\n                    if(dup.count(grid[i][j]) > 0) {\\n                        return false;\\n                    }\\n                    else {\\n                        dup[grid[i][j]] = 3 * i + j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //! 3 row\\n        int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];\\n        if(sum != grid[x+1][y] + grid[x+1][y+1] + grid[x+1][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2])\\n            return false;\\n        //! 3 column\\n        if(sum != grid[x][y] + grid[x+1][y] + grid[x+2][y])\\n            return false;\\n        if(sum != grid[x][y+1] + grid[x+1][y+1] + grid[x+2][y+1])\\n            return false;\\n        if(sum != grid[x][y+2] + grid[x+1][y+2] + grid[x+2][y+2])\\n            return false;\\n        //! two disgonals\\n        if(sum != grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+1][y+1] + grid[x][y+2])\\n            return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int iCount = 0;\\n        \\n        for (int x = 1; x < m - 1; x ++) {\\n            for (int y = 1; y < n - 1; y ++) {\\n                if(grid[x][y] == 5) {\\n                    if(isMagicSquare(grid, x-1, y-1))\\n                        iCount ++;\\n                }\\n            }\\n        }\\n        \\n        return iCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532829,
                "title": "fast-extremely-clear-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isUnique(vector<vector<int>>&grid, int u, int v)\\n    {\\n        int hash[10]={0};\\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            for(int j=v;j<grid[0].size() && j<3+v;j++)\\n            {\\n                if(grid[i][j]>9) return false;\\n                hash[grid[i][j]]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<10;i++)\\n        {\\n            if(hash[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int digSum(vector<vector<int>>&grid,int u,int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v+1]+grid[u+2][v+2]);\\n    }\\n    \\n    int rowSum(vector<vector<int>>&grid, int u,int v)\\n    {\\n        return (grid[u][v]+grid[u][v+1]+grid[u][v+2]);\\n    }\\n    \\n    int colSum(vector<vector<int>>&grid, int u , int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v]+grid[u+2][v]);\\n    }\\n    \\n    \\n    bool sumCheck(vector<vector<int>>&grid,int u,int v)\\n    {\\n        int dS = digSum(grid,u,v);\\n        for(int i=v;i<3+v && i<grid[0].size();i++)\\n        {\\n            if(colSum(grid,u,i)!=dS) return false;\\n        }\\n        \\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            if(rowSum(grid,i,v)!=dS) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size(),ans=0;\\n        if(m<3 || n<3) return 0;\\n        \\n        for(int i=0;i+2<n;i++)\\n        {\\n            for(int j=0;j+2<m;j++)\\n            {\\n                if(isUnique(grid,i,j) &&sumCheck(grid,i,j))\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isUnique(vector<vector<int>>&grid, int u, int v)\\n    {\\n        int hash[10]={0};\\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            for(int j=v;j<grid[0].size() && j<3+v;j++)\\n            {\\n                if(grid[i][j]>9) return false;\\n                hash[grid[i][j]]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<10;i++)\\n        {\\n            if(hash[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int digSum(vector<vector<int>>&grid,int u,int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v+1]+grid[u+2][v+2]);\\n    }\\n    \\n    int rowSum(vector<vector<int>>&grid, int u,int v)\\n    {\\n        return (grid[u][v]+grid[u][v+1]+grid[u][v+2]);\\n    }\\n    \\n    int colSum(vector<vector<int>>&grid, int u , int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v]+grid[u+2][v]);\\n    }\\n    \\n    \\n    bool sumCheck(vector<vector<int>>&grid,int u,int v)\\n    {\\n        int dS = digSum(grid,u,v);\\n        for(int i=v;i<3+v && i<grid[0].size();i++)\\n        {\\n            if(colSum(grid,u,i)!=dS) return false;\\n        }\\n        \\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            if(rowSum(grid,i,v)!=dS) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size(),ans=0;\\n        if(m<3 || n<3) return 0;\\n        \\n        for(int i=0;i+2<n;i++)\\n        {\\n            for(int j=0;j+2<m;j++)\\n            {\\n                if(isUnique(grid,i,j) &&sumCheck(grid,i,j))\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504747,
                "title": "intuitive-simulate",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435412,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    bool magic(int a,int b,int c,int d,int e,int f,int g,int h,int i){\\n        \\n        set<int>s1={a,b,c,d,e,f,g,h,i};\\n        set<int>s2={1,2,3,4,5,6,7,8,9};\\n        \\n        if(s1==s2 && (a+b+c)==15 && (d+e+f)==15 && (g+h+i)==15 && (a+d+g)==15 && (b+e+h)==15 && (c+f+i)==15 && (a+e+i)==15 && (c+e+g)==15 && e==5 ){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(m<3 || n<3){\\n            return 0;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                \\n              \\n                \\n                if(magic(grid[i][j],grid[i][j+1],grid[i][j+2],grid[i+1][j],grid[i+1][j+1],grid[i+1][j+2],grid[i+2][j],grid[i+2][j+1],grid[i+2][j+2])){\\n                    ans+=1;\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool magic(int a,int b,int c,int d,int e,int f,int g,int h,int i){\\n        \\n        set<int>s1={a,b,c,d,e,f,g,h,i}",
                "codeTag": "Java"
            },
            {
                "id": 1430066,
                "title": "c-brute-force",
                "content": "**The idea is to iterate over each 3*3 matrix in grid and check the given condition**\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n      \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<=r-3;i++){\\n            \\n            for(int j=0;j<=c-3;j++){\\n            \\n               bool b=1;\\n                int arr[10]={};\\n                \\n                for(int rr=i;rr<i+3;rr++){\\n                    for(int cc=j;cc<j+3;cc++){\\n                        if(grid[rr][cc]>9 or grid[rr][cc]<1){\\n                            b=0;\\n                            break;\\n                        }\\n                        else\\n                            {\\n                                if(arr[grid[rr][cc]]==0)\\n                                    arr[grid[rr][cc]]=1;\\n                                else{\\n                                    b=0;break;\\n                                }\\n                             }\\n                    }\\n                    if(!b) break;\\n                }\\n                if(b){\\n                    bool bb=1;\\n                    int prev=INT_MIN;\\n                    for(int rr=i;rr<i+3;rr++){\\n                        int sm=grid[rr][j]+grid[rr][j+1]+grid[rr][j+2];\\n                        if(prev==INT_MIN) prev=sm;\\n                        else if(prev!=sm){\\n                            bb=0;\\n                            goto last;\\n                        }\\n                    }\\n                    \\n                    for(int cc=j;cc<j+3;cc++){\\n                        int sm=grid[i][cc]+grid[i+1][cc]+grid[i+2][cc];\\n                        if(prev!=sm){\\n                            bb=0;goto last;\\n                        }\\n                    }\\n                    if(grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]!=prev)\\n                        bb=0;\\n                    if(grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]!=prev)\\n                        bb=0;\\n                    last:\\n                    if(bb)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n      \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<=r-3;i++){\\n            \\n            for(int j=0;j<=c-3;j++){\\n            \\n               bool b=1;\\n                int arr[10]={};\\n                \\n                for(int rr=i;rr<i+3;rr++){\\n                    for(int cc=j;cc<j+3;cc++){\\n                        if(grid[rr][cc]>9 or grid[rr][cc]<1){\\n                            b=0;\\n                            break;\\n                        }\\n                        else\\n                            {\\n                                if(arr[grid[rr][cc]]==0)\\n                                    arr[grid[rr][cc]]=1;\\n                                else{\\n                                    b=0;break;\\n                                }\\n                             }\\n                    }\\n                    if(!b) break;\\n                }\\n                if(b){\\n                    bool bb=1;\\n                    int prev=INT_MIN;\\n                    for(int rr=i;rr<i+3;rr++){\\n                        int sm=grid[rr][j]+grid[rr][j+1]+grid[rr][j+2];\\n                        if(prev==INT_MIN) prev=sm;\\n                        else if(prev!=sm){\\n                            bb=0;\\n                            goto last;\\n                        }\\n                    }\\n                    \\n                    for(int cc=j;cc<j+3;cc++){\\n                        int sm=grid[i][cc]+grid[i+1][cc]+grid[i+2][cc];\\n                        if(prev!=sm){\\n                            bb=0;goto last;\\n                        }\\n                    }\\n                    if(grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]!=prev)\\n                        bb=0;\\n                    if(grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]!=prev)\\n                        bb=0;\\n                    last:\\n                    if(bb)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419104,
                "title": "straightforward-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/5975e6c4-d95f-446a-bbf7-67aaeb6672ad_1629618715.8212204.png)\\n```\\nclass Solution:\\n\\n    digits = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\n\\n    @classmethod\\n    def magic_3_3(cls, square: List[List[int]]) -> bool:\\n        if set(sum(square, [])) != Solution.digits:\\n            return False\\n        sum_row0 = sum(square[0])\\n        for r in range(1, 3):\\n            if sum(square[r]) != sum_row0:\\n                return False\\n        if any(sum(col) != sum_row0 for col in zip(*square)):\\n            return False\\n        sum_main_diagonal = sum_second_diagonal = 0\\n        for i in range(3):\\n            sum_main_diagonal += square[i][i]\\n            sum_second_diagonal += square[i][2 - i]\\n        return sum_main_diagonal == sum_second_diagonal == sum_row0\\n\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows - 2):\\n            for c in range(cols - 2):\\n                if Solution.magic_3_3([grid[row_idx][c: c + 3]\\n                                       for row_idx in range(r, r + 3)]):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    digits = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\n\\n    @classmethod\\n    def magic_3_3(cls, square: List[List[int]]) -> bool:\\n        if set(sum(square, [])) != Solution.digits:\\n            return False\\n        sum_row0 = sum(square[0])\\n        for r in range(1, 3):\\n            if sum(square[r]) != sum_row0:\\n                return False\\n        if any(sum(col) != sum_row0 for col in zip(*square)):\\n            return False\\n        sum_main_diagonal = sum_second_diagonal = 0\\n        for i in range(3):\\n            sum_main_diagonal += square[i][i]\\n            sum_second_diagonal += square[i][2 - i]\\n        return sum_main_diagonal == sum_second_diagonal == sum_row0\\n\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows - 2):\\n            for c in range(cols - 2):\\n                if Solution.magic_3_3([grid[row_idx][c: c + 3]\\n                                       for row_idx in range(r, r + 3)]):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393313,
                "title": "100-00-than-all-c-online-submission-so-far",
                "content": "```\\n public int NumMagicSquaresInside(int[][] grid) {\\n        int numberOfMagicSqaures = 0;\\n        if(grid.Length < 3 && grid[0].Length < 3)\\n            return numberOfMagicSqaures;        \\n        \\n        for(int i = 0;i < grid.Length; i++)\\n        {\\n             for(int j = 0; j < grid[i].Length; j++)\\n             {\\n                 if(i + 2 < grid.Length && j + 2 < grid[i].Length && CountMagic(grid, i, j))\\n                 {\\n                     numberOfMagicSqaures++;\\n                 }\\n             }\\n        }\\n        \\n        return numberOfMagicSqaures;\\n    }\\n    \\n    private bool CountMagic(int[][] grid, int i, int j)\\n    {  \\n        bool[] distinctDigits = new bool[10];\\n        for(int k=i;k <= i+2; k++)\\n        {\\n            for(int l=j;l <= j+2; l++)\\n            {\\n                if(grid[k][l] < 1 || grid[k][l] > 9)\\n                    return false;\\n                \\n                if(distinctDigits[grid[k][l]])\\n                    return false;\\n                else\\n                    distinctDigits[grid[k][l]] = true;\\n            }\\n        }        \\n        \\n        // Rows\\n        if( grid[i][j] + grid[i][j+1] + grid[i][j+2] != 15 || grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2] != 15 ||\\n          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] != 15)\\n            return false;\\n        \\n        // Columns\\n        if(grid[i][j] + grid[i+1][j] + grid[i+2][j] != 15 || grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1] != 15 ||\\n          grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2] != 15)\\n            return false;\\n          \\n         // Diagonals \\n        if(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != 15 || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int NumMagicSquaresInside(int[][] grid) {\\n        int numberOfMagicSqaures = 0;\\n        if(grid.Length < 3 && grid[0].Length < 3)\\n            return numberOfMagicSqaures;        \\n        \\n        for(int i = 0;i < grid.Length; i++)\\n        {\\n             for(int j = 0; j < grid[i].Length; j++)\\n             {\\n                 if(i + 2 < grid.Length && j + 2 < grid[i].Length && CountMagic(grid, i, j))\\n                 {\\n                     numberOfMagicSqaures++;\\n                 }\\n             }\\n        }\\n        \\n        return numberOfMagicSqaures;\\n    }\\n    \\n    private bool CountMagic(int[][] grid, int i, int j)\\n    {  \\n        bool[] distinctDigits = new bool[10];\\n        for(int k=i;k <= i+2; k++)\\n        {\\n            for(int l=j;l <= j+2; l++)\\n            {\\n                if(grid[k][l] < 1 || grid[k][l] > 9)\\n                    return false;\\n                \\n                if(distinctDigits[grid[k][l]])\\n                    return false;\\n                else\\n                    distinctDigits[grid[k][l]] = true;\\n            }\\n        }        \\n        \\n        // Rows\\n        if( grid[i][j] + grid[i][j+1] + grid[i][j+2] != 15 || grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2] != 15 ||\\n          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] != 15)\\n            return false;\\n        \\n        // Columns\\n        if(grid[i][j] + grid[i+1][j] + grid[i+2][j] != 15 || grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1] != 15 ||\\n          grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2] != 15)\\n            return false;\\n          \\n         // Diagonals \\n        if(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != 15 || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384638,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n           int ans = 0; \\n         unordered_map<int , int >mp; \\n        for(int i = 0;i+3<=grid.size();i++)\\n        { \\n             for(int j = 0; j+3 <= grid[0].size(); j++)\\n             {  \\n                 int ok = 0; \\n                 int sum = 0; \\n                  for(int k = i; k<i+3; k++)\\n                  {  sum = 0; \\n                     for(int l =j ; l<j+3; l++)\\n                     {  mp[grid[k][l]]++;\\n                        sum += grid[k][l] ; \\n                     }\\n                   if(sum == 15)ok++; \\n                  } \\n                   for(int k = j; k<j+3; k++)\\n                  {  sum = 0; \\n                     for(int l =i ; l<i+3; l++)\\n                     { mp[grid[l][k]]++;\\n                        sum += grid[l][k] ; \\n                     }\\n                   if(sum == 15) ok++; \\n             }\\n              if(grid[i+1][j+1] == 5) ok++; \\n                 int mx = 0; \\n                 for(auto a : mp){mx = max(mx , a.first); }\\n              if(ok == 7 && mp.size()==9 && mx==9) ans++; \\n                 mp.clear(); \\n        } \\n        }\\n        \\n        return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n           int ans = 0; \\n         unordered_map<int , int >mp; \\n        for(int i = 0;i+3<=grid.size();i++)\\n        { \\n             for(int j = 0; j+3 <= grid[0].size(); j++)\\n             {  \\n                 int ok = 0; \\n                 int sum = 0; \\n                  for(int k = i; k<i+3; k++)\\n                  {  sum = 0; \\n                     for(int l =j ; l<j+3; l++)\\n                     {  mp[grid[k][l]]++;\\n                        sum += grid[k][l] ; \\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 1306651,
                "title": "javascript-easy-to-understand-solution-81-100",
                "content": "Runtime: 76 ms, faster than 81.82% of JavaScript online submissions for Magic Squares In Grid.\\nMemory Usage: 38.8 MB, less than 100.00% of JavaScript online submissions for Magic Squares In Grid.\\n```\\nvar numMagicSquaresInside = function(grid) {\\n    let res = 0;\\n    for(let i = 0; i < grid.length - 2; i++){\\n       for(let j = 0; j < grid[0].length - 2; j++){\\n\\t       //only check 4\\n           if(grid[i][j]+grid[i][j+1]+grid[i][j+2]==15\\n           && grid[i][j]+grid[i+1][j]+grid[i+2][j]==15\\n           && grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15\\n           && grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15){\\n               let set = new Set();\\n           for(let a = i; a<=i+2; a++){\\n              for(let b = j; b<=j+2; b++){ \\n                  if(grid[a][b]>=1&&grid[a][b]<=9) set.add(grid[a][b]);                \\n           }}\\n           if(set.size===9) res++;      \\n       }}}\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    let res = 0;\\n    for(let i = 0; i < grid.length - 2; i++){\\n       for(let j = 0; j < grid[0].length - 2; j++){\\n\\t       //only check 4\\n           if(grid[i][j]+grid[i][j+1]+grid[i][j+2]==15\\n           && grid[i][j]+grid[i+1][j]+grid[i+2][j]==15\\n           && grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15\\n           && grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15){\\n               let set = new Set();\\n           for(let a = i; a<=i+2; a++){\\n              for(let b = j; b<=j+2; b++){ \\n                  if(grid[a][b]>=1&&grid[a][b]<=9) set.add(grid[a][b]);                \\n           }}\\n           if(set.size===9) res++;      \\n       }}}\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305588,
                "title": "java-brute-approach",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int a[][]=new int[3][3];\\n        if(n<3 || m<3)\\n            return 0;\\n        else\\n            {\\n            int count=0;\\n            int r=0;\\n            while(r+2<n)\\n            {\\n            \\n            for(int i=0;i+2<m;i++)\\n            {\\n                if(check(matrix(grid,r+2,i,i+2)))\\n                   count++;\\n                \\n            }\\n            r++;\\n            }\\n            return count;\\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n    private int[][] matrix(int grid[][],int row,int start,int end)\\n    {\\n        int a[][]=new int[3][3];\\n        \\n        for(int i=row-2;i<=row;i++)\\n        {\\n            for(int j=start;j<=end;j++)\\n            {\\n                a[i-row+2][j-start]=grid[i][j];\\n            }\\n            \\n        }\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public boolean check(int[][] a)\\n    {\\n      \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            set.add(i);\\n        }\\n        int sum=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            sum=sum+a[0][i];\\n            \\n        }\\n        for(int i=0;i<3;i++)\\n        {   int tsum=0;\\n            for(int j=0;j<3;j++)\\n            {\\n            tsum=tsum+a[i][j];\\n            if(!set.remove(a[i][j]))\\n                return false;\\n            \\n            }\\n            if(tsum!=sum)\\n                return false;\\n        }\\n        for(int i=0;i<3;i++)\\n        {int sum2=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                sum2=sum2+a[j][i];\\n            }\\n         if(sum2!=sum)\\n             return false;\\n        }\\n        if(a[0][0]+a[1][1]+a[2][2]==sum && a[0][2]+a[1][1]+a[2][0]==sum && set.isEmpty())\\n            return true;\\n        else \\n            return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int a[][]=new int[3][3];\\n        if(n<3 || m<3)\\n            return 0;\\n        else\\n            {\\n            int count=0;\\n            int r=0;\\n            while(r+2<n)\\n            {\\n            \\n            for(int i=0;i+2<m;i++)\\n            {\\n                if(check(matrix(grid,r+2,i,i+2)))\\n                   count++;\\n                \\n            }\\n            r++;\\n            }\\n            return count;\\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n    private int[][] matrix(int grid[][],int row,int start,int end)\\n    {\\n        int a[][]=new int[3][3];\\n        \\n        for(int i=row-2;i<=row;i++)\\n        {\\n            for(int j=start;j<=end;j++)\\n            {\\n                a[i-row+2][j-start]=grid[i][j];\\n            }\\n            \\n        }\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public boolean check(int[][] a)\\n    {\\n      \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            set.add(i);\\n        }\\n        int sum=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            sum=sum+a[0][i];\\n            \\n        }\\n        for(int i=0;i<3;i++)\\n        {   int tsum=0;\\n            for(int j=0;j<3;j++)\\n            {\\n            tsum=tsum+a[i][j];\\n            if(!set.remove(a[i][j]))\\n                return false;\\n            \\n            }\\n            if(tsum!=sum)\\n                return false;\\n        }\\n        for(int i=0;i<3;i++)\\n        {int sum2=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                sum2=sum2+a[j][i];\\n            }\\n         if(sum2!=sum)\\n             return false;\\n        }\\n        if(a[0][0]+a[1][1]+a[2][2]==sum && a[0][2]+a[1][1]+a[2][0]==sum && set.isEmpty())\\n            return true;\\n        else \\n            return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303628,
                "title": "javascript-solution-brute-force",
                "content": "```\\nvar numMagicSquaresInside = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n            const sums = new Array(8).fill(0); // (1)\\n            const set = new Set();\\n            \\n            let isMagical = true;\\n\\n            for (let k = 0; k < 3; k++) { // row direction\\n                for (let l = 0; l < 3; l++) { // col direction\\n\\n                    const num = grid[i + k][j + l];\\n\\n                    if (num === 0 || num > 9 || set.has(num)) { // (2)\\n                        isMagical = false;\\n                        break;\\n                    }\\n\\n                    set.add(num);\\n\\n                    sums[k] += num;\\n                    sums[3 + l] += num;\\n\\n                    if (k === l) sums[6] += num; // left diagonal\\n                    if (k + l === 2) sums[7] += num; // right diagonal\\n                }\\n            } \\n    \\n            if (!isMagical) continue;\\n\\n            let areSame = true; // Boolean to check if all the sums are the same\\n            \\n            for (let i = 1; i < 8; i++) {\\n                if (sums[i] != sums[i - 1]) {\\n                    areSame = false;\\n                    break;\\n                }\\n            }\\n\\n            count += areSame;\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n/**\\nAdditional Notes:\\n1. The first 3 element maintains sum for the 3 rows, the next 3 elements maintain the sum for the columns, \\n\\tand the last two element maintains the sum for the left and right diagonals.\\n\\t\\n2. If the num is out of range of 1 to 9 or if we seen the number already before, we mark the current \\n\\t3x3 square as non magical and break\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n            const sums = new Array(8).fill(0); // (1)\\n            const set = new Set();\\n            \\n            let isMagical = true;\\n\\n            for (let k = 0; k < 3; k++) { // row direction\\n                for (let l = 0; l < 3; l++) { // col direction\\n\\n                    const num = grid[i + k][j + l];\\n\\n                    if (num === 0 || num > 9 || set.has(num)) { // (2)\\n                        isMagical = false;\\n                        break;\\n                    }\\n\\n                    set.add(num);\\n\\n                    sums[k] += num;\\n                    sums[3 + l] += num;\\n\\n                    if (k === l) sums[6] += num; // left diagonal\\n                    if (k + l === 2) sums[7] += num; // right diagonal\\n                }\\n            } \\n    \\n            if (!isMagical) continue;\\n\\n            let areSame = true; // Boolean to check if all the sums are the same\\n            \\n            for (let i = 1; i < 8; i++) {\\n                if (sums[i] != sums[i - 1]) {\\n                    areSame = false;\\n                    break;\\n                }\\n            }\\n\\n            count += areSame;\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n/**\\nAdditional Notes:\\n1. The first 3 element maintains sum for the 3 rows, the next 3 elements maintain the sum for the columns, \\n\\tand the last two element maintains the sum for the left and right diagonals.\\n\\t\\n2. If the num is out of range of 1 to 9 or if we seen the number already before, we mark the current \\n\\t3x3 square as non magical and break\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283640,
                "title": "python-o-n-2-brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def isMagic(i,j):\\n            total = 0\\n            count = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]\\n            distinctDic = collections.defaultdict(int)\\n            #check rows and cols\\n            for r in range(3):\\n                distinctDic[grid[i+r][j]]+=1\\n                distinctDic[grid[i+r][j+1]]+=1\\n                distinctDic[grid[i+r][j+2]]+=1\\n                \\n                \\n                row = grid[i+r][j] + grid[i+r][j+1] + grid[i+r][2+j]\\n                col = grid[i][r+j] + grid[1+i][r+j] + grid[2+i][r+j]\\n                if row != col or row != count:\\n                    return 0\\n             # checks if all numbers are distinct\\n            for num in range(1,10):\\n                if distinctDic[num] == 0:\\n                    return 0\\n                    \\n            return 1 if count == grid[i][2+j] + grid[1+i][1+j] + grid[2+i][j] else 0\\n            \\n        \\n            \\n        r = len(grid)\\n        c = len(grid[0])\\n        \\n        ret = 0\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                ret+=isMagic(i,j)\\n        return ret\\n                \\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def isMagic(i,j):\\n            total = 0\\n            count = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]\\n            distinctDic = collections.defaultdict(int)\\n            #check rows and cols\\n            for r in range(3):\\n                distinctDic[grid[i+r][j]]+=1\\n                distinctDic[grid[i+r][j+1]]+=1\\n                distinctDic[grid[i+r][j+2]]+=1\\n                \\n                \\n                row = grid[i+r][j] + grid[i+r][j+1] + grid[i+r][2+j]\\n                col = grid[i][r+j] + grid[1+i][r+j] + grid[2+i][r+j]\\n                if row != col or row != count:\\n                    return 0\\n             # checks if all numbers are distinct\\n            for num in range(1,10):\\n                if distinctDic[num] == 0:\\n                    return 0\\n                    \\n            return 1 if count == grid[i][2+j] + grid[1+i][1+j] + grid[2+i][j] else 0\\n            \\n        \\n            \\n        r = len(grid)\\n        c = len(grid[0])\\n        \\n        ret = 0\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                ret+=isMagic(i,j)\\n        return ret\\n                \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270304,
                "title": "c-brute-force-o-n-m-important-test-cases",
                "content": "Different test cases:\\n**[[4,3,8,4],[9,5,1,9],[2,7,6,2]]\\n[[10,3,5],[1,6,11],[7,9,2]]\\n[[8]]\\n[[4,4],[4,4]]\\n[[4,3,8],[9,5,1],[2,7,6]]\\n[[7,0,5],[2,4,6],[3,8,1]]\\n[[4,7,8],[9,5,1],[2,3,6]]\\n[[4,3,8],[9,5,1],[2,7,6]]**\\n\\n**OUTPUT:\\n1\\n0\\n0\\n0\\n1\\n0\\n0\\n1**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMagicSquare(vector<vector<int>> &grid, int a, int b, int c, int d) {\\n        --a; --b; --c; --d;\\n        int magicSum = 0;\\n        vector<bool> distinct(9, true);\\n        for (int i = b; i <= d; i++) {\\n            if(distinct[grid[a][i]] == false or grid[a][i] <= 0 or grid[a][i] > 9)\\n                return false;\\n            magicSum += grid[a][i];\\n            distinct[grid[a][i]] = false;\\n        }\\n\\n        // for every row in matrix\\n        for (int i = a + 1; i <= c; i++) {\\n            int rowSum = 0;\\n            for (int j = b; j <= d; j++) {\\n                if(distinct[grid[i][j]] == false or grid[i][j] <= 0 or grid[i][j] > 9)\\n                    return false;\\n                rowSum += grid[i][j];\\n                distinct[grid[i][j]] = false;\\n            }\\n            if (magicSum != rowSum)\\n                return false;\\n        }\\n\\n        // for every column in matrix\\n        for (int j = b; j <= d; j++) {\\n            int colSum = 0;\\n            for (int i = a; i <= c; i++)   \\n                colSum += grid[i][j];\\n            if (magicSum != colSum)\\n                return false;\\n        }\\n\\n        int diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[a + i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n\\n        diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[c - i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(n < 3 or m < 3)\\n            return 0;\\n        int count = 0;\\n        int k = 3;\\n            for (int i = 1; i + k - 1 <= n; i++)\\n                for (int j = 1; j + k - 1 <= m; j++)\\n                    if (isMagicSquare(grid, i, j, i + k - 1, j + k - 1))  \\n                        count++;\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMagicSquare(vector<vector<int>> &grid, int a, int b, int c, int d) {\\n        --a; --b; --c; --d;\\n        int magicSum = 0;\\n        vector<bool> distinct(9, true);\\n        for (int i = b; i <= d; i++) {\\n            if(distinct[grid[a][i]] == false or grid[a][i] <= 0 or grid[a][i] > 9)\\n                return false;\\n            magicSum += grid[a][i];\\n            distinct[grid[a][i]] = false;\\n        }\\n\\n        // for every row in matrix\\n        for (int i = a + 1; i <= c; i++) {\\n            int rowSum = 0;\\n            for (int j = b; j <= d; j++) {\\n                if(distinct[grid[i][j]] == false or grid[i][j] <= 0 or grid[i][j] > 9)\\n                    return false;\\n                rowSum += grid[i][j];\\n                distinct[grid[i][j]] = false;\\n            }\\n            if (magicSum != rowSum)\\n                return false;\\n        }\\n\\n        // for every column in matrix\\n        for (int j = b; j <= d; j++) {\\n            int colSum = 0;\\n            for (int i = a; i <= c; i++)   \\n                colSum += grid[i][j];\\n            if (magicSum != colSum)\\n                return false;\\n        }\\n\\n        int diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[a + i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n\\n        diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[c - i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(n < 3 or m < 3)\\n            return 0;\\n        int count = 0;\\n        int k = 3;\\n            for (int i = 1; i + k - 1 <= n; i++)\\n                for (int j = 1; j + k - 1 <= m; j++)\\n                    if (isMagicSquare(grid, i, j, i + k - 1, j + k - 1))  \\n                        count++;\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564901,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1567304,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1573774,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1572779,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1569228,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1757940,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1573136,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1744405,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            }
        ]
    },
    {
        "title": "Keys and Rooms",
        "question_content": "<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>\n\n<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>\n\n<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1],[2],[3],[]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 133855,
                "title": "straight-forward",
                "content": "**C++:**\\n```\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        stack<int> dfs; dfs.push(0);\\n        unordered_set<int> seen = {0};\\n        while (!dfs.empty()) {\\n            int i = dfs.top(); dfs.pop();\\n            for (int j : rooms[i])\\n                if (seen.count(j) == 0) {\\n                    dfs.push(j);\\n                    seen.insert(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Stack<Integer> dfs = new Stack<>(); dfs.add(0);\\n        HashSet<Integer> seen = new HashSet<Integer>(); seen.add(0);\\n        while (!dfs.isEmpty()) {\\n            int i = dfs.pop();\\n            for (int j : rooms.get(i))\\n                if (!seen.contains(j)) {\\n                    dfs.add(j);\\n                    seen.add(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n```\\n**Python:**\\n```\\n    def canVisitAllRooms(self, rooms):\\n        dfs = [0]\\n        seen = set(dfs)\\n        while dfs:\\n            i = dfs.pop()\\n            for j in rooms[i]:\\n                if j not in seen:\\n                    dfs.append(j)\\n                    seen.add(j)\\n                    if len(seen) == len(rooms): return True\\n        return len(seen) == len(rooms)\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        stack<int> dfs; dfs.push(0);\\n        unordered_set<int> seen = {0};\\n        while (!dfs.empty()) {\\n            int i = dfs.top(); dfs.pop();\\n            for (int j : rooms[i])\\n                if (seen.count(j) == 0) {\\n                    dfs.push(j);\\n                    seen.insert(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n```\n```\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Stack<Integer> dfs = new Stack<>(); dfs.add(0);\\n        HashSet<Integer> seen = new HashSet<Integer>(); seen.add(0);\\n        while (!dfs.isEmpty()) {\\n            int i = dfs.pop();\\n            for (int j : rooms.get(i))\\n                if (!seen.contains(j)) {\\n                    dfs.add(j);\\n                    seen.add(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n```\n```\\n    def canVisitAllRooms(self, rooms):\\n        dfs = [0]\\n        seen = set(dfs)\\n        while dfs:\\n            i = dfs.pop()\\n            for j in rooms[i]:\\n                if j not in seen:\\n                    dfs.append(j)\\n                    seen.add(j)\\n                    if len(seen) == len(rooms): return True\\n        return len(seen) == len(rooms)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 135306,
                "title": "bfs-9-lines-10ms-and-dfs-7-lines-18ms-in-c-w-beginner-friendly-explanation",
                "content": "**BFS:**\\nWe use an unordered_set to record the rooms visited, and a queue for BFS. Push room 0 to queue first.\\nWhile the queue is not empty, meaning we have more rooms to visit, we check all keys in the current room, if we haven\\'t visit all of these rooms, push it to the queue.\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> visited;\\n        queue<int> to_visit;\\n        to_visit.push(0);\\n        while(!to_visit.empty()) {\\n            int curr = to_visit.front();\\n            to_visit.pop();\\n            visited.insert(curr);\\n            for (int k : rooms[curr]) if (visited.find(k) == visited.end()) to_visit.push(k);\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```\\n\\n**DFS:**\\nWhen we enter a room, mark it as visited.\\nThen we put the keys in the current room to our unordered_set keys.\\nCheck all the keys we have, if we haven\\'t visited all corresponding room, go DFS.\\nIf we have visited all rooms, number of visited rooms should be the same as number of rooms.\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& rooms, unordered_set<int> & keys, unordered_set<int> & visited, int curr) {\\n        visited.insert(curr);\\n        for (int k : rooms[curr]) keys.insert(k);\\n        for (int k : keys) if (visited.find(k) == visited.end()) dfs(rooms, keys, visited, k);\\n    }\\n    \\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> keys;\\n        unordered_set<int> visited;\\n        dfs(rooms, keys, visited, 0);\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```\\n\\n**Possible followup**: Why would you use BFS over DFS in this solution (except that DFS takes longer here)?\\nAns: If input is too large, DFS might cause stack overflow.\\n\\n**Some general ideas on how to tackle a whatever-first search problem:**\\nBFS:\\nGeneral Idea of BFS is that we need to use a queue to record which rooms / nodes / blocks that we want to visit in the future, usually we use an unordered_set to record the places that we have visited, so that we don\\'t visit them anymore. \\nFirst we want to push the starting point to the queue, we use a while (!queue.empty()) to make sure there are still work to do. Take the front element from queue, pop queue, then do what you gotta do, for instance insert it into visited, do some calculation, return something if this guy met certain conditions, blah blah. Then we get its neighbors, push them to the queue. \\nIn general, we want to expand one step at a time. \\n\\nDFS:\\nThe general idea of DFS is that we recursively call itself with changing parameters. When we enter DFS, we normally want to check if certain conditions are met, for instance we want to visit all nodes: we first check if our unordered_set visited.size() is the same as node size. If so, return true. We also want to check if current DFS is viable, like is i or j out of boundary? If they are, you should return / return false. \\nThen for each possible ways to go, we try DFS on them: go left, go right, go up, go down, you name it! So unlike BFS, DFS is more like going to one direction straight, if it works that\\'s great, if it doesn\\'t, we come back to the previous recursive call and try another way.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> visited;\\n        queue<int> to_visit;\\n        to_visit.push(0);\\n        while(!to_visit.empty()) {\\n            int curr = to_visit.front();\\n            to_visit.pop();\\n            visited.insert(curr);\\n            for (int k : rooms[curr]) if (visited.find(k) == visited.end()) to_visit.push(k);\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& rooms, unordered_set<int> & keys, unordered_set<int> & visited, int curr) {\\n        visited.insert(curr);\\n        for (int k : rooms[curr]) keys.insert(k);\\n        for (int k : keys) if (visited.find(k) == visited.end()) dfs(rooms, keys, visited, k);\\n    }\\n    \\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> keys;\\n        unordered_set<int> visited;\\n        dfs(rooms, keys, visited, 0);\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664904,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>> &graph, int s, vector<bool> &vis){\\n        vis[s] = true;\\n        for(int i = 0; i < graph[s].size(); i++){\\n            if(!vis[graph[s][i]]){\\n                dfs(graph, graph[s][i], vis);\\n            }\\n        }\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int i, n=rooms.size();\\n        vector<bool> vis(n, false);\\n        dfs(rooms, 0, vis);\\n        for(i = 0; i < n; i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>> &graph, int s, vector<bool> &vis){\\n        vis[s] = true;\\n        for(int i = 0; i < graph[s].size(); i++){\\n            if(!vis[graph[s][i]]){\\n                dfs(graph, graph[s][i], vis);\\n            }\\n        }\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int i, n=rooms.size();\\n        vector<bool> vis(n, false);\\n        dfs(rooms, 0, vis);\\n        for(i = 0; i < n; i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331847,
                "title": "5-python-solutions",
                "content": "Keep track of which rooms we visit to avoid visiting the same room more than once.\\n\\nRecursive:\\n\\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        visited = set()\\n        \\n        def dfs(room: int) -> None:\\n            if room not in visited: \\n                visited.add(room)\\n                for key in rooms[room]:\\n                    dfs(key)\\n        dfs(0)\\n        return len(visited) == len(rooms)\\n```\\n\\nIterative with a stack (DFS):\\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        to_visit = [0]\\n\\n        while to_visit:\\n            room = to_visit.pop()\\n            if room in visited: continue\\n            visited.add(room)\\n            to_visit.extend(rooms[room])\\n                \\n        return len(visited) == len(rooms)\\n```\\n\\nIterative with a set:\\n\\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        to_visit = {0}\\n\\n        while to_visit:\\n            room = to_visit.pop()\\n            visited.add(room)\\n            to_visit |= set(rooms[room])-visited\\n                \\n        return len(visited) == len(rooms)\\n        \\n```\\n\\nIterative space-optimized with a use of 1000-bit integer to track visited rooms:\\n\\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = 0\\n        ct = 0\\n        to_visit = [0]\\n\\t\\t\\n        while to_visit:\\n            room = to_visit.pop()\\n\\t\\t\\t\\n            mask = 1 << room\\n            if visited & mask: continue\\n\\t\\t\\t\\n            visited |= mask\\n            ct += 1\\n            to_visit.extend(rooms[room])\\n\\t\\t\\t\\n        return ct == len(rooms)\\n```\\n\\nIterative with a list of visited rooms:\\n\\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [0] * len(rooms)\\n        to_visit = [0]\\n        \\n        while to_visit:\\n            room = to_visit.pop()\\n            if visited[room]: continue\\n            visited[room] = 1\\n            to_visit.extend(rooms[room])\\n        \\n        return sum(visited) == len(rooms)\\n```",
                "solutionTags": [],
                "code": "```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        visited = set()\\n        \\n        def dfs(room: int) -> None:\\n            if room not in visited: \\n                visited.add(room)\\n                for key in rooms[room]:\\n                    dfs(key)\\n        dfs(0)\\n        return len(visited) == len(rooms)\\n```\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        to_visit = [0]\\n\\n        while to_visit:\\n            room = to_visit.pop()\\n            if room in visited: continue\\n            visited.add(room)\\n            to_visit.extend(rooms[room])\\n                \\n        return len(visited) == len(rooms)\\n```\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        to_visit = {0}\\n\\n        while to_visit:\\n            room = to_visit.pop()\\n            visited.add(room)\\n            to_visit |= set(rooms[room])-visited\\n                \\n        return len(visited) == len(rooms)\\n        \\n```\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = 0\\n        ct = 0\\n        to_visit = [0]\\n\\t\\t\\n        while to_visit:\\n            room = to_visit.pop()\\n\\t\\t\\t\\n            mask = 1 << room\\n            if visited & mask: continue\\n\\t\\t\\t\\n            visited |= mask\\n            ct += 1\\n            to_visit.extend(rooms[room])\\n\\t\\t\\t\\n        return ct == len(rooms)\\n```\n```\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [0] * len(rooms)\\n        to_visit = [0]\\n        \\n        while to_visit:\\n            room = to_visit.pop()\\n            if visited[room]: continue\\n            visited[room] = 1\\n            to_visit.extend(rooms[room])\\n        \\n        return sum(visited) == len(rooms)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133895,
                "title": "clean-code",
                "content": "```\\nHashSet<Integer> enteredRooms = new HashSet<>();\\n\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n    enterRoom(0, rooms);\\n    return enteredRooms.size() == rooms.size();\\n}\\n\\nprivate void enterRoom(int roomId, List<List<Integer>> rooms) {\\n    enteredRooms.add(roomId);\\n    List<Integer> keysInRoom = rooms.get(roomId);\\n    for (int key: keysInRoom)\\n        if (!enteredRooms.contains(key))\\n            enterRoom(key, rooms);\\n}",
                "solutionTags": [],
                "code": "```\\nHashSet<Integer> enteredRooms = new HashSet<>();\\n\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n    enterRoom(0, rooms);\\n    return enteredRooms.size() == rooms.size();\\n}\\n\\nprivate void enterRoom(int roomId, List<List<Integer>> rooms) {\\n    enteredRooms.add(roomId);\\n    List<Integer> keysInRoom = rooms.get(roomId);\\n    for (int key: keysInRoom)\\n        if (!enteredRooms.contains(key))\\n            enterRoom(key, rooms);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 133944,
                "title": "java-8-lines",
                "content": "Just store all the keys we got ( equals to the rooms can visit) to a set then judge whether the size==rooms.size; \\n```\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n    Set<Integer> visited=new HashSet<>();\\n    addKey(0, rooms,visited);\\n    return visited.size() == rooms.size();\\n}\\n\\nprivate void addKey(int room, List<List<Integer>> rooms,Set<Integer> visited) {\\n    visited.add(room);\\n    for (int key: rooms.get(room))\\n        if (!visited.contains(key)) addKey(key, rooms,visited);\\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n    Set<Integer> visited=new HashSet<>();\\n    addKey(0, rooms,visited);\\n    return visited.size() == rooms.size();\\n}\\n\\nprivate void addKey(int room, List<List<Integer>> rooms,Set<Integer> visited) {\\n    visited.add(room);\\n    for (int key: rooms.get(room))\\n        if (!visited.contains(key)) addKey(key, rooms,visited);\\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116703,
                "title": "python-simple-dfs-oneliner-explained",
                "content": "The main idea you need to understand to solve this problem that it is a graph problem. We have list of rooms - nodes and for each room you have list of keys, this is edges which go from this node. Problem is asking if you can traverse all graph, starting from node `0`. As usual, there are different ways to do it:\\n1. iterative `dfs` with stack\\n2. recursive `dfs` without explicit stack (however we have implicit stack)\\n3. `bfs`, using queue.\\n\\nWhenever I can I choose recursive `dfs`, because it is the easiest to code: we keep set of visited nodes, and for `dfs(room)` we try to visit all new rooms which we can open with keys, which we did not visit yet, run then to visited set and run `dfs` recursively. In the end we check that length of visited set is equal to length of total number of rooms.\\n\\n**Complexity**: time complexity is `O(N+E)`, where `N` is number of rooms ans `E` is total number of keys. Space complexity is `O(N)` - size of `visited` and size of implicit stack as well.\\n\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        visited = set([0])\\n        \\n        def dfs(room):\\n            for neib in rooms[room]:\\n                if neib not in visited:\\n                    visited.add(neib)\\n                    dfs(neib)\\n                    \\n        dfs(0)\\n        return len(visited) == len(rooms)    \\n```\\n\\n### Oneliner, just for fun:\\nIdea is to construct adjacency matrix and then use matrix exponent to understand if we can reach nodes or not.\\n```\\nfrom scipy.sparse.linalg import expm\\n\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        return 0 not in expm([[j in r + [i] for j in range(len(rooms))] for i,r in enumerate(rooms)])[0]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        visited = set([0])\\n        \\n        def dfs(room):\\n            for neib in rooms[room]:\\n                if neib not in visited:\\n                    visited.add(neib)\\n                    dfs(neib)\\n                    \\n        dfs(0)\\n        return len(visited) == len(rooms)    \\n```\n```\\nfrom scipy.sparse.linalg import expm\\n\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        return 0 not in expm([[j in r + [i] for j in range(len(rooms))] for i,r in enumerate(rooms)])[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116825,
                "title": "bfs-and-dfs-solution-w-explanation-short-easy",
                "content": "The problem asks us to check if we can visit every room starting from the room 0. This can be viewed as a **graph problem** where we want to check if we can visited every node if we start from `node 0`. The rooms are the nodes and keys are the edges of the graph.\\n\\n----------\\n\\n***Solution - I (Depth-First Search)***\\n\\n\\nThis can be done easily using a DFS. We only initiate the DFS from the `node 0` and once the DFS is complete, we check if every room is visited or not.\\n\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/9f12d683-452d-4911-b045-ad4a3a072a8e_1616144286.1954126.png)\\n\\n\\n------------\\n-----------\\n\\n***Solution - II (Breadth-First Search)***\\n\\nWe can also solve the problem using a BFS appraoch -\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/40ccb23c-f0e8-4e7d-ba4d-1c95bdd2c070_1616144264.2904758.png)\\n\\n-------------\\n-------------\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116836,
                "title": "python3-soln-keys-and-rooms-stack-implementation",
                "content": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited_rooms = set()\\n        stack = [0] # for rooms that we need to visit and we start from room [0]\\n        \\n        while stack: \\n            room = stack.pop() \\n            visited_rooms.add(room)\\n            for key in rooms[room]:\\n                if key not in visited_rooms:\\n                    stack.append(key)\\n        return len(visited_rooms) == len(rooms)            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited_rooms = set()\\n        stack = [0] # for rooms that we need to visit and we start from room [0]\\n        \\n        while stack: \\n            room = stack.pop() \\n            visited_rooms.add(room)\\n            for key in rooms[room]:\\n                if key not in visited_rooms:\\n                    stack.append(key)\\n        return len(visited_rooms) == len(rooms)            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930127,
                "title": "python3-dfs-bfs-explained",
                "content": "The problem can be seen as a graph problem, where the rooms are the nodes and the keys in each room are its neighbors (i.e., there is a directed edge connecting this room and the key\\'s room). Starting from node 0, we want to see if we can traverse the entire graph or not. **BFS** and **DFS** are the two algorithms that come to my mind, and since this problem has nothing to do with distance, shortest path, etc. **DFS** is a very good candidate. \\n\\n**DFS (recursion)**\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        # Track the visited node.\\n        visited = set()\\n\\n        # Go from one node (room) to another as much as possible.\\n        def dfs(node):\\n        \\t# We don\\'t really need to return anything here, \\n        \\t# since we just want to add the new node to the visited list in this function.\\n            \\n            if node in visited:\\n                return\\n            \\n            visited.add(node)\\n            \\n            for k in rooms[node]:\\n                dfs(k)\\n        \\n        dfs(0)\\n\\n        # Return True if we visited all the rooms\\n        return len(visited) == len(rooms)\\n```\\n\\n**DFS (iterative)**\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        stack = [0]\\n        visited = {0}\\n        while stack:\\n            node = stack.pop()\\n            for k in rooms[node]:\\n                if k not in visited:\\n                    visited.add(k)\\n                    stack.append(k)\\n        return len(visited) == len(rooms)\\n```\\n\\n**BFS**\\nNote that using BFS in this problem doesn\\'t make much sense since we are not trying to find a shortest path but only trying to expand the connected rooms as much as possible. And you can see that we are not tracking any distance-related information in the BFS implementation, which makes it more or less the same as the DFS except the ```popleft()```.\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        q = deque([0])\\n        visited = {0}\\n        while q:\\n            node = q.popleft()\\n            for k in rooms[node]:\\n                if k not in visited:\\n                    visited.add(k)\\n                    q.append(k)\\n        return len(visited) == len(rooms)\\n```\\n\\n**Union-find**\\nOne may wondering why Union-find doesnot work here, this is because the graph in this problem is directed!\\n```rooms[i]``` has keys means: the ```rooms[i]``` is connected to the ```keys[j]``` (```keys[j]``` represent a room as well, i.e., the room can be opened by ```keys[j]```). However, this doesn\\'t mean ```keys[j]``` is connected to ```rooms[i]```, because the room ```keys[j]``` may not have the key to ```rooms[i]```. So the edge has direction.\\nWhen we say \\'a **union** b\\' we cannot make out the direction of edge\\nis a going to b? (or)\\nis b going to a?\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        # Track the visited node.\\n        visited = set()\\n\\n        # Go from one node (room) to another as much as possible.\\n        def dfs(node):\\n        \\t# We don\\'t really need to return anything here, \\n        \\t# since we just want to add the new node to the visited list in this function.\\n            \\n            if node in visited:\\n                return\\n            \\n            visited.add(node)\\n            \\n            for k in rooms[node]:\\n                dfs(k)\\n        \\n        dfs(0)\\n\\n        # Return True if we visited all the rooms\\n        return len(visited) == len(rooms)\\n```\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        stack = [0]\\n        visited = {0}\\n        while stack:\\n            node = stack.pop()\\n            for k in rooms[node]:\\n                if k not in visited:\\n                    visited.add(k)\\n                    stack.append(k)\\n        return len(visited) == len(rooms)\\n```\n```popleft()```\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        q = deque([0])\\n        visited = {0}\\n        while q:\\n            node = q.popleft()\\n            for k in rooms[node]:\\n                if k not in visited:\\n                    visited.add(k)\\n                    q.append(k)\\n        return len(visited) == len(rooms)\\n```\n```rooms[i]```\n```rooms[i]```\n```keys[j]```\n```keys[j]```\n```keys[j]```\n```keys[j]```\n```rooms[i]```\n```keys[j]```\n```rooms[i]```",
                "codeTag": "Java"
            },
            {
                "id": 2930099,
                "title": "python-c-iterative-dfs-bfs-bonus-2-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs several approaches to visit rooms. \\n****\\n\\n**Python #1.** Iterative solution.\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        seen, keys = set(), set({0})\\n\\n        while len(seen) != len(keys):\\n            for k in list(keys):\\n                if k not in seen:\\n                    seen.add(k)\\n                    keys.update(rooms[k])\\n        \\n        return len(seen) == len(rooms)\\n```\\n\\n**Python #2.** DFS.\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        seen = set({0})\\n\\n        def dfs(r):\\n            for k in rooms[r]:\\n                if k not in seen:\\n                    seen.add(k), dfs(k)\\n        \\n        dfs(0)\\n        \\n        return len(seen) == len(rooms)\\n```\\n\\n**C++.** BFS.\\n```\\nclass Solution \\n{\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        deque<int> Q({0});\\n        unordered_set<int> seen;\\n        while (!Q.empty())\\n        {\\n            int r = Q.front(); Q.pop_front();\\n            seen.insert(r);\\n            for (int k : rooms[r])\\n                if (!seen.count(k))\\n                    Q.push_back(k);\\n        }\\n        \\n        return seen.size() == rooms.size();\\n    }\\n};\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** The DFS solution can be compactified to a 2-liner.\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rs: List[List[int]]) -> bool:\\n\\n        def dfs(r,s) : return sum(s.add(k) or 1 + dfs(k,s) for k in rs[r] if k not in s)\\n        return dfs(0,{0}) + 1 == len(rs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        seen, keys = set(), set({0})\\n\\n        while len(seen) != len(keys):\\n            for k in list(keys):\\n                if k not in seen:\\n                    seen.add(k)\\n                    keys.update(rooms[k])\\n        \\n        return len(seen) == len(rooms)\\n```\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        seen = set({0})\\n\\n        def dfs(r):\\n            for k in rooms[r]:\\n                if k not in seen:\\n                    seen.add(k), dfs(k)\\n        \\n        dfs(0)\\n        \\n        return len(seen) == len(rooms)\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        deque<int> Q({0});\\n        unordered_set<int> seen;\\n        while (!Q.empty())\\n        {\\n            int r = Q.front(); Q.pop_front();\\n            seen.insert(r);\\n            for (int k : rooms[r])\\n                if (!seen.count(k))\\n                    Q.push_back(k);\\n        }\\n        \\n        return seen.size() == rooms.size();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rs: List[List[int]]) -> bool:\\n\\n        def dfs(r,s) : return sum(s.add(k) or 1 + dfs(k,s) for k in rs[r] if k not in s)\\n        return dfs(0,{0}) + 1 == len(rs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116707,
                "title": "js-python-java-c-easy-dfs-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince we can only enter rooms to which we have found a key, we can\\'t just iterate through the entire input array (**R**) normally. If we think of this like a graph problem, we can see that the rooms are like nodes and the keys are like edges.\\n\\nIn that case, we can use a **breadth-first search** (**BFS**) **queue** or a **depth-first search** (**DFS**) **stack** approach, or even a **DFS recursion** approach here to good effect. Here, we\\'ll push newly found keys onto **stack** as we go through.\\n\\nTo eliminate duplicate stack entries, we can use a lightweight **boolean array** (**vis**) to keep track of which rooms have already been pushed onto the stack. Rather than having to count the number of visited rooms again at the end, we can just use another variable (**count**) to keep track of that separately.\\n\\nOnce our stack runs empty, we can just check to see if the **count** is the same as the length of **R** and **return** the answer.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use a Uint8Array instead of a boolean array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 60%).\\n```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **52ms / 14.6MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.4MB** (beats 86% / 100%).\\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.4MB** (beats 99% / 67%).\\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133845,
                "title": "c-straight-forward-bfs-solution-with-explanation",
                "content": "This is a straight fwd graph traversal problem and can be solved by BFS with a `visited` array. Idea is to go inside a room, mark it visited and go to all other rooms reachable from the keys present inside this current room. And so on till we have no more rooms are left to visit. Finally, check if we have visited all rooms. If so, return true. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool> visited( rooms.size(), false );\\n        queue<int> q;\\n        q.push( 0 );// Start from room 0.        \\n        while( !q.empty() ) {\\n            int size = q.size();\\n            for( int i = 0; i < size; i++ ) {\\n                int room = q.front(); q.pop();\\n                visited[room] = true;\\n                for( int ele: rooms[room])\\n                    if ( !visited[ele] ) q.push( ele );\\n            }\\n        }\\n        return count( visited.begin(), visited.end(), true ) == rooms.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool> visited( rooms.size(), false );\\n        queue<int> q;\\n        q.push( 0 );// Start from room 0.        \\n        while( !q.empty() ) {\\n            int size = q.size();\\n            for( int i = 0; i < size; i++ ) {\\n                int room = q.front(); q.pop();\\n                visited[room] = true;\\n                for( int ele: rooms[room])\\n                    if ( !visited[ele] ) q.push( ele );\\n            }\\n        }\\n        return count( visited.begin(), visited.end(), true ) == rooms.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500961,
                "title": "c-2-solutions-bfs-dfs-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        unordered_set<int> seen;\\n        seen.insert(0);\\n        queue<int> q;\\n        q.push(0);\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int nextRoom : rooms[u]) {\\n                if (seen.count(nextRoom)) continue;\\n                seen.insert(nextRoom);\\n                q.push(nextRoom);\\n            }\\n        }\\n        return seen.size() == n;\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3000` is total number of edges which is `sum(rooms[i].length)`, `N <= 1000` is number of vertices.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> seen;\\n        dfs(rooms, 0, seen);\\n        return seen.size() == rooms.size();\\n    }\\n    void dfs(vector<vector<int>>& rooms, int src, unordered_set<int>& seen) {\\n        if (seen.count(src)) return;\\n        seen.insert(src);\\n        for (int room : rooms[src]) {\\n            dfs(rooms, room, seen);\\n        }\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3000` is total number of edges which is `sum(rooms[i].length)`, `N <= 1000` is number of vertices.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        unordered_set<int> seen;\\n        seen.insert(0);\\n        queue<int> q;\\n        q.push(0);\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int nextRoom : rooms[u]) {\\n                if (seen.count(nextRoom)) continue;\\n                seen.insert(nextRoom);\\n                q.push(nextRoom);\\n            }\\n        }\\n        return seen.size() == n;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> seen;\\n        dfs(rooms, 0, seen);\\n        return seen.size() == rooms.size();\\n    }\\n    void dfs(vector<vector<int>>& rooms, int src, unordered_set<int>& seen) {\\n        if (seen.count(src)) return;\\n        seen.insert(src);\\n        for (int room : rooms[src]) {\\n            dfs(rooms, room, seen);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930947,
                "title": "c-dfs-bfs-intuitive-approach",
                "content": "# Intuition\\nWe need to use BFS/DFS traversal technique to visit all rooms.\\n\\n# Approach\\nWe define visited array and while visiting all rooms we mark visited rooms. At last we check whether all rooms are visited or not. \\n\\n# DFS\\n```\\nclass Solution \\n{\\npublic:\\n    \\n    void dfs(int i, vector<vector<int>> & rooms, vector<int> &vis)\\n    {\\n        vis[i]=1;\\n        for(auto key: rooms[i])\\n            if(!vis[key])\\n                dfs(key, rooms, vis);\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        vector<int> vis(rooms.size(), 0);\\n        \\n        dfs(0, rooms, vis);\\n        \\n        for(auto it:vis)\\n            if(!it) return false;\\n        \\n        return true;\\n        \\n    }\\n};\\n```\\n## Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n) ~ O(n)\\n\\n# BFS\\n```\\nclass Solution \\n{\\npublic:\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n=rooms.size();\\n        vector<int> vis(n, 0);\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int curr_room = q.front(); q.pop();\\n            vis[curr_room] = 1;\\n            for(auto key:rooms[curr_room])\\n                if(!vis[key])\\n                    q.push(key);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n            if(!vis[i]) return false;\\n           \\n        return true;\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n) ~ O(n)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    void dfs(int i, vector<vector<int>> & rooms, vector<int> &vis)\\n    {\\n        vis[i]=1;\\n        for(auto key: rooms[i])\\n            if(!vis[key])\\n                dfs(key, rooms, vis);\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        vector<int> vis(rooms.size(), 0);\\n        \\n        dfs(0, rooms, vis);\\n        \\n        for(auto it:vis)\\n            if(!it) return false;\\n        \\n        return true;\\n        \\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n=rooms.size();\\n        vector<int> vis(n, 0);\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int curr_room = q.front(); q.pop();\\n            vis[curr_room] = 1;\\n            for(auto key:rooms[curr_room])\\n                if(!vis[key])\\n                    q.push(key);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n            if(!vis[i]) return false;\\n           \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395642,
                "title": "java-dfs-0ms-100-a-tale-of-two-friends-dfs-and-visited-boolean-array",
                "content": "```\\nBelow is a short story of two friends who cannot work without each other. Want to read there story ? Go on.....\\n\\nThis is typical DFS problem. Recursively go to each room, if it has any keys, use them one by one i.e they are nothing but keys to other rooms, so get key to next room one after the other, go to that next room, find keys in the new room and repeat above step.\\n\\ni.e. Initially u r at room 0, get all possible keys in that room, for each key, go to that room, find keys in that room and go to those next next rooms,  repeat this step. \\n\\nDo you know DFS ? I am assuming yes. \\nDFS is nothing without his friend visited boolean array.\\nHe is the one using whom DFS will end the recursion, else we will keep visiting rooms one after the other. \\n\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean visited[] = new boolean[rooms.size()];\\n        dfs(rooms.get(0), 0, rooms, visited);\\n\\n        for(int i=0;i<visited.length;i++) {\\n            if(!visited[i]) {\\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n    \\n    private void dfs(List<Integer> keysInRoom, int room, List<List<Integer>> rooms, boolean[] visited) {\\n        visited[room] = true;\\n\\n        for(Integer i: keysInRoom) {\\n            if(!visited[i]) {\\n                dfs(rooms.get(i), i, rooms, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nBelow is a short story of two friends who cannot work without each other. Want to read there story ? Go on.....\\n\\nThis is typical DFS problem. Recursively go to each room, if it has any keys, use them one by one i.e they are nothing but keys to other rooms, so get key to next room one after the other, go to that next room, find keys in the new room and repeat above step.\\n\\ni.e. Initially u r at room 0, get all possible keys in that room, for each key, go to that room, find keys in that room and go to those next next rooms,  repeat this step. \\n\\nDo you know DFS ? I am assuming yes. \\nDFS is nothing without his friend visited boolean array.\\nHe is the one using whom DFS will end the recursion, else we will keep visiting rooms one after the other. \\n\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean visited[] = new boolean[rooms.size()];\\n        dfs(rooms.get(0), 0, rooms, visited);\\n\\n        for(int i=0;i<visited.length;i++) {\\n            if(!visited[i]) {\\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n    \\n    private void dfs(List<Integer> keysInRoom, int room, List<List<Integer>> rooms, boolean[] visited) {\\n        visited[room] = true;\\n\\n        for(Integer i: keysInRoom) {\\n            if(!visited[i]) {\\n                dfs(rooms.get(i), i, rooms, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930987,
                "title": "c-simple-bfs-traversal",
                "content": "# Intuition\\nTaking this case for example :\\n\\nrooms = [[1,3],[3,0,1],[2],[0]]\\n\\nVisit room number 0 (`root`) and store the keys of rooms that room 0 contains (`children`), for example, suppose rooms[0] contains [1,3], keys to room number 1 and 3. Likewise visiting every room with a key available to unlock it.(`path`)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI took **queue** to store the rooms to be visited. (Refer to code for steps)\\n> 1. As room number **0** will always be open push it onto queue.\\n> 2. While queue contains rooms to be explored, transfer room number at front in queue to temp variable and remove the room from queue after exploring it.\\n> 3. If room already visited ignore exploring that.\\n>4. Push keys of rooms in the to queue.\\n>5. If any room left to enter return false.\\n\\n\\n# Complexity\\n- Time complexity: $$O(number of Rooms + number of Keys)$$\\n\\n---\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        queue<int> q;\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        q.push(0);  // 1\\n\\n        while(!q.empty()){\\n            \\n            int temp = q.front();     // 2\\n            q.pop();                 \\n            \\n            if(vis[temp] == true) continue; // 3\\n            vis[temp] = true;\\n            \\n            for(auto room : rooms[temp]){   // 4\\n                q.push(room);\\n            }\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){         // 5\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        queue<int> q;\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        q.push(0);  // 1\\n\\n        while(!q.empty()){\\n            \\n            int temp = q.front();     // 2\\n            q.pop();                 \\n            \\n            if(vis[temp] == true) continue; // 3\\n            vis[temp] = true;\\n            \\n            for(auto room : rooms[temp]){   // 4\\n                q.push(room);\\n            }\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){         // 5\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598969,
                "title": "0-ms-100-faster-java-solution-easy-to-understand",
                "content": "Ask if there\\'s any doubt.\\n```\\nclass Solution {\\n    boolean[] v;\\n    public boolean canVisitAllRooms(List<List<Integer>> r) {\\n        int n=r.size();\\n        v=new boolean[n];\\n        solve(r, n, 0);\\n        for(int i=0;i<n;i++){\\n            if(!v[i]) return false;\\n        }\\n        return true;\\n    }\\n    void solve(List<List<Integer>> r, int n, int ind){\\n        if(ind>=n) return;\\n        if(v[ind]) return;\\n        v[ind]=true;\\n        for(int i=0;i<r.get(ind).size();i++){\\n            solve(r, n, r.get(ind).get(i));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] v;\\n    public boolean canVisitAllRooms(List<List<Integer>> r) {\\n        int n=r.size();\\n        v=new boolean[n];\\n        solve(r, n, 0);\\n        for(int i=0;i<n;i++){\\n            if(!v[i]) return false;\\n        }\\n        return true;\\n    }\\n    void solve(List<List<Integer>> r, int n, int ind){\\n        if(ind>=n) return;\\n        if(v[ind]) return;\\n        v[ind]=true;\\n        for(int i=0;i<r.get(ind).size();i++){\\n            solve(r, n, r.get(ind).get(i));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931019,
                "title": "c-bfs-dsf-comments-added",
                "content": "If I can visit all the rooms from room Number 0 then I need to return **true else false**\\n\\nso what we can do, we can traverse through the given vector and keep track of a visited array and If I can visit whole array then return **true else false**.\\n\\n\\n**BFS Approach**\\n```\\nclass Solution \\n{\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        \\n        queue<int> q;\\n        q.push(0);                       // start from 0 because it is unlocked room\\n        vis[0]=true;\\n        \\n        while(!q.empty())\\n        {\\n            int room = q.front();\\n            q.pop();\\n            \\n            for(auto it : rooms[room])\\n            {\\n                if(!vis[it])\\n                {\\n                    q.push(it);\\n                    vis[it]=true;\\n                }\\n            }\\n        }\\n        \\n        for(auto it : vis)\\n        {\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n**DSF Approach**\\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(int room,vector<bool>& vis,vector<vector<int>>& rooms)\\n    {\\n        vis[room] = true;\\n        for(auto it : rooms[room])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,rooms);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        \\n        // dfs traversal\\n        dfs(0,vis,rooms);               // starts from 0 because it is unlocked room\\n        \\n        for(auto it : vis)\\n        {\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        \\n        queue<int> q;\\n        q.push(0);                       // start from 0 because it is unlocked room\\n        vis[0]=true;\\n        \\n        while(!q.empty())\\n        {\\n            int room = q.front();\\n            q.pop();\\n            \\n            for(auto it : rooms[room])\\n            {\\n                if(!vis[it])\\n                {\\n                    q.push(it);\\n                    vis[it]=true;\\n                }\\n            }\\n        }\\n        \\n        for(auto it : vis)\\n        {\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(int room,vector<bool>& vis,vector<vector<int>>& rooms)\\n    {\\n        vis[room] = true;\\n        for(auto it : rooms[room])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,rooms);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        \\n        // dfs traversal\\n        dfs(0,vis,rooms);               // starts from 0 because it is unlocked room\\n        \\n        for(auto it : vis)\\n        {\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770073,
                "title": "c-simple-graph-dfs-bfs-traversal-question-well-explained",
                "content": "**Approach:**\\nAfter reading the question one can easily think it as a graph DS, where each room is connected to other rooms.\\nLike:\\n0 --> 1,2,3\\n1 --->2,3\\netc\\n\\nSince you can only start from room 0 ,so just start traversing using  dfs or BFS from room 0 and mark all the rooms which can be visited.\\n\\nIf all rooms are marked as visited -->return true -->else false.\\n\\n**DFS Solution:**\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int st, vector<vector<int>>& rooms, vector<bool> &visited){\\n        visited[st] = true;\\n        for(int i : rooms[st]){\\n            if(!visited[i]){\\n                dfs(i, rooms, visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n,0);\\n        \\n        dfs(0, rooms, visited); // DO dfs starting from room 0\\n        \\n        //Check if all rooms are visited or not\\n        for(bool i : visited){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**BFS Sol:**\\n```\\nclass Solution {\\npublic:\\n    \\n    void bfs(int startRoom, vector<vector<int>>& rooms, vector<bool> &visited){\\n        queue<int> q;\\n        visited[startRoom] = true;\\n        q.push(startRoom);\\n        \\n        while(!q.empty()){\\n            int currRoom = q.front();\\n            q.pop();\\n            \\n            for(int connectedRoom : rooms[currRoom]){\\n                if(!visited[connectedRoom]){\\n                    visited[connectedRoom] = true;\\n                    q.push(connectedRoom);\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n,0);\\n        \\n        bfs(0, rooms, visited); // DO bfs starting from room 0\\n        \\n        //Check if all rooms are visited or not\\n        for(bool i : visited){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nHope this helps!\\n\\nPlease upVote if you like the solution and explanation :) !\\nEveryone loves when their efforts are appreciated, it keeps them motivated :) \\n\\nHappy Coding!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int st, vector<vector<int>>& rooms, vector<bool> &visited){\\n        visited[st] = true;\\n        for(int i : rooms[st]){\\n            if(!visited[i]){\\n                dfs(i, rooms, visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n,0);\\n        \\n        dfs(0, rooms, visited); // DO dfs starting from room 0\\n        \\n        //Check if all rooms are visited or not\\n        for(bool i : visited){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void bfs(int startRoom, vector<vector<int>>& rooms, vector<bool> &visited){\\n        queue<int> q;\\n        visited[startRoom] = true;\\n        q.push(startRoom);\\n        \\n        while(!q.empty()){\\n            int currRoom = q.front();\\n            q.pop();\\n            \\n            for(int connectedRoom : rooms[currRoom]){\\n                if(!visited[connectedRoom]){\\n                    visited[connectedRoom] = true;\\n                    q.push(connectedRoom);\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n,0);\\n        \\n        bfs(0, rooms, visited); // DO bfs starting from room 0\\n        \\n        //Check if all rooms are visited or not\\n        for(bool i : visited){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135840,
                "title": "python-simple-recursive-dfs",
                "content": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        \"\"\"\\n        :type rooms: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n        return len(self.dfs(rooms, [])) == len(rooms)\\n    \\n    def dfs(self, rooms, path, source=0):\\n        path += [source]\\n        \\n        for k in rooms[source]:\\n            if k not in set(path):\\n                self.dfs(rooms, path, k)\\n        return path\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        \"\"\"\\n        :type rooms: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n        return len(self.dfs(rooms, [])) == len(rooms)\\n    \\n    def dfs(self, rooms, path, source=0):\\n        path += [source]\\n        \\n        for k in rooms[source]:\\n            if k not in set(path):\\n                self.dfs(rooms, path, k)\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930084,
                "title": "daily-leetcoding-challenge-december-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/keys-and-rooms/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/keys-and-rooms/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2080113,
                "title": "java-beginners-solution",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        int n = rooms.size();\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0); // we assume that we have 0th room\\'s key\\n        \\n        while(!q.isEmpty())\\n        {\\n            int curr = q.poll();\\n            visited[curr] = true;\\n            for(int el : rooms.get(curr))\\n            {\\n                if(!visited[el])\\n                q.add(el);\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(boolean el : visited)\\n        {\\n            if(!el) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        int n = rooms.size();\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0); // we assume that we have 0th room\\'s key\\n        \\n        while(!q.isEmpty())\\n        {\\n            int curr = q.poll();\\n            visited[curr] = true;\\n            for(int el : rooms.get(curr))\\n            {\\n                if(!visited[el])\\n                q.add(el);\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(boolean el : visited)\\n        {\\n            if(!el) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133853,
                "title": "python-7-lines-easy-to-understand-44-ms",
                "content": "Just remove room from pool set if it is visited and return boolean of emptiness of set.\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        pool, stack = set(range(len(rooms))), [0]\\n        while stack: \\n            pool.discard(stack[-1])\\n            for nex in rooms[stack.pop()]:\\n                if nex in pool: \\n                    stack.append(nex)\\n        return not pool\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms):\\n        pool, stack = set(range(len(rooms))), [0]\\n        while stack: \\n            pool.discard(stack[-1])\\n            for nex in rooms[stack.pop()]:\\n                if nex in pool: \\n                    stack.append(nex)\\n        return not pool\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928136,
                "title": "dfs-cpp-easy-approach",
                "content": "# Intuition\\nWe have to check first can we visit every node(room) with using adj list(rooms)\\n\\n# Approach\\nUsing DFS we can check we can visit every node(room) or not. If we cannot visit then return False otherwise True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void traverse(int node,map<int,bool>& vis,vector<vector<int>>& adj)\\n    {\\n        vis[node]=true;\\n\\n        for(auto i:adj[node])\\n        {\\n            if(!vis[i])\\n            {\\n                traverse(i,vis,adj);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n       \\n        int n=rooms.size();\\n         map<int,bool> vis;\\n        for(int i=0;i<n;i++)\\n        {\\n             vis[i]=false;\\n        }\\n        \\n        traverse(0,vis,rooms);\\n\\n\\n        for(int i=0;i<vis.size();i++)\\n        {\\n            if(!vis[i])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(int node,map<int,bool>& vis,vector<vector<int>>& adj)\\n    {\\n        vis[node]=true;\\n\\n        for(auto i:adj[node])\\n        {\\n            if(!vis[i])\\n            {\\n                traverse(i,vis,adj);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n       \\n        int n=rooms.size();\\n         map<int,bool> vis;\\n        for(int i=0;i<n;i++)\\n        {\\n             vis[i]=false;\\n        }\\n        \\n        traverse(0,vis,rooms);\\n\\n\\n        for(int i=0;i<vis.size();i++)\\n        {\\n            if(!vis[i])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375576,
                "title": "c-easy-solution-dfs-bfs",
                "content": "# Intuition\\nThe key to one of the rooms leads to a key to another room. Solution can be done using DFS/BFS. \\n\\n# Approach\\nApply simple DFS/BFS and check whether all rooms are visited.\\n\\nDFS: Apply dfs to every successor recursively if it is not visited.\\n\\nBFS: Push every successor into queue if it is not visited.\\n\\n# Complexity\\n- Time complexity:\\nDFS: O(N+M)\\nBFS: O(N+M)\\n\\n- Space complexity:\\nDFS: O(H) where H is the maximum height of the graph\\nBFS: O(W) where W is the maximum width of the graph\\n\\n# Code\\n```\\n//Using DFS\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<int>adj[],vector<bool>&vis){\\n    vis[node] = 1;\\n    for(auto child: adj[node]){\\n        if(!vis[child]){\\n            dfs(child,adj,vis);\\n        }\\n    }\\n}\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        vector<bool>vis(n,0);\\n        dfs(0,adj,vis);\\n        for(int i = 0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```\\n//Using BFS\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        vector<bool>vis(n,0);\\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            vis[node] = 1;\\n            for(auto child: adj[node]){\\n                if(!vis[child]){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n//Using DFS\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<int>adj[],vector<bool>&vis){\\n    vis[node] = 1;\\n    for(auto child: adj[node]){\\n        if(!vis[child]){\\n            dfs(child,adj,vis);\\n        }\\n    }\\n}\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        vector<bool>vis(n,0);\\n        dfs(0,adj,vis);\\n        for(int i = 0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n//Using BFS\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        vector<bool>vis(n,0);\\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            vis[node] = 1;\\n            for(auto child: adj[node]){\\n                if(!vis[child]){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224096,
                "title": "simple-dfs-approach-using-python-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<b>step 1</b> : <br>create hashmap or adjecency list to store the room numbers and their respective keys <br>\\n<pre> {room.no : [keys present]} </pre>\\n\\n<b>step 2</b> : \\ncreate visited set() and stack (empty list) to store the elements over iteration\\n\\nstep 3: \\nadd elements to the stack and update the visted set()\\n\\nstep 4:\\nfinally return if length of visited is equal to lenght of hashmap i.e, total rooms\\n\\n# Complexity\\n- Time complexity: O(n), where n = no.of rooms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n = no.of rooms\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        dic = {}\\n        stack = []\\n\\n        # create dic or adj list\\n        for i in range(len(rooms)):\\n            dic[i] = rooms[i]\\n            \\n        # update stack since room 0 is always allowed\\n        for i in dic[0]:\\n            stack.append(i)\\n\\n        # update the room number to visited\\n        visited.add(0)\\n        \\n        # while stack is not empty\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            visited.add(curr)\\n            for i in dic[curr]:\\n                if i not in visited:\\n                    stack.append(i)\\n        \\n        return len(dic) == len(visited)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        dic = {}\\n        stack = []\\n\\n        # create dic or adj list\\n        for i in range(len(rooms)):\\n            dic[i] = rooms[i]\\n            \\n        # update stack since room 0 is always allowed\\n        for i in dic[0]:\\n            stack.append(i)\\n\\n        # update the room number to visited\\n        visited.add(0)\\n        \\n        # while stack is not empty\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            visited.add(curr)\\n            for i in dic[curr]:\\n                if i not in visited:\\n                    stack.append(i)\\n        \\n        return len(dic) == len(visited)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116708,
                "title": "keys-and-rooms-js-python-java-c-easy-dfs-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince we can only enter rooms to which we have found a key, we can\\'t just iterate through the entire input array (**R**) normally. If we think of this like a graph problem, we can see that the rooms are like nodes and the keys are like edges.\\n\\nIn that case, we can use a **breadth-first search** (**BFS**) **queue** or a **depth-first search** (**DFS**) **stack** approach, or even a **DFS recursion** approach here to good effect. Here, we\\'ll push newly found keys onto **stack** as we go through.\\n\\nTo eliminate duplicate stack entries, we can use a lightweight **boolean array** (**vis**) to keep track of which rooms have already been pushed onto the stack. Rather than having to count the number of visited rooms again at the end, we can just use another variable (**count**) to keep track of that separately.\\n\\nOnce our stack runs empty, we can just check to see if the **count** is the same as the length of **R** and **return** the answer.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use a Uint8Array instead of a boolean array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 60%).\\n```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **52ms / 14.6MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.4MB** (beats 86% / 100%).\\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.4MB** (beats 99% / 67%).\\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008211,
                "title": "python-dfs-bfs",
                "content": "DFS:\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [True] + [False]*(len(rooms) - 1)\\n        stack = [0]\\n        while stack:\\n            cur = stack.pop()\\n            for room in rooms[cur]:\\n                if not visited[room]:\\n                    visited[room] = True\\n                    stack.append(room)\\n        return all(visited)\\n```\\nBFS:\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [True] + [False]*(len(rooms) - 1)\\n        dq = deque([0])\\n        while dq:\\n            cur = dq.popleft()\\n            for room in rooms[cur]:\\n                if not visited[room]:\\n                    visited[room] = True\\n                    dq.append(room)\\n        return all(visited)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [True] + [False]*(len(rooms) - 1)\\n        stack = [0]\\n        while stack:\\n            cur = stack.pop()\\n            for room in rooms[cur]:\\n                if not visited[room]:\\n                    visited[room] = True\\n                    stack.append(room)\\n        return all(visited)\\n```\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = [True] + [False]*(len(rooms) - 1)\\n        dq = deque([0])\\n        while dq:\\n            cur = dq.popleft()\\n            for room in rooms[cur]:\\n                if not visited[room]:\\n                    visited[room] = True\\n                    dq.append(room)\\n        return all(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200749,
                "title": "java-dfs-bfs-solution-with-explanation",
                "content": "```\\n/*\\nRecursive DFS:\\nUse a set to track rooms that have been visited.\\nStarting from room 0, add 0 to the visited set, for each key in room 0, \\nif the key is not visited yet, add the key to visited and recursively visit keys in that room,\\notherwise do not visit the room again.\\nWe can visit all rooms only when the size of visited set equals to the size of the rooms.\\n\\nIterative BFS:\\nUse a queue to keep the keys we found in a room, only enqueue the keys not visited yet.\\nRepeat until the queue is empty, and check if size of visited set equals size of rooms.\\n*/\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        if(rooms == null || rooms.size() == 0) return false;\\n        Set<Integer> visited = new HashSet<>();\\n        visitBFS(rooms, 0, visited);\\n        return visited.size() == rooms.size();\\n    }\\n    \\n    private void visitDFS(List<List<Integer>> rooms, Integer i, Set<Integer> visited) {\\n        if(visited.contains(i)) return;\\n        visited.add(i);\\n        for(Integer key : rooms.get(i)) {\\n            visitDFS(rooms, key, visited);\\n        }\\n    }\\n    \\n    private void visitBFS(List<List<Integer>> rooms, Integer i, Set<Integer> visited) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(i);\\n        while(!queue.isEmpty()){\\n            Integer key = queue.poll();\\n            visited.add(key);\\n            for(Integer k : rooms.get(key)){\\n                if(!visited.contains(k)){\\n                    queue.offer(k);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRecursive DFS:\\nUse a set to track rooms that have been visited.\\nStarting from room 0, add 0 to the visited set, for each key in room 0, \\nif the key is not visited yet, add the key to visited and recursively visit keys in that room,\\notherwise do not visit the room again.\\nWe can visit all rooms only when the size of visited set equals to the size of the rooms.\\n\\nIterative BFS:\\nUse a queue to keep the keys we found in a room, only enqueue the keys not visited yet.\\nRepeat until the queue is empty, and check if size of visited set equals size of rooms.\\n*/\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        if(rooms == null || rooms.size() == 0) return false;\\n        Set<Integer> visited = new HashSet<>();\\n        visitBFS(rooms, 0, visited);\\n        return visited.size() == rooms.size();\\n    }\\n    \\n    private void visitDFS(List<List<Integer>> rooms, Integer i, Set<Integer> visited) {\\n        if(visited.contains(i)) return;\\n        visited.add(i);\\n        for(Integer key : rooms.get(i)) {\\n            visitDFS(rooms, key, visited);\\n        }\\n    }\\n    \\n    private void visitBFS(List<List<Integer>> rooms, Integer i, Set<Integer> visited) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(i);\\n        while(!queue.isEmpty()){\\n            Integer key = queue.poll();\\n            visited.add(key);\\n            for(Integer k : rooms.get(key)){\\n                if(!visited.contains(k)){\\n                    queue.offer(k);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133846,
                "title": "simple-java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        if(rooms.size() == 0) return true;\\n        boolean[] visited = new boolean[rooms.size()];\\n        dfs(0,rooms,visited);\\n        for(int i=0;i<rooms.size();i++)\\n            if(!visited[i])\\n                return false;\\n        return true;\\n    }\\n    public void dfs(int index,List<List<Integer>> rooms,boolean[] visited){\\n        visited[index] = true;\\n        for(int n:rooms.get(index)){\\n            if(!visited[n]){\\n                dfs(n,rooms,visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        if(rooms.size() == 0) return true;\\n        boolean[] visited = new boolean[rooms.size()];\\n        dfs(0,rooms,visited);\\n        for(int i=0;i<rooms.size();i++)\\n            if(!visited[i])\\n                return false;\\n        return true;\\n    }\\n    public void dfs(int index,List<List<Integer>> rooms,boolean[] visited){\\n        visited[index] = true;\\n        for(int n:rooms.get(index)){\\n            if(!visited[n]){\\n                dfs(n,rooms,visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661693,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v){\\n        for(int i=0; i<v.size(); i++) if(v[i] != 1) return false; \\n        return true; \\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> visited(rooms.size(), 0); int n = rooms.size(); \\n        visited[0] = 1; int counter = 0; \\n        while(counter < n){\\n            counter++; \\n            for(int i=0; i<n; i++){\\n                if(visited[i] == 1){\\n                    for(int j=0; j<rooms[i].size(); j++){\\n                        visited[rooms[i][j]] = 1; \\n                    }\\n                }\\n            }\\n            if(check(visited)) return true; \\n        }\\n\\n        return false; \\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v){\\n        for(int i=0; i<v.size(); i++) if(v[i] != 1) return false; \\n        return true; \\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> visited(rooms.size(), 0); int n = rooms.size(); \\n        visited[0] = 1; int counter = 0; \\n        while(counter < n){\\n            counter++; \\n            for(int i=0; i<n; i++){\\n                if(visited[i] == 1){\\n                    for(int j=0; j<rooms[i].size(); j++){\\n                        visited[rooms[i][j]] = 1; \\n                    }\\n                }\\n            }\\n            if(check(visited)) return true; \\n        }\\n\\n        return false; \\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931659,
                "title": "simple-recursive-solutions-and-an-iterative-one",
                "content": "Recursive solution:\\n```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        var visited = new bool[rooms.Count];\\n        Dfs(room: 0);\\n        return visited.All(v => v);\\n\\n        void Dfs(int room)\\n        {\\n            if (visited[room]) return;\\n            \\n            visited[room] = true;\\n\\n            foreach (int key in rooms[room])\\n            {\\n                Dfs(key);\\n            }\\n        }\\n    }\\n}\\n```\\nAlternatively, we can check whether the room was visited before calling `Dfs`:\\n```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        var visited = new bool[rooms.Count];\\n        Dfs(room: 0);\\n        return visited.All(v => v);\\n\\n        void Dfs(int room)\\n        {\\n            visited[room] = true;\\n\\n            foreach (int key in rooms[room])\\n            {\\n                if (!visited[key]) Dfs(key);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nA nice iterative solution by [PrashantUnity](https://leetcode.com/PrashantUnity/) from the comments:\\n```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        Stack<int> stack = new();\\n        HashSet<int> visited = new();\\n\\n        stack.Push(0);\\n        visited.Add(0);\\n\\n        while (stack.Count > 0)\\n        {\\n            int cur = stack.Pop();\\n            visited.Add(cur);\\n\\n            foreach (int key in rooms[cur])\\n            {\\n                if (!visited.Contains(key)) stack.Push(key);\\n            }\\n        }\\n\\n        return visited.Count == rooms.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        var visited = new bool[rooms.Count];\\n        Dfs(room: 0);\\n        return visited.All(v => v);\\n\\n        void Dfs(int room)\\n        {\\n            if (visited[room]) return;\\n            \\n            visited[room] = true;\\n\\n            foreach (int key in rooms[room])\\n            {\\n                Dfs(key);\\n            }\\n        }\\n    }\\n}\\n```\n```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        var visited = new bool[rooms.Count];\\n        Dfs(room: 0);\\n        return visited.All(v => v);\\n\\n        void Dfs(int room)\\n        {\\n            visited[room] = true;\\n\\n            foreach (int key in rooms[room])\\n            {\\n                if (!visited[key]) Dfs(key);\\n            }\\n        }\\n    }\\n}\\n```\n```csharp\\npublic class Solution \\n{\\n    public bool CanVisitAllRooms(IList<IList<int>> rooms)\\n    {\\n        Stack<int> stack = new();\\n        HashSet<int> visited = new();\\n\\n        stack.Push(0);\\n        visited.Add(0);\\n\\n        while (stack.Count > 0)\\n        {\\n            int cur = stack.Pop();\\n            visited.Add(cur);\\n\\n            foreach (int key in rooms[cur])\\n            {\\n                if (!visited.Contains(key)) stack.Push(key);\\n            }\\n        }\\n\\n        return visited.Count == rooms.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930601,
                "title": "python-3-8-lines-iteration-with-set-t-m-98-88",
                "content": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\\n        \\n        n, keys, open = len(rooms), deque([0]), set()\\n        \\n        while keys and len(open) < n:\\n            key = keys.popleft()\\n            open.add(key)\\n            \\n            for r in rooms[key]:\\n                if r not in open:\\n                    keys.append(r)\\n                    \\n        return len(open) == n\\n```\\n[https://leetcode.com/problems/keys-and-rooms/submissions/862397666/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\\n        \\n        n, keys, open = len(rooms), deque([0]), set()\\n        \\n        while keys and len(open) < n:\\n            key = keys.popleft()\\n            open.add(key)\\n            \\n            for r in rooms[key]:\\n                if r not in open:\\n                    keys.append(r)\\n                    \\n        return len(open) == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930347,
                "title": "c-bfs-application-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n=rooms.size();\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                int cur_room =q.front();\\n                q.pop();\\n                for(int key:rooms[cur_room]){\\n                    if(!vis[key]){\\n                        vis[key]=1;\\n                        q.push(key);\\n                    }\\n                }\\n            }\\n        }\\n        if(find(vis.begin(),vis.end(),0)!=vis.end()){// checking is there any room not visited\\n            return false;\\n        } \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n=rooms.size();\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                int cur_room =q.front();\\n                q.pop();\\n                for(int key:rooms[cur_room]){\\n                    if(!vis[key]){\\n                        vis[key]=1;\\n                        q.push(key);\\n                    }\\n                }\\n            }\\n        }\\n        if(find(vis.begin(),vis.end(),0)!=vis.end()){// checking is there any room not visited\\n            return false;\\n        } \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292352,
                "title": "python3-dfs",
                "content": "```\\nclass Solution:\\n    \\n    def visitAll(self,rooms,index,visited):\\n        if index not in visited:\\n            visited.add(index)\\n            for i in rooms[index]:\\n                self.visitAll(rooms,i,visited)\\n    \\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        self.visitAll(rooms,0,visited)\\n        return len(visited)==len(rooms)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def visitAll(self,rooms,index,visited):\\n        if index not in visited:\\n            visited.add(index)\\n            for i in rooms[index]:\\n                self.visitAll(rooms,i,visited)\\n    \\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        self.visitAll(rooms,0,visited)\\n        return len(visited)==len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117876,
                "title": "c-bfs-and-dfs-simple-bitset-solution-100-time-100-space",
                "content": "**BFS Solution:**\\n\\nThis solution uses a bitset to store which rooms have been visited starting with room 0 as visited and pushing room 0 to the queue.\\nWhile the queue remains empty, for each key in the room, we push all the keys which have not been visited to the queue.\\nAfter the queue is empty, we check if the count of the bits switched on is the same as the number of rooms.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        bitset<1000> visited;\\n        visited.set(0);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        while (!q.empty()) {\\n            for (int key : rooms[q.front()]) {\\n                if (!visited.test(key)) {\\n                    q.push(key);\\n                    visited.set(key);\\n                }\\n            }\\n\\n            q.pop();\\n        }\\n        \\n        return visited.count() == rooms.size();\\n    }\\n};\\n```\\n\\n\\n**DFS Solution:**\\n\\nThis solution also uses a bitset to store which rooms have been visited starting with room 0 as visited.\\nFor each key in the room, we call the dfs recursive function for all the keys which have not been visited.\\nAfter the dfs function has finished for all the keys, we check if the count of the bits switched on is the same as the number of rooms.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        bitset<1000> visited;\\n        visited.set(0);\\n        \\n        dfs(rooms, visited, 0);\\n        \\n        return visited.count() == rooms.size();\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms, bitset<1001>& visited, int currentKey) {\\n        for (int key : rooms[currentKey]) {\\n            if (!visited.test(key)) {\\n                visited.set(key);\\n                dfs(rooms, visited, key);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        bitset<1000> visited;\\n        visited.set(0);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        while (!q.empty()) {\\n            for (int key : rooms[q.front()]) {\\n                if (!visited.test(key)) {\\n                    q.push(key);\\n                    visited.set(key);\\n                }\\n            }\\n\\n            q.pop();\\n        }\\n        \\n        return visited.count() == rooms.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        bitset<1000> visited;\\n        visited.set(0);\\n        \\n        dfs(rooms, visited, 0);\\n        \\n        return visited.count() == rooms.size();\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms, bitset<1001>& visited, int currentKey) {\\n        for (int key : rooms[currentKey]) {\\n            if (!visited.test(key)) {\\n                visited.set(key);\\n                dfs(rooms, visited, key);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117268,
                "title": "python-go-o-v-e-by-simple-dfs-w-comment",
                "content": "Python O(V+E) by simple DFS\\n\\nV (Vertice): number of rooms\\nE (Directed egde): number of keys\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\t\\t\\n\\t\\t# a set to record visited rooms\\n        visited = set()\\n        \\n        # --------------------------------\\n        def dfs( cur_room ):\\n            \\n            if cur_room in visited:\\n\\t\\t\\t\\n\\t\\t\\t\\t# base case aslo known as stop condition\\n                return\\n            \\n\\t\\t\\t# mark current room as visited\\n            visited.add( cur_room )\\n            \\n\\t\\t\\t# general case:\\n            for next_room in rooms[cur_room]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Visit next room in DFS\\n                dfs( next_room )\\n            \\n            return\\n        # --------------------------------\\n        \\n\\t\\t# Launch DFS at room_#0\\n        dfs(cur_room = 0)\\n        \\n\\t\\t# Return true if all rooms are visited\\n        return len(visited) == len(rooms)\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc canVisitAllRooms(rooms [][]int) bool {\\n    \\n\\t// a map (so-called dictionary) to record visited rooms\\n\\t// Note: golang has no native set, so here we use map as alternative plan.\\n    visited := make( map[int]bool)\\n    \\n\\t// ------------------------------------------\\n    var dfs func( curRoom int )\\n    \\n    dfs = func( curRoom int){\\n        \\n        if _, exist:= visited[curRoom]; exist{\\n            \\n            // base case also known as stop condition\\n            return\\n        }\\n        \\n\\t\\t// mark current room as visited\\n        visited[curRoom] = true\\n        \\n\\t\\t// general case:\\n        for _, nextRoom := range rooms[curRoom]{\\n\\t\\t\\t\\n\\t\\t\\t// Visit next room in DFS\\n            dfs( nextRoom )\\n        }\\n        return\\n    }\\n\\t\\n    // ------------------------------------------\\n\\t\\n\\t// Launch DFS at room_#0\\n    dfs( 0 )\\n    \\n\\t// Return true if all rooms are visited\\n    return len(visited) == len(rooms)\\n    \\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\t\\t\\n\\t\\t# a set to record visited rooms\\n        visited = set()\\n        \\n        # --------------------------------\\n        def dfs( cur_room ):\\n            \\n            if cur_room in visited:\\n\\t\\t\\t\\n\\t\\t\\t\\t# base case aslo known as stop condition\\n                return\\n            \\n\\t\\t\\t# mark current room as visited\\n            visited.add( cur_room )\\n            \\n\\t\\t\\t# general case:\\n            for next_room in rooms[cur_room]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Visit next room in DFS\\n                dfs( next_room )\\n            \\n            return\\n        # --------------------------------\\n        \\n\\t\\t# Launch DFS at room_#0\\n        dfs(cur_room = 0)\\n        \\n\\t\\t# Return true if all rooms are visited\\n        return len(visited) == len(rooms)\\n```\n```\\nfunc canVisitAllRooms(rooms [][]int) bool {\\n    \\n\\t// a map (so-called dictionary) to record visited rooms\\n\\t// Note: golang has no native set, so here we use map as alternative plan.\\n    visited := make( map[int]bool)\\n    \\n\\t// ------------------------------------------\\n    var dfs func( curRoom int )\\n    \\n    dfs = func( curRoom int){\\n        \\n        if _, exist:= visited[curRoom]; exist{\\n            \\n            // base case also known as stop condition\\n            return\\n        }\\n        \\n\\t\\t// mark current room as visited\\n        visited[curRoom] = true\\n        \\n\\t\\t// general case:\\n        for _, nextRoom := range rooms[curRoom]{\\n\\t\\t\\t\\n\\t\\t\\t// Visit next room in DFS\\n            dfs( nextRoom )\\n        }\\n        return\\n    }\\n\\t\\n    // ------------------------------------------\\n\\t\\n\\t// Launch DFS at room_#0\\n    dfs( 0 )\\n    \\n\\t// Return true if all rooms are visited\\n    return len(visited) == len(rooms)\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117104,
                "title": "bfs-and-dfs-time-o-n-and-space-o-n",
                "content": "**Solution 1: Standard BFS**\\nAlways follow this rule while writing BFS\\n#### *Remove check mark Add*\\n```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visited=new boolean[rooms.size()];  //will store either room is visited or not\\n        Queue<Integer> que=new ArrayDeque<>();\\n        que.add(0);  // as initially we are room 0 nd its open\\n       \\n    \\n        while(que.size()>0){\\n\\t\\t//1.Remove\\n          int curr=que.remove();\\n            \\n         //2.Check\\n          if(visited[curr]) continue;  \\n\\t\\t  \\n\\t\\t  //3.Mark\\n          visited[curr]=true; \\n\\t\\t  \\n\\t\\t  //4. Add Neighbours\\n          for(int nbr:rooms.get(curr)){  \\n              if(!visited[nbr]){\\n                 que.add(nbr); \\n              }\\n          }  \\n        }\\n        \\n       for(boolean room:visited){\\n           if(!room) return false;  // means we haven\\'t visited that room\\n       }\\n        return true;\\n    }\\n```\\t\\n**Time:O(N) and Space:O(N)**\\n\\n**Solution 2: BFS**\\nWe can use HashSet to store visited rooms and at last if HashSet size equals to rooms means all rooms are visited\\n```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> visited=new HashSet<>();\\n\\n        Queue<Integer> que= new ArrayDeque<>();\\n        que.add(0);\\n        \\n        while(que.size()>0){\\n\\t\\t   //1.Remove\\n            int curr=que.remove();  //curr:current room\\n\\t\\t\\t\\n            //2.Check\\n            if(visited.contains(curr)) continue;\\n\\n           //3.Mark\\n            visited.add(curr);\\n            \\n\\t\\t\\t//4.Add Neighbours\\n           for(int nbrRooms:rooms.get(curr)){\\n               if(!visited.contains(nbrRooms)){\\n                  que.add(nbrRooms);\\n               }\\n           } \\n        }\\n        \\n       return visited.size()==rooms.size(); \\n    }\\n```\\n**Time O(N) && Space:O(N)**\\n**Solution 3: DFS**\\n```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visited=new boolean[rooms.size()];\\n        dfs(rooms,0,visited);\\n        for(boolean isRoomVisited:visited){\\n            if(!isRoomVisited) return false;\\n        }\\n        return true;\\n    }\\n    \\n   private void dfs(List<List<Integer>> graph,int src,boolean[] visited){\\n          \\n         visited[src]=true;\\n         for(int nbr:graph.get(src)){\\n             if(!visited[nbr]) dfs(graph,nbr,visited);\\n         } \\n   } \\n ```\\n**Time:O(N) and Space:O(N)**\\nPlease **Upvote** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visited=new boolean[rooms.size()];  //will store either room is visited or not\\n        Queue<Integer> que=new ArrayDeque<>();\\n        que.add(0);  // as initially we are room 0 nd its open\\n       \\n    \\n        while(que.size()>0){\\n\\t\\t//1.Remove\\n          int curr=que.remove();\\n            \\n         //2.Check\\n          if(visited[curr]) continue;  \\n\\t\\t  \\n\\t\\t  //3.Mark\\n          visited[curr]=true; \\n\\t\\t  \\n\\t\\t  //4. Add Neighbours\\n          for(int nbr:rooms.get(curr)){  \\n              if(!visited[nbr]){\\n                 que.add(nbr); \\n              }\\n          }  \\n        }\\n        \\n       for(boolean room:visited){\\n           if(!room) return false;  // means we haven\\'t visited that room\\n       }\\n        return true;\\n    }\\n```\n```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> visited=new HashSet<>();\\n\\n        Queue<Integer> que= new ArrayDeque<>();\\n        que.add(0);\\n        \\n        while(que.size()>0){\\n\\t\\t   //1.Remove\\n            int curr=que.remove();  //curr:current room\\n\\t\\t\\t\\n            //2.Check\\n            if(visited.contains(curr)) continue;\\n\\n           //3.Mark\\n            visited.add(curr);\\n            \\n\\t\\t\\t//4.Add Neighbours\\n           for(int nbrRooms:rooms.get(curr)){\\n               if(!visited.contains(nbrRooms)){\\n                  que.add(nbrRooms);\\n               }\\n           } \\n        }\\n        \\n       return visited.size()==rooms.size(); \\n    }\\n```\n```\\n public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visited=new boolean[rooms.size()];\\n        dfs(rooms,0,visited);\\n        for(boolean isRoomVisited:visited){\\n            if(!isRoomVisited) return false;\\n        }\\n        return true;\\n    }\\n    \\n   private void dfs(List<List<Integer>> graph,int src,boolean[] visited){\\n          \\n         visited[src]=true;\\n         for(int nbr:graph.get(src)){\\n             if(!visited[nbr]) dfs(graph,nbr,visited);\\n         } \\n   } \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117025,
                "title": "c-super-easy-and-short-recursive-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        m_seen.insert(0);\\n        m_rooms = rooms;\\n        DFS(0);\\n        return m_seen.size() == rooms.size();\\n    }\\n    \\nprivate:\\n    void DFS(int room) {\\n        for (auto key : m_rooms[room]) {\\n            if (m_seen.find(key) == m_seen.end()) {\\n                m_seen.insert(key);\\n                DFS(key);\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> m_seen;\\n    vector<vector<int>> m_rooms;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        m_seen.insert(0);\\n        m_rooms = rooms;\\n        DFS(0);\\n        return m_seen.size() == rooms.size();\\n    }\\n    \\nprivate:\\n    void DFS(int room) {\\n        for (auto key : m_rooms[room]) {\\n            if (m_seen.find(key) == m_seen.end()) {\\n                m_seen.insert(key);\\n                DFS(key);\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> m_seen;\\n    vector<vector<int>> m_rooms;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116804,
                "title": "keys-and-rooms-short-easy-w-explanation-bfs-dfs",
                "content": "The problem asks us to check if we can visit every room starting from the room 0. This can be viewed as a **graph problem** where we want to check if we can visited every node if we start from `node 0`. The rooms are the nodes and keys are the edges of the graph.\\n\\n----------\\n\\n***Solution - I (Depth-First Search)***\\n\\n\\nThis can be done easily using a DFS. We only initiate the DFS from the `node 0` and once the DFS is complete, we check if every room is visited or not.\\n\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/9f12d683-452d-4911-b045-ad4a3a072a8e_1616144286.1954126.png)\\n\\n\\n------------\\n-----------\\n\\n***Solution - II (Breadth-First Search)***\\n\\nWe can also solve the problem using a BFS appraoch -\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/40ccb23c-f0e8-4e7d-ba4d-1c95bdd2c070_1616144264.2904758.png)\\n\\n\\n-----------\\n-----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3316711,
                "title": "best-dfs-bfs-solution",
                "content": "# Approach 1\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(V + E)$$\\n\\n- Space complexity:\\n$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int src, vector<vector<int>>& rooms, vector <int>& vis) {\\n        vis[src] = 1;\\n        for (auto it : rooms[src]) {\\n                if (!vis[it])\\n                    dfs(it, rooms, vis);\\n            }\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector <int> vis(n, 0);\\n        dfs(0, rooms, vis);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(V + E)$$\\n\\n- Space complexity:\\n$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector <int> vis(n, 0);\\n        queue <int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        while (!q.empty()) {\\n            int room = q.front();\\n            q.pop();\\n            for (auto it : rooms[room]) {\\n                if (!vis[it]) {\\n                    q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int src, vector<vector<int>>& rooms, vector <int>& vis) {\\n        vis[src] = 1;\\n        for (auto it : rooms[src]) {\\n                if (!vis[it])\\n                    dfs(it, rooms, vis);\\n            }\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector <int> vis(n, 0);\\n        dfs(0, rooms, vis);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector <int> vis(n, 0);\\n        queue <int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        while (!q.empty()) {\\n            int room = q.front();\\n            q.pop();\\n            for (auto it : rooms[room]) {\\n                if (!vis[it]) {\\n                    q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932394,
                "title": "c-dfs-bfs-graph-easy-to-understand-easy-to-code",
                "content": "# Approach\\nUsing \\n1) BFS - breadth first search.\\n2) DFS - depth first search.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) \\n\\n# Code\\n```\\n/* Using BFS */\\n\\nbool canVisitAllRooms(vector<vector<int>> &rooms)\\n{\\n    int n = rooms.size();\\n    vector<bool> visited(n, 0);\\n\\n    queue<int> q;\\n    q.push(0);\\n    visited[0] = true;\\n\\n    while (!q.empty())\\n    {\\n        int curr = q.front();\\n        q.pop();\\n\\n        for (auto element : rooms[curr])\\n        {\\n            if (!visited[element])\\n            {\\n                visited[element] = true;\\n                q.push(element);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/* Using DFS */\\n\\nbool canVisitAllRooms(vector<vector<int>> &rooms)\\n{\\n    int n = rooms.size();\\n    vector<bool> visited(n, 0);\\n\\n    stack<int>st;\\n    st.push(0);\\n    visited[0] = true;\\n\\n    while (!st.empty())\\n    {\\n        int curr = st.top();\\n        st.pop();\\n\\n        for (auto element : rooms[curr])\\n        {\\n            if (!visited[element])\\n            {\\n                visited[element] = true;\\n                st.push(element);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/* Using BFS */\\n\\nbool canVisitAllRooms(vector<vector<int>> &rooms)\\n{\\n    int n = rooms.size();\\n    vector<bool> visited(n, 0);\\n\\n    queue<int> q;\\n    q.push(0);\\n    visited[0] = true;\\n\\n    while (!q.empty())\\n    {\\n        int curr = q.front();\\n        q.pop();\\n\\n        for (auto element : rooms[curr])\\n        {\\n            if (!visited[element])\\n            {\\n                visited[element] = true;\\n                q.push(element);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/* Using DFS */\\n\\nbool canVisitAllRooms(vector<vector<int>> &rooms)\\n{\\n    int n = rooms.size();\\n    vector<bool> visited(n, 0);\\n\\n    stack<int>st;\\n    st.push(0);\\n    visited[0] = true;\\n\\n    while (!st.empty())\\n    {\\n        int curr = st.top();\\n        st.pop();\\n\\n        for (auto element : rooms[curr])\\n        {\\n            if (!visited[element])\\n            {\\n                visited[element] = true;\\n                st.push(element);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2931339,
                "title": "simple-dfs-commented-explained-o-n-wise-recursive-call",
                "content": "# Approach\\nmaintain a visited array to store have we visited a perticular index before if not visited and the index we are now at has key to that index then do recursive call to know how many more rooms we can visit using the key. \\ninitially we will make a call as index 0 as mentioned in the problem\\nafter traverse accordingly.\\nTC-O(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<bool>visited; //store particular index is visited or not.\\n    void util(vector<vector<int>>& rooms, int idx){\\n        visited[idx]=true;//assign true for the index we reached now.\\n\\n        for(int i=0; i<rooms[idx].size(); i++){\\n            if(visited[rooms[idx][i]]==false){//make call only if the room is unvisited.\\n                \\n                util(rooms, rooms[idx][i]);\\n            }\\n        }\\n\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        visited.resize(rooms.size(), false);\\n        util(rooms, 0);\\n        for(int i=0; i<visited.size(); i++){//check whether all room are visited or not\\n        //if not visited return false;\\n            if(!visited[i])return false;\\n        }//ending this loop implies we visited all rooms=>return true\\n        return true;\\n    }\\n};\\n```\\n\\n# Upvote if helpful.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<bool>visited; //store particular index is visited or not.\\n    void util(vector<vector<int>>& rooms, int idx){\\n        visited[idx]=true;//assign true for the index we reached now.\\n\\n        for(int i=0; i<rooms[idx].size(); i++){\\n            if(visited[rooms[idx][i]]==false){//make call only if the room is unvisited.\\n                \\n                util(rooms, rooms[idx][i]);\\n            }\\n        }\\n\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        visited.resize(rooms.size(), false);\\n        util(rooms, 0);\\n        for(int i=0; i<visited.size(); i++){//check whether all room are visited or not\\n        //if not visited return false;\\n            if(!visited[i])return false;\\n        }//ending this loop implies we visited all rooms=>return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931161,
                "title": "java-easy-to-understand-using-set-and-stack-full-explanation-both-dfs-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere may be repitition of keys so to remove that and keep record of distinct keys first thought came of using set. Adding keys on each traversal and if size of set will be equal to no. of rooms then its confirmed that all rooms are accessed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo following the intuition I use a set to keep record of unique keys and a stack to maintain rooms which needs to be visited. Now firstly add key-0 to set and keys in room-0 to set and stack. \\n\\nNow iterate over the rooms untill the stack is empty. but there was a catch that we need to ensure that repeted keys are not added to stack which we ensured by checking if key is added to set then its uique so push it to stack else don\\'t push.\\n\\nLastly the if condition in while loop to check if set\\'s size is equal to number of rooms.\\n\\nThis apprroch is DFS another approch can be using queue i.e. BFS. \\n\\n# Code (DFS)\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Set<Integer> set = new HashSet<>();\\n        Stack<Integer> s = new Stack<>();\\n        int n = rooms.size();\\n          set.add(0);\\n        for(int i=0;i<rooms.get(0).size();i++){\\n            set.add(rooms.get(0).get(i));\\n            s.push(rooms.get(0).get(i));\\n        }\\n        \\n        while(!s.empty()){\\n            int i = s.pop();\\n            for(int j=0;j<rooms.get(i).size();j++){\\n                if(set.add(rooms.get(i).get(j)))\\n                s.push(rooms.get(i).get(j));\\n            }\\n            if(set.size()==n) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n# Code (BFS)\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited.add(0);\\n        while (!queue.isEmpty()) {\\n            int i = queue.poll();\\n            for (int k : rooms.get(i)) {\\n                if (!visited.contains(k)) {\\n                    queue.offer(k);\\n                    visited.add(k);\\n                }\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Set<Integer> set = new HashSet<>();\\n        Stack<Integer> s = new Stack<>();\\n        int n = rooms.size();\\n          set.add(0);\\n        for(int i=0;i<rooms.get(0).size();i++){\\n            set.add(rooms.get(0).get(i));\\n            s.push(rooms.get(0).get(i));\\n        }\\n        \\n        while(!s.empty()){\\n            int i = s.pop();\\n            for(int j=0;j<rooms.get(i).size();j++){\\n                if(set.add(rooms.get(i).get(j)))\\n                s.push(rooms.get(i).get(j));\\n            }\\n            if(set.size()==n) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited.add(0);\\n        while (!queue.isEmpty()) {\\n            int i = queue.poll();\\n            for (int k : rooms.get(i)) {\\n                if (!visited.contains(k)) {\\n                    queue.offer(k);\\n                    visited.add(k);\\n                }\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930381,
                "title": "very-easy-solution-using-bfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n    int n = rooms.size();\\n    vector<int> vis(n, 0);\\n    queue<vector<int>> q;\\n    q.push(rooms[0]);\\n    vis[0] = 1;\\n    while (!q.empty()) {\\n      vector<int> arr = q.front();\\n      q.pop();\\n      for (auto it : arr) {\\n        if (!vis[it]) {\\n          q.push(rooms[it]);\\n          vis[it] = 1;\\n        }\\n      }\\n    }\\n\\n    for (auto it : vis) {\\n      if (it == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n    int n = rooms.size();\\n    vector<int> vis(n, 0);\\n    queue<vector<int>> q;\\n    q.push(rooms[0]);\\n    vis[0] = 1;\\n    while (!q.empty()) {\\n      vector<int> arr = q.front();\\n      q.pop();\\n      for (auto it : arr) {\\n        if (!vis[it]) {\\n          q.push(rooms[it]);\\n          vis[it] = 1;\\n        }\\n      }\\n    }\\n\\n    for (auto it : vis) {\\n      if (it == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930159,
                "title": "c-dfs-and-bfs",
                "content": "## DFS\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rooms, vector<bool>&visited, int curr)\\n    {\\n        visited[curr] = true;\\n        int roomsVisited = 1;\\n        for (int nextRoom : rooms[curr])\\n        {\\n            if (visited[nextRoom]) continue;\\n            roomsVisited += dfs(rooms, visited, nextRoom);\\n        }\\n        return roomsVisited;\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool>visited(n, false);\\n        int roomsVisited = dfs(rooms, visited, 0);\\n        return (n == roomsVisited);\\n    }\\n};\\n```\\n//===============================================================================================================================\\n\\n## BFS\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool>visited(n, false);\\n        queue<int>q;\\n        q.push(0);\\n        int roomsVisited = 1; //0th room is visited\\n        visited[0] = true;\\n        //========================================================\\n        while(!q.empty())\\n        {\\n            int currRoom = q.front();\\n            q.pop();\\n            \\n            for (int nextRoom : rooms[currRoom])\\n            {\\n                if (visited[nextRoom]) continue;\\n                visited[nextRoom] = true;\\n                q.push(nextRoom);\\n                roomsVisited++;\\n            }\\n        }\\n        //=============================================================\\n        return (roomsVisited == n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&rooms, vector<bool>&visited, int curr)\\n    {\\n        visited[curr] = true;\\n        int roomsVisited = 1;\\n        for (int nextRoom : rooms[curr])\\n        {\\n            if (visited[nextRoom]) continue;\\n            roomsVisited += dfs(rooms, visited, nextRoom);\\n        }\\n        return roomsVisited;\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool>visited(n, false);\\n        int roomsVisited = dfs(rooms, visited, 0);\\n        return (n == roomsVisited);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        int n = rooms.size();\\n        vector<bool>visited(n, false);\\n        queue<int>q;\\n        q.push(0);\\n        int roomsVisited = 1; //0th room is visited\\n        visited[0] = true;\\n        //========================================================\\n        while(!q.empty())\\n        {\\n            int currRoom = q.front();\\n            q.pop();\\n            \\n            for (int nextRoom : rooms[currRoom])\\n            {\\n                if (visited[nextRoom]) continue;\\n                visited[nextRoom] = true;\\n                q.push(nextRoom);\\n                roomsVisited++;\\n            }\\n        }\\n        //=============================================================\\n        return (roomsVisited == n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078587,
                "title": "java-dfs-self-explanatory-easy",
                "content": "```\\nclass Solution {\\n    Set<Integer> all;\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        all = new HashSet<>();\\n        all.add(0);\\n        check(rooms,0);\\n        return all.size() == rooms.size();\\n    }\\n    public void check(List<List<Integer>> rooms,int idx){\\n        List<Integer> cur = rooms.get(idx);\\n        for(int i=0;i<cur.size();i++){\\n            if(!all.contains(cur.get(i))){\\n                all.add(cur.get(i));\\n                check(rooms,cur.get(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> all;\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        all = new HashSet<>();\\n        all.add(0);\\n        check(rooms,0);\\n        return all.size() == rooms.size();\\n    }\\n    public void check(List<List<Integer>> rooms,int idx){\\n        List<Integer> cur = rooms.get(idx);\\n        for(int i=0;i<cur.size();i++){\\n            if(!all.contains(cur.get(i))){\\n                all.add(cur.get(i));\\n                check(rooms,cur.get(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066830,
                "title": "c-easy-dfs-and-bfs-implementation",
                "content": "# DFS (Depth First Search).\\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int>>& rooms,vector<int>&visited,int node){\\n        visited[node] = 1;\\n        for(auto child : rooms[node]){\\n            if(visited[child] == 0){\\n                DFS(rooms,visited,child);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int number_of_room = rooms.size();\\n        vector<int> visited(number_of_room,0);\\n        DFS(rooms,visited,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i] == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# BFS (Breadth First Search).\\n```\\nclass Solution {\\npublic:\\n    void BFS(vector<vector<int>>&rooms,vector<int>&visited,int source){\\n        queue<int> q;\\n        q.push(source);\\n        visited[source] = 1;\\n        while(!q.empty()){\\n            int curr_node = q.front();\\n            q.pop();\\n            for(auto child : rooms[curr_node]){\\n                if(visited[child] == 0){\\n                    q.push(child);\\n                    visited[child] = 1;\\n                }\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int number_of_rooms = rooms.size();\\n        vector<int>visited(number_of_rooms,0);\\n        BFS(rooms,visited,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i] == 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n# Guys Please upvote me.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int>>& rooms,vector<int>&visited,int node){\\n        visited[node] = 1;\\n        for(auto child : rooms[node]){\\n            if(visited[child] == 0){\\n                DFS(rooms,visited,child);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int number_of_room = rooms.size();\\n        vector<int> visited(number_of_room,0);\\n        DFS(rooms,visited,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i] == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void BFS(vector<vector<int>>&rooms,vector<int>&visited,int source){\\n        queue<int> q;\\n        q.push(source);\\n        visited[source] = 1;\\n        while(!q.empty()){\\n            int curr_node = q.front();\\n            q.pop();\\n            for(auto child : rooms[curr_node]){\\n                if(visited[child] == 0){\\n                    q.push(child);\\n                    visited[child] = 1;\\n                }\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int number_of_rooms = rooms.size();\\n        vector<int>visited(number_of_rooms,0);\\n        BFS(rooms,visited,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i] == 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756839,
                "title": "python-simple-dfs-bfs-explained-w-complexity",
                "content": "**Intuition**\\nThe problem statement tell us that we have access to a room `y`  only if the key is a previous room `x`. This highlights a specific, directional relationship: `x --> y`. Relationships between objects can naturally be viewed through a graph lens. We can put it in a graph context by viewing the rooms as vertices in a directed graph. More formally, we know that there is an edge `(u,v)` if vertex `v` is in the list `rooms[u]`, i.e. if the room `u` contains a key to room `v`.\\nWe are trying to determine whether we can unlock the entire set of rooms (i.e. visit all the nodes in the graph) if we start at room (node) 0. We can thus reduce this problem to running a graph traversal and, at its conclusion, checking to see if we have indeed seen all `n` rooms. \\n\\n**Approach**\\nThe type of traversal doesn\\'t matter - both BFS and DFS do the job. We keep track of the rooms we\\'ve seen via an array `seen`. `seen[i]` indicates whether we have unlocked room `i`. At the end of the traversal, if there is any index in `seen` that contains a `False` value, we know that we were not able to unlock all of the rooms.\\n\\n**Implementation**\\nCode for DFS:\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        stack = [0]  # room 0 is unlocked\\n        while stack:\\n            room = stack.pop()\\n            if not seen[room]:  # if not previously visited\\n                seen[room] = True\\n                for key in rooms[room]:\\n                        stack.append(key)\\n        \\n        return all(seen)\\n```\\n\\t\\t\\nCode for BFS:\\n```\\nfrom collections import deque\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        queue = deque([0]) # room 0 is unlocked\\n        while queue:\\n            room = queue.popleft()\\n            seen[room] = True\\n            for key in rooms[room]:\\n                if not seen[key]:  # if not previously visited\\n                    queue.append(key)\\n                    seen[key] = True\\n        \\n        return all(seen)\\n```\\n**Complexity**\\n* Time: `O(N + E)`, where N is the number of rooms and E the number of total keys (edges)\\n\\t* Doing `O(1)` work for all `N` rooms - checking if seen, adding to queue/stack\\n\\t* Doing `O(1)` work for all `E` keys - going through the list of neighbors for each room\\n* Space: `O(N)`\\n\\t* `seen` array is `O(N)` as its keeping track of all the vertices\\n\\t* data structure used to process vertices (queue or stack depending on traversal) will hold at most `O(N)` elements at once\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        stack = [0]  # room 0 is unlocked\\n        while stack:\\n            room = stack.pop()\\n            if not seen[room]:  # if not previously visited\\n                seen[room] = True\\n                for key in rooms[room]:\\n                        stack.append(key)\\n        \\n        return all(seen)\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        queue = deque([0]) # room 0 is unlocked\\n        while queue:\\n            room = queue.popleft()\\n            seen[room] = True\\n            for key in rooms[room]:\\n                if not seen[key]:  # if not previously visited\\n                    queue.append(key)\\n                    seen[key] = True\\n        \\n        return all(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117867,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visitedRoom = new boolean[rooms.size()];\\n        \\n        Queue<List<Integer>> queue = new LinkedList();\\n        \\n        //add first room and mark as visited\\n        queue.add(rooms.get(0));\\n        visitedRoom[0] = true;\\n        \\n        //start from 1, as first room is visited\\n        int visitedCount = 1;\\n        \\n        \\n        while(!queue.isEmpty()){\\n            List<Integer> roomKeys = queue.remove();\\n            \\n            //add all the room, whick key is found, \\n            //and mark is visted, if not visted already\\n            for(int key : roomKeys){\\n                \\n                if(!visitedRoom[key]){\\n                    //add room\\n                    queue.add(rooms.get(key));\\n                    \\n                    //mark as visited\\n                    visitedRoom[key] = true;\\n                    \\n                    visitedCount++;\\n                }\\n            }\\n        }    \\n        \\n        //return true if all room visited\\n        return visitedCount == visitedRoom.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] visitedRoom = new boolean[rooms.size()];\\n        \\n        Queue<List<Integer>> queue = new LinkedList();\\n        \\n        //add first room and mark as visited\\n        queue.add(rooms.get(0));\\n        visitedRoom[0] = true;\\n        \\n        //start from 1, as first room is visited\\n        int visitedCount = 1;\\n        \\n        \\n        while(!queue.isEmpty()){\\n            List<Integer> roomKeys = queue.remove();\\n            \\n            //add all the room, whick key is found, \\n            //and mark is visted, if not visted already\\n            for(int key : roomKeys){\\n                \\n                if(!visitedRoom[key]){\\n                    //add room\\n                    queue.add(rooms.get(key));\\n                    \\n                    //mark as visited\\n                    visitedRoom[key] = true;\\n                    \\n                    visitedCount++;\\n                }\\n            }\\n        }    \\n        \\n        //return true if all room visited\\n        return visitedCount == visitedRoom.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117198,
                "title": "c-bfs-vs-dfs-solutions-compared-and-explained-100-time-95-space",
                "content": "Nice problem to practice navigating a graph without too much hassle, since all the keys map directly to the matching index of the room they open.\\n\\nThe first approach we might be willing to attempt is probably a BFS, since reading this problem we might really be visualising proceeding in \"waves\" of doors to open and keys to collect - matching the levels of a BFS traversal.\\n\\nTo prepare for it, we will first of all define a few support variables:\\n* `len` stores the initial size of our input;\\n* `qLen` stores the size of our queue, initially set to `1`, since we know we will always get at least a room and that room will always be opened;\\n* `tot` will count how many doors are left to open - initially set to `len - 1`, since, as mentioned right above, we will always start with an open door;\\n* `keys` will keep track of what keys we have collected (and thus what door we have opened) so far;\\n* `q` is our queue.\\n\\nWe will the initialise `keys` to be with all values set to `false` save for the first one and push `0` into `q` - again, just because we are told the first door will always be open for us in the beginning.\\n\\nTime to go for our main BFS loop, that will run as long as `q` has elements (ie: `qLen != 0`) and:\\n* run an internal loop, proceeding `qLen` times to:\\n\\t* loop through all the queues in the current room (`rooms[q.front()]`) and if we reach a key/room we did not touch before (`!keys[key]`):\\n\\t\\t* mark it as obtained/visited;\\n\\t\\t* push that `key` into `q` for the next round;\\n\\t\\t* reduce the amount of rooms to visit (`tot`) by `1`;\\n\\t* pop the current room out of `q`;\\n* update the value of `qLen` with the current size of `q`.\\n\\nOnce done, we will return `true` if we opened all the doors (`tot == 0`), `false` otherwise.\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size(), qLen = 1, tot = len - 1;\\n        bool keys[len];\\n        queue<int> q;\\n        // preparing keys\\n        keys[0] = true;\\n        for (int i = 1; i < len; i++) keys[i] = false;\\n        // preparing q\\n        q.push(0);\\n        while (qLen) {\\n            while (qLen--) {\\n                for (int key: rooms[q.front()]) {\\n                    // exploring only elements with new keys\\n                    if (!keys[key]) {\\n                        // marking the key as gained\\n                        keys[key] = true;\\n                        // updating q\\n                        q.push(key);\\n                        // reducing tot\\n                        tot--;\\n                    }\\n                }\\n                // removing the current key/room from q\\n                q.pop();\\n            }\\n            qLen = q.size();\\n        }\\n        return !tot;\\n    }\\n};\\n```\\n\\nSame logic, declined as a DFS, which seems to go a bit faster, consuming a tiny bit more memory (I guess for the recursive call stack):\\n\\n```cpp\\nclass Solution {\\n    int tot;\\npublic:\\n    void dfs(int startKey, bool *keys, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, keys, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        bool keys[len];\\n        // preparing keys\\n        keys[0] = true;\\n        for (int i = 1; i < len; i++) keys[i] = false;\\n        dfs(0, keys, rooms);\\n        return !tot;\\n    }\\n};\\n```\\n\\nOr, passing one less argument (with `keys` as a class variable):\\n\\n```cpp\\nclass Solution {\\n    int tot;\\n    bool *keys;\\npublic:\\n    void dfs(int startKey, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        bool tmpKeys[len];\\n        // preparing keys\\n        tmpKeys[0] = true;\\n        for (int i = 1; i < len; i++) tmpKeys[i] = false;\\n        keys = tmpKeys;\\n        dfs(0, rooms);\\n        return !tot;\\n    }\\n};\\n```\\n\\nOr, directly, without using `tmpKeys`:\\n\\n```cpp\\nclass Solution {\\n    int tot;\\n    bool *keys;\\npublic:\\n    void dfs(int startKey, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        // preparing keys\\n        keys = new bool[len];\\n        memset(keys, false, len);\\n        keys[0] = true;\\n        dfs(0, rooms);\\n        return !tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size(), qLen = 1, tot = len - 1;\\n        bool keys[len];\\n        queue<int> q;\\n        // preparing keys\\n        keys[0] = true;\\n        for (int i = 1; i < len; i++) keys[i] = false;\\n        // preparing q\\n        q.push(0);\\n        while (qLen) {\\n            while (qLen--) {\\n                for (int key: rooms[q.front()]) {\\n                    // exploring only elements with new keys\\n                    if (!keys[key]) {\\n                        // marking the key as gained\\n                        keys[key] = true;\\n                        // updating q\\n                        q.push(key);\\n                        // reducing tot\\n                        tot--;\\n                    }\\n                }\\n                // removing the current key/room from q\\n                q.pop();\\n            }\\n            qLen = q.size();\\n        }\\n        return !tot;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int tot;\\npublic:\\n    void dfs(int startKey, bool *keys, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, keys, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        bool keys[len];\\n        // preparing keys\\n        keys[0] = true;\\n        for (int i = 1; i < len; i++) keys[i] = false;\\n        dfs(0, keys, rooms);\\n        return !tot;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int tot;\\n    bool *keys;\\npublic:\\n    void dfs(int startKey, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        bool tmpKeys[len];\\n        // preparing keys\\n        tmpKeys[0] = true;\\n        for (int i = 1; i < len; i++) tmpKeys[i] = false;\\n        keys = tmpKeys;\\n        dfs(0, rooms);\\n        return !tot;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int tot;\\n    bool *keys;\\npublic:\\n    void dfs(int startKey, vector<vector<int>>& rooms) {\\n        for (int key: rooms[startKey]) {\\n            // exploring only elements with new keys\\n            if (!keys[key]) {\\n                // marking the key as gained\\n                keys[key] = true;\\n                // recursively calling dfs\\n                dfs(key, rooms);\\n                // reducing tot\\n                tot--;\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // support variables\\n        int len = rooms.size();\\n        tot = len - 1;\\n        // preparing keys\\n        keys = new bool[len];\\n        memset(keys, false, len);\\n        keys[0] = true;\\n        dfs(0, rooms);\\n        return !tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116833,
                "title": "python-super-simple-short-solution",
                "content": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        keys_to_rooms = {0}\\n        room = [0]\\n        \\n        for r in room:\\n            for key in rooms[r]:\\n                room += [key] if key not in keys_to_rooms else []\\n                keys_to_rooms |= {key}\\n                    \\n        return len(keys_to_rooms) == len(rooms)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        keys_to_rooms = {0}\\n        room = [0]\\n        \\n        for r in room:\\n            for key in rooms[r]:\\n                room += [key] if key not in keys_to_rooms else []\\n                keys_to_rooms |= {key}\\n                    \\n        return len(keys_to_rooms) == len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784454,
                "title": "simple-python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    \\n    def visitAll(self,rooms,index,visited):\\n        if index not in visited:\\n            visited.add(index)\\n            for i in rooms[index]:\\n                self.visitAll(rooms,i,visited)\\n    \\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        self.visitAll(rooms,0,visited)\\n        return len(visited)==len(rooms)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def visitAll(self,rooms,index,visited):\\n        if index not in visited:\\n            visited.add(index)\\n            for i in rooms[index]:\\n                self.visitAll(rooms,i,visited)\\n    \\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        self.visitAll(rooms,0,visited)\\n        return len(visited)==len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160372,
                "title": "dfs-swift-solution-beats-100",
                "content": "```\\nfunc canVisitAllRooms(_ rooms: [[Int]]) -> Bool {\\n    \\n    var visited: Set<Int> = []\\n    var toVisit = [0]\\n    \\n    while !toVisit.isEmpty {\\n        let node = toVisit.popLast()!\\n        \\n        if(!visited.contains(node)) {\\n            visited.insert(node)\\n            \\n            for key in rooms[node] {\\n                toVisit.append(key)\\n            }\\n \\n        }\\n    }\\n    \\n    return rooms.count == visited.count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canVisitAllRooms(_ rooms: [[Int]]) -> Bool {\\n    \\n    var visited: Set<Int> = []\\n    var toVisit = [0]\\n    \\n    while !toVisit.isEmpty {\\n        let node = toVisit.popLast()!\\n        \\n        if(!visited.contains(node)) {\\n            visited.insert(node)\\n            \\n            for key in rooms[node] {\\n                toVisit.append(key)\\n            }\\n \\n        }\\n    }\\n    \\n    return rooms.count == visited.count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133892,
                "title": "12ms-c-stack-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        map<int, bool> mp;        \\n        \\n        stack<int> st;\\n        st.push(0);\\n            \\n        while (!st.empty())\\n        {\\n            int curr = st.top(); \\n            st.pop();\\n            mp[curr] = true;\\n            \\n            for (auto &i: rooms[curr])\\n            {\\n                if (mp[i] == false)\\n                st.push(i);\\n            }\\n        }\\n        \\n        return mp.size() == rooms.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        map<int, bool> mp;        \\n        \\n        stack<int> st;\\n        st.push(0);\\n            \\n        while (!st.empty())\\n        {\\n            int curr = st.top(); \\n            st.pop();\\n            mp[curr] = true;\\n            \\n            for (auto &i: rooms[curr])\\n            {\\n                if (mp[i] == false)\\n                st.push(i);\\n            }\\n        }\\n        \\n        return mp.size() == rooms.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708132,
                "title": "python-simple-clean-code-using-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        v = [False] * len(rooms)\\n        v[0] = True\\n\\n        def dfs(k):\\n            for i in rooms[k]:\\n                if not v[i]:\\n                    v[i] = True\\n                    dfs(i)\\n        \\n        dfs(0)\\n        return all(v)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        v = [False] * len(rooms)\\n        v[0] = True\\n\\n        def dfs(k):\\n            for i in rooms[k]:\\n                if not v[i]:\\n                    v[i] = True\\n                    dfs(i)\\n        \\n        dfs(0)\\n        return all(v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556648,
                "title": "c-easy-bfs-code-o-n-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem gives us direct hint that we must traverse from a room to other room and complete it until we have no rooms left. So, this can be solved using BFS or DFS.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Key points to take away:\\n        1. A Room may or may not contain any keys to other room.\\n        2. A Room can only be opened if we have the key to that room.  \\n        3. The unvisited rooms can only be obtained if we traverse all the rooms.\\n\\n- Solution: \\n- 1. Instead of checking all the rooms, we can check the rooms which we have currently access to.\\n- 2. Then, we can iterate over the next set of accessible rooms and eventually, we will end up either reaching all the rooms or maximum of the rooms.\\n- 3. If we visit all the rooms, then the answer is `true` else, `false`.\\n\\n- Coding Solution:\\n- 1. A list can be used to check if the current room is visited or not.\\n- 2. A Queue can be used to iterate over the next accessible rooms.\\n- 3. If a room that is already visited turns up in the queue, we need not visit it again as we already have all the keys in that room.\\n- 4. We can start with 0, take all the keys in 0th room and iterate through those rooms.\\n- 5. So if we cannot reach any other node from 0, or we cannot reach some nodes from 0, the answer will be `false`.\\n- 6. And if we visit all the rooms, the answer will be `true`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs all the rooms may be visited once, the time complexity will be `O(n)`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs extra queue and vector are being used to store `n` items at max, the space complexity will be `O(n)`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n\\n        // Create a vector to check if we visited all rooms or not\\n        vector<bool> visited(n, false);\\n\\n        // Create a queue for BFS and let us visit room 0 first\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(!q.empty()) {\\n            // Get current room\\n            int index = q.front();\\n            q.pop();\\n\\n            // If already visited, skip it because we already have all the keys from the index\\n            if(visited[index]) continue;\\n\\n            // Mark the room visited and add all rooms which can be unlocked into the queue\\n            visited[index] = true;\\n            for(auto i: rooms[index]) q.push(i);\\n        }\\n\\n        // If any room is unvisited, then we can return false else true\\n        for(auto i: visited) {\\n            if(!i) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n                ```Please Upvote if you like my content.```\\n.",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n\\n        // Create a vector to check if we visited all rooms or not\\n        vector<bool> visited(n, false);\\n\\n        // Create a queue for BFS and let us visit room 0 first\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(!q.empty()) {\\n            // Get current room\\n            int index = q.front();\\n            q.pop();\\n\\n            // If already visited, skip it because we already have all the keys from the index\\n            if(visited[index]) continue;\\n\\n            // Mark the room visited and add all rooms which can be unlocked into the queue\\n            visited[index] = true;\\n            for(auto i: rooms[index]) q.push(i);\\n        }\\n\\n        // If any room is unvisited, then we can return false else true\\n        for(auto i: visited) {\\n            if(!i) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Please Upvote if you like my content.```",
                "codeTag": "Java"
            },
            {
                "id": 3048795,
                "title": "easiest-java-solution-beats-99",
                "content": "# Intuition\\n- Assume the given 2D list as an adjacency list and try to visit each element of the graph if you don\\'t reach all the elements return false else return true.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    void convert(List<List<Integer>>rooms,int index){\\n\\n    st.add(index);\\n\\n    for(int i=0;i<rooms.get(index).size();i++){\\n\\n    if(!st.contains(rooms.get(index).get(i)))\\n    convert(rooms,rooms.get(index).get(i));\\n\\n    }\\n\\n    }\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n\\n    convert(rooms,0);        \\n\\n    return st.size()==rooms.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    void convert(List<List<Integer>>rooms,int index){\\n\\n    st.add(index);\\n\\n    for(int i=0;i<rooms.get(index).size();i++){\\n\\n    if(!st.contains(rooms.get(index).get(i)))\\n    convert(rooms,rooms.get(index).get(i));\\n\\n    }\\n\\n    }\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n\\n    convert(rooms,0);        \\n\\n    return st.size()==rooms.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933781,
                "title": "8-lines-python3-dfs-solution-beats-98-time-comp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA basic graph traversal problem that should return true if you have access to all doors given access to the first one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoosing to use DFS vs BFS algorithm is not really too big of an issue as both will run in the same complexity. Using DFS you can build a quick recursive solution that utilizes an extra array to store whether or not the room has been visited or not. At the end of the DFS the visited array should tell you whether all the rooms have been visited or not.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+E) where N is the number of rooms and E is the number of keys\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) where N is the number of rooms\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        # Initialize a visited array to be all false since none have been visited yet\\n        visited = [False for _ in rooms]\\n\\n        # Create the DFS function that will go through the rooms\\n        def dfs(rooms, visited, index):\\n            if not visited[index]:\\n                visited[index] = True\\n                # Will iterate through every room that can be accessed from nth room and add it to the visited array\\n                for room in rooms[index]:\\n                    dfs(rooms, visited, room)\\n        # Calling the dfs function with 0 as this is the first point we have access to\\n        dfs(rooms, visited, 0)\\n        # all will check to see if entire visited is True, if even one False is in array the output should be False\\n        return all(visited)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        # Initialize a visited array to be all false since none have been visited yet\\n        visited = [False for _ in rooms]\\n\\n        # Create the DFS function that will go through the rooms\\n        def dfs(rooms, visited, index):\\n            if not visited[index]:\\n                visited[index] = True\\n                # Will iterate through every room that can be accessed from nth room and add it to the visited array\\n                for room in rooms[index]:\\n                    dfs(rooms, visited, room)\\n        # Calling the dfs function with 0 as this is the first point we have access to\\n        dfs(rooms, visited, 0)\\n        # all will check to see if entire visited is True, if even one False is in array the output should be False\\n        return all(visited)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933667,
                "title": "simple-bfs-striver-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<int> &vis,vector<vector<int>> rooms){\\n             queue<int> q;\\n             int count=1; //need to count 0 also\\n             q.push(0);   //Starting with 0\\n             while(!q.empty()){\\n                int node = q.front(); q.pop();\\n                for(auto it: rooms[node]){ //Iterating over rooms[0,1,2,3]-->0-->1-->2--->3 etc\\n                    if(vis[it]==0){\\n                         count++;\\n                         vis[it]=1; //marking it visited\\n                        q.push(it);  //Pushing in queue\\n                    }\\n                }\\n             }\\n             return count;          \\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int V = rooms.size();\\n         vector<int> vis(V,0); //Intialise Visited array to 0\\n         vis[0] = 1;     //Marking 0 as visited\\n       int count = bfs(vis,rooms); // bfs called on 0\\n        return V==count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<int> &vis,vector<vector<int>> rooms){\\n             queue<int> q;\\n             int count=1; //need to count 0 also\\n             q.push(0);   //Starting with 0\\n             while(!q.empty()){\\n                int node = q.front(); q.pop();\\n                for(auto it: rooms[node]){ //Iterating over rooms[0,1,2,3]-->0-->1-->2--->3 etc\\n                    if(vis[it]==0){\\n                         count++;\\n                         vis[it]=1; //marking it visited\\n                        q.push(it);  //Pushing in queue\\n                    }\\n                }\\n             }\\n             return count;          \\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int V = rooms.size();\\n         vector<int> vis(V,0); //Intialise Visited array to 0\\n         vis[0] = 1;     //Marking 0 as visited\\n       int count = bfs(vis,rooms); // bfs called on 0\\n        return V==count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932490,
                "title": "dfs-python-beats-97-of-other-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use depth first search for the problem \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPerfoming dfs with source as zero and maintaining a visited array which is initialized to False and we go on into the dfs algorithm the visited array values will be replaced by True . Finally we need to find we need to know that the visited array contains any False values or not , we can use a set to check it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of dfs function is $$O(V+E)$$ and for the set operation $$O(V)$$ . Therefore the overall time complexity is $$O(V+E)$$.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we used a visited and stack space for the dfs function is also considered so the overall space complexity is $$O(V^2)$$ . Which is a worst scenario in terms of space but pretty efficient in terms of time. \\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        def dfs(rooms,visited,source):\\n            visited[source] = True\\n            for i in rooms[source]:\\n                if visited[i] == False:\\n                    dfs(rooms,visited,i)\\n        visited = [False for i in range(len(rooms))]\\n        dfs(rooms,visited,0)\\n        return len(set(visited)) == 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        def dfs(rooms,visited,source):\\n            visited[source] = True\\n            for i in rooms[source]:\\n                if visited[i] == False:\\n                    dfs(rooms,visited,i)\\n        visited = [False for i in range(len(rooms))]\\n        dfs(rooms,visited,0)\\n        return len(set(visited)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931629,
                "title": "c-dfs-easy-understanding",
                "content": "We can visualise this as a **graph** with **rooms as nodes** and the **keys to different rooms as edges**.\\n\\nWe start with making an adjacency list \"graph\" to store all the edges of the graph and a visited array is taken of the same size as rooms array. \\n\\nNow, we just do a normal DFS traversal and **update the visited array**. We check the visited array at the end to see if all rooms were visited or not.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph, vector<bool> &visited, int curr) {\\n        visited[curr] = 1;\\n        for(auto it: graph[curr]) \\n            if(!visited[it]) dfs(graph, visited, it);\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++) {\\n            for(auto it: rooms[i])\\n                graph[i].push_back(it);\\n        }\\n        vector<bool> visited(n,0);\\n        dfs(graph, visited, 0);\\n        for(auto it: visited) if(it==false) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph, vector<bool> &visited, int curr) {\\n        visited[curr] = 1;\\n        for(auto it: graph[curr]) \\n            if(!visited[it]) dfs(graph, visited, it);\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++) {\\n            for(auto it: rooms[i])\\n                graph[i].push_back(it);\\n        }\\n        vector<bool> visited(n,0);\\n        dfs(graph, visited, 0);\\n        for(auto it: visited) if(it==false) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931626,
                "title": "keys-and-rooms-c-easy-dfs-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1)Make a stack put keys of rooms[0] into it;\\n2)Run aloop till stack not empty;\\n3)take top element and pop it out;\\n4)push all keys present in that element (room number) into stack;\\n5)mark every key we got as true; \\n6)cheak for 1 to n-1 key ;\\n7)if all are martked true then ans is true else false;\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n# Code\\n```\\nvoid push(stack<int>&st,vector<int>v){\\nfor(int i=0;i<v.size();i++) st.push(v[i]);\\n}\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n    stack<int>st;\\n    int n=rooms.size();\\n    push(st,rooms[0]);\\n    map<int,bool>mpp;\\n    while(!st.empty()){\\n      int temp=st.top();\\n      st.pop();\\n      if(!mpp[temp]) push(st,rooms[temp]);\\n      mpp[temp]=true;\\n    }\\n    for(int i=1;i<n;i++){\\n        if(!mpp[i]) return false;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1)Make a stack put keys of rooms[0] into it;\\n2)Run aloop till stack not empty;\\n3)take top element and pop it out;\\n4)push all keys present in that element (room number) into stack;\\n5)mark every key we got as true; \\n6)cheak for 1 to n-1 key ;\\n7)if all are martked true then ans is true else false;\\n```\n```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nvoid push(stack<int>&st,vector<int>v){\\nfor(int i=0;i<v.size();i++) st.push(v[i]);\\n}\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n    stack<int>st;\\n    int n=rooms.size();\\n    push(st,rooms[0]);\\n    map<int,bool>mpp;\\n    while(!st.empty()){\\n      int temp=st.top();\\n      st.pop();\\n      if(!mpp[temp]) push(st,rooms[temp]);\\n      mpp[temp]=true;\\n    }\\n    for(int i=1;i<n;i++){\\n        if(!mpp[i]) return false;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931043,
                "title": "java-dfs-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        set.add(0);\\n        helper(rooms, set, 0);\\n        return set.size()==rooms.size();\\n    }\\n\\n    public void helper(List<List<Integer>> rooms, HashSet<Integer> set , int curr){\\n        for(int next: rooms.get(curr)){\\n            if(!set.contains(next)){\\n                set.add(next);\\n                helper(rooms, set, next);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        set.add(0);\\n        helper(rooms, set, 0);\\n        return set.size()==rooms.size();\\n    }\\n\\n    public void helper(List<List<Integer>> rooms, HashSet<Integer> set , int curr){\\n        for(int next: rooms.get(curr)){\\n            if(!set.contains(next)){\\n                set.add(next);\\n                helper(rooms, set, next);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930859,
                "title": "easy-c-solution-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Self Explainatory Code\\nHope You Understand!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>& rooms,vector<int>&vis)\\n    {\\n        vis[node]=1;// Mark Visited to tell that room is unlocked by key\\n        for(auto it:rooms[node]) // To unlock whose keys are in current room\\n        {\\n            if(vis[it]!=1) \\n            {\\n                dfs(it,rooms,vis);//If Room not visited/unlocked earlier then visit the room and unlock it.\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int>vis(rooms.size(),0);//To mark unlocked rooms\\n        int start=0;//To pass the key for first room\\n        dfs(start,rooms,vis);// Function to traverse through all rooms and unlock the locked ones if their keys found.\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(vis[i]==0)return false;//If Room is not unlocked yet then return false;\\n        }\\n        return true;//All rooms are visited and unlocked\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>& rooms,vector<int>&vis)\\n    {\\n        vis[node]=1;// Mark Visited to tell that room is unlocked by key\\n        for(auto it:rooms[node]) // To unlock whose keys are in current room\\n        {\\n            if(vis[it]!=1) \\n            {\\n                dfs(it,rooms,vis);//If Room not visited/unlocked earlier then visit the room and unlock it.\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int>vis(rooms.size(),0);//To mark unlocked rooms\\n        int start=0;//To pass the key for first room\\n        dfs(start,rooms,vis);// Function to traverse through all rooms and unlock the locked ones if their keys found.\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(vis[i]==0)return false;//If Room is not unlocked yet then return false;\\n        }\\n        return true;//All rooms are visited and unlocked\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930532,
                "title": "java-solution-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n       Stack<Integer> dfs = new Stack<>(); dfs.add(0);\\n        HashSet<Integer> seen = new HashSet<Integer>(); seen.add(0);\\n        while (!dfs.isEmpty()) {\\n            int i = dfs.pop();\\n            for (int j : rooms.get(i))\\n                if (!seen.contains(j)) {\\n                    dfs.add(j);\\n                    seen.add(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n       Stack<Integer> dfs = new Stack<>(); dfs.add(0);\\n        HashSet<Integer> seen = new HashSet<Integer>(); seen.add(0);\\n        while (!dfs.isEmpty()) {\\n            int i = dfs.pop();\\n            for (int j : rooms.get(i))\\n                if (!seen.contains(j)) {\\n                    dfs.add(j);\\n                    seen.add(j);\\n                    if (rooms.size() == seen.size()) return true;\\n                }\\n        }\\n        return rooms.size() == seen.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930487,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/OoapoM-H85w\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Complexity\\n- Time complexity:\\n- O(v+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n void dfs(vector<vector<int>>& rooms,vector<int>&visited,int current){\\n        // make visited.\\n        visited[current] = 1;\\n        // traversal.\\n        for(int i =0;i<rooms[current].size();i++){\\n            // if not visited call dfs.\\n            if(!visited[rooms[current][i]]){\\n                dfs(rooms,visited,rooms[current][i]);\\n            }\\n        }\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>visited(n,0);\\n\\n        dfs(rooms,visited,0);\\n\\n        for(int i=0;i<n;i++){\\n            if(visited[i] == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n void dfs(vector<vector<int>>& rooms,vector<int>&visited,int current){\\n        // make visited.\\n        visited[current] = 1;\\n        // traversal.\\n        for(int i =0;i<rooms[current].size();i++){\\n            // if not visited call dfs.\\n            if(!visited[rooms[current][i]]){\\n                dfs(rooms,visited,rooms[current][i]);\\n            }\\n        }\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int>visited(n,0);\\n\\n        dfs(rooms,visited,0);\\n\\n        for(int i=0;i<n;i++){\\n            if(visited[i] == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930341,
                "title": "98-51-javascript-fast-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n# Code\\n```\\n/**\\n * @param {number[][]} rooms\\n * @return {boolean}\\n */\\nvar canVisitAllRooms = function(rooms) {\\n    let arr = new Array(rooms.length).fill(false);\\n\\n    let queue = [rooms[0]]\\n    arr[0] = true\\n    while(queue.length>0){\\n        let v = queue.pop();\\n        for(let i =0; i<v.length; i++){\\n            if(v[i] == 0 || arr[v[i]]) continue;\\n            arr[v[i]] = true;\\n            queue.push(rooms[v[i]])\\n        }\\n    }\\n\\n    for(let i =0; i<arr.length;i++){\\n        if(arr[i] == false) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} rooms\\n * @return {boolean}\\n */\\nvar canVisitAllRooms = function(rooms) {\\n    let arr = new Array(rooms.length).fill(false);\\n\\n    let queue = [rooms[0]]\\n    arr[0] = true\\n    while(queue.length>0){\\n        let v = queue.pop();\\n        for(let i =0; i<v.length; i++){\\n            if(v[i] == 0 || arr[v[i]]) continue;\\n            arr[v[i]] = true;\\n            queue.push(rooms[v[i]])\\n        }\\n    }\\n\\n    for(let i =0; i<arr.length;i++){\\n        if(arr[i] == false) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930173,
                "title": "python-ez-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS intuition from the fact that we have to visit an unvisited path such as rooms for as long as possible to obtain all the rooms we can visit. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple dfs traversal checking all the rooms that are possible to visit, then in the end return whether the rooms visited length matches the total rooms from the input\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nT: O(R + K) where R is # of rooms and K is average # of keys in rooms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nS: O(R + K) where R is # of rooms and K is average # of keys in rooms\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        can_visit = set()\\n\\n        def dfs(key):\\n            if key in can_visit:\\n                return\\n            can_visit.add(key)\\n            for k in rooms[key]:\\n                dfs(k)\\n        dfs(0)\\n        return len(can_visit) == len(rooms)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        can_visit = set()\\n\\n        def dfs(key):\\n            if key in can_visit:\\n                return\\n            can_visit.add(key)\\n            for k in rooms[key]:\\n                dfs(k)\\n        dfs(0)\\n        return len(can_visit) == len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570776,
                "title": "easy-c-code",
                "content": "\\tvoid dfs(int i, vector<vector<int>> &rooms, vector<bool> &visited){\\n        visited[i]=true;\\n        for(auto nbr: rooms[i]){\\n            if(!visited[nbr])\\n                dfs(nbr,rooms,visited);\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<bool> visited(n);\\n        dfs(0,rooms,visited);\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i])\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\tvoid dfs(int i, vector<vector<int>> &rooms, vector<bool> &visited){\\n        visited[i]=true;\\n        for(auto nbr: rooms[i]){\\n            if(!visited[nbr])\\n                dfs(nbr,rooms,visited);\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<bool> visited(n);\\n        dfs(0,rooms,visited);\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i])\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2507951,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n   void  dfs(int i, vector<vector<int>>& rooms, vector<bool>& vis){\\n       vis[i]=true;\\n       for(auto nbr:rooms[i]){\\n           if(!vis[nbr]){\\n                dfs(nbr, rooms, vis);\\n           }\\n       }\\n   }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        dfs(0,rooms,vis);\\n        for(auto i:vis){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void  dfs(int i, vector<vector<int>>& rooms, vector<bool>& vis){\\n       vis[i]=true;\\n       for(auto nbr:rooms[i]){\\n           if(!vis[nbr]){\\n                dfs(nbr, rooms, vis);\\n           }\\n       }\\n   }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> vis(n,false);\\n        dfs(0,rooms,vis);\\n        for(auto i:vis){\\n            if(!i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193271,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> r) {\\n        Queue<Integer> nm=new LinkedList<>();\\n        for(int i=0;i<r.get(0).size();i++)\\n        {\\n            nm.offer(r.get(0).get(i));\\n        }\\n        int k=r.size();\\n        boolean p[]=new boolean[k];\\n        p[0]=true;\\n        while(!nm.isEmpty())\\n        {\\n            int f=nm.poll();\\n            for(int i=0;i<r.get(f).size();i++)\\n            {\\n                if(p[r.get(f).get(i)]==false)\\n                {\\n                    nm.offer(r.get(f).get(i));\\n                }\\n            }\\n            p[f]=true;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            if(!p[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> r) {\\n        Queue<Integer> nm=new LinkedList<>();\\n        for(int i=0;i<r.get(0).size();i++)\\n        {\\n            nm.offer(r.get(0).get(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177137,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs (vector<vector<int>>& rooms, int i, vector<bool> &visited) {\\n        if( visited[i] ) return;\\n        visited[i] = true;\\n        for ( int j=0; j<rooms[i].size(); j++) {\\n            if( !visited[rooms[i][j]] ){\\n                dfs ( rooms , rooms[i][j] , visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n = rooms.size();\\n        vector<bool> visit(n,false);\\n        dfs ( rooms , 0, visit);\\n        for( int i=0; i<n; i++) {\\n            if( !visit[i] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs (vector<vector<int>>& rooms, int i, vector<bool> &visited) {\\n        if( visited[i] ) return;\\n        visited[i] = true;\\n        for ( int j=0; j<rooms[i].size(); j++) {\\n            if( !visited[rooms[i][j]] ){\\n                dfs ( rooms , rooms[i][j] , visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n = rooms.size();\\n        vector<bool> visit(n,false);\\n        dfs ( rooms , 0, visit);\\n        for( int i=0; i<n; i++) {\\n            if( !visit[i] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160053,
                "title": "841-keys-and-rooms-python-easy-explained",
                "content": "**Success**\\nDetails \\nRuntime: 69 ms, faster than **90.50%** of Python3 online submissions for Keys and Rooms.\\nMemory Usage: 14.5 MB, less than **34.84%** of Python3 online submissions for Keys and Rooms.\\n\\n1. Create a Stack and a visited set. Visited set can have 0 initilly because we can access the 0th room without a key. add 0 to the visited set\\n2. While stack is non empty we can pop the element from the stack and check if we have visited that element or not.\\n3.  If not we just add the element to visited set and also add the keys which are in the current room to our stack.\\n4.  Whenever the length of visited set get equal to the total number of rooms we can return True mean we have visited all the room which are there to visit.\\n5.  When the stack becomes empty and if length of visited set is not equal to the total number of rooms we can return False. \\n\\nLeave an upvote if this helps !!!\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        stack=[]\\n        stack=stack+rooms[0]\\n        l=len(rooms)\\n        visited=set()\\n        visited.add(0)\\n        while stack:\\n            if l==len(visited):\\n                return True\\n            curr=stack.pop(0)\\n            if curr not in visited:\\n                visited.add(curr)\\n                stack=stack+rooms[curr]\\n        if len(visited)==l:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        stack=[]\\n        stack=stack+rooms[0]\\n        l=len(rooms)\\n        visited=set()\\n        visited.add(0)\\n        while stack:\\n            if l==len(visited):\\n                return True\\n            curr=stack.pop(0)\\n            if curr not in visited:\\n                visited.add(curr)\\n                stack=stack+rooms[curr]\\n        if len(visited)==l:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993254,
                "title": "c-straight-forward-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void bfs(vector<vector<int>>& r,vector<int> & a,int i){\\n        queue<int> q;\\n        a[0]++;\\n        for(int j=0;j<r[i].size();j++){\\n            if(a[r[i][j]]==0){a[r[i][j]]++;\\n            q.push(r[i][j]);}\\n        }\\n        while(!q.empty()){\\n            int x=q.front(); \\n            q.pop();\\n            for(int j=0;j<r[x].size();j++){\\n                if(a[r[x][j]]==0){\\n                     q.push(r[x][j]);\\n                     a[r[x][j]]++;  \\n                }   \\n            }   \\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        n=rooms.size();\\n        vector<int> v(n,1);\\n        vector<int> a(n,0);\\n        bfs(rooms,a,0);\\n        return a==v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void bfs(vector<vector<int>>& r,vector<int> & a,int i){\\n        queue<int> q;\\n        a[0]++;\\n        for(int j=0;j<r[i].size();j++){\\n            if(a[r[i][j]]==0){a[r[i][j]]++;\\n            q.push(r[i][j]);}\\n        }\\n        while(!q.empty()){\\n            int x=q.front(); \\n            q.pop();\\n            for(int j=0;j<r[x].size();j++){\\n                if(a[r[x][j]]==0){\\n                     q.push(r[x][j]);\\n                     a[r[x][j]]++;  \\n                }   \\n            }   \\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        n=rooms.size();\\n        vector<int> v(n,1);\\n        vector<int> a(n,0);\\n        bfs(rooms,a,0);\\n        return a==v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919433,
                "title": "python-graph-dfs",
                "content": "* visit all the possible nodes through depth first traversal \\n* then check if the visited nodes equal to the nodes present in the graph\\n* If they both are the same return TRUE\\n* else Return False\\n```\\ndef canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        def dfs(rooms,source,visited):\\n            if(source in visited):\\n                return \\n            else:\\n                visited.append(source)\\n                for i in rooms[source]:\\n                    dfs(rooms,i,visited)\\n        visited=[]\\n        dfs(rooms,0,visited)\\n        if(len(visited)==len(rooms)):\\n            return True\\n        return False\\n```\\n* Upvote the answer if you like my answer !!!!!Thank You",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        def dfs(rooms,source,visited):\\n            if(source in visited):\\n                return \\n            else:\\n                visited.append(source)\\n                for i in rooms[source]:\\n                    dfs(rooms,i,visited)\\n        visited=[]\\n        dfs(rooms,0,visited)\\n        if(len(visited)==len(rooms)):\\n            return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1801455,
                "title": "easy-to-understand-bfs-and-iterative-recursive-dfs-solutions",
                "content": "```\\nclass Solution(object):\\n    # bfs\\n    def canVisitAllRooms1(self, rooms):\\n        visited = set()\\n        queue = collections.deque([0])\\n        while queue:\\n            node = queue.popleft()\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            for neighbor in rooms[node]:\\n                queue.append(neighbor)\\n        return len(visited)  == len(rooms)\\n       \\n    # dfs iteratively\\n    def canVisitAllRooms2(self, rooms):\\n        visited = set()\\n        stack = [0]\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            for neighbor in rooms[node]:\\n                stack.append(neighbor)\\n        return len(visited) == len(rooms)\\n    \\n    # dfs recursively\\n    def canVisitAllRooms(self, rooms):\\n        visited = set()\\n        self.dfs(rooms, 0, visited)\\n        return len(visited) == len(rooms)\\n        \\n    def dfs(self, rooms, i, visited):\\n        if i in visited:\\n            return \\n        visited.add(i)\\n        for neighbor in rooms[i]:\\n            self.dfs(rooms, neighbor, visited)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    # bfs\\n    def canVisitAllRooms1(self, rooms):\\n        visited = set()\\n        queue = collections.deque([0])\\n        while queue:\\n            node = queue.popleft()\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            for neighbor in rooms[node]:\\n                queue.append(neighbor)\\n        return len(visited)  == len(rooms)\\n       \\n    # dfs iteratively\\n    def canVisitAllRooms2(self, rooms):\\n        visited = set()\\n        stack = [0]\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            for neighbor in rooms[node]:\\n                stack.append(neighbor)\\n        return len(visited) == len(rooms)\\n    \\n    # dfs recursively\\n    def canVisitAllRooms(self, rooms):\\n        visited = set()\\n        self.dfs(rooms, 0, visited)\\n        return len(visited) == len(rooms)\\n        \\n    def dfs(self, rooms, i, visited):\\n        if i in visited:\\n            return \\n        visited.add(i)\\n        for neighbor in rooms[i]:\\n            self.dfs(rooms, neighbor, visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755399,
                "title": "dfs-solution-6ms-java",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> visited= new HashSet<>();\\n        visited.add(0);\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n        \\n        while(!st.isEmpty()){\\n            List<Integer> keys= rooms.get(st.pop());\\n            for(int key:keys){\\n                if(!visited.contains(key)){\\n                    visited.add(key);\\n                    st.add(key);\\n                }\\n            }\\n        }\\n        return visited.size()==rooms.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> visited= new HashSet<>();\\n        visited.add(0);\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n        \\n        while(!st.isEmpty()){\\n            List<Integer> keys= rooms.get(st.pop());\\n            for(int key:keys){\\n                if(!visited.contains(key)){\\n                    visited.add(key);\\n                    st.add(key);\\n                }\\n            }\\n        }\\n        return visited.size()==rooms.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721164,
                "title": "c-most-intuitive-solution-with-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//count-> just to check whether we are able to go to each room in one dfs call or not\\n\\t\\tint count=0;\\n\\t\\t//dfs call \\n\\t\\tvoid dfs(vector<vector<int>> &graph,vector<bool> &visited,int src){\\n\\t\\t\\t  count++;\\n\\t\\t\\t  visited[src]=true;\\n\\t\\t\\t for(auto nbr: graph[src]){\\n\\t\\t\\t\\t if(!visited[nbr])\\n\\t\\t\\t\\t\\t  dfs(graph,visited,nbr);\\n\\t\\t\\t }\\n\\t\\t}\\n\\t\\tbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\t\\t\\t int n=rooms.size();\\n\\t\\t\\t vector<vector<int>> graph(n);\\n\\t\\t\\tfor(int i=0;i<rooms.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<rooms[i].size();j++){\\n\\t\\t\\t\\t\\tgraph[i].push_back(rooms[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<bool> visited(n,false);\\n\\t\\t\\t//do not apply dfs for each number because for self loop (0->1->2) (3->3) it will give true but answer is false\\n\\t\\t\\tdfs(graph,visited,0);\\n\\t\\t\\t//if in one dfs call we traverse all room means we are done \\n\\t\\t   return count==n;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n**\\tDo upvote If Solution Was Helpful**\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//count-> just to check whether we are able to go to each room in one dfs call or not\\n\\t\\tint count=0;\\n\\t\\t//dfs call \\n\\t\\tvoid dfs(vector<vector<int>> &graph,vector<bool> &visited,int src){\\n\\t\\t\\t  count++;\\n\\t\\t\\t  visited[src]=true;\\n\\t\\t\\t for(auto nbr: graph[src]){\\n\\t\\t\\t\\t if(!visited[nbr])\\n\\t\\t\\t\\t\\t  dfs(graph,visited,nbr);\\n\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1132893,
                "title": "javascript-solution-faster-than-94-dfs-with-total-count",
                "content": "So the solution is basically  a dfs traversal of the rooms, with the added step of keeping track of the \\'total\\' rooms visited during the traversal. If the total number of rooms visited is equal to the length of the rooms array, then we have effectively visited all the rooms ad we return true.\\n\\nWe can add a check in the beginning for the edge cases where the total number of rooms is only 1, or the zeroth room has no keys (rooms[0].length == 0)) in which case we should return the appropriate result.\\n\\n```\\n\\n    function dfs(current){\\n        current.forEach(node => {\\n           if (!(visited.has(node))){\\n               visited.add(node);\\n               total++;\\n               dfs(rooms[node]);\\n           } \\n        });\\n    }\\n   \\n    let visited = new Set();\\n    visited.add(0);\\n    let total = 0;\\n    \\n    dfs(rooms[0]);\\n    return total == rooms.length-1? true:false;\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n    function dfs(current){\\n        current.forEach(node => {\\n           if (!(visited.has(node))){\\n               visited.add(node);\\n               total++;\\n               dfs(rooms[node]);\\n           } \\n        });\\n    }\\n   \\n    let visited = new Set();\\n    visited.add(0);\\n    let total = 0;\\n    \\n    dfs(rooms[0]);\\n    return total == rooms.length-1? true:false;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1129421,
                "title": "c-easy-to-understand-solution-faster-than-41-only-hashmap-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    void vi(vector<vector<int>>& rooms, vector<int>& vis, unordered_map<int, int>& umap, int ind){\\n        if(vis[ind]==1){return;}\\n        vis[ind]=1;\\n        int m=rooms[ind].size();\\n        for(int j=0;j<m;j++){\\n            umap[rooms[ind][j]]=1;\\n            vi(rooms,vis,umap,rooms[ind][j]);\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int> vis(n,0);\\n        unordered_map<int, int> umap;\\n        umap[0]=1;\\n        int i=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1){\\n                continue;\\n            }\\n            else if(umap[i]==1){\\n                vi(rooms,vis,umap,i);\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void vi(vector<vector<int>>& rooms, vector<int>& vis, unordered_map<int, int>& umap, int ind){\\n        if(vis[ind]==1){return;}\\n        vis[ind]=1;\\n        int m=rooms[ind].size();\\n        for(int j=0;j<m;j++){\\n            umap[rooms[ind][j]]=1;\\n            vi(rooms,vis,umap,rooms[ind][j]);\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int> vis(n,0);\\n        unordered_map<int, int> umap;\\n        umap[0]=1;\\n        int i=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==1){\\n                continue;\\n            }\\n            else if(umap[i]==1){\\n                vi(rooms,vis,umap,i);\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116925,
                "title": "c-simple-easy-question",
                "content": "```\\nclass Solution {\\n    bool visited[1001];\\npublic:\\n    void dfs(vector<vector<int> > &rooms,int curr,int &count){\\n        if(visited[curr])\\n            return ;\\n        ++count;\\n        visited[curr]=true;\\n        for(int i=0;i<rooms[curr].size();i++)\\n            dfs(rooms,rooms[curr][i],count);\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int count=0;\\n        memset(visited,101,false);\\n        dfs(rooms,0,count);\\n        return (count==rooms.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool visited[1001];\\npublic:\\n    void dfs(vector<vector<int> > &rooms,int curr,int &count){\\n        if(visited[curr])\\n            return ;\\n        ++count;\\n        visited[curr]=true;\\n        for(int i=0;i<rooms[curr].size();i++)\\n            dfs(rooms,rooms[curr][i],count);\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int count=0;\\n        memset(visited,101,false);\\n        dfs(rooms,0,count);\\n        return (count==rooms.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116846,
                "title": "cpp-iterative-and-recursive-solution-99-47-and-100-better-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool vis[1001];\\n    \\n    void bfs(int node,vector<vector<int>>& rooms)\\n    {\\n        if(!vis[node])\\n        {\\n            vis[node]=true;\\n            for(int i=0;i<rooms[node].size();i++)\\n            {\\n                if(!vis[rooms[node][i]])\\n                {\\n                    bfs(rooms[node][i],rooms);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        //recursive\\n        memset(vis,false,sizeof(vis));\\n        bfs(0,rooms);\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        //itrative\\n        bool vis[rooms.size()];\\n        memset(vis,false,sizeof(vis));\\n        queue<int> Q;\\n        Q.push(0);\\n        while(!Q.empty())\\n        {\\n            int node=Q.front();\\n            if(!vis[node])\\n            {\\n                vis[node]=true;\\n                for(int i=0;i<rooms[node].size();i++)\\n                {\\n                    if(!vis[rooms[node][i]])\\n                    {\\n                        Q.push(rooms[node][i]);\\n                    }\\n                }\\n            }\\n            Q.pop();\\n        }\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\n\\n**If You Like!Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[1001];\\n    \\n    void bfs(int node,vector<vector<int>>& rooms)\\n    {\\n        if(!vis[node])\\n        {\\n            vis[node]=true;\\n            for(int i=0;i<rooms[node].size();i++)\\n            {\\n                if(!vis[rooms[node][i]])\\n                {\\n                    bfs(rooms[node][i],rooms);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        //recursive\\n        memset(vis,false,sizeof(vis));\\n        bfs(0,rooms);\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        //itrative\\n        bool vis[rooms.size()];\\n        memset(vis,false,sizeof(vis));\\n        queue<int> Q;\\n        Q.push(0);\\n        while(!Q.empty())\\n        {\\n            int node=Q.front();\\n            if(!vis[node])\\n            {\\n                vis[node]=true;\\n                for(int i=0;i<rooms[node].size();i++)\\n                {\\n                    if(!vis[rooms[node][i]])\\n                    {\\n                        Q.push(rooms[node][i]);\\n                    }\\n                }\\n            }\\n            Q.pop();\\n        }\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805516,
                "title": "simple-java-solution-using-both-bfs-and-dfs",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        boolean[] visited = new boolean[rooms.size()];\\n        \\n       // DFS(rooms, 0,visited);\\n          BFS(rooms,visited);\\n        \\n        for(int i=0; i<visited.length; i++){\\n            if(visited[i] == false) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // private void DFS(List<List<Integer>> rooms, int sv, boolean[] visited){\\n    //     visited[sv] = true;\\n    //     for(int  i : rooms.get(sv)){\\n    //         if(visited[i] == false)\\n    //             DFS(rooms,i,visited);\\n    //     }\\n    // }\\n    \\n    private void BFS(List<List<Integer>> rooms,boolean[] visited){\\n        \\n        Queue<Integer> queue =  new LinkedList<>();\\n        visited[0] = true;\\n        for(int i : rooms.get(0)){\\n            queue.add(i);\\n            visited[i] = true;\\n        }\\n        while(!queue.isEmpty()){\\n            int v = queue.poll();\\n            for(int i : rooms.get(v)){\\n                if(visited[i] == false){\\n                    queue.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        boolean[] visited = new boolean[rooms.size()];\\n        \\n       // DFS(rooms, 0,visited);\\n          BFS(rooms,visited);\\n        \\n        for(int i=0; i<visited.length; i++){\\n            if(visited[i] == false) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // private void DFS(List<List<Integer>> rooms, int sv, boolean[] visited){\\n    //     visited[sv] = true;\\n    //     for(int  i : rooms.get(sv)){\\n    //         if(visited[i] == false)\\n    //             DFS(rooms,i,visited);\\n    //     }\\n    // }\\n    \\n    private void BFS(List<List<Integer>> rooms,boolean[] visited){\\n        \\n        Queue<Integer> queue =  new LinkedList<>();\\n        visited[0] = true;\\n        for(int i : rooms.get(0)){\\n            queue.add(i);\\n            visited[i] = true;\\n        }\\n        while(!queue.isEmpty()){\\n            int v = queue.poll();\\n            for(int i : rooms.get(v)){\\n                if(visited[i] == false){\\n                    queue.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624630,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    vector<bool>visited;\\n    \\n    void dfs(vector<vector<int>>& rooms, int v) {\\n        \\n        if (visited[v]) return;\\n        \\n        visited[v] = true;\\n        for (auto it = rooms[v].begin(); it != rooms[v].end(); it++)\\n            dfs(rooms, *it);\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n = rooms.size();\\n        \\n        visited.resize(n, false);\\n        \\n        dfs(rooms, 0);\\n        \\n        for (int i = 0; i < visited.size(); i++) \\n            if (!visited[i])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<bool>visited;\\n    \\n    void dfs(vector<vector<int>>& rooms, int v) {\\n        \\n        if (visited[v]) return;\\n        \\n        visited[v] = true;\\n        for (auto it = rooms[v].begin(); it != rooms[v].end(); it++)\\n            dfs(rooms, *it);\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n = rooms.size();\\n        \\n        visited.resize(n, false);\\n        \\n        dfs(rooms, 0);\\n        \\n        for (int i = 0; i < visited.size(); i++) \\n            if (!visited[i])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317947,
                "title": "c-bfs-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool> visited(rooms.size(), false);\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            visited[i] = true;\\n            for(auto key:rooms[i]) if(visited[key] == false) q.push(key);\\n        }\\n        for(auto i:visited) if(i == false) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool> visited(rooms.size(), false);\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            visited[i] = true;\\n            for(auto key:rooms[i]) if(visited[key] == false) q.push(key);\\n        }\\n        for(auto i:visited) if(i == false) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133871,
                "title": "simple-dfs",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] v = new boolean[rooms.size()];\\n        dfs (rooms, 0, v);\\n        for (boolean each: v) {\\n            if (each == false) return false;\\n        } \\n        return true;\\n    }\\n    \\n    private void dfs(List<List<Integer>> rooms, int i, boolean[] v) {\\n        if (v[i] == true) return;\\n        v[i] = true;\\n        for (int room : rooms.get(i)) {\\n            dfs(rooms, room, v);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] v = new boolean[rooms.size()];\\n        dfs (rooms, 0, v);\\n        for (boolean each: v) {\\n            if (each == false) return false;\\n        } \\n        return true;\\n    }\\n    \\n    private void dfs(List<List<Integer>> rooms, int i, boolean[] v) {\\n        if (v[i] == true) return;\\n        v[i] = true;\\n        for (int room : rooms.get(i)) {\\n            dfs(rooms, room, v);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133856,
                "title": "easy-to-understand-python",
                "content": "```\\ndef canVisitAllRooms(self, rooms):\\n    visited = [0] * len(rooms)\\n\\n    def _canVisitAllRooms(i):\\n        if visited[i]:\\n            return\\n        visited[i] = True\\n        for j in range(len(rooms[i])):\\n            _canVisitAllRooms(rooms[i][j])\\n        return\\n\\n    _canVisitAllRooms(0)\\n    return all(visited)\\n```",
                "solutionTags": [],
                "code": "```\\ndef canVisitAllRooms(self, rooms):\\n    visited = [0] * len(rooms)\\n\\n    def _canVisitAllRooms(i):\\n        if visited[i]:\\n            return\\n        visited[i] = True\\n        for j in range(len(rooms[i])):\\n            _canVisitAllRooms(rooms[i][j])\\n        return\\n\\n    _canVisitAllRooms(0)\\n    return all(visited)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3959774,
                "title": "easy-java-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n + k), where n is the number of rooms and k is the average number of keys.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) due to recursion stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int total = rooms.size();\\n        boolean[] visited = new boolean[total];\\n        visited[0] = true; // Starting from room 0\\n        \\n        dfs(rooms, 0, visited);\\n        \\n        for (boolean roomVisited : visited) {\\n            if (!roomVisited) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void dfs(List<List<Integer>> rooms, int room, boolean[] visited) {\\n        for (int key : rooms.get(room)) {\\n            if (!visited[key]) {\\n                visited[key] = true;\\n                dfs(rooms, key, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int total = rooms.size();\\n        boolean[] visited = new boolean[total];\\n        visited[0] = true; // Starting from room 0\\n        \\n        dfs(rooms, 0, visited);\\n        \\n        for (boolean roomVisited : visited) {\\n            if (!roomVisited) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void dfs(List<List<Integer>> rooms, int room, boolean[] visited) {\\n        for (int key : rooms.get(room)) {\\n            if (!visited[key]) {\\n                visited[key] = true;\\n                dfs(rooms, key, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750646,
                "title": "beats-100-onlyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        boolean[] visited = new boolean[n];\\n        int ans = helper(rooms, visited, 0,n);\\n        return ans == n;\\n    }\\n    public int helper(List<List<Integer>> rooms, boolean[] visited, int curr, int n) {\\n        if(visited[curr]) {\\n            return 0;\\n        }\\n        visited[curr] = true;\\n        int ans = 1;\\n        for(int i = 0; i<rooms.get(curr).size(); i++) {\\n            List<Integer> keys = rooms.get(curr);\\n            ans += helper(rooms, visited, keys.get(i), n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        boolean[] visited = new boolean[n];\\n        int ans = helper(rooms, visited, 0,n);\\n        return ans == n;\\n    }\\n    public int helper(List<List<Integer>> rooms, boolean[] visited, int curr, int n) {\\n        if(visited[curr]) {\\n            return 0;\\n        }\\n        visited[curr] = true;\\n        int ans = 1;\\n        for(int i = 0; i<rooms.get(curr).size(); i++) {\\n            List<Integer> keys = rooms.get(curr);\\n            ans += helper(rooms, visited, keys.get(i), n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750640,
                "title": "beats-89-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n=rooms.size();\\n        boolean[] vis=new boolean[n];\\n        int visitedN=0;\\n        visit(rooms,0,vis);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]) visitedN++;\\n        }\\n        if(visitedN == n) return true;\\n        else return false;\\n    }\\n    void visit(List<List<Integer>> rooms, int i, boolean [] visited) {\\n        if(visited[i]) return;\\n\\n\\n        visited[i] = true;\\n\\n        List<Integer> keys = rooms.get(i);\\n        for(Integer next : keys){\\n            visit(rooms, next, visited);\\n        }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n=rooms.size();\\n        boolean[] vis=new boolean[n];\\n        int visitedN=0;\\n        visit(rooms,0,vis);\\n        for(int i=0; i<n; i++){\\n            if(vis[i]) visitedN++;\\n        }\\n        if(visitedN == n) return true;\\n        else return false;\\n    }\\n    void visit(List<List<Integer>> rooms, int i, boolean [] visited) {\\n        if(visited[i]) return;\\n\\n\\n        visited[i] = true;\\n\\n        List<Integer> keys = rooms.get(i);\\n        for(Integer next : keys){\\n            visit(rooms, next, visited);\\n        }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531267,
                "title": "easy-c-solution-dfs-unordered-set",
                "content": "# Intuition\\nThe code performs a depth-first search (DFS) starting from room 0, keeping track of visited rooms using an unordered set, and checks if all rooms have been visited at the end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a graph traversal algorithm (e.g., DFS or BFS) to visit all reachable rooms starting from room 0, keeping track of visited rooms using a set or unordered set. At the end, we check if all rooms have been visited.\\n# Complexity\\n- Time complexity:\\nO(N + E)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        unordered_set<int> visited;\\n        dfs(rooms, 0, visited);\\n        return visited.size() == n;\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms, int currRoom, unordered_set<int>& visited) {\\n        visited.insert(currRoom);\\n        for (int key : rooms[currRoom]) {\\n            if (visited.count(key) == 0) {\\n                dfs(rooms, key, visited);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        unordered_set<int> visited;\\n        dfs(rooms, 0, visited);\\n        return visited.size() == n;\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms, int currRoom, unordered_set<int>& visited) {\\n        visited.insert(currRoom);\\n        for (int key : rooms[currRoom]) {\\n            if (visited.count(key) == 0) {\\n                dfs(rooms, key, visited);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489359,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector <int> current;\\n        current.emplace_back(0);\\n        int index = 0;\\n        vector <bool> marked(rooms.size());\\n        marked[0]=true;\\n        while(current.size()!=index){\\n            for (auto node: rooms[current[index]]){\\n                if(marked[node]==false){\\n                    marked[node]=true;\\n                    current.emplace_back(node);\\n                }\\n            }\\n            index++;\\n        }\\n        return index == rooms.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        stack = [0] \\n        while stack:\\n            room = stack.pop()\\n            if not seen[room]:  \\n                seen[room] = True\\n                for key in rooms[room]:\\n                        stack.append(key)\\n        \\n        return all(seen)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int N = rooms.size();\\n        boolean [] visited = new boolean[N];\\n        visit(rooms, 0, visited);\\n        int visitedN=0;\\n        for(int i=0; i<N; i++){\\n            if(visited[i]) visitedN++;\\n        }\\n        if(visitedN == N) return true;\\n        else return false;\\n    }\\n    void visit(List<List<Integer>> rooms, int i, boolean [] visited) {\\n        if(visited[i]) return;\\n        visited[i] = true;\\n        List<Integer> keys = rooms.get(i);\\n        for(Integer next : keys){\\n            visit(rooms, next, visited);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector <int> current;\\n        current.emplace_back(0);\\n        int index = 0;\\n        vector <bool> marked(rooms.size());\\n        marked[0]=true;\\n        while(current.size()!=index){\\n            for (auto node: rooms[current[index]]){\\n                if(marked[node]==false){\\n                    marked[node]=true;\\n                    current.emplace_back(node);\\n                }\\n            }\\n            index++;\\n        }\\n        return index == rooms.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        n = len(rooms)\\n        seen = [False] * n\\n        stack = [0] \\n        while stack:\\n            room = stack.pop()\\n            if not seen[room]:  \\n                seen[room] = True\\n                for key in rooms[room]:\\n                        stack.append(key)\\n        \\n        return all(seen)\\n```\n```Java []\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int N = rooms.size();\\n        boolean [] visited = new boolean[N];\\n        visit(rooms, 0, visited);\\n        int visitedN=0;\\n        for(int i=0; i<N; i++){\\n            if(visited[i]) visitedN++;\\n        }\\n        if(visitedN == N) return true;\\n        else return false;\\n    }\\n    void visit(List<List<Integer>> rooms, int i, boolean [] visited) {\\n        if(visited[i]) return;\\n        visited[i] = true;\\n        List<Integer> keys = rooms.get(i);\\n        for(Integer next : keys){\\n            visit(rooms, next, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094526,
                "title": "java-very-easy-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer>q=new LinkedList<>();\\n        int n=rooms.size();\\n        boolean temp[]=new boolean[n];\\n        Arrays.fill(temp,false);\\n\\n        for(int i=0;i<rooms.get(0).size();i++){\\n            q.add(rooms.get(0).get(i));\\n        }\\n\\n        temp[0]=true;\\n\\n        while(!q.isEmpty()){\\n            int x=q.peek();\\n            if(!temp[x]){\\n                int N=rooms.get(x).size();\\n                for(int i=0;i<N;i++){\\n                    if(!temp[rooms.get(x).get(i)]){\\n                        q.add(rooms.get(x).get(i));\\n                    }\\n                }\\n                temp[x]=true;\\n            }\\n            q.poll();\\n        }\\n\\n        for(int i=0;i<temp.length;i++){\\n            if(temp[i]==false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer>q=new LinkedList<>();\\n        int n=rooms.size();\\n        boolean temp[]=new boolean[n];\\n        Arrays.fill(temp,false);\\n\\n        for(int i=0;i<rooms.get(0).size();i++){\\n            q.add(rooms.get(0).get(i));\\n        }\\n\\n        temp[0]=true;\\n\\n        while(!q.isEmpty()){\\n            int x=q.peek();\\n            if(!temp[x]){\\n                int N=rooms.get(x).size();\\n                for(int i=0;i<N;i++){\\n                    if(!temp[rooms.get(x).get(i)]){\\n                        q.add(rooms.get(x).get(i));\\n                    }\\n                }\\n                temp[x]=true;\\n            }\\n            q.poll();\\n        }\\n\\n        for(int i=0;i<temp.length;i++){\\n            if(temp[i]==false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933576,
                "title": "video",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/9uf5la94VDw\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nvar canVisitAllRooms = function(rooms) {\\n    let stack = new Array();\\n    let visited = new Set();\\n\\n    stack.push(...rooms[0]);\\n    visited.add(0);\\n    while(stack.length) {\\n        let r = stack.pop();\\n        if (visited.has(r)) continue;\\n        visited.add(r);\\n        stack.push(...rooms[r]);\\n    }\\n    return visited.size == rooms.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canVisitAllRooms = function(rooms) {\\n    let stack = new Array();\\n    let visited = new Set();\\n\\n    stack.push(...rooms[0]);\\n    visited.add(0);\\n    while(stack.length) {\\n        let r = stack.pop();\\n        if (visited.has(r)) continue;\\n        visited.add(r);\\n        stack.push(...rooms[r]);\\n    }\\n    return visited.size == rooms.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2933433,
                "title": "straightforward-short-solution-with-set",
                "content": "Surprisingly it worked pretty good.\\n```\\nconst canVisitAllRooms = function(rooms) {\\n    const accessableRooms = new Set([0]);\\n\\n    for (const room of accessableRooms) {\\n      rooms[room].forEach(key => accessableRooms.add(key))\\n    }\\n\\n    return accessableRooms.size === rooms.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst canVisitAllRooms = function(rooms) {\\n    const accessableRooms = new Set([0]);\\n\\n    for (const room of accessableRooms) {\\n      rooms[room].forEach(key => accessableRooms.add(key))\\n    }\\n\\n    return accessableRooms.size === rooms.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2933432,
                "title": "easy-and-simple-intuitive-python-soultion-with-explanation-dfs",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis is classical DFS and BFS problem. We can solve it using DFS approach.(Recursion).\\n\\n**Problem Statement**\\nIn the problem, we are given certain keys and rooms. Our task is to find is it possible to visit all the rooms or not if we are initially at room 0. If it is possible then return True else False.\\n\\n**DFS Approach**\\nInitially, the room 0 is unlocked or we can say it is our starting point and the keys in it are accessible to us and using that we can visit to those rooms. \\n\\nHere we can create a recursive DFS function (**IsPossible**) in which we will start with room 0 and will keep on moving to other rooms, of which we are having keys in that particular room and we will do this till we have not visited every rooms for which the key is accessible to us.\\n\\nNow, we have to keep a check which room we have visited. So for that we will make an array of False and we will change that particular index to True for which we got the key.\\n\\nWith the help of the visited array we can keep a track of which rooms we have visited at the end of function and from there we will return our ans.\\n\\nWe will return True if all the values in visited array is True otherwise False, even if a single room is unvisited.\\n\\n# Complexity\\n- Time complexity: O(N + k), where N is the number of rooms and k is the total number of keys.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N), where N is the number of rooms (Extra Space because of visited array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        visited = [False for i in range(len(rooms))]\\n        self.IsPossible(rooms, 0, visited)\\n\\n        for visit in visited:\\n            if(visit == False):\\n                return False\\n        return True\\n\\n    def IsPossible(self, rooms, index, visited):\\n\\n        if(visited[index] == True):\\n            return\\n        \\n        visited[index] = True\\n        for key in rooms[index]:\\n            if(visited[key] == False):\\n                self.IsPossible(rooms, key, visited)\\n        return\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n\\n        visited = [False for i in range(len(rooms))]\\n        self.IsPossible(rooms, 0, visited)\\n\\n        for visit in visited:\\n            if(visit == False):\\n                return False\\n        return True\\n\\n    def IsPossible(self, rooms, index, visited):\\n\\n        if(visited[index] == True):\\n            return\\n        \\n        visited[index] = True\\n        for key in rooms[index]:\\n            if(visited[key] == False):\\n                self.IsPossible(rooms, key, visited)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932956,
                "title": "java-dfs-easiest",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(rooms, 0, visited);\\n\\n        return visited.size() == n;\\n    }\\n\\n    private void dfs(List<List<Integer>> rooms, int room, Set<Integer> visited) {\\n        if(visited.contains(room)) {\\n            return;\\n        }\\n        visited.add(room);\\n        rooms.get(room).forEach(x -> dfs(rooms, x, visited));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(rooms, 0, visited);\\n\\n        return visited.size() == n;\\n    }\\n\\n    private void dfs(List<List<Integer>> rooms, int room, Set<Integer> visited) {\\n        if(visited.contains(room)) {\\n            return;\\n        }\\n        visited.add(room);\\n        rooms.get(room).forEach(x -> dfs(rooms, x, visited));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932819,
                "title": "beginner-friendly-code-python",
                "content": "\\n\\n# Approach\\nusing stack to append key of each into visited rooms if total visited  is equal to length of rooms then return True \\n[[1, 3], [3, 0, 1], [2], [0]]\\n1. visited = [], stack = [0] --> visited = [0], stack = []\\n2. vitited = [0], stack = [1, 3] --> visited = [0, 3, 1]\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        stack = [0]\\n        while stack:\\n            room = stack.pop()\\n            visited.add(room)\\n            for key in rooms[room]:\\n                if key not in visited:\\n                    stack.append(key)\\n        return len(visited) == len(rooms)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set()\\n        stack = [0]\\n        while stack:\\n            room = stack.pop()\\n            visited.add(room)\\n            for key in rooms[room]:\\n                if key not in visited:\\n                    stack.append(key)\\n        return len(visited) == len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932781,
                "title": "recursive-solution-with-visited-array-clean-code-1ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean isPossible(int src, List<List<Integer>> rooms, boolean[] visited){\\n\\n        visited[src] = true;\\n        boolean flag = true;\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n            return true;\\n        \\n        for(int key : rooms.get(src)){\\n            if(!visited[key])\\n                if(isPossible(key, rooms, visited))\\n                    return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        return isPossible(0, rooms, new boolean[rooms.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean isPossible(int src, List<List<Integer>> rooms, boolean[] visited){\\n\\n        visited[src] = true;\\n        boolean flag = true;\\n        for(int i=0;i<visited.length;i++){\\n            if(!visited[i]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n            return true;\\n        \\n        for(int key : rooms.get(src)){\\n            if(!visited[key])\\n                if(isPossible(key, rooms, visited))\\n                    return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n        return isPossible(0, rooms, new boolean[rooms.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932743,
                "title": "easiest-for-beginner-with-solving-approach-explanation-in-points",
                "content": "### Explanation\\n- Given by question, the first room is unlocked, so the keys found inside the first room is now collected in a key chain(take this as Stack).\\n- Now we have keys in our key chain, we will continue the loop until the key chain is empty.\\n- Now we remove the top most key from that key chain and keep in our hand.\\n- Now we will check if the key we have in our hand is already used or not.\\n- If this key is not used, we will use this key to open its room. And we will add this room record to our visited rooms set.\\n- Now in this newly unlocked room, we might find new keys, we will collect the keys we find in this room and keep in our key chain so that we can unlock more rooms.\\n- As we are in loop until the key chain is not empty, we will be continously be using keys from key chain to unlock new rooms.\\n- Once all the keys from our key chain are used, we compare the number of rooms unlocked with the total rooms. If rooms that are unlocked until the key chain is empty matches with total number of rooms. The function returns True else it returns False.\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        keys_in_hand = rooms[0]\\n        rooms_unlocked = {0}\\n        while keys_in_hand:\\n            # popping to remove key from hand once we use that key\\n            room_to_unlock = keys_in_hand.pop()\\n            if room_to_unlock not in rooms_unlocked:\\n                rooms_unlocked.add(room_to_unlock)\\n                # now keeping the keys in hand that we find in newly unlocked room\\n                keys_in_hand += rooms[room_to_unlock]\\n        return len(rooms_unlocked) == len(rooms)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        keys_in_hand = rooms[0]\\n        rooms_unlocked = {0}\\n        while keys_in_hand:\\n            # popping to remove key from hand once we use that key\\n            room_to_unlock = keys_in_hand.pop()\\n            if room_to_unlock not in rooms_unlocked:\\n                rooms_unlocked.add(room_to_unlock)\\n                # now keeping the keys in hand that we find in newly unlocked room\\n                keys_in_hand += rooms[room_to_unlock]\\n        return len(rooms_unlocked) == len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932691,
                "title": "easy-java-implementation-using-stack-and-set",
                "content": "\\n\\n\\n# Approach\\nTake a stack (to store the rooms which can be visited),initially add 0 to it.\\nTake a HashSet (to store the visited rooms),initially add 0 to it ,since 0 is open according to the question.\\nNow pop each element of the stack and check the keys available in popped room number and also add the new room numbers in the set and stack whose keys are found.\\nFinally when the stack is empty check if the size of the set is same as the number of rooms available(return true or false accordingly).\\n\\n\\n# Code\\n```\\nclass Solution {\\n        public static boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Stack<Integer> st = new Stack<>();\\n        st.add(0);\\n        HashSet<Integer> visited = new HashSet<Integer>();\\n        visited.add(0);\\n        while (!st.isEmpty()) {\\n            int i = st.pop();\\n            for (int j : rooms.get(i))\\n                if (!visited.contains(j)) {\\n                    st.add(j);\\n                    visited.add(j);\\n                    // if (rooms.size() == visited.size()) return true;\\n                }\\n        }\\n        return rooms.size() == visited.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n        public static boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Stack<Integer> st = new Stack<>();\\n        st.add(0);\\n        HashSet<Integer> visited = new HashSet<Integer>();\\n        visited.add(0);\\n        while (!st.isEmpty()) {\\n            int i = st.pop();\\n            for (int j : rooms.get(i))\\n                if (!visited.contains(j)) {\\n                    st.add(j);\\n                    visited.add(j);\\n                    // if (rooms.size() == visited.size()) return true;\\n                }\\n        }\\n        return rooms.size() == visited.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932548,
                "title": "very-simple-solution-using-queue-java-solution",
                "content": "*If you like it please **Upvote** this Solution!*\\n\\n# Complexity\\n- Time complexity:O(V + E)  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        boolean[] visited = new boolean[rooms.size()];\\n\\n        visited[0] = true;\\n        for(int i: rooms.get(0)) {\\n            queue.add(i);\\n            visited[i] = true;\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            int temp = queue.poll();\\n            for(int i: rooms.get(temp)) {\\n                if(visited[i] == false) {\\n                    queue.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n\\n        for(int i = 1; i < visited.length; i++) {\\n            if(visited[i] == false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# Happy Coding:)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        boolean[] visited = new boolean[rooms.size()];\\n\\n        visited[0] = true;\\n        for(int i: rooms.get(0)) {\\n            queue.add(i);\\n            visited[i] = true;\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            int temp = queue.poll();\\n            for(int i: rooms.get(temp)) {\\n                if(visited[i] == false) {\\n                    queue.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n\\n        for(int i = 1; i < visited.length; i++) {\\n            if(visited[i] == false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932508,
                "title": "c-easy-approach-solution",
                "content": "# Intuition\\nLooking at the question we can see that we are being asked whether we can visit all the rooms from room 0 which looks like to check whether all the nodes of graph can be visited from the source node or not.\\n\\n# Approach\\nTo solve this problem a simple BFS solution would work fine.\\n\\n# Complexity\\n- Time complexity:O(V+E) where V is number of vertices and E is the number of edges.\\n\\n- Space complexity: O(n) where n is the size of rooms vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>visited(n,0);\\n        bool flag=true;\\n        visited[0]=1;\\n        queue<int>q;\\n        for(int i=0;i<rooms[0].size();i++){\\n            q.push(rooms[0][i]);\\n        }\\n        while(!q.empty()){\\n            int x=q.front();\\n            q.pop();\\n            if(!visited[x]){\\n            visited[x]=1;\\n            for(int i=0;i<rooms[x].size();i++){\\n                    q.push(rooms[x][i]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>visited(n,0);\\n        bool flag=true;\\n        visited[0]=1;\\n        queue<int>q;\\n        for(int i=0;i<rooms[0].size();i++){\\n            q.push(rooms[0][i]);\\n        }\\n        while(!q.empty()){\\n            int x=q.front();\\n            q.pop();\\n            if(!visited[x]){\\n            visited[x]=1;\\n            for(int i=0;i<rooms[x].size();i++){\\n                    q.push(rooms[x][i]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932296,
                "title": "c-beats-90-runtime-explained-using-dfs",
                "content": "# Easy And Beginner Friendly\\n\\n    Runtime - 90%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Assume Rooms as your Adjacency List & create a visited array.\\n2. Start DFS for Node-0 and mark it as Visited then call DFS for all nodes that are present in rooms array at Node-0 position.\\n3. At last check if every element is visited or not if it is not then return False else return True.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> & visited,vector<vector<int>>& rooms,int v){\\n        if(visited[v])return;\\n        visited[v]=1;\\n        for(auto u:rooms[v]){\\n            dfs(visited,rooms,u);\\n        }\\n        return;\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> visited(rooms.size());\\n        dfs(visited,rooms,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i]==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> & visited,vector<vector<int>>& rooms,int v){\\n        if(visited[v])return;\\n        visited[v]=1;\\n        for(auto u:rooms[v]){\\n            dfs(visited,rooms,u);\\n        }\\n        return;\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> visited(rooms.size());\\n        dfs(visited,rooms,0);\\n        for(int i=0;i<rooms.size();i++){\\n            if(visited[i]==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931994,
                "title": "easy-and-efficient-java-code-in-both-dfs-and-bfs-way",
                "content": "\\n# DFS Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] vis = new boolean[rooms.size()];\\n        dfs(rooms,vis,0);\\n        \\n        for(int i=0; i<vis.length; i++){\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n    }\\n    public void dfs(List<List<Integer>> rooms,boolean[] vis,int s){\\n        vis[s] = true;\\n        for(int i=0; i<rooms.get(s).size(); i++){\\n            if(vis[rooms.get(s).get(i)]==false){\\n                dfs(rooms,vis,rooms.get(s).get(i));\\n            }\\n        }\\n    }\\n}\\n```\\n# BFS Code\\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        boolean[] vis = new boolean[rooms.size()];\\n        q.add(0);\\n        vis[0] =true;\\n        while(q.size()>0){\\n            int n = q.remove();\\n            vis[n] = true;\\n            for(int i=0; i<rooms.get(n).size(); i++){\\n                if(vis[rooms.get(n).get(i)]==false){\\n                    q.add(rooms.get(n).get(i));\\n                }\\n            }\\n        }\\n        for(int i=0; i<vis.length; i++){\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean[] vis = new boolean[rooms.size()];\\n        dfs(rooms,vis,0);\\n        \\n        for(int i=0; i<vis.length; i++){\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n    }\\n    public void dfs(List<List<Integer>> rooms,boolean[] vis,int s){\\n        vis[s] = true;\\n        for(int i=0; i<rooms.get(s).size(); i++){\\n            if(vis[rooms.get(s).get(i)]==false){\\n                dfs(rooms,vis,rooms.get(s).get(i));\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        boolean[] vis = new boolean[rooms.size()];\\n        q.add(0);\\n        vis[0] =true;\\n        while(q.size()>0){\\n            int n = q.remove();\\n            vis[n] = true;\\n            for(int i=0; i<rooms.get(n).size(); i++){\\n                if(vis[rooms.get(n).get(i)]==false){\\n                    q.add(rooms.get(n).get(i));\\n                }\\n            }\\n        }\\n        for(int i=0; i<vis.length; i++){\\n            if(vis[i]==false) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931850,
                "title": "simple-recursion-using-dfs-beats-87-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to check whether the elements in rooms[i] are visited before or not. We can do this by using a hash. If the element is already visited do nothing else add the new element to hash and then perform dfs on the new element indexed in rooms.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. define a hash with key and value as 0,0 since the key to rooms[0] is 0 itself.\\n2. create a function dfs() which will take rooms[0] as initial parameter. since the keys the next rooms will start from 0th room only.\\n3. if room is empty return\\n4. else take a key from room\\n5. if key is not already present in our hash then add it and here I don\\'t have anything to do with value since I already have my next keys at rooms[key].\\n6. continue dfs as long as room is empty( i.e we took all keys from it )\\n7. Now our hash has all the keys present in rooms. If a room is unvisited then length of hash will be less than number of rooms.\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        h = {0:0}\\n        def dfs(room):\\n            if not room:\\n                return\\n            key = room.pop()\\n\\n            if key not in h:\\n                h[key] = 0 \\n                dfs(rooms[key])\\n                \\n            if len(room)!=0:\\n                dfs(room)\\n        \\n        dfs(rooms[0])\\n        return len(rooms) == len(h)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        h = {0:0}\\n        def dfs(room):\\n            if not room:\\n                return\\n            key = room.pop()\\n\\n            if key not in h:\\n                h[key] = 0 \\n                dfs(rooms[key])\\n                \\n            if len(room)!=0:\\n                dfs(room)\\n        \\n        dfs(rooms[0])\\n        return len(rooms) == len(h)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931749,
                "title": "simple-dfs-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> adj) {\\n        int n = adj.size();        \\n        boolean[] vis = new boolean[n];\\n        canBeVisited(adj, 0, vis);\\n        \\n        for(boolean val: vis){\\n            if(!val) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void canBeVisited(List<List<Integer>> adj, int room, boolean[] vis){\\n        vis[room] = true;\\n        \\n        for(int key: adj.get(room)){\\n            if(!vis[key]){\\n                canBeVisited(adj, key, vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> adj) {\\n        int n = adj.size();        \\n        boolean[] vis = new boolean[n];\\n        canBeVisited(adj, 0, vis);\\n        \\n        for(boolean val: vis){\\n            if(!val) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void canBeVisited(List<List<Integer>> adj, int room, boolean[] vis){\\n        vis[room] = true;\\n        \\n        for(int key: adj.get(room)){\\n            if(!vis[key]){\\n                canBeVisited(adj, key, vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931574,
                "title": "java-dfs-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        //creat one boolean array for to check all the rooms are visited or not\\n        boolean[] arr = new boolean[rooms.size()];\\n\\t\\t//you always can go to 0th index room\\n        arr[0] = true;\\n        //call the method\\n        checkTheRoom(arr,rooms,0);\\n        //check the resultant array\\n        for(boolean ind:arr){\\n            if(!ind){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public void checkTheRoom(boolean[] arr,List<List<Integer>> rooms,int currInd){ \\n        if(arr[currInd] && currInd!=0){\\n            return;\\n        }\\n\\t\\t//make current ind as traversed \\n        arr[currInd] = true;\\n        List<Integer> room = rooms.get(currInd);\\n\\t\\t//do recursion for other rooms for that index\\n        for(int roomInd:room){\\n            checkTheRoom(arr,rooms,roomInd);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        //creat one boolean array for to check all the rooms are visited or not\\n        boolean[] arr = new boolean[rooms.size()];\\n\\t\\t//you always can go to 0th index room\\n        arr[0] = true;\\n        //call the method\\n        checkTheRoom(arr,rooms,0);\\n        //check the resultant array\\n        for(boolean ind:arr){\\n            if(!ind){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public void checkTheRoom(boolean[] arr,List<List<Integer>> rooms,int currInd){ \\n        if(arr[currInd] && currInd!=0){\\n            return;\\n        }\\n\\t\\t//make current ind as traversed \\n        arr[currInd] = true;\\n        List<Integer> room = rooms.get(currInd);\\n\\t\\t//do recursion for other rooms for that index\\n        for(int roomInd:room){\\n            checkTheRoom(arr,rooms,roomInd);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930996,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->As we know that room 0 is already unlocked so we have initially stored all the rooms which we can unlock with the keys present at room 0 then we are traversing over unlocked rooms and storing the room number which we can unlock.At last we have checked whether all the rooms are unlocked or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        lis=[]\\n        lis.extend(rooms[0])\\n        for i in lis:\\n            for j in rooms[i]:\\n                if(j not in lis):\\n                    lis.append(j)\\n        for i in range(1,len(rooms)):\\n            if(i not in lis):\\n                return(False)\\n        return(True)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        lis=[]\\n        lis.extend(rooms[0])\\n        for i in lis:\\n            for j in rooms[i]:\\n                if(j not in lis):\\n                    lis.append(j)\\n        for i in range(1,len(rooms)):\\n            if(i not in lis):\\n                return(False)\\n        return(True)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930848,
                "title": "python-easy-to-read-dfs",
                "content": "- The basic idea of the code is to keep a record of all the keys you have already obtained. \\n- You can obtain all the keys in the rooms that you can go to\\n- And if the count of all the keys you can obtain is equal to the number of rooms, your answer is True.\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        res = set() #set of keys that we can obtain\\n        visited = set() #set of rooms we have visited\\n\\n        n = len(rooms)\\n\\n        def solve(pos):\\n            if pos in visited:\\n                return\\n\\n            visited.add(pos)\\n            temp = rooms[pos]\\n            for i in temp:\\n                res.add(i)\\n                solve(i)\\n\\n        solve(0)\\n        if 0 in res:\\n            res.remove(0)\\n\\n        return len(res) == n - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        \\n        res = set() #set of keys that we can obtain\\n        visited = set() #set of rooms we have visited\\n\\n        n = len(rooms)\\n\\n        def solve(pos):\\n            if pos in visited:\\n                return\\n\\n            visited.add(pos)\\n            temp = rooms[pos]\\n            for i in temp:\\n                res.add(i)\\n                solve(i)\\n\\n        solve(0)\\n        if 0 in res:\\n            res.remove(0)\\n\\n        return len(res) == n - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930723,
                "title": "simple-bfs-solution-using-queue-c-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        if(rooms.size() == 0)return true;\\n        \\n\\t\\t// queue for storing the keys\\n        queue<int>q;\\n        for(auto i:rooms[0])q.push(i); //first add all keys of rooms[0]\\n        \\n\\t\\t// visit bool vector to check if room is already visited\\n        vector<bool>vis(rooms.size(),false);\\n        vis[0] = true; // room 0 is already opened\\n        \\n        int tp;\\n\\t\\t/* there is no chance we can open the door without key \\n\\t\\tbecause we\\'re traversing those doors whose keys we already have */\\n        while(!q.empty())\\n        {\\n            tp = q.front();\\n\\t\\t\\t\\n\\t\\t\\t// if the room is not visited then push all keys into queue.\\n            if(!vis[tp])\\n            {\\n                for(auto i:rooms[tp])q.push(i);\\n            }\\n\\t\\t\\t// mark room visited\\n            vis[tp] = true;\\n            q.pop();\\n        }\\n        \\n\\t\\t// check if any room is not visited return false\\n        for(auto i:vis)\\n            if(i == false)\\n                return false;\\n\\t\\t\\t\\t\\n        // else return true\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        if(rooms.size() == 0)return true;\\n        \\n\\t\\t// queue for storing the keys\\n        queue<int>q;\\n        for(auto i:rooms[0])q.push(i); //first add all keys of rooms[0]\\n        \\n\\t\\t// visit bool vector to check if room is already visited\\n        vector<bool>vis(rooms.size(),false);\\n        vis[0] = true; // room 0 is already opened\\n        \\n        int tp;\\n\\t\\t/* there is no chance we can open the door without key \\n\\t\\tbecause we\\'re traversing those doors whose keys we already have */\\n        while(!q.empty())\\n        {\\n            tp = q.front();\\n\\t\\t\\t\\n\\t\\t\\t// if the room is not visited then push all keys into queue.\\n            if(!vis[tp])\\n            {\\n                for(auto i:rooms[tp])q.push(i);\\n            }\\n\\t\\t\\t// mark room visited\\n            vis[tp] = true;\\n            q.pop();\\n        }\\n        \\n\\t\\t// check if any room is not visited return false\\n        for(auto i:vis)\\n            if(i == false)\\n                return false;\\n\\t\\t\\t\\t\\n        // else return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930665,
                "title": "3ms-100-efficient-using-stack-and-visited-array",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) \\n    {\\n     int room[]=new int[rooms.size()];\\n        // room[0]=1;\\n        Stack<Integer> st=new Stack<>();\\n        st.push(0);\\n        while(st.isEmpty()!=true)\\n        {\\n            int idx=st.pop();\\n            if(room[idx]==1)\\n                continue;\\n            for(int i=0;i<rooms.get(idx).size();i++)\\n            {\\n                st.push(rooms.get(idx).get(i));\\n            }\\n            room[idx]=1;\\n        }\\n        for(int i=0;i<room.length;i++)\\n        {\\n            if(room[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) \\n    {\\n     int room[]=new int[rooms.size()];\\n        // room[0]=1;\\n        Stack<Integer> st=new Stack<>();\\n        st.push(0);\\n        while(st.isEmpty()!=true)\\n        {\\n            int idx=st.pop();\\n            if(room[idx]==1)\\n                continue;\\n            for(int i=0;i<rooms.get(idx).size();i++)\\n            {\\n                st.push(rooms.get(idx).get(i));\\n            }\\n            room[idx]=1;\\n        }\\n        for(int i=0;i<room.length;i++)\\n        {\\n            if(room[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930610,
                "title": "bfs-traversal-100-fast-solution-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Can be related to graph (BFS/DFS)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->BFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n\\n        queue<int> q;\\n        q.push(0);\\n        int x;\\n        while(!q.empty()){\\n             x=q.front();\\n            q.pop();\\n\\n            for(auto it:rooms[x]){\\n                if(vis[it]==0){\\n                    q.push(it);\\n                    vis[it]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n\\n        queue<int> q;\\n        q.push(0);\\n        int x;\\n        while(!q.empty()){\\n             x=q.front();\\n            q.pop();\\n\\n            for(auto it:rooms[x]){\\n                if(vis[it]==0){\\n                    q.push(it);\\n                    vis[it]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930235,
                "title": "python-89-time-complexity-simple-and-concise-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform a dfs search to see if we can get to every room\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo a dfs search starting at index 0 and keep track of what rooms we visit in a set; after the search, check if the rooms we visited through the dfs search is equal to the number of rooms in the input array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set([0])\\n        def dfs(index):\\n            for neighbor in rooms[index]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    dfs(neighbor)\\n        dfs(0)\\n        return len(visited) == len(rooms)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        visited = set([0])\\n        def dfs(index):\\n            for neighbor in rooms[index]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    dfs(neighbor)\\n        dfs(0)\\n        return len(visited) == len(rooms)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930211,
                "title": "kotlin-simple-bfs-solution-easy-to-understand",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/graph/KeysAndRooms.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2930106,
                "title": "python3-simple-dfs-approach-with-explanation",
                "content": "\\n# Approach\\nSimply run standard DFS algorithm and keep track of all seen rooms in a set for fast lookup. Since a set has unique elements,  we can simply check the length of the set and see how many rooms were seen.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        seen = set()\\n        self.DFS(0, rooms, seen)\\n        return len(seen) == len(rooms)\\n\\n    def DFS(self, source, rooms, seen):\\n        seen.add(source)\\n        for node in rooms[source]:\\n            if node not in seen: \\n                self.DFS(node, rooms, seen)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        seen = set()\\n        self.DFS(0, rooms, seen)\\n        return len(seen) == len(rooms)\\n\\n    def DFS(self, source, rooms, seen):\\n        seen.add(source)\\n        for node in rooms[source]:\\n            if node not in seen: \\n                self.DFS(node, rooms, seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769221,
                "title": "beats-100-java-solution-recursive",
                "content": "```\\nclass Solution {\\n\\n    boolean[] visited;\\n    List<List<Integer>> allRooms;\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        allRooms = rooms;\\n        visited = new boolean[rooms.size()];\\n        goInRecursively(0, rooms.get(0));\\n        return allVisited();\\n    }\\n\\n    private void goInRecursively(int room, List<Integer> keys) {\\n        if (visited[room]) return;\\n\\n        visited[room] = true;\\n        for (int i = 0; i < keys.size(); i++) {\\n            int key = keys.get(i);\\n            goInRecursively(key, allRooms.get(key));\\n        }\\n    }\\n\\n    private boolean allVisited() {\\n        for (int i = 0; i < visited.length / 2; i++) {\\n            if (!visited[i] || !visited[visited.length - 1 - i])\\n                return false;\\n        }\\n        return visited[visited.length / 2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean[] visited;\\n    List<List<Integer>> allRooms;\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        allRooms = rooms;\\n        visited = new boolean[rooms.size()];\\n        goInRecursively(0, rooms.get(0));\\n        return allVisited();\\n    }\\n\\n    private void goInRecursively(int room, List<Integer> keys) {\\n        if (visited[room]) return;\\n\\n        visited[room] = true;\\n        for (int i = 0; i < keys.size(); i++) {\\n            int key = keys.get(i);\\n            goInRecursively(key, allRooms.get(key));\\n        }\\n    }\\n\\n    private boolean allVisited() {\\n        for (int i = 0; i < visited.length / 2; i++) {\\n            if (!visited[i] || !visited[visited.length - 1 - i])\\n                return false;\\n        }\\n        return visited[visited.length / 2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688253,
                "title": "ttypescript-solution-2-solutions",
                "content": "Here is the DFS Solution\\n\\n```\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    let stack: number[] = [0];\\n    let visited = new Set();\\n\\n    while(stack.length){\\n        let curr = stack.pop()!;\\n        if(visited.has(curr)) continue;\\n\\n        stack.push(...rooms[curr]);\\n\\n        visited.add(curr)\\n    }\\n\\n    return visited.size === rooms.length;\\n};\\n\\n```\\n\\n\\nAnd Here is the BFS Solution\\n\\n```\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    let queue: number[] = [0];\\n    let visited = new Set();\\n\\n    while(queue.length){\\n        let curr = queue.shift()!;\\n        if(visited.has(curr)) continue;\\n        for(let k of rooms[curr]){\\n            queue.push(k);\\n        }\\n        visited.add(curr)\\n    }\\n\\n    return visited.size === rooms.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    let stack: number[] = [0];\\n    let visited = new Set();\\n\\n    while(stack.length){\\n        let curr = stack.pop()!;\\n        if(visited.has(curr)) continue;\\n\\n        stack.push(...rooms[curr]);\\n\\n        visited.add(curr)\\n    }\\n\\n    return visited.size === rooms.length;\\n};\\n\\n```\n```\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    let queue: number[] = [0];\\n    let visited = new Set();\\n\\n    while(queue.length){\\n        let curr = queue.shift()!;\\n        if(visited.has(curr)) continue;\\n        for(let k of rooms[curr]){\\n            queue.push(k);\\n        }\\n        visited.add(curr)\\n    }\\n\\n    return visited.size === rooms.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586251,
                "title": "java-dfs-faster-than-100-00-of-java-online-submissions",
                "content": "Runtime: 0 ms, faster than **100.00%** of Java online submissions for Keys and Rooms.\\nMemory Usage: 41.9 MB, less than **94.50%** of Java online submissions for Keys and Rooms.\\n\\n```\\n\\tpublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        \\n        boolean [] visited = new boolean[n];\\n        \\n        dfs(0, rooms, visited);\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                // We found one room unvisited, so return false;\\n                return false;\\n            }\\n        }\\n        // We could not find any room unvisted, so return true;\\n        return true;\\n    }\\n    \\n    private void dfs(int room, List<List<Integer>> rooms, boolean [] visited){\\n        visited[room] = true;\\n        // Visit unvisited next room\\'s whose distinct keys are present in current room.\\n        for(int nextRoom : rooms.get(room)){\\n            if(!visited[nextRoom]){\\n                dfs(nextRoom, rooms, visited);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tpublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        \\n        boolean [] visited = new boolean[n];\\n        \\n        dfs(0, rooms, visited);\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                // We found one room unvisited, so return false;\\n                return false;\\n            }\\n        }\\n        // We could not find any room unvisted, so return true;\\n        return true;\\n    }\\n    \\n    private void dfs(int room, List<List<Integer>> rooms, boolean [] visited){\\n        visited[room] = true;\\n        // Visit unvisited next room\\'s whose distinct keys are present in current room.\\n        for(int nextRoom : rooms.get(room)){\\n            if(!visited[nextRoom]){\\n                dfs(nextRoom, rooms, visited);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2543811,
                "title": "python-elegant-short-bfs",
                "content": "\\tdef canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        queue = deque([0])\\n        unvisited = set(range(len(rooms)))\\n\\n        while queue:\\n            v = queue.popleft()\\n            if v in unvisited:\\n                unvisited.remove(v)\\n                queue.extend(rooms[v])\\n\\n        return not unvisited\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tdef canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        queue = deque([0])\\n        unvisited = set(range(len(rooms)))\\n\\n        while queue:\\n            v = queue.popleft()\\n            if v in unvisited:\\n                unvisited.remove(v)\\n                queue.extend(rooms[v])\\n\\n        return not unvisited\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2534528,
                "title": "simple-solution-faster-than-93-python-o-n",
                "content": "```\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        q = deque(rooms[0])   #deque -> doubly ended queue\\n        visited = defaultdict(int)\\n        visited[0]=1\\n        count = 1  #to keep a count of unique number of rooms visited\\n        while q:\\n            room = q.popleft()  #poping first element\\n            if room not in visited:\\n                visited[room] = 1\\n                count+=1\\n                q+=rooms[room]\\n        if count==len(rooms):\\n            return True\\n        return False\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        q = deque(rooms[0])   #deque -> doubly ended queue\\n        visited = defaultdict(int)\\n        visited[0]=1\\n        count = 1  #to keep a count of unique number of rooms visited\\n        while q:\\n            room = q.popleft()  #poping first element\\n            if room not in visited:\\n                visited[room] = 1\\n                count+=1\\n                q+=rooms[room]\\n        if count==len(rooms):\\n            return True\\n        return False\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2449046,
                "title": "easy-c-solution-beginners-friendly-bfs",
                "content": "The question seems hard but the the concept is easy. It just says that can we visit all node or not.\\n1. So, we know BFS, we track all node by a visited vector.\\n2. we will traverse the graph\\n3. After traversing if any node is false in visited vector then we can say false.\\n\\n```\\nclass Solution {\\npublic:\\n    void BFS(vector<bool>&visited, vector<vector<int>>& rooms, int source){\\n        queue<int>q;\\n        q.push(source);\\n        visited[source]=true;\\n        while(!q.empty())\\n        {\\n            int front=q.front();\\n            q.pop();\\n            for(auto neighbour : rooms[front]){\\n                if(!visited[neighbour]){\\n                    visited[neighbour]=true;\\n                    q.push(neighbour);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool>visited(rooms.size(), false);\\n        for(int i=0; i<rooms.size(); i++)\\n        {\\n            visited[i]=false;\\n        }\\n        BFS(visited, rooms, 0);\\n        for(auto it : visited){\\n            if(it!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nIf it helps you please upvote me. Thank you",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void BFS(vector<bool>&visited, vector<vector<int>>& rooms, int source){\\n        queue<int>q;\\n        q.push(source);\\n        visited[source]=true;\\n        while(!q.empty())\\n        {\\n            int front=q.front();\\n            q.pop();\\n            for(auto neighbour : rooms[front]){\\n                if(!visited[neighbour]){\\n                    visited[neighbour]=true;\\n                    q.push(neighbour);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<bool>visited(rooms.size(), false);\\n        for(int i=0; i<rooms.size(); i++)\\n        {\\n            visited[i]=false;\\n        }\\n        BFS(visited, rooms, 0);\\n        for(auto it : visited){\\n            if(it!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288580,
                "title": "keys-and-rooms-detailed-explanation",
                "content": "***PROBLEM STATEMENT***\\nGiven a graph of rooms where the index is the room and the keys it is holding is the key for other rooms. We should return true if we are able to visit all rooms else false.\\nTEST CASES :\\n[ [1] ,[2] ,[3] ,[ ] ]\\nRoom 0 has key for room 1 , Room 1 has key for room 2 ,Room 2 has key for room 3 ,Room 3 has no key . As we are able to visit all rooms succesfully, we will return true.\\n[ [1,3],[3,0,1],[2],[0] ]\\nRoom 0 has key for room 1 & 3. Room 0 has key for room 1 has keys for room 0,1,3 ( we already visited room 0,1). But we can\\'t enter room 2 as we don\\'t have key for it also key for room 2 is in room 2. Now we can visit room 3. We will return false as we don\\'t have the key for room 2.\\n\\n***APPROACH***\\n* In main function -\\n* We will visit all the only once. So to mark them visited we will maintain a visited array.\\n* If any one element of the array is not visited (false) then we will return false else true.\\n* In DFS function - \\n* Our aim is to visit all the rooms only if we have the keys for it. We will have the key for \\n   room 0.\\n*   In dfs if we have the key and not visited then we will visit the room and mark it visited.\\n*   If we don\\'t have key then we won\\'t visit it which will return false.\\n\\tTime complexity : O(rooms)  [O(rooms+keys)-worst case]\\n    Space complexity : O(rooms) \\n***CODE***\\n```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        //visited array\\n        visited = new boolean[rooms.size()];\\n        visited[0] = true;\\n        //visiting from room 0\\n        dfs(rooms,0);\\n        for(boolean b:visited){\\n            if(!b){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public void dfs(List<List<Integer>> rooms,int i){\\n        for(int j:rooms.get(i)){\\n            //if true then no need to do anything..but if not visited then mark it visited and call recursion\\n            if(!visited[j]){\\n                visited[j]=true;\\n                //visiting other rooms if we have key\\n                dfs(rooms,j);\\n            }\\n        }\\n    }\\n}\\n```\\nThank you.Hope it is useful . Please do upvote !!\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        //visited array\\n        visited = new boolean[rooms.size()];\\n        visited[0] = true;\\n        //visiting from room 0\\n        dfs(rooms,0);\\n        for(boolean b:visited){\\n            if(!b){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public void dfs(List<List<Integer>> rooms,int i){\\n        for(int j:rooms.get(i)){\\n            //if true then no need to do anything..but if not visited then mark it visited and call recursion\\n            if(!visited[j]){\\n                visited[j]=true;\\n                //visiting other rooms if we have key\\n                dfs(rooms,j);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276616,
                "title": "easy-and-concise-fastest-simple-dfs-c",
                "content": "class Solution {\\npublic:void dfs(int i,vector< bool> &vis, vector<vector< int>>& rooms){\\n    vis[i]=1;\\n    for(auto it:rooms[i]){\\n        if(!vis[it])\\n            dfs(it,vis,rooms);\\n    }\\n    return;\\n}\\n    bool canVisitAllRooms(vector<vector< int>>& rooms) {\\n        vector< bool> vis(rooms.size(),0);\\n        dfs(0,vis,rooms);\\n        for(int i=0;i<vis.size();i++){\\n            if(!vis[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:void dfs(int i,vector< bool> &vis, vector<vector< int>>& rooms){\\n    vis[i]=1;\\n    for(auto it:rooms[i]){\\n        if(!vis[it])\\n            dfs(it,vis,rooms);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2210840,
                "title": "simple-dfs-and-bfs",
                "content": "# DFS\\n\\n\\tclass Solution {\\n    int n;\\n    \\n    void dfs(int i,vector<vector<int>>& rooms,vector<int>&vis)\\n    {\\n        if(vis[i])\\n            return;\\n        \\n        vis[i]=1;\\n        \\n        for(auto it:rooms[i])\\n        {\\n            dfs(it,rooms,vis);\\n        }\\n    }\\n    \\n\\tpublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        n=rooms.size();\\n        vector<int>vis(n,0);\\n        \\n        dfs(0,rooms,vis);\\n        \\n        for(auto it:vis)        \\n            if(!it)\\n                return 0;\\n        \\n        return 1;\\n    }\\n\\t};\\n\\t\\n\\t\\n# \\tBFS\\n\\t\\n\\tclass Solution {    \\n\\tpublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>vis(n,0);\\n        \\n        queue<int>q;\\n        q.emplace(0);\\n        \\n        while(!q.empty())\\n        {\\n            int i=q.front();\\n            vis[i]=1;\\n            q.pop();\\n            for(auto it:rooms[i])\\n            {\\n                if(!vis[it])\\n                {\\n                    q.emplace(it);\\n                }\\n            }\\n        }\\n        \\n        for(auto it:vis)        \\n            if(!it)\\n                return 0;\\n        \\n        return 1;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    int n;\\n    \\n    void dfs(int i,vector<vector<int>>& rooms,vector<int>&vis)\\n    {\\n        if(vis[i])\\n            return;\\n        \\n        vis[i]=1;\\n        \\n        for(auto it:rooms[i])\\n        {\\n            dfs(it,rooms,vis);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2119590,
                "title": "java-simple-dfs-solution-beats-95-with-explanation",
                "content": "**Intuition and Approach:-** \\n* This is a classical DFS graph problem, where we actually need to traverse through all the graph nodes, which are actually the rooms in this problem. BFS will also have the same time complexity as DFS based solution. \\n\\n* Here, we just need to traverse the graph, ie the rooms, in DFS manner and mark the rooms as ```visited=true```. We can also use a hashset to know the number of rooms we could go to, starting from the source, ie room no. 0; but using boolean array drastically reduces both time and space complexity.\\n\\n* Atlast, we just check if the ```visited[]``` has a false value, indicating that we couldn\\'t go to that particular room, else we just return true.\\n```\\n```\\n**Code:-**\\n\\n```\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) \\n{\\n    boolean[] visited=new boolean[rooms.size()];\\n    DFS(rooms,0,visited);\\n    for (boolean val:visited)\\n        if (!val)\\n            return false;\\n    return true;\\n}\\npublic static void DFS(List<List<Integer>> graph, int source, boolean[] visited)\\n{\\n    visited[source]=true;\\n    for(int node: graph.get(source))\\n        if(!visited[node])\\n            DFS(graph,node,visited);\\n}\\n```\\n\\n**Time  Complexity:-** O(V+E), where V and E are the number of vertices and edges of the graph, respectively.\\n**Space Complexity:-** O(V) \\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```visited=true```\n```visited[]```\n```\\n```\n```\\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) \\n{\\n    boolean[] visited=new boolean[rooms.size()];\\n    DFS(rooms,0,visited);\\n    for (boolean val:visited)\\n        if (!val)\\n            return false;\\n    return true;\\n}\\npublic static void DFS(List<List<Integer>> graph, int source, boolean[] visited)\\n{\\n    visited[source]=true;\\n    for(int node: graph.get(source))\\n        if(!visited[node])\\n            DFS(graph,node,visited);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082489,
                "title": "c-simple-dfs-solution",
                "content": "\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector <int> vis (n,0);\\n        dfs (0,vis,rooms);\\n        int cnt=count(vis.begin(),vis.end(),0);\\n        if (cnt) return false; return true;\\n    }\\n    void dfs (int node, vector <int> &vis , vector<vector<int>>& rooms)\\n    {\\n        vis[node]=1;\\n        for (auto it:rooms[node])\\n        {\\n            if (vis[it]==0) dfs(it,vis,rooms);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector <int> vis (n,0);\\n        dfs (0,vis,rooms);\\n        int cnt=count(vis.begin(),vis.end(),0);\\n        if (cnt) return false; return true;\\n    }\\n    void dfs (int node, vector <int> &vis , vector<vector<int>>& rooms)\\n    {\\n        vis[node]=1;\\n        for (auto it:rooms[node])\\n        {\\n            if (vis[it]==0) dfs(it,vis,rooms);\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2039068,
                "title": "c-simple-approach-dfs-with-explanation-easy-to-understand",
                "content": "**Understanding the question:**\\nBasically the question asks you find if it is a disconnected graph, which means one or more vertex are isolated. Drawing the analogy, you will traverse from the first (or 0th) room and traverse through all the rooms connected to it (via keys). Here, keys basically mean edges and rooms mean vertices.\\n\\n**Approach:**\\nA simple ***DFS*** (or you can use ***BFS*** too) approach will do the job. I have kept a vector `visited` handy to check which all *vertices* (rooms) are visited. I have started a `DFS` traversal from *the 0th vertex*  (the first room) and whichever *vertices* (rooms) are traversed via *edges* (keys) are marked as visited. At the end, iterate through the visited vector and if there exists any such *vertex* (room) which is *false* (not visited) return false.\\n\\n*Did not understand? Read the above approach again but replace the italic words with the words inside the braces next to it to make it more literal than technical.*\\n\\n**Code:**\\n```\\nclass Solution {\\n    void DFS(vector<vector<int>>& rooms, int src, vector<bool>& visited) {\\n        visited[src] = true;\\n        for(int i: rooms[src]) {\\n            if(!visited[i])\\n                DFS(rooms, i, visited);\\n        }\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int N = rooms.size();\\n        vector<bool> visited(N, false);\\n        DFS(rooms, 0, visited);\\n        for(bool b: visited) if(!b) return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Upvote, if you find it useful!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void DFS(vector<vector<int>>& rooms, int src, vector<bool>& visited) {\\n        visited[src] = true;\\n        for(int i: rooms[src]) {\\n            if(!visited[i])\\n                DFS(rooms, i, visited);\\n        }\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int N = rooms.size();\\n        vector<bool> visited(N, false);\\n        DFS(rooms, 0, visited);\\n        for(bool b: visited) if(!b) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824553,
                "title": "simple-bfs-java",
                "content": "1. To do BFS we take a queue and a set of keys that we have found\\n2. We already have key to room zero, so we add 0 to our queue and also to our set of keys.\\n3. then we perform BFS, and keep adding newly found keys to our set of keys.\\n4. At any point of time if size of our set becomes n(number of rooms) we return true;\\n\\n```class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        Set<Integer> keys = new HashSet<>();\\n        LinkedList<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        keys.add(0);\\n        \\n        while(!q.isEmpty()) {\\n            int room = q.removeFirst();\\n            for(int key : rooms.get(room)) {\\n                if(!keys.contains(key)) {\\n                    q.add(key);\\n                    keys.add(key);\\n                }\\n            }\\n            if(keys.size() == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        int n = rooms.size();\\n        Set<Integer> keys = new HashSet<>();\\n        LinkedList<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        keys.add(0);\\n        \\n        while(!q.isEmpty()) {\\n            int room = q.removeFirst();\\n            for(int key : rooms.get(room)) {\\n                if(!keys.contains(key)) {\\n                    q.add(key);\\n                    keys.add(key);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1812312,
                "title": "very-easy-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>> &rooms, vector<bool> &v, int i){\\n       v[i] = true;\\n       for(auto it : rooms[i]){\\n           if(!v[it]){\\n               dfs(rooms, v, it);\\n           }\\n       }\\n   }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n, 0);\\n        dfs(rooms, visited, 0);\\n        for(int i=0; i<n; i++){\\n            if(!visited[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>> &rooms, vector<bool> &v, int i){\\n       v[i] = true;\\n       for(auto it : rooms[i]){\\n           if(!v[it]){\\n               dfs(rooms, v, it);\\n           }\\n       }\\n   }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool> visited(n, 0);\\n        dfs(rooms, visited, 0);\\n        for(int i=0; i<n; i++){\\n            if(!visited[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625252,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>> &graph, int s, vector<bool> &vis)\\n    {\\n        vis[s] = true;\\n        for(int i=0; i<graph[s].size(); i++)\\n            if(!vis[graph[s][i]])\\n                solve(graph, graph[s][i], vis);\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>> &rooms) \\n    {\\n        vector<bool> vis(rooms.size(), false);\\n        solve(rooms, 0, vis);\\n        for(int i=0; i<rooms.size(); i++)\\n            if(!vis[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<vector<int>> &graph, int s, vector<bool> &vis)\\n    {\\n        vis[s] = true;\\n        for(int i=0; i<graph[s].size(); i++)\\n            if(!vis[graph[s][i]])\\n                solve(graph, graph[s][i], vis);\\n    }\\n\\n    bool canVisitAllRooms(vector<vector<int>> &rooms) \\n    {\\n        vector<bool> vis(rooms.size(), false);\\n        solve(rooms, 0, vis);\\n        for(int i=0; i<rooms.size(); i++)\\n            if(!vis[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616136,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    Set<Integer> visited = new HashSet<>();\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        addKey(0, rooms);\\n        return visited.size() == rooms.size();\\n    }\\n    private void addKey(int room, List<List<Integer>> rooms){\\n        visited.add(room); for the next key we got as a recursion\\n        for(int key : rooms.get(room))\\n            if(!visited.contains(key))\\n                addKey(key, rooms);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> visited = new HashSet<>();\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        addKey(0, rooms);\\n        return visited.size() == rooms.size();\\n    }\\n    private void addKey(int room, List<List<Integer>> rooms){\\n        visited.add(room); for the next key we got as a recursion\\n        for(int key : rooms.get(room))\\n            if(!visited.contains(key))\\n                addKey(key, rooms);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529025,
                "title": "simple-c-dfs-approach",
                "content": "```\\n void dfs(vector<int> adj[],vector<int> &vis,int node){\\n        vis[node]=1;\\n        \\n        for(auto x: adj[node]){\\n            \\n            if(!vis[x]){\\n                dfs(adj,vis,x);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n=rooms.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        \\n        \\n        vector<int> vis(n,0);\\n        \\n        int cmp=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(!vis[i]){\\n                cmp+=1;\\n                dfs(adj,vis,i);\\n            }\\n        }\\n        \\n        return cmp==1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n void dfs(vector<int> adj[],vector<int> &vis,int node){\\n        vis[node]=1;\\n        \\n        for(auto x: adj[node]){\\n            \\n            if(!vis[x]){\\n                dfs(adj,vis,x);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        int n=rooms.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<rooms[i].size();j++){\\n                adj[i].push_back(rooms[i][j]);\\n            }\\n        }\\n        \\n        \\n        vector<int> vis(n,0);\\n        \\n        int cmp=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(!vis[i]){\\n                cmp+=1;\\n                dfs(adj,vis,i);\\n            }\\n        }\\n        \\n        return cmp==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522977,
                "title": "simple-c-solution-using-dfs",
                "content": "We should have the whole graph connected, to be able to visit every room and for that we are conforming if the number of components of the graph is equal to one and if it is then we can visit all the rooms but if they are not equal to one then we cannot visit every room.\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<bool>&vis,vector<vector<int>>&adj){\\n        vis[node]=true;\\n        for(auto nbr:adj[node]){\\n            if(!vis[nbr]){\\n                dfs(nbr,vis,adj);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n       int n=rooms.size();\\n        vector<bool>vis(n,false);\\n        int ct{0};\\n        for(int i{0};i<n;i++){\\n            if(!vis[i]){\\n                ct++;\\n                dfs(i,vis,rooms);\\n            }\\n        }\\n        if(ct==1)return true;\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<bool>&vis,vector<vector<int>>&adj){\\n        vis[node]=true;\\n        for(auto nbr:adj[node]){\\n            if(!vis[nbr]){\\n                dfs(nbr,vis,adj);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n       int n=rooms.size();\\n        vector<bool>vis(n,false);\\n        int ct{0};\\n        for(int i{0};i<n;i++){\\n            if(!vis[i]){\\n                ct++;\\n                dfs(i,vis,rooms);\\n            }\\n        }\\n        if(ct==1)return true;\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477745,
                "title": "c-clean-code-dfs-solution-easy-to-understand-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& rooms, int key, int visited[])\\n    {\\n        visited[key]=true;\\n        for(int i=0;i<rooms[key].size();i++)\\n        {\\n            if(!visited[rooms[key][i]])\\n            {\\n                dfs(rooms,rooms[key][i],visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        int visited[n];\\n        \\n        memset(visited,0, sizeof visited);\\n        \\n        dfs(rooms, 0, visited);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**If you have any questions, feel free to comment below.\\nPlease help to UPVOTE if this post is useful for you.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& rooms, int key, int visited[])\\n    {\\n        visited[key]=true;\\n        for(int i=0;i<rooms[key].size();i++)\\n        {\\n            if(!visited[rooms[key][i]])\\n            {\\n                dfs(rooms,rooms[key][i],visited);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        int visited[n];\\n        \\n        memset(visited,0, sizeof visited);\\n        \\n        dfs(rooms, 0, visited);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317726,
                "title": "c-90-faster-sol-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& rooms,vector<int> &vis,int s){\\n        if(s==rooms.size()){\\n            return;\\n        }\\n        for(int i=0;i<rooms[s].size();i++){\\n            if(vis[rooms[s][i]]==0){\\n                vis[rooms[s][i]]=1;\\n                dfs(rooms,vis,rooms[s][i]);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> vis(rooms.size(),0);\\n        vis[0]=1;\\n        dfs(rooms,vis,0);\\n        for(auto i:vis){\\n            if(i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& rooms,vector<int> &vis,int s){\\n        if(s==rooms.size()){\\n            return;\\n        }\\n        for(int i=0;i<rooms[s].size();i++){\\n            if(vis[rooms[s][i]]==0){\\n                vis[rooms[s][i]]=1;\\n                dfs(rooms,vis,rooms[s][i]);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> vis(rooms.size(),0);\\n        vis[0]=1;\\n        dfs(rooms,vis,0);\\n        for(auto i:vis){\\n            if(i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310534,
                "title": "easy-c-dfs-bfs-solution-commented",
                "content": "DFS solution\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        //we have to reach every room\\n        //mark the rooms as visited when you reach a new room\\n        //grab the keys in the room and traverse using dfs or bfs to all those rooms which are not yet visited\\n        int numRooms=rooms.size();\\n        vector<bool> visited(numRooms,false);\\n        //count stores the number of rooms visited\\n        int count=0;\\n        visited[0]=true;\\n        explore(0,rooms,visited,count);\\n        return count==numRooms;\\n    }\\n    void explore(int currRoom,vector<vector<int>>& rooms,vector<bool>& visited,int& count)\\n    {\\n        visited[currRoom]=true;\\n        count++;\\n        //grab all keys and also explore the room of each key\\n        for(auto key:rooms[currRoom])\\n        {\\n            if(!visited[key])\\n            {\\n                explore(key,rooms,visited,count);\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n\\nBFS solution \\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        //we have to reach every room\\n        //mark the rooms as visited when you reach a new room\\n        //grab the keys in the room and traverse using dfs or bfs to all those rooms which are not yet visited\\n        int numRooms=rooms.size();\\n        vector<bool> visited(numRooms,false);\\n        //count stores the number of rooms visited\\n        int count=1;\\n        visited[0]=true;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int currRoom=q.front();\\n            q.pop();\\n            for(auto key:rooms[currRoom])\\n            {\\n                if(!visited[key])\\n                {\\n                    visited[key]=true;\\n                    count++;\\n                    q.push(key);\\n                }\\n            }\\n        }\\n        return count==numRooms;\\n    }\\n   \\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        //we have to reach every room\\n        //mark the rooms as visited when you reach a new room\\n        //grab the keys in the room and traverse using dfs or bfs to all those rooms which are not yet visited\\n        int numRooms=rooms.size();\\n        vector<bool> visited(numRooms,false);\\n        //count stores the number of rooms visited\\n        int count=0;\\n        visited[0]=true;\\n        explore(0,rooms,visited,count);\\n        return count==numRooms;\\n    }\\n    void explore(int currRoom,vector<vector<int>>& rooms,vector<bool>& visited,int& count)\\n    {\\n        visited[currRoom]=true;\\n        count++;\\n        //grab all keys and also explore the room of each key\\n        for(auto key:rooms[currRoom])\\n        {\\n            if(!visited[key])\\n            {\\n                explore(key,rooms,visited,count);\\n            }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        \\n        //we have to reach every room\\n        //mark the rooms as visited when you reach a new room\\n        //grab the keys in the room and traverse using dfs or bfs to all those rooms which are not yet visited\\n        int numRooms=rooms.size();\\n        vector<bool> visited(numRooms,false);\\n        //count stores the number of rooms visited\\n        int count=1;\\n        visited[0]=true;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int currRoom=q.front();\\n            q.pop();\\n            for(auto key:rooms[currRoom])\\n            {\\n                if(!visited[key])\\n                {\\n                    visited[key]=true;\\n                    count++;\\n                    q.push(key);\\n                }\\n            }\\n        }\\n        return count==numRooms;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171679,
                "title": "c-dfs-easy-and-straight-forward-o-e",
                "content": "**Time Complexity: O(E)**\\n**Space Complexity: O(E)**\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int val, unordered_set <int> &visited, vector<vector<int>> &graph) {\\n        visited.insert(val);\\n        for (int i: graph[val]) {\\n            if (visited.find(i) == visited.end()) {\\n                dfs(i, visited, graph);\\n            }\\n        }\\n    }\\n    \\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set <int> visited;\\n        dfs(0, visited, rooms);\\n        return visited.size() == rooms.size()) {\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int val, unordered_set <int> &visited, vector<vector<int>> &graph) {\\n        visited.insert(val);\\n        for (int i: graph[val]) {\\n            if (visited.find(i) == visited.end()) {\\n                dfs(i, visited, graph);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1122005,
                "title": "c-4ms",
                "content": "This ran in 8ms until I calloc\\'ed the arrays, taking the burden off of the stack.\\nArrays are always faster than hashmaps.  (and easier in C!)\\nUpvote (honk) if you love speed!\\n```\\nbool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\\n    int *todo;              // stack\\n    unsigned char *done;    // bytemap\\n    int i, room, key, count = 0, top=0;\\n    todo = calloc(4096, sizeof(int)); // dynamic mem allocation...\\n    done = calloc(1024, sizeof(unsigned char)); // faster than static!\\n\\t\\n    todo[top++] = 0;\\n    done[todo[top-1]] = 1;\\n\\tcount++;\\n    while(top>0) { // when the \\'stack\\' is empty, the array still has a bunch of values\\n        room = todo[--top]; // top is always one greater than the \\'top\\' value\\n        for(i=0;i<roomsColSize[room];i++) {\\n            key = rooms[room][i];\\n            if(!done[key]) {\\n                todo[top++] = key;\\n                done[key] = 1;\\n                count++;\\n            }\\n        }\\n    }\\n    if(count != roomsSize) { return false; }\\n    return true;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\\n    int *todo;              // stack\\n    unsigned char *done;    // bytemap\\n    int i, room, key, count = 0, top=0;\\n    todo = calloc(4096, sizeof(int)); // dynamic mem allocation...\\n    done = calloc(1024, sizeof(unsigned char)); // faster than static!\\n\\t\\n    todo[top++] = 0;\\n    done[todo[top-1]] = 1;\\n\\tcount++;\\n    while(top>0) { // when the \\'stack\\' is empty, the array still has a bunch of values\\n        room = todo[--top]; // top is always one greater than the \\'top\\' value\\n        for(i=0;i<roomsColSize[room];i++) {\\n            key = rooms[room][i];\\n            if(!done[key]) {\\n                todo[top++] = key;\\n                done[key] = 1;\\n                count++;\\n            }\\n        }\\n    }\\n    if(count != roomsSize) { return false; }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117607,
                "title": "c-simple-bfs-solution-quite-understandable",
                "content": "Using **Queue** to *store* the rooms we have to visit and at last just checking if we have visited all rooms once then returning ```true``` else returning ```false```\\n```\\nclass Solution {\\npublic:\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        \\n        bool visited[1000] = {false};\\n        \\n        queue<int>q;\\n        visited[0] = true;\\n        for(int i = 0;i<rooms[0].size();i++){\\n            q.push(rooms[0][i]);\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            int x = q.front();\\n            q.pop();\\n            if(visited[x])continue;\\n            visited[x] = true;\\n            for(int j = 0;j<rooms[x].size();j++){\\n                q.push(rooms[x][j]);\\n            }\\n        }\\n        \\n        for(int i = 0;i<rooms.size();i++){\\n            if(!visited[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```true```\n```false```\n```\\nclass Solution {\\npublic:\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        \\n        bool visited[1000] = {false};\\n        \\n        queue<int>q;\\n        visited[0] = true;\\n        for(int i = 0;i<rooms[0].size();i++){\\n            q.push(rooms[0][i]);\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            int x = q.front();\\n            q.pop();\\n            if(visited[x])continue;\\n            visited[x] = true;\\n            for(int j = 0;j<rooms[x].size();j++){\\n                q.push(rooms[x][j]);\\n            }\\n        }\\n        \\n        for(int i = 0;i<rooms.size();i++){\\n            if(!visited[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117177,
                "title": "c-bfs-and-dfs",
                "content": "Approach 1: BFS\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        queue<int> q{{0}};\\n        unordered_set<int> visited{0};        \\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            for(const auto nxt: rooms[cur]){\\n                if(visited.count(nxt)) continue;\\n                visited.insert(nxt);\\n                if(visited.size() == rooms.size()) return true;\\n                q.push(nxt);\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```\\n\\nApproach 2: DFS\\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> visited;\\n        helper(rooms, 0, visited);\\n        return visited.size() == rooms.size();\\n    }\\n    \\nprivate:\\n    void helper(vector<vector<int>>& rooms, int cur, unordered_set<int>& visited){\\n        visited.insert(cur);\\n        for(const auto nxt: rooms[cur])\\n            if(!visited.count(nxt)) helper(rooms, nxt, visited);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        queue<int> q{{0}};\\n        unordered_set<int> visited{0};        \\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            for(const auto nxt: rooms[cur]){\\n                if(visited.count(nxt)) continue;\\n                visited.insert(nxt);\\n                if(visited.size() == rooms.size()) return true;\\n                q.push(nxt);\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_set<int> visited;\\n        helper(rooms, 0, visited);\\n        return visited.size() == rooms.size();\\n    }\\n    \\nprivate:\\n    void helper(vector<vector<int>>& rooms, int cur, unordered_set<int>& visited){\\n        visited.insert(cur);\\n        for(const auto nxt: rooms[cur])\\n            if(!visited.count(nxt)) helper(rooms, nxt, visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117107,
                "title": "java-solution-using-bfs",
                "content": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\n        while (!queue.isEmpty()) {\\n            int key = queue.poll();\\n            for (int k : rooms.get(key)) {\\n                if (visited.contains(k)) continue;\\n                visited.add(k);\\n                queue.add(k);\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n}\\n```\\nTime: O(n)\\nSpace: O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\n        while (!queue.isEmpty()) {\\n            int key = queue.poll();\\n            for (int k : rooms.get(key)) {\\n                if (visited.contains(k)) continue;\\n                visited.add(k);\\n                queue.add(k);\\n            }\\n        }\\n        return visited.size() == rooms.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117031,
                "title": "c-dfs-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        stack<int> s;\\n        s.push(0);\\n        int n=rooms.size(), ans=0;\\n        vector<int> visited(n, 0);\\n        while(!s.empty())\\n        {\\n            int temp=s.top();\\n            s.pop();\\n            if(visited[temp]==1) continue;\\n            visited[temp] = 1;\\n            ans++;\\n            for(int i=0; i<rooms[temp].size(); i++)\\n            {\\n                if(visited[rooms[temp][i]]==1) continue;\\n                s.push(rooms[temp][i]);\\n            }\\n        }\\n        return ans==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \\n    {\\n        stack<int> s;\\n        s.push(0);\\n        int n=rooms.size(), ans=0;\\n        vector<int> visited(n, 0);\\n        while(!s.empty())\\n        {\\n            int temp=s.top();\\n            s.pop();\\n            if(visited[temp]==1) continue;\\n            visited[temp] = 1;\\n            ans++;\\n            for(int i=0; i<rooms[temp].size(); i++)\\n            {\\n                if(visited[rooms[temp][i]]==1) continue;\\n                s.push(rooms[temp][i]);\\n            }\\n        }\\n        return ans==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116968,
                "title": "c-solution-using-dfs-19-march",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int> visited(n,0);\\n        \\n        dfs(rooms,0,visited);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                return false;\\n            }\\n            cout<<visited[i]<<\" \";\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms,int src,vector<int>& visited)\\n    {\\n        visited[src]=1;\\n        for(int i=0;i<rooms[src].size();i++)\\n        {\\n            if(visited[rooms[src][i]]==0)\\n            {\\n                dfs(rooms,rooms[src][i],visited);\\n            }            \\n        }\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<int> visited(n,0);\\n        \\n        dfs(rooms,0,visited);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                return false;\\n            }\\n            cout<<visited[i]<<\" \";\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>>& rooms,int src,vector<int>& visited)\\n    {\\n        visited[src]=1;\\n        for(int i=0;i<rooms[src].size();i++)\\n        {\\n            if(visited[rooms[src][i]]==0)\\n            {\\n                dfs(rooms,rooms[src][i],visited);\\n            }            \\n        }\\n    }    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1116746,
                "title": "keys-and-rooms-c-easy-solution-simple-code-with-explanation-dfs-approach",
                "content": "**DFS**:\\nThis is just DFS traversal, where rooms are nodes in a graph and keys in each room are edges to that nodes. Here only `room[0]` is opened, so we traverse only for `0` and keep visiting all possible nodes from `0`, Al last we check if any room is not visited. if all are visited,then we just `return true`, or else `return false`\\n```\\n bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool>visited(n,false);\\n        dfs(rooms,0,visited);\\n        for(bool it: visited){\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>rooms,int i,vector<bool>&visited){\\n        visited[i] = true;\\n        for(int key : rooms[i]){\\n            if(!visited[key])\\n                dfs(rooms,key,visited);\\n        }\\n        return;\\n    }\\n```\\n**BFS**\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool>visited(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visited[0] = true;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            for(int key:rooms[cur]){\\n                if(!visited[key]){\\n                    visited[key] = true;\\n                    q.push(key);\\n                }\\n            }\\n        }\\n        for(bool it:visited){\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n```\\n**Please upvote** if you like the code",
                "solutionTags": [],
                "code": "```\\n bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool>visited(n,false);\\n        dfs(rooms,0,visited);\\n        for(bool it: visited){\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>rooms,int i,vector<bool>&visited){\\n        visited[i] = true;\\n        for(int key : rooms[i]){\\n            if(!visited[key])\\n                dfs(rooms,key,visited);\\n        }\\n        return;\\n    }\\n```\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n = rooms.size();\\n        vector<bool>visited(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visited[0] = true;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            for(int key:rooms[cur]){\\n                if(!visited[key]){\\n                    visited[key] = true;\\n                    q.push(key);\\n                }\\n            }\\n        }\\n        for(bool it:visited){\\n            if(!it) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116685,
                "title": "java-bfs-queue-and-set",
                "content": "\\t\\tSet<Integer> set = new HashSet<Integer>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        set.add(0);\\n        queue.add(0);\\n        while(!queue.isEmpty()){\\n            List<Integer> keys = rooms.get(queue.poll());\\n            for(int j=0;j<keys.size();j++){\\n                if(!set.contains(keys.get(j))){\\n                    set.add(keys.get(j));\\n                    queue.add(keys.get(j));\\n                }\\n            }\\n        }\\n        return set.size() == rooms.size();",
                "solutionTags": [],
                "code": "\\t\\tSet<Integer> set = new HashSet<Integer>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        set.add(0);\\n        queue.add(0);\\n        while(!queue.isEmpty()){\\n            List<Integer> keys = rooms.get(queue.poll());\\n            for(int j=0;j<keys.size();j++){\\n                if(!set.contains(keys.get(j))){\\n                    set.add(keys.get(j));\\n                    queue.add(keys.get(j));\\n                }\\n            }\\n        }\\n        return set.size() == rooms.size();",
                "codeTag": "Unknown"
            },
            {
                "id": 1048823,
                "title": "javascript-100-faster-set-stack",
                "content": "We can use a stack to keep track of keys we have available to unlock rooms. However, we do not want to revisit a room if we find a duplicate key (redundant) so we can maintain a set that keeps track of unique occurrences of keys we encounter. If we encounter a unique key we add it to the stack and the set. After we visit all rooms with this criteria we should have a set that contains 1 instance of each possible key that we can encounter. If the set size is the same as the number of rooms then we have a key for each room!\\n\\n```\\n    const uniqueKeys = new Set([0]);\\n    const availableKeys = [0];\\n    \\n    while (availableKeys.length) {\\n        let currentKey = availableKeys.pop();\\n        rooms[currentKey].forEach(key => {\\n           if (!uniqueKeys.has(key)) {\\n               uniqueKeys.add(key);\\n               availableKeys.push(key);\\n           }\\n        });\\n    }\\n\\n    return uniqueKeys.size === rooms.length;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "```\\n    const uniqueKeys = new Set([0]);\\n    const availableKeys = [0];\\n    \\n    while (availableKeys.length) {\\n        let currentKey = availableKeys.pop();\\n        rooms[currentKey].forEach(key => {\\n           if (!uniqueKeys.has(key)) {\\n               uniqueKeys.add(key);\\n               availableKeys.push(key);\\n           }\\n        });\\n    }\\n\\n    return uniqueKeys.size === rooms.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 972137,
                "title": "bfs-1ms-and-dfs-0ms-solution-in-java",
                "content": "```\\n// using BFS\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[rooms.size()];\\n        visited[0] = true;\\n        for(int i : rooms.get(0)) {\\n            q.add(i);\\n            visited[i] = true;\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int front = q.poll();\\n            for(int i : rooms.get(front)) {\\n                if(!visited[i]) {\\n                    q.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n        \\n        for(boolean i : visited) if(!i) return false;\\n        return true;\\n    }\\n}\\n\\n// using DFS\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean visited[] = new boolean[rooms.size()];\\n        DFS(rooms, 0, visited);\\n        \\n        for(boolean x : visited) if(!x) return false;\\n        return true;\\n    }\\n    \\n    public void DFS(List<List<Integer>> rooms, int i, boolean[] visited) {\\n        visited[i] = true;\\n        for(int c : rooms.get(i)) {\\n            if(!visited[c]) {\\n                visited[c] = true;\\n                DFS(rooms, c, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// using BFS\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[rooms.size()];\\n        visited[0] = true;\\n        for(int i : rooms.get(0)) {\\n            q.add(i);\\n            visited[i] = true;\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int front = q.poll();\\n            for(int i : rooms.get(front)) {\\n                if(!visited[i]) {\\n                    q.add(i);\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n        \\n        for(boolean i : visited) if(!i) return false;\\n        return true;\\n    }\\n}\\n\\n// using DFS\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        boolean visited[] = new boolean[rooms.size()];\\n        DFS(rooms, 0, visited);\\n        \\n        for(boolean x : visited) if(!x) return false;\\n        return true;\\n    }\\n    \\n    public void DFS(List<List<Integer>> rooms, int i, boolean[] visited) {\\n        visited[i] = true;\\n        for(int c : rooms.get(i)) {\\n            if(!visited[c]) {\\n                visited[c] = true;\\n                DFS(rooms, c, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1722316,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1723246,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1569947,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1722061,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1569227,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1721992,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1574649,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1570758,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1573294,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1722982,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1722316,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1723246,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1569947,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1722061,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1569227,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1721992,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1574649,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1570758,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1573294,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1722982,
                "content": [
                    {
                        "username": "hulponot",
                        "content": "is it me, or yesterday\\' easy was much harder? :)"
                    },
                    {
                        "username": "joshuamahadevan23",
                        "content": "Even I was shocked why it was easy.. well, its basic implementation of disjoint-set which isn\\'t too difficult, but disjoint-set itself is something ppl study with graphs.. so many people won\\'t know it.."
                    },
                    {
                        "username": "Shruti_16",
                        "content": "u r not alone thinking that"
                    },
                    {
                        "username": "benb127",
                        "content": "Everyone on here saying this should be an easy one can really discourage those who don\\'t already know the algorithms used and are studying on their own (cough me cough). I don\\'t think raising your hand and saying \\'hey teach that was mislabeled\\' is helping as much as it is hurting"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is all about solving. If you write it out on pen and paper and completely understand it, then it is on the easier side "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@psionl0](/psionl0) Its very intuitive to figure out an algorithm even if you dont know anythink about DFS or BFS. For the begginers could take a litle more time becouse they dosen't have adjust their brains to think like a computer yet, , but with some practice this problem could be easy for them to.\n [Here My Solution](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac) BFS by chance whitout looking for it."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@psionl0](/psionl0) \n\nAs one dude wrote in comments below, they all say that the problem should be easy until got it on an interview :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually relatively easy compared to some of the nightmares presented on this site. Of course, if you are unfamiliar with DFS or BFS then the solution will remain elusive."
                    },
                    {
                        "username": "sabraham296",
                        "content": "Input:\\n[[2],[],[1]]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHello fello Leetcoders,\\n\\nI am implementing a hashtable dictionary to solve this and it works well but I can\\'t understand why it can\\'t pass this test case. According to the description, you need key 1 in order to go to room one. There is no key 1 in room 0 so how can expected answer be true?? If someone can explain if I am not understanding the description or if this is a faulty test case (doubt it). \\n\\nThank you in advance."
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Check if(rooms.get(i).isEmpty()) continue;"
                    },
                    {
                        "username": "sherali716z",
                        "content": "you visited first room and by default got key 1 and second room don\\'t require key and third  requires key 1 which you already got in room 1. so visited all the rooms"
                    },
                    {
                        "username": "dkashi",
                        "content": "It is not sequential. e.g.: [[2], [], [1]], there are 3 rooms lets label the rooms as #0, 1, 2. \\n1. We always start with room 0 which is always unlocked. So we visit room0. lets use a visited set to keep track of visited rooms. So visited = {0}\\n2. From room0 we find keys to room2. so we visit room2 and visited = {0, 2}\\n3. From room2 we find keys to room1. So we visit room1 and visited = {0, 2, 1}\\n\\nAt this point our search is complete and we have visited all rooms, hence the answer is True. "
                    },
                    {
                        "username": "amit24x",
                        "content": "bro, Firstly I also have same doubt but now i understand why? - Let\\'s me make it clear\\n\\nfirstly, if you start from room 0 - you find the key for room 2 at room 0. From that, you directly go to room 2 and their you find key for room 1 and from which you unlock all the room..\\n\\nTHANK YOU!  HOPE IT HELPS"
                    },
                    {
                        "username": "dev_mooie",
                        "content": "This question should be labeled easy."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "[@lakshayne](/lakshayne) I personally agree with the OP. Don\\'t think he/she is gloating - this is one of the easier variations of these questions, this is a platform for studying and the difficulty levels should be accurate."
                    },
                    {
                        "username": "Asential",
                        "content": "[@Msey](/Msey) this is too real ... :("
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@slipnslidebaby](/slipnslidebaby) Yeah, and having accurate gradings on the questions is not a bad thing. Difficulty is obviously subjective based on what you know, but this is definitely not as hard as a lot of the other Medium-graded questions on here!"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@lakshayne](/lakshayne) but this is the most basic variation of a graph traversal problem. It is an \"easy\" type of that problem. Of course people would struggle if they\\'ve never approached a graph problem using BFS - but that can be said for any \"easy\" question on this website which requires some specific knowledge of the DS used. I don\\'t think dev_mooie is gloating here lol"
                    },
                    {
                        "username": "Msey",
                        "content": "They all say that until got it on interview "
                    },
                    {
                        "username": "lakshayne",
                        "content": "So u are here to gloat huh ? The guys like you are creating a toxic environment here . We know you did it at your first try but there are people who are struggling so ,just keep this thought to yourself ."
                    },
                    {
                        "username": "defood",
                        "content": "There is no constraint on only visiting the rooms in order"
                    },
                    {
                        "username": "growingcoder07",
                        "content": "Yes\\n"
                    },
                    {
                        "username": "topswe",
                        "content": "Use dfs. Maintain a visited set of rooms. Return len(visited) == len(rooms)."
                    },
                    {
                        "username": "trancememes",
                        "content": "Can someone explain the question to me? Not following"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Read this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "achoudhary94",
                        "content": "I am failing to understand why is the complexity O(N+E). Should it not be O(N * E)? Because for every room, we will take all the keys and then visit those rooms."
                    },
                    {
                        "username": "pocketcookies",
                        "content": "E represents the total number of keys in all the rooms, not the number of keys per room."
                    },
                    {
                        "username": "user6744c",
                        "content": "We are writing the solution in such a way that one room is visited only once, if we discover a key to a room that is already visited earlier, we simply don\\'t visit that room."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we will not visit the rooms we already visited !!"
                    },
                    {
                        "username": "asieber",
                        "content": "The following sentence:\\n\\n\"You can walk back and forth between rooms freely.\"\\n\\nshould be changed to:\\n\\n\"You can walk back and forth between **unlocked** rooms freely.\"\\n\\nI thought this was a backtracking question and didn\\'t realize I didn\\'t have to unlock these rooms in a single sequence of N unlocks. Rather, I could unlock a room, go there, walk right back to the previous room and unlock another room all in the same sequence. The following example might help clarify this as well:\\n\\nExample:\\n\\nInput: [[1,2,3],[],[],[]]\\nOutput: true\\nExplanation:  \\nWe start in room 0, and pick up key 1.\\nWe then go to room 1.\\nWe then return to room 0, and pick up key 2.\\nWe then go to room 2.\\nWe then return to room 0, and pick up key 3.\\nWe then go to room 3.\\nSince we were able to go to every room, we return true."
                    },
                    {
                        "username": "slicedkiwis",
                        "content": "I don\\'t think this should be a medium ranked problem. It\\'s pretty straightforward."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@georgezakharov](/georgezakharov) I don\\'t call a problem \"easy\" because I think I would ace it at an interview (I can stuff up an interviews as well as the next guy). I consider how easy the problem is compared to the rest of the problems in LeetCode. This problem is just a stock standard graph traversal and should be doable for anybody who has experience with this."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    }
                ]
            },
            {
                "id": 1572671,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 1722755,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 1722541,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 1722085,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2071098,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2069953,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2015325,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2015308,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2015304,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2015301,
                "content": [
                    {
                        "username": "ankitchouhan1020",
                        "content": "Question will be better if a person can use only one of the keys available in current room. Backtracking will be required then."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Would be a good follow up question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I thought about that first and implemented according to that only , but then read the question again after failing test cases , and got to know it was asking much easier (without backtracking) than what I mistakenly thought."
                    },
                    {
                        "username": "alexey0206",
                        "content": "There is no reference that i can visit the room in any order, and according to provided test cases I made a suspection than I should, but it is a mistake. It would be better to mention it in discription..."
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "simple approch using bfs,traverse all nodes like a graph and create visited array in which strore nodes are visited or not. and last count visited node  and compare with number of set of key.if equal then return true......."
                    },
                    {
                        "username": "GargShubham",
                        "content": "[ [1, 3] , [1, 4] ,  [2, 3, 4, 1] , [ ] , [4, 3, 2] ] \\nWhy this show TRUE instead of False. because we don\\'t have lock of room-2 ;"
                    },
                    {
                        "username": "vishalk3014687",
                        "content": "Because at room 1 , we get the key of room 4, and room 4 will give you key of room 2 , so we can visit all the rooms and hence ans is true"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "yes it is easy, but poor me who thought of using hashset"
                    },
                    {
                        "username": "luckymyli",
                        "content": "Why this testCase returns False?\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n// use  typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\n``````"
                    }
                ]
            },
            {
                "id": 2015278,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 2002255,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1993527,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1930513,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1916963,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1876171,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1834314,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1798878,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1798542,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1725317,
                "content": [
                    {
                        "username": "kongnakornna",
                        "content": "\n\n``````\n// typescript\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \n// use typescript \n\nfunction canVisitAllRooms(rooms: number[][]): boolean {\n    const visited: boolean[] = new Array(rooms.length).fill(false);\n    visited[0] = true; //  room 0\n    const stack: number[] = [0]; //  stack  \n    while (stack.length > 0) {\n        const currentRoom = stack.pop()!;  // push object to array typescript\n        const keys = rooms[currentRoom];\n        for (const key of keys) {\n            if (!visited[key]) {  // \n                visited[key] = true;  \n                stack.push(key); // push  function   function \n            }\n        }\n    }\n    return visited.every(roomVisited => roomVisited);\n}\n// Test cases\nconst rooms1 = [[1],[2],[3],[]];\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\n\n``````"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## My Solution With HashSet!!\\n\\nI think I\\'m getting better or this problem is at the wrong level\\n\\n[Here](https://leetcode.com/problems/keys-and-rooms/solutions/3870020/my-solution-with-hashset-no-stack-no-visited-list-no-recursion/?source=submission-ac)"
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "I believe the description should be modified to be like the following :\nYou are given n rooms labeled from 0 to n - 1, and each room is initially locked except for room 0, which is unlocked. Your goal is to visit all the rooms, but there's a constraint: you can only enter a locked room if you have the key for it.\n\nEach room you visit may contain a set of distinct keys. Each key has a number on it, indicating the room it can unlock. You can take all the keys with you when you leave a room to unlock other rooms later.\n\nGiven an array rooms, where rooms[i] is an array representing the set of keys that you can obtain if you visited room i, return true if it's possible to visit all the rooms, starting from room 0, using the keys acquired along the way, or false otherwise.\n\nWith this refined description, it should be clearer that the task is to determine if there is a way to visit all the rooms by navigating through the provided keys, starting from room 0 and unlocking other rooms as needed. "
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n\\n``````\\n\\n\\nfunction canVisitAllRooms(rooms: number[][]): boolean {\\n    const visited: boolean[] = new Array(rooms.length).fill(false);\\n    visited[0] = true; // \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01 room 0\\n    const stack: number[] = [0]; //  stack  \\u0E19\\u0E33\\u0E21\\u0E32\\u0E40\\u0E1B\\u0E23\\u0E35\\u0E22\\u0E1A\\u0E40\\u0E17\\u0E35\\u0E22\\u0E1A\\n    while (stack.length > 0) {\\n        const currentRoom = stack.pop()!;  // push object to array typescript\\n        const keys = rooms[currentRoom];\\n        for (const key of keys) {\\n            if (!visited[key]) {  // \\u0E2B\\u0E32\\u0E27\\u0E48\\u0E32\\u0E04\\u0E48\\u0E32\\u0E21\\u0E35\\u0E08\\u0E23\\u0E34\\u0E07\\u0E44\\u0E2B\\u0E21\\n                visited[key] = true;  \\n                stack.push(key); // push \\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E43\\u0E0A\\u0E49\\u0E01\\u0E31\\u0E19\\u0E1A\\u0E48\\u0E2D\\u0E22\\u0E21\\u0E32\\u0E01\\u0E46 \\u0E40\\u0E1E\\u0E23\\u0E32\\u0E30\\u0E27\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19 function \\u0E17\\u0E35\\u0E48\\u0E40\\u0E1E\\u0E34\\u0E48\\u0E21\\u0E04\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B\\n            }\\n        }\\n    }\\n    return visited.every(roomVisited => roomVisited);\\n}\\n// Test cases\\nconst rooms1 = [[1],[2],[3],[]];\\nconsole.log(canVisitAllRooms(rooms1)); // Output: true\\nconst rooms2 = [[1,3],[3,0,1],[2],[0]];\\nconsole.log(canVisitAllRooms(rooms2)); // Output: false\\n\\nDefine the Problem:\\nYou have a list of rooms, each containing a set of keys that can unlock other rooms. You need to check if you can visit all rooms starting from room 0.\\n\\nCreate a Visited Array:\\nCreate an array to keep track of which rooms you\\'ve visited. Initialize all elements as false except for the first room (room 0), which you set to true.\\n\\nImplement DFS:\\nYou will implement a Depth-First Search (DFS) algorithm to explore the rooms and their keys. Start from room 0.\\n\\nFor each room you visit:\\nMark the room as visited by setting the corresponding element in the visited array to true.\\nIterate through the keys in the current room.\\nIf you find a key to a room that hasn\\'t been visited yet, recursively call the DFS function with that room as the new starting point.\\nCheck All Rooms:\\nAfter the DFS traversal is complete, check if all rooms have been visited. If any room remains unvisited, return false. Otherwise, return true.\\n\\nHere\\'s the TypeScript code to implement the above steps:\\n\\ntypescript\\n/*\\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\\n\\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\\n\\n \\n\\nExample 1:\\n\\nInput: rooms = [[1],[2],[3],[]]\\nOutput: true\\nExplanation: \\nWe visit room 0 and pick up key 1.\\nWe then visit room 1 and pick up key 2.\\nWe then visit room 2 and pick up key 3.\\nWe then visit room 3.\\nSince we were able to visit every room, we return true.\\nExample 2:\\n\\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\\nOutput: false\\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\\n \\n\\nConstraints:\\n\\nn == rooms.length\\n2 <= n <= 1000\\n0 <= rooms[i].length <= 1000\\n1 <= sum(rooms[i].length) <= 3000\\n0 <= rooms[i][j] < n\\nAll the values of rooms[i] are unique.\\n*/\\n// typescript\\n// https://www.tutorialspoint.com/typescript/typescript_array_pop.htm\\n// https://stackoverflow.com/questions/46249472/how-to-push-an-object-into-an-array-with-typescript \\n\\n\\n\\n\\u0E15\\u0E2D\\u0E1A\\n\\u0E04\\u0E38\\u0E13\\u0E21\\u0E35\\u0E23\\u0E32\\u0E22\\u0E0A\\u0E37\\u0E48\\u0E2D\\u0E2B\\u0E49\\u0E2D\\u0E07 \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35\\u0E0A\\u0E38\\u0E14\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E17\\u0E35\\u0E48\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E44\\u0E02\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E2D\\u0E37\\u0E48\\u0E19\\u0E46 \\u0E44\\u0E14\\u0E49 \\u0E04\\u0E38\\u0E13\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E04\\u0E38\\u0E13\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E42\\u0E14\\u0E22\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0 \\u0E44\\u0E14\\u0E49\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48\\n\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21:\\n\\u0E2A\\u0E23\\u0E49\\u0E32\\u0E07\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E15\\u0E34\\u0E14\\u0E15\\u0E32\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E04\\u0E22\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E22\\u0E01\\u0E40\\u0E27\\u0E49\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E23\\u0E01 (\\u0E2B\\u0E49\\u0E2D\\u0E07 0) \\u0E0B\\u0E36\\u0E48\\u0E07\\u0E04\\u0E38\\u0E13\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E43\\u0E0A\\u0E49 DFS:\\n\\u0E04\\u0E38\\u0E13\\u0E08\\u0E30\\u0E43\\u0E0A\\u0E49\\u0E2D\\u0E31\\u0E25\\u0E01\\u0E2D\\u0E23\\u0E34\\u0E17\\u0E36\\u0E21\\u0E01\\u0E32\\u0E23\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E40\\u0E0A\\u0E34\\u0E07\\u0E25\\u0E36\\u0E01 (DFS) \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E2A\\u0E33\\u0E23\\u0E27\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E41\\u0E25\\u0E30\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08 \\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E08\\u0E32\\u0E01\\u0E2B\\u0E49\\u0E2D\\u0E07 0\\n\\n\\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A\\u0E41\\u0E15\\u0E48\\u0E25\\u0E30\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E04\\u0E38\\u0E13\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21:\\n\\u0E17\\u0E33\\u0E40\\u0E04\\u0E23\\u0E37\\u0E48\\u0E2D\\u0E07\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E27\\u0E48\\u0E32\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E41\\u0E25\\u0E49\\u0E27\\u0E42\\u0E14\\u0E22\\u0E15\\u0E31\\u0E49\\u0E07\\u0E04\\u0E48\\u0E32\\u0E2D\\u0E07\\u0E04\\u0E4C\\u0E1B\\u0E23\\u0E30\\u0E01\\u0E2D\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E35\\u0E48\\u0E22\\u0E27\\u0E02\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E40\\u0E02\\u0E49\\u0E32\\u0E0A\\u0E21\\u0E43\\u0E2B\\u0E49\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E23\\u0E34\\u0E07\\n\\u0E27\\u0E19\\u0E0B\\u0E49\\u0E33\\u0E1C\\u0E48\\u0E32\\u0E19\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E43\\u0E19\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E1B\\u0E31\\u0E08\\u0E08\\u0E38\\u0E1A\\u0E31\\u0E19\\n\\u0E2B\\u0E32\\u0E01\\u0E04\\u0E38\\u0E13\\u0E1E\\u0E1A\\u0E01\\u0E38\\u0E0D\\u0E41\\u0E08\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E35\\u0E48\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E02\\u0E49\\u0E32\\u0E44\\u0E1B \\u0E43\\u0E2B\\u0E49\\u0E40\\u0E23\\u0E35\\u0E22\\u0E01\\u0E1F\\u0E31\\u0E07\\u0E01\\u0E4C\\u0E0A\\u0E31\\u0E19 DFS \\u0E0B\\u0E49\\u0E33\\u0E42\\u0E14\\u0E22\\u0E43\\u0E2B\\u0E49\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E21\\u0E48\\n\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14:\\n\\u0E2B\\u0E25\\u0E31\\u0E07\\u0E08\\u0E32\\u0E01\\u0E1C\\u0E48\\u0E32\\u0E19 DFS \\u0E40\\u0E2A\\u0E23\\u0E47\\u0E08\\u0E2A\\u0E34\\u0E49\\u0E19 \\u0E43\\u0E2B\\u0E49\\u0E15\\u0E23\\u0E27\\u0E08\\u0E2A\\u0E2D\\u0E1A\\u0E27\\u0E48\\u0E32\\u0E21\\u0E35\\u0E01\\u0E32\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14\\u0E2B\\u0E23\\u0E37\\u0E2D\\u0E44\\u0E21\\u0E48 \\u0E2B\\u0E32\\u0E01\\u0E22\\u0E31\\u0E07\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E43\\u0E04\\u0E23\\u0E40\\u0E22\\u0E35\\u0E48\\u0E22\\u0E21\\u0E0A\\u0E21\\u0E2B\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E14 \\u0E43\\u0E2B\\u0E49\\u0E2A\\u0E48\\u0E07\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E40\\u0E17\\u0E47\\u0E08 \\u0E21\\u0E34\\u0E09\\u0E30\\u0E19\\u0E31\\u0E49\\u0E19\\u0E43\\u0E2B\\u0E49\\u0E04\\u0E37\\u0E19\\u0E04\\u0E48\\u0E32\\u0E08\\u0E23\\u0E34\\u0E07\\n\\n\\u0E19\\u0E35\\u0E48\\u0E04\\u0E37\\u0E2D\\u0E23\\u0E2B\\u0E31\\u0E2A TypeScript \\u0E40\\u0E1E\\u0E37\\u0E48\\u0E2D\\u0E14\\u0E33\\u0E40\\u0E19\\u0E34\\u0E19\\u0E01\\u0E32\\u0E23\\u0E15\\u0E32\\u0E21\\u0E02\\u0E31\\u0E49\\u0E19\\u0E15\\u0E2D\\u0E19\\u0E02\\u0E49\\u0E32\\u0E07\\u0E15\\u0E49\\u0E19:\\n\\n``````"
                    },
                    {
                        "username": "dsa_sucks",
                        "content": "x=[0]+=rooms[0]\\n        while True:\\n            a=len(x)\\n            print(x)\\n            for i in x:\\n                x+=rooms[i]\\n            x=(set(x))\\n            if a==len(x):\\n                return 0\\n            if len(x)==len(rooms):\\n                return 1\\n        \\n\\n        \\n            Any idea why this is showing Memory Limit Exceeded? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The indentation is missing.\n- `x=[0]+=rooms[0]` is invalid syntax.\n- After `x=(set(x))` you can no longer add/append to `x` with `+=`.\n- Don't append to a list (`x += rooms[i]`) while looping over it with an iterator (`for i in x`).\n\nPlease post valid code. That makes it more likely that somebody will help you."
                    },
                    {
                        "username": "Banwar54ba",
                        "content": "we can either use dfs or bfs to solve this ques.\\nfor a little speedup we can use dynamic programming and skip the rooms which are already opened."
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Can someone explain to me why in the [[2],[],[1]] example the function should return true? In room zero \\'[2]\\' (we can always enter it), we take the key of the second room \\'[1]\\'. But we don\\'t have a key for the first room \\'[]\\', so we can\\'t enter it and continue the path, so it\\'s false? I think I misunderstood the logic, although I made 5 test cases and everything works correctly, including the 2 standard cases from the task description."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don\\'t have to enter the rooms in-order.  \\nInitially only room `0` is unlocked.  \\nVisit room `0` and get the key to room `2`.  \\nVisit room `2` and get the key to room `1`.  \\nVisit room `1` (and get no keys).  \\nYou\\'ve visited all rooms, return `true`."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "when i use this code in other online compiler then its working but here it is showing wrong answer why?\\nfrom collections import defaultdict \\nclass Solution:\\n    def canVisitAllRooms(self, rooms) :\\n        \\n        g=defaultdict(list)\\n        \\n        for i in range(len(rooms)):\\n            \\n            g[i]=rooms[i]\\n        w=self.dfs(g,0)\\n        \\n        return w\\n\\n    def dfs(self,g,v,visited=set()):\\n        visited.add(v)\\n        for i in g[v]:\\n            if i not in visited:\\n                self.dfs(g,i)\\n        print(visited)\\n        for j in range(len(g)):\\n            #print(i in visited)\\n            if j not in visited:\\n                \\n                return False\\n        return True"
                    },
                    {
                        "username": "neetee",
                        "content": "```\\nclass Solution {\\n    vector<int> *graph1;\\n    vector<int> *graph2;\\n    vector<int> vis1;\\n    vector<int> vis2;\\n\\n    void dfs2(int v) {\\n        vis2[v]=true;\\n\\n        for(int i:graph2[v]){\\n            if(!vis2[i]){\\n                dfs2(i);\\n            }\\n        }\\n    }\\n\\n    void dfs1(int v) {\\n        vis1[v]=true;\\n\\n        for(int i:graph1[v]){\\n            if(!vis1[i]){\\n                dfs1(i);\\n            }\\n        }\\n    }\\n\\n    bool isConnected(int n) {\\n        vis1.resize(n, false);\\n        dfs1(0);\\n        vis2.resize(n, false);\\n        dfs2(0);\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis1[i]&&!vis2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        // directed graph should be connected\\n        graph1=new vector<int>[rooms.size()];\\n        graph2=new vector<int>[rooms.size()];\\n\\n        int i=0;\\n        for(vector<int> room:rooms) {\\n            for(int key:room){\\n                graph1[i].push_back(key);\\n                graph2[key].push_back(i);\\n            }\\n            i++;\\n        }\\n\\n        return isConnected(rooms.size());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Sooo... what exactly do you want to discuss here? :)"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "can anyone explain why the answer of this test case is true [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Initially only room `0` is unlocked.  \nGo to room `0` and get keys to rooms `1` and `3`.  \nUnlock room `1` and get keys to rooms `1` and `4`.  \nUnlock room `3` and get no keys.  \nUnlock room `4` and get keys to rooms `4`, `3`, and `2`.  \nUnlock room `2` and get keys to rooms `2`, `3`, `4`, and `1`.  \nYou've visited all rooms, return `true`."
                    },
                    {
                        "username": "user3515OJ",
                        "content": "   public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        \\n       \\n        int[] visited = new int[rooms.size()];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        visited[0] = 1;\\n        int visitedCnt = 1;\\n        while(!q.isEmpty()){\\n            int currNode = q.poll();\\n            for(int adjNode: rooms.get(currNode)){\\n                if(visited[adjNode] == 0){\\n                    visited[adjNode] = 1;\\n                    visitedCnt++; \\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n\\n        return visitedCnt == rooms.size()? true: false;\\n    "
                    }
                ]
            },
            {
                "id": 1723968,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1723280,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1723262,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722968,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722902,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722870,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722814,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722809,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722748,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722696,
                "content": [
                    {
                        "username": "close27",
                        "content": "If you add one more loop for debugging, in theory it is still constant time, but here the execution speed is in below 5%."
                    },
                    {
                        "username": "swapnilxi",
                        "content": "` for(int next: rooms.get(curr)){\n// code\n}\n`\ncan someone help me to convert this code in for loop?\n\n``` \nfor(int next: rooms.get(curr)){\n            if(!set.contains(next)){\n                set.add(next);\n                helper(rooms, set, next);\n            }\n        }\n```\n"
                    },
                    {
                        "username": "benb127",
                        "content": "I\\'m going insane. Why does it seem like canVisitAllRooms is being called multiple times for 1 test case?\\n\\nclass Solution{\\n\\n    public List<List<Integer>> rooms;\\n\\tpublic int[] roomsVisited;\\n\\tpublic List<Integer> keysCollected = new ArrayList<Integer>();\\n\\n    public boolean canVisitAllRooms(List<List<Integer>> input) {\\n        //System.out.println(\"TESTTESTTESTTEST\");\\n        rooms = input;\\n        createRoomsVisitedChecklist();\\n        keysCollected.add(0);\\n\\n        if(firstRoomEmpty()) return false;\\n\\n        //loop start\\n        System.out.println(\"pre-loop keysCollected size != 0: \" + (keysCollected.size() != 0));\\n        while(keysCollected.size() != 0){\\n            int currentRoom = keysCollected.get(0);\\n            \\n            /*\\n            System.out.println(\"Current room is: \" + currentRoom);\\n            System.out.print(\"Keys collected before room: \");\\n            printList(keysCollected);\\n            */\\n            \\n            collectKeysInOrderFromRoom(currentRoom);\\n            markRoomAsVisited(currentRoom);\\n            removeUsedKeyFromCollection(currentRoom);\\n            \\n            /*\\n            System.out.print(\"Keys collected after room: \");\\n            printList(keysCollected);\\n            \\n            System.out.print(\"Rooms visited: \");\\n            printArray(roomsVisited);\\n\\n            System.out.println(\"keysCollected size != 0: \" + (keysCollected.size() != 0));\\n            System.out.println(\"!allRoomsVisited: \" + !allRoomsVisited());\\n            */\\n        }\\n\\n\\n        if(allRoomsVisited())\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    public void createRoomsVisitedChecklist(){\\n        roomsVisited = new int[rooms.size()];\\n        setRoomsVisitedToNone();\\n        \\n        //printArray(roomsVisited);\\n    }\\n\\n    public void setRoomsVisitedToNone(){\\n        for(int i = 0; i < roomsVisited.length; i++)\\n            roomsVisited[i] = 0;\\n    }\\n\\n    public boolean firstRoomEmpty(){\\n        if(rooms.get(0).size() == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public void collectKeysInOrderFromRoom(int room){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to visiting room: \");\\n    \\tprintList(keysCollected);\\n    \\t\\n    \\tSystem.out.print(\"Keys in room: \");\\n    \\tprintList(rooms.get(room));\\n    \\t*/\\n    \\t\\n        for(int i = 0; i < rooms.get(room).size(); i++){\\n            collectKeysInOrder(rooms.get(room).get(i));\\n        }\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    //places key in keysCollected in ascending order\\n    public void collectKeysInOrder(int keyToBeAdded){\\n    \\t\\n    \\t/*\\n    \\tSystem.out.print(\"Keys collected prior to adding: \");\\n    \\tprintList(keysCollected);\\n    \\tSystem.out.println(\"Keys to be added: \" + keyToBeAdded);\\n    \\t*/\\n        \\n    \\tfor(int i = 0; i < keysCollected.size(); i++){\\n            if(keysCollected.get(i) > keyToBeAdded){\\n                keysCollected.add(i, keyToBeAdded);\\n                return;\\n            }\\n        }\\n        keysCollected.add(keyToBeAdded);\\n        \\n        /*\\n        System.out.print(\"Keys collected after adding: \");\\n    \\tprintList(keysCollected);\\n    \\t*/\\n    }\\n\\n    public void markRoomAsVisited(int room){\\n        roomsVisited[room] = 1;\\n    }\\n\\n    public void removeUsedKeyFromCollection(int room){\\n        if(keysCollected.indexOf(room) == -1)\\n            return;\\n        keysCollected.remove(keysCollected.indexOf(room));\\n    }\\n\\n    public boolean allRoomsVisited(){\\n        if(sumArray(roomsVisited) == roomsVisited.length)\\n            return true;\\n        return false;\\n    }\\n\\n    public int sumArray(int[] arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            sum += arr[i];\\n        return sum;\\n    }\\n\\n    //returns true if the input keyList has the input key\\n    public boolean listHasKey(List<Integer> keyList, int key){\\n        for(int i = 0; i < keyList.size(); i++){\\n            if(keyList.get(i) == key)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public void printList(List<Integer> list){\\n        for(int i = 0; i < list.size(); i++){\\n            System.out.print(list.get(i) + \" \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    public void printArray(int[] arr){\\n    \\tfor(int i = 0; i < arr.length; i++){\\n    \\t\\tSystem.out.print(arr[i] + \" \");\\n    \\t}\\n    \\tSystem.out.println();\\n    }\\n}"
                    },
                    {
                        "username": "benb127",
                        "content": "I wrote the same thing in eclipse and it spits out \\'true\\' instantly"
                    },
                    {
                        "username": "abhiintheweb",
                        "content": "It was  quick.  I think it should be labeled as easy :P"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "Test Case Failed - [[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nSolution Tried\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n        HashSet<Integer> hm = new HashSet();\\n        for( int i=0;i<rooms.size();i++){\\n            if(i==0){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(hm.contains(i) ){\\n                addToSet(rooms.get(i),hm);\\n            }\\n            else if(rooms.get(i).isEmpty()) continue;\\n            else return false;\\n        }\\n        // Iterator<Integer> i=hm.iterator();  \\n        //    while(i.hasNext())  \\n        //    {  \\n        //    System.out.println(8);  \\n        //    }  \\n        return true;\\n    }\\n    private HashSet<Integer> addToSet(List<Integer> room, HashSet<Integer> set){\\n        for(int j=0;j<room.size();j++){\\n                set.add(room.get(j));\\n                            // System.out.println(room.get(j));\\n                }\\n        return set;\\n    }\\n}\\n\\nTrouble Issue -\\nWe visit room 0 and pick up key 1,3.                   Set->1,3\\nWe then visit room 1 and pick up key 1,4.           Set->1,3,4\\nCan\\'t visit room 2 , because we don\\'t have key for room 2.\\nSo it should return false, compiler is returning false, but expected it true.\\n\\nCan anyone explain ??"
                    },
                    {
                        "username": "himanshu_hc",
                        "content": "[@siebenschlaefer](/siebenschlaefer) /thanks a lot for this explanation"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You don't have to visit the rooms in order.\nGo to room 0, pick up the keys to rooms 1 and 3.\nGo to room 1, pick up the key to room 4.\nGo to room 4, pick up the keys to room 2.\nGo to rooms 2 and 3.\nYou visited all the rooms."
                    },
                    {
                        "username": "JigneshThakkar",
                        "content": "An O(m*n) solution is an easy one. m=max number of distinct keys across all rooms, n=number of rooms.\\nAny hints on optimizing the solution further?"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "can someone please tell me if i wanna make the same input as in `List<List<Integer>> `: which gives [[1] , [2] , [3]]  how to write in java?"
                    },
                    {
                        "username": "benb127",
                        "content": "I did this for mine: \\n\\nList<List<Integer>> testInput = new ArrayList<List<Integer>>();\\ntestInput.add(Arrays.asList(new Integer[]{1}));\\ntestInput.add(Arrays.asList(new Integer[]{2}));\\ntestInput.add(Arrays.asList(new Integer[]{3}));\\ntestInput.add(Arrays.asList(new Integer[]{}));"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@Minamikaze392](/Minamikaze392) thanks dude!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You need to create a list of lists. Quite verbose to do in Java:\\n```java\\nList<List<Integer>> rooms = new ArrayList<>();\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.add(new ArrayList<>());\\nrooms.get(0).add(1);\\nrooms.get(1).add(2);\\nrooms.get(2).add(3);\\n```"
                    },
                    {
                        "username": "nomaanahmad",
                        "content": "Someone please help me understand how this question is related to graph, dfs and bfs. I used a hashset and queue to solve it but not able to understand graph approach here. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You can imagine each room as a vertix in a graph, each key is a directed edge to a specific room/vertix.\n\nFor example the input `[[4],[3],[],[2,5,7],[1],[ ],[8,9],[ ],[ ],[6] ]` is eqivalent to this graph:\n          \n                   +-> 2\n                   |\n    0 -> 4 -> 1 -> 3 -> 5\n                   |\n                   +-> 7\n    6 <-> 9\n    |\n    +-> 8\n\nStarting from `0` you cannot get to `6`, `8`, or `9`."
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "I don\\'t think this question must be marked as \"Medium\", it should be easy."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "i thought the question was that we have to check weather we have the keys of all the rooms or not ... so my brute force  was to check weather all the were present in the list or not other than its own index one !\\nNOT the correct solution but worth seeing \\nint n= rooms.size();\\n        boolean a[]= new boolean [n];\\n        for(int i = 1 ; i < a.length; i++)\\n        {\\n            a[i]= false;\\n        }\\n        a[0]=true;\\n        for(int i=0 ; i< rooms.size(); i++)\\n        {\\n            List<Integer> currList = rooms.get(i);\\n            for(int j = 0 ; j< currList.size(); j++)\\n            {\\n                int num = currList.get(j);\\n                if( i!= num && num<n)\\n                {\\n                    a[num]= true;\\n                }\\n            }\\n        }\\n        for(int i =0; i<a.length; i++)\\n        {\\n            if(a[i]==false)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n"
                    }
                ]
            },
            {
                "id": 1722689,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722538,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722526,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722389,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722348,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722300,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722259,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722236,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722234,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722204,
                "content": [
                    {
                        "username": "ram-bhardwaj",
                        "content": "[ [4] , [3] ,[ ], [2,5,7] , [1] , [ ] , [8,9] , [ ] , [ ] , [6] ]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nhow is this false ? it is 9 indexed and it contains all numbers from 1 to 9 ......\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them."
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Can anyone explain how to form a graph for this question ?"
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Think in terms of directional graph!!\\n\\nlike 0 index is connected to other indexs,\\nNow you have to find nodes which are unreachable.\\nyou can use BFS of DFS any traversing algorithm."
                    },
                    {
                        "username": "baosaurus",
                        "content": "shouldn\\'t time complexity be O(n*m) where n is numRooms and m is numKeys. We visit each room once, and for each room we consider each key by checking if they are in visited set. "
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Use the DFS graph traversal to traverse the rooms list of list and maintain a visited array of Boolean type and if any node is not visited return false else true."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "```class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int n=rooms.size();\\n        vector<int>v(n);\\n        queue<int>q;\\n        q.push(0);\\n        while(q.size()) {\\n            int idx = q.front();\\n            q.pop();\\n            v[idx]=1;\\n            for(int i=0;i<rooms[idx].size();i++)\\n            {\\n                q.push(rooms[idx][i]);\\n            }\\n        }\\n        return 1;\\n    }\\n};```\\n\\nwhy it is TLE"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@satyabratojha04](/satyabratojha04) Did you consider adding only those rooms to the queue that you haven\\'t visited yet?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Look at the second example: `[[1,3],[3,0,1],[2],[0]]`\\nRoom 0 contains a key to room 1, room 1 contains a key to room 0.\\nYour solution will visit rooms `0` and `1` over and over again, the queue will never become empty."
                    },
                    {
                        "username": "satyabratojha04",
                        "content": "even for shorter test cases\\nthat q.push(rooms[idx][i]) is making problem"
                    },
                    {
                        "username": "six519",
                        "content": "recursion guys!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I prefer Iterative :)"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "What is wrong with my code?\\n\\n\\n `your inline code...your inline code...`class Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        unordered_map<int,bool>m;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=false;\\n        }\\n        vector<int>c;\\n        for(int i=0;i<rooms.size();i++)\\n        {\\n            m[rooms[i]]=true;\\n            c.push_back(rooms[i]);\\n            for(int j=0;i<c.size();i++)\\n            {\\n                m[rooms[j]]=true;\\n                c.clear();\\n            }\\n        }\\n        for(auto &it:m)\\n        {\\n            if(m.second==false)\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please format the code properly. Put a line with three backticks (\\`\\`\\`) before and after the code. Otherwise it is hard to read and parts of it might be missing (for example: `vectorc;`)\n\nVariable names like `m` and `c` don't carry much meaning, they make the code hard to understand. Use expressive names, make it easy for others to help you.\n\nThis solution looks like it won't compile:\n- `m` is a `std::unordered_map<int,bool>`, `rooms` is a `std::vector<std::vector<int>>`, therefore you can't access `m[rooms[i]]`. Did you mean `m[i]`?\n- `m` is a `std::unordered_map<int,bool>`, it has no member `second`. Did you mean `it.second`?\n\nIt's not clear what the \"middle\" loop tries to accomplish. The inner `for` loop loops as long as `i < c.size()`. But the end of the loop body calls `c.clear()` so the loop will iterate at most once."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "How is this false?\\n\\n[[4],[3],[],[2,5,7],[1],[],[8,9],[],[],[6]]"
                    },
                    {
                        "username": "c0derr0r",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Ah good catch, thanks!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The keys for rooms 8 and 9 are only in room 6.\\nThe key for room 6 is only in room 9.\\nYou cannot get into the rooms 6, 8, or 9 because they are initially locked and you cannot get keys to them.\\n\\n\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "   void getKey(vector<vector<int>> rooms, vector<int> &sol, int index){\\n      int size=rooms[index].size();\\n      for(int i=0;i<size;i++){\\n          int key=rooms[index][i];\\n          if(find(sol.begin(), sol.end(), key)==sol.end()){\\n              sol.push_back(rooms[index][i]);\\n          }\\n      }\\n   }\\n\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        vector<int> sol;\\n        sol.push_back(0);\\n        for(int i=0;i<sol.size();i++){\\n            getKey(rooms, sol, sol[i]);\\n        }\\n        if(sol.size()!=rooms.size()) return false;\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1722197,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722184,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722135,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722131,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722129,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722013,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722012,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722009,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1722000,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            },
            {
                "id": 1708439,
                "content": [
                    {
                        "username": "amanchandna",
                        "content": "Think of this question as a graph given to you with directions. You just need to find out is it a complete graph or not, by traversing it."
                    },
                    {
                        "username": "space_invader",
                        "content": "The similar problem as the [yesterday\\'s](https://leetcode.com/problems/find-if-path-exists-in-graph) except we do not even need to build a graph."
                    },
                    {
                        "username": "prabhudas",
                        "content": "Consider  rooms `0 .. n - 1` are the vertices and keys stored in each room as the `edges` connecting to other vertices. \nIf we follow above considerations, it will result into a `directed` graph.\n\nNow the problem is reduced to check if it is possible to visit all vertices starting from vertex `0`.\n\nWe can either do `BFS` or `DFS` starting from vertex `0`"
                    },
                    {
                        "username": "chiragraghuwanshi176",
                        "content": "just a dfs problem "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "HINT:\\n\\nRead this statement -> When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\\n\\nSo, you are at node 0 at the beginning, also, 0 has some some keys of other rooms\\nIf we think about it, can we say that room 0 has an edge with all those rooms whose keys are in room 0?\\nOkay, we understood that this is a question involving graphs\\n\\nSo, for example, room 0 has key of room 1\\nIn other words, 0 has an edge with 1\\ni.e. you can say that you can travel to room 1 with room 0\\n\\nNow, you reached room 1 and room 1 has key of room 3, so, we got to know that room 1 and 3 also have an edge\\n\\nAccording to the question, we need to find out how many rooms can we visit?\\nCan we do it by just running a DFS over all edges and increasing the count of visited edges by 1 when we visit an unvisited edge?\\nYes, and if count is n, answer is true, else false\\n\\nSo, you just have to form an adjacency list, and perform dfs/bfs counting nodes you visit\\n\\nIf you want to see the implementation:\\nhttps://leetcode.com/problems/keys-and-rooms/submissions/862459198/\\n\\nPLEASE UPVOTE IF YOU LIKE THE EXPLANATION"
                    },
                    {
                        "username": "megazortti",
                        "content": "Something is wrong with it, isnt?\\n\\n[[1,3],[1,4],[2,3,4,1],[],[4,3,2]]\\n\\nI cant enter the room 2 since the only key that unlocks it is in that room.\\nBut the algorithim says TRUE.. Didnt get it.. can anoyne help me ?"
                    },
                    {
                        "username": "megazortti",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) OMG URE A MONSTER"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Key of Room 2 is present in two rooms: 2nd and 4th one\\n\\nSo when I react 4th, I can go to room 2\\n\\none of the paths:\\n0 -> 1-> 4 -> 2"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how this can be true? helpppppppppppppppppp\\n[[2],[],[1]]\\nexpected : true"
                    },
                    {
                        "username": "Schnedarb",
                        "content": "You start off with key 0.\\n\\ninside room 0 is the key to room 2.\\n\\ninside room 2 is the room to key 1."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Because you start from 0, then go to 2 and then 1\\n0 -> 2-> 1\\nYou have visited all the nodes in the graph\\n\\nThe given rooms inputs is same as of a adjacency list representation, it tells that which nodes are connected to the current one"
                    },
                    {
                        "username": "maroshim",
                        "content": "initially room 0 is unlocked"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "1. take an array to store the keys(e.g., since 0th room will always be open then 0th index value can be 1)\\n2. take a variable(x) as 1\\n3. iterate in given list of lists\\n    keep on increasing the key(e.g., arr[i]++) on the index of array\\n4. x will check if current room key u have or not\\n    if not then return false\\n5. else after the end of loop of iterating the list, u can return true"
                    },
                    {
                        "username": "medmoe",
                        "content": "can anyone explain why i have list index out of range in this code !!!\\n\\n```\\nclass Solution:\\n\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        #assume size = 6\\n        size = len(rooms)\\n        l = list(range(size))\\n        print(l)\\n        print(l[5])\\n```"
                    },
                    {
                        "username": "KershKersh",
                        "content": "I tested this out on replit, and I\\'m guessing the assumption of size=6 is the error. Without more context, at least."
                    },
                    {
                        "username": "ranjan410014",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...`class Solution:\\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n        st=[0]*len(rooms)\\n        s=0\\n        q=[0]\\n        st[0]=1\\n        while(q):\\n            x=q.pop(0)\\n            l=rooms[x]\\n            for y in l:\\n                if st[y]==0:\\n                    st[y]=1\\n                    q.append(y)\\n        if 0 in st :\\n            return False\\n        else:\\n            return True\\n        "
                    },
                    {
                        "username": "neil_paul",
                        "content": "Discussion is not for posting the solutions. Kindly head to the Solutions tab to share the code."
                    }
                ]
            }
        ]
    }
]