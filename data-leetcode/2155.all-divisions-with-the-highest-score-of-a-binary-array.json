[
    {
        "title": "All Divisions With the Highest Score of a Binary Array",
        "question_content": "You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:\n\n\tnumsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).\n\tIf i == 0, numsleft is empty, while numsright has all the elements of nums.\n\tIf i == n, numsleft has all the elements of nums, while numsright is empty.\n\nThe division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.\nReturn all distinct indices that have the highest possible division score. You may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [0,0,1,0]\nOutput: [2,4]\nExplanation: Division at index\n- 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.\n- 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.\n- 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.\n- 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.\n- 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.\nIndices 2 and 4 both have the highest possible division score 3.\nNote the answer [4,2] would also be accepted.\nExample 2:\n\nInput: nums = [0,0,0]\nOutput: [3]\nExplanation: Division at index\n- 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.\n- 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.\n- 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.\n- 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.\nOnly index 3 has the highest possible division score 3.\n\nExample 3:\n\nInput: nums = [1,1]\nOutput: [0]\nExplanation: Division at index\n- 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.\n- 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.\n- 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.\nOnly index 0 has the highest possible division score 2.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 105\n\tnums[i] is either 0 or 1.",
        "solutions": [
            {
                "id": 1730364,
                "title": "easy-c-keep-track-of-rightone-leftzero-o-n",
                "content": "Initially,\\n``RightOne = Total \\'1\\' present in the Array``\\n``LeftZero = 0 (since we are at the left most corner of array)``\\n\\nNow, Keep Traversing and update RightOne and LeftZero on the go.\\n\\nTime: O(N)\\nSpace:O(N)\\n```\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n        int rightOne=accumulate(begin(nums),end(nums),0),leftZero=0,maxScore=0;\\n        vector<int>res;\\n        for(int i=0;i<=nums.size();i++){\\n            \\n            if(rightOne+leftZero > maxScore){\\n                maxScore=rightOne+leftZero;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            \\n            else if(rightOne+leftZero == maxScore) res.push_back(i);\\n            \\n            if(i!=nums.size()){\\n                if(nums[i]==0)leftZero++;\\n                if(nums[i]==1)rightOne--;\\n            }\\n        }\\n        return res;\\n    }\\n```\\nPlease upvote, if find helpful! suggestions are welcomed :)\\nFind me on https://coderaky.com\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n        int rightOne=accumulate(begin(nums),end(nums),0),leftZero=0,maxScore=0;\\n        vector<int>res;\\n        for(int i=0;i<=nums.size();i++){\\n            \\n            if(rightOne+leftZero > maxScore){\\n                maxScore=rightOne+leftZero;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            \\n            else if(rightOne+leftZero == maxScore) res.push_back(i);\\n            \\n            if(i!=nums.size()){\\n                if(nums[i]==0)leftZero++;\\n                if(nums[i]==1)rightOne--;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730197,
                "title": "count-ones",
                "content": "#### Simplified Solution\\nCompared to the original solution, we can use one variable `score`, instead of two (`ones` and `zeros`).\\n\\nAlso, if we pre-assign the initial score for the `0` index, we can avoid going `i < nums.size()` check.\\n\\n**C++**\\n```cpp\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n    int score = accumulate(begin(nums), end(nums), 0), max_score = score;\\n    vector<int> res{0};\\n    for (int i = 0; i < nums.size(); ++i) {\\n        score += (nums[i] == 0) - nums[i];\\n        if (score > max_score) {\\n            max_score = score;\\n            res.clear();\\n        }\\n        if (score == max_score)\\n            res.push_back(i + 1);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Original Solution\\nJust for the refence.\\n**C++**\\n```cpp\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n    int ones = accumulate(begin(nums), end(nums), 0), zeros = 0, score = 0;\\n    vector<int> res;\\n    for (int i = 0; i <= nums.size(); ++i) {\\n        if (ones + zeros > score) {\\n            score = ones + zeros;\\n            res.clear();\\n        }\\n        if (ones + zeros == score)\\n            res.push_back(i);\\n        if (i < nums.size()) {\\n            zeros += nums[i] == 0;\\n            ones -= nums[i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n    int score = accumulate(begin(nums), end(nums), 0), max_score = score;\\n    vector<int> res{0};\\n    for (int i = 0; i < nums.size(); ++i) {\\n        score += (nums[i] == 0) - nums[i];\\n        if (score > max_score) {\\n            max_score = score;\\n            res.clear();\\n        }\\n        if (score == max_score)\\n            res.push_back(i + 1);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> maxScoreIndices(vector<int>& nums) {\\n    int ones = accumulate(begin(nums), end(nums), 0), zeros = 0, score = 0;\\n    vector<int> res;\\n    for (int i = 0; i <= nums.size(); ++i) {\\n        if (ones + zeros > score) {\\n            score = ones + zeros;\\n            res.clear();\\n        }\\n        if (ones + zeros == score)\\n            res.push_back(i);\\n        if (i < nums.size()) {\\n            zeros += nums[i] == 0;\\n            ones -= nums[i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730123,
                "title": "java-o-n-time-prefix-sum-easy-to-understand",
                "content": "Intuition: The idea used in both approaches is to keep track of the **total** number of **ones in the array** and the number of **ones (or zeros)** encountered **till** `i`**th index**.\\nUsing this we calculate number zeros on the left division and number of ones on the right division.\\n\\n\\n**Approach 1: Prefix Array**\\n\\nUsing a prefix array we keep count of number of ones appeared till each index.\\n```\\n\\t\\tint[] pref = new int[N + 1];\\n        pref[0] = 0; // at zeroth division we have no elements\\n        for(int i = 0; i < N; ++i) pref[i+1] = nums[i] + pref[i];\\n```\\n\\nThen `zeroesToLeft` = `i - pref[i];` // (number of elements - number of ones) till `i`\\nand `onesToRight` = `pref[N] - pref[i]` // (total number of ones - ones till index `i` )\\n\\nScore for each index `currScore` = `zeroesToLeft + onesToRight`\\nIf the currScore is greater than maxScore, we clear the result list and set `maxScore` to `currScore`.\\nIf the `currScore` is equal to the `maxscore`, we add the index to result list.\\n\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int N = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        int[] pref = new int[N + 1];\\n        pref[0] = 0; // at zeroth division we have no elements\\n        for(int i = 0; i < N; ++i) pref[i+1] = nums[i] + pref[i];\\n        \\n        int maxScore = -1;\\n        int onesToRight, zeroesToLeft, currScore;\\n\\t\\t\\n        for(int i = 0; i < N + 1; ++i) {\\n            onesToRight = pref[N] - pref[i];\\n            zeroesToLeft = i - pref[i];\\n            currScore = zeroesToLeft + onesToRight;\\n\\t\\n            if(currScore > maxScore) {\\n                res.clear();\\n                maxScore = currScore;\\n            }\\n            if(currScore == maxScore) res.add(i);                        \\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nTime Complexity: **O(N)**\\nSpace Complexity: **O(N)**\\n\\n**Approach 2 Running Sum _(Space Optimised)_** (Credits: [jay3047\\'s](https://leetcode.com/jay3047/) **[Solution](https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/discuss/1730365/java-on-time-complexity-2-loops-minimum-space)**, do upvote it, if this approach helped you :D)\\n\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int oneCount=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i]==1){\\n                oneCount++;\\n            }\\n        }\\n\\n        int maxDivisor = oneCount;\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        int runningCount = oneCount;//1\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                runningCount++;\\n            } else if (nums[i] == 1) {\\n                runningCount--;\\n            }\\n            if (runningCount >= maxDivisor) {\\n                if(runningCount != maxDivisor) {\\n                    result.clear();\\n                    maxDivisor = runningCount;\\n                }\\n                result.add(i+1);\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\nTime Complexity: **O(N)**\\nSpace Complexity: **O(1)**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t\\tint[] pref = new int[N + 1];\\n        pref[0] = 0; // at zeroth division we have no elements\\n        for(int i = 0; i < N; ++i) pref[i+1] = nums[i] + pref[i];\\n```\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int N = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        int[] pref = new int[N + 1];\\n        pref[0] = 0; // at zeroth division we have no elements\\n        for(int i = 0; i < N; ++i) pref[i+1] = nums[i] + pref[i];\\n        \\n        int maxScore = -1;\\n        int onesToRight, zeroesToLeft, currScore;\\n\\t\\t\\n        for(int i = 0; i < N + 1; ++i) {\\n            onesToRight = pref[N] - pref[i];\\n            zeroesToLeft = i - pref[i];\\n            currScore = zeroesToLeft + onesToRight;\\n\\t\\n            if(currScore > maxScore) {\\n                res.clear();\\n                maxScore = currScore;\\n            }\\n            if(currScore == maxScore) res.add(i);                        \\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int oneCount=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i]==1){\\n                oneCount++;\\n            }\\n        }\\n\\n        int maxDivisor = oneCount;\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        int runningCount = oneCount;//1\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                runningCount++;\\n            } else if (nums[i] == 1) {\\n                runningCount--;\\n            }\\n            if (runningCount >= maxDivisor) {\\n                if(runningCount != maxDivisor) {\\n                    result.clear();\\n                    maxDivisor = runningCount;\\n                }\\n                result.add(i+1);\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730274,
                "title": "c-o-n-easy-understanding",
                "content": "**[0,0,1,0]**\\n*count zeros from left to right*\\nzeros=**[0,1,2,2,3]**\\n*count ones form right to left*\\nones=**[1,1,1,0,0]**\\ntotal=**[1,2,3,2,3]**\\n\\n3 appears at **[2,4]**\\n\\n```\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> zeros(n+1,0);\\n        vector<int> ones(n+1,0);\\n        vector<int> total(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)zeros[i+1]=zeros[i]+1;\\n            else zeros[i+1]=zeros[i];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)ones[i]=ones[i+1]+1;\\n            else ones[i]=ones[i+1];\\n        }\\n        \\n        int max=0;\\n        for(int i=0;i<n+1;i++){\\n            total[i]=ones[i]+zeros[i];\\n            if(total[i]>max)max=total[i];\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<n+1;i++){\\n            if(total[i]==max)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> zeros(n+1,0);\\n        vector<int> ones(n+1,0);\\n        vector<int> total(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)zeros[i+1]=zeros[i]+1;\\n            else zeros[i+1]=zeros[i];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)ones[i]=ones[i+1]+1;\\n            else ones[i]=ones[i+1];\\n        }\\n        \\n        int max=0;\\n        for(int i=0;i<n+1;i++){\\n            total[i]=ones[i]+zeros[i];\\n            if(total[i]>max)max=total[i];\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<n+1;i++){\\n            if(total[i]==max)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730440,
                "title": "c-o-n-prefix-suffix-sum-count-0-s-and-1-s",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach 1:**\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxScoreIndices(vector<int> &a) {\\n        int n=a.size();\\n        \\n        vector<int> left(n+1,0), right(n+1,0);\\n        \\n        for(int i=1;i<n+1;i++) left[i]=left[i-1]+(a[i-1]==0);\\n        for(int i=n-1;i>=0;i--) right[i]=right[i+1]+(a[i]==1);\\n        \\n        int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<=n;i++){\\n            int s=left[i]+right[i]; \\n            if(s>maxs){\\n                maxs=s;\\n                ans={i};\\n            }else if(s==maxs){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxScoreIndices(vector<int> &a) {\\n        int n=a.size();\\n        \\n        int one=accumulate(a.begin(),a.end(),0), zero=0;\\n        \\n        int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<=n;i++){\\n            int s=one+zero;\\n            if(s>maxs){\\n                maxs=s;\\n                ans={i};\\n            }else if(s==maxs){\\n                ans.push_back(i);\\n            }\\n            if(i<n){\\n                one -= (a[i]==1);\\n                zero += (a[i]==0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxScoreIndices(vector<int> &a) {\\n        int n=a.size();\\n        \\n        vector<int> left(n+1,0), right(n+1,0);\\n        \\n        for(int i=1;i<n+1;i++) left[i]=left[i-1]+(a[i-1]==0);\\n        for(int i=n-1;i>=0;i--) right[i]=right[i+1]+(a[i]==1);\\n        \\n        int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<=n;i++){\\n            int s=left[i]+right[i]; \\n            if(s>maxs){\\n                maxs=s;\\n                ans={i};\\n            }else if(s==maxs){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxScoreIndices(vector<int> &a) {\\n        int n=a.size();\\n        \\n        int one=accumulate(a.begin(),a.end(),0), zero=0;\\n        \\n        int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<=n;i++){\\n            int s=one+zero;\\n            if(s>maxs){\\n                maxs=s;\\n                ans={i};\\n            }else if(s==maxs){\\n                ans.push_back(i);\\n            }\\n            if(i<n){\\n                one -= (a[i]==1);\\n                zero += (a[i]==0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730105,
                "title": "keep-count-of-1-s-and-0-s",
                "content": "**Please upvote if you find this helpful**\\n\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int oneCount = 0, zeroCount = 0;\\n        \\n        for(int num : nums)\\n            if(num == 1) ++oneCount;\\n        \\n        res.add(0);\\n        int max = oneCount;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(nums[i] == 1){\\n                --oneCount;\\n            }\\n            else if(nums[i] == 0){\\n                ++zeroCount;\\n            }\\n            int total = oneCount + zeroCount;\\n            if(max < total){\\n                res.clear();\\n                res.add(i+1);\\n                max = total;\\n            }\\n            else if(max == total){\\n                res.add(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int oneCount = 0, zeroCount = 0;\\n        \\n        for(int num : nums)\\n            if(num == 1) ++oneCount;\\n        \\n        res.add(0);\\n        int max = oneCount;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(nums[i] == 1){\\n                --oneCount;\\n            }\\n            else if(nums[i] == 0){\\n                ++zeroCount;\\n            }\\n            int total = oneCount + zeroCount;\\n            if(max < total){\\n                res.clear();\\n                res.add(i+1);\\n                max = total;\\n            }\\n            else if(max == total){\\n                res.add(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730402,
                "title": "o-n-python-solution-with-a-linear-search",
                "content": "In this solution, I iterate through the list and add 1 to the left_div_score everytime I encounter a 0 and substract 1 from the right_div_score when a 1 is encountered. \\nWe then find the indexes where left_div_score+right_div_score is max\\n\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        left_div_score = 0\\n        right_div_score = sum(nums)\\n        \\n        div_sum = [left_div_score+right_div_score]\\n        \\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                left_div_score+=1\\n            if nums[i]==1:\\n                right_div_score-=1\\n            div_sum.append(left_div_score+right_div_score)\\n                \\n        max_val = max(div_sum)\\n        \\n        return( [i for i, v in enumerate(div_sum) if v==max_val])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        left_div_score = 0\\n        right_div_score = sum(nums)\\n        \\n        div_sum = [left_div_score+right_div_score]\\n        \\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                left_div_score+=1\\n            if nums[i]==1:\\n                right_div_score-=1\\n            div_sum.append(left_div_score+right_div_score)\\n                \\n        max_val = max(div_sum)\\n        \\n        return( [i for i, v in enumerate(div_sum) if v==max_val])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738308,
                "title": "c-simple-prefix-sum-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> left(n+1),right(n+1);\\n        left[0]=0;\\n        right[n]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            if(nums[i-1]==0)\\n                left[i]=left[i-1]+1;\\n            else \\n                left[i]=left[i-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)\\n                right[i]=right[i+1]+1;\\n            else \\n                right[i]=right[i+1];\\n        }\\n        \\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<n+1;i++){\\n            mp[left[i]+right[i]].push_back(i);\\n        }\\n        \\n           return mp.rbegin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> left(n+1),right(n+1);\\n        left[0]=0;\\n        right[n]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            if(nums[i-1]==0)\\n                left[i]=left[i-1]+1;\\n            else \\n                left[i]=left[i-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)\\n                right[i]=right[i+1]+1;\\n            else \\n                right[i]=right[i+1];\\n        }\\n        \\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<n+1;i++){\\n            mp[left[i]+right[i]].push_back(i);\\n        }\\n        \\n           return mp.rbegin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730631,
                "title": "c-easiest-solution-65-fast-solution-prefix-sum",
                "content": "**PREFIX SUM**\\n\\n* As the question demands we have to find the score based on some conditions;\\n* The conditon is\\n\\t* Count of zeroes on left and ones on right for every index i.e score[i] =c{.....0...0...} before i  + {...1....1...} after i and upto N;\\n\\t* But the ans vector should consist of only those indexes for which this score is maximum;\\n* The simple logic is to calculate the right ones by pos_ones_right[i] = pos_ones_right[i+1]+(a[i]==1);\\n* And  pre_zeroes_left[i] =  pre_zeroes_left[i-1]+(a[i]==0);\\n* While traversing we take the max_score 0 and if while traversal pre_zeroes_left[i]+ pos_ones_right[i] >max_score we will just clear the ans vector and push i;\\n* else if same score found we will push that index too;\\n\\n```\\n\\t\\tint N=a.size();\\n        vector<int> r(N+1),l(N+1);\\n        for(int i=1;i<N+1;i++) l[i]=l[i-1]+(a[i-1]==0);\\n        for(int i=N-1;i>=0;i--) r[i]=r[i+1]+(a[i]==1);\\n        \\n         int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<N+1;i++){\\n            int val=r[i]+l[i];\\n            if(val>maxs){\\n                maxs=val;\\n                ans={i};\\n            }\\n            else if(val==maxs) ans.push_back(i);\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\t\\tint N=a.size();\\n        vector<int> r(N+1),l(N+1);\\n        for(int i=1;i<N+1;i++) l[i]=l[i-1]+(a[i-1]==0);\\n        for(int i=N-1;i>=0;i--) r[i]=r[i+1]+(a[i]==1);\\n        \\n         int maxs=0;\\n        vector<int> ans;\\n        for(int i=0;i<N+1;i++){\\n            int val=r[i]+l[i];\\n            if(val>maxs){\\n                maxs=val;\\n                ans={i};\\n            }\\n            else if(val==maxs) ans.push_back(i);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730365,
                "title": "16ms-java-o-n-without-prefix-space-efficient",
                "content": "initialize  running count with total number of one and then iterate over the array if current is 0 then increment  running count as total divisor if it\\'s 1 then decrement \\n\\n    public List<Integer> maxScoreIndices2(int[] nums) {\\n\\n        int oneCount=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i]==1){\\n                oneCount++;\\n            }\\n        }\\n\\n        int maxDivisor = oneCount;\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        int runningCount = oneCount;//1\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                runningCount++;\\n                if (runningCount >= maxDivisor) {\\n                    if(runningCount != maxDivisor) {\\n                        result.clear();\\n                        maxDivisor = runningCount;\\n                    }\\n                    result.add(i+1);\\n                }\\n            } else if (nums[i] == 1) {\\n                runningCount--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "initialize  running count with total number of one and then iterate over the array if current is 0 then increment  running count as total divisor if it\\'s 1 then decrement \\n\\n    public List<Integer> maxScoreIndices2(int[] nums) {\\n\\n        int oneCount=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i]==1){\\n                oneCount++;\\n            }\\n        }\\n\\n        int maxDivisor = oneCount;\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        int runningCount = oneCount;//1\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                runningCount++;\\n                if (runningCount >= maxDivisor) {\\n                    if(runningCount != maxDivisor) {\\n                        result.clear();\\n                        maxDivisor = runningCount;\\n                    }\\n                    result.add(i+1);\\n                }\\n            } else if (nums[i] == 1) {\\n                runningCount--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1730232,
                "title": "python-3-linear-time-solution",
                "content": "\\n# Python 3 \\u2714\\u2714 Linear Time Solution\\n\\n## Main Idea\\nStep 1.  Expand from **left to right** to calculate **0**s\\nStep 2.  Expand from **right to left** to calculate **1**s\\nStep 3.  Calculate Sum of zeroFromLeft and oneFromRight and return where maximum value\\'s index\\n## Complexity Analysis\\n* Time: O(n) : Let *n* be nums\\'s length\\n* Space: O(n): Store zeroFromLeft and oneFromRight take O(n)\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        zeroFromLeft = [0] * (len(nums) + 1)\\n        oneFromRight = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\\n            else:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\\n                \\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 1:\\n                oneFromRight[i] = oneFromRight[i + 1] + 1\\n            else:\\n                oneFromRight[i] = oneFromRight[i + 1]\\n        \\n        allSum = [0] * (len(nums) + 1)\\n        currentMax = 0\\n        res = []\\n        for i in range(len(nums) + 1):\\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\\n            if allSum[i] > currentMax:\\n                res = []\\n                currentMax = allSum[i]\\n            if allSum[i] == currentMax:\\n                res.append(i)\\n        return res\\n            \\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        zeroFromLeft = [0] * (len(nums) + 1)\\n        oneFromRight = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\\n            else:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\\n                \\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 1:\\n                oneFromRight[i] = oneFromRight[i + 1] + 1\\n            else:\\n                oneFromRight[i] = oneFromRight[i + 1]\\n        \\n        allSum = [0] * (len(nums) + 1)\\n        currentMax = 0\\n        res = []\\n        for i in range(len(nums) + 1):\\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\\n            if allSum[i] > currentMax:\\n                res = []\\n                currentMax = allSum[i]\\n            if allSum[i] == currentMax:\\n                res.append(i)\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731240,
                "title": "javascript-o-n-easy-understanding-with-example",
                "content": "3 Step \\uD83E\\uDE9C process\\nnums = [0,0,1,0]                      index  0,1,2,3,4\\nleft array [] => [0,1,2,2,3] ; count the zeros from left to right\\nright array[]=>  [1,1,1,0,0]; count the ones from right to left\\ntotal array []=> SUM  (0+1),(1+1),(2+1),(2+0),(3+0) => [1,2,3,2,3]\\nAll done \\u2705 just find max element index !\\n(Please upvote if you love this explanation)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(nums) {\\n        let n=nums.length;\\n        // initialize 3 arrays for counting with n+1 size\\n        let zeros = new Array(n+1).fill(0);\\n        let ones = new Array(n+1).fill(0);\\n        let total = new Array(n+1).fill(0);\\n        \\n       // count no of zeros from left to right\\n        for(let i=0;i<n;i++){\\n            if(nums[i]==0)zeros[i+1]=zeros[i]+1;\\n            else zeros[i+1]=zeros[i];\\n        }\\n\\n        \\n        // count no of ones from right to left\\n        for(let i=n-1;i>=0;i--){\\n            if(nums[i]==1)ones[i]=ones[i+1]+1;\\n            else ones[i]=ones[i+1];\\n        }\\n\\n        \\n        // merge left and right to total and find max element\\n        let max=0;\\n        for(let i=0;i<n+1;i++){\\n            total[i]=ones[i]+zeros[i];\\n            if(total[i]>max)max=total[i];\\n        }\\n\\n        \\n        // Find occurrence of max elements and return those indexes\\n        let ans= [];\\n        for(let i=0;i<n+1;i++){\\n            if(total[i]==max)ans.push(i);\\n        }\\n\\n        return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(nums) {\\n        let n=nums.length;\\n        // initialize 3 arrays for counting with n+1 size\\n        let zeros = new Array(n+1).fill(0);\\n        let ones = new Array(n+1).fill(0);\\n        let total = new Array(n+1).fill(0);\\n        \\n       // count no of zeros from left to right\\n        for(let i=0;i<n;i++){\\n            if(nums[i]==0)zeros[i+1]=zeros[i]+1;\\n            else zeros[i+1]=zeros[i];\\n        }\\n\\n        \\n        // count no of ones from right to left\\n        for(let i=n-1;i>=0;i--){\\n            if(nums[i]==1)ones[i]=ones[i+1]+1;\\n            else ones[i]=ones[i+1];\\n        }\\n\\n        \\n        // merge left and right to total and find max element\\n        let max=0;\\n        for(let i=0;i<n+1;i++){\\n            total[i]=ones[i]+zeros[i];\\n            if(total[i]>max)max=total[i];\\n        }\\n\\n        \\n        // Find occurrence of max elements and return those indexes\\n        let ans= [];\\n        for(let i=0;i<n+1;i++){\\n            if(total[i]==max)ans.push(i);\\n        }\\n\\n        return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730189,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nvector<int> maxScoreIndices(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        vector<int> left(n + 1);\\n        \\n        vector<int> right(n + 1);\\n        \\n        left[0] = 0;\\n        \\n        right[n] = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(arr[i - 1] == 0)\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n            else\\n            {\\n                left[i] = left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                right[i] = 1 + right[i + 1];\\n            }\\n            else\\n            {\\n                right[i] = right[i + 1];\\n            }\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            maxi = max(maxi, left[i] + right[i]);\\n        }\\n        \\n        vector<int> res;\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            if(left[i] + right[i] == maxi)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nvector<int> maxScoreIndices(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        vector<int> left(n + 1);\\n        \\n        vector<int> right(n + 1);\\n        \\n        left[0] = 0;\\n        \\n        right[n] = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(arr[i - 1] == 0)\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n            else\\n            {\\n                left[i] = left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                right[i] = 1 + right[i + 1];\\n            }\\n            else\\n            {\\n                right[i] = right[i + 1];\\n            }\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            maxi = max(maxi, left[i] + right[i]);\\n        }\\n        \\n        vector<int> res;\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            if(left[i] + right[i] == maxi)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735506,
                "title": "python3-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        j=0 \\n        ones=nums.count(1)\\n        zeros=0\\n        ma=ones\\n        ans=[0]        \\n        while j<len(nums):\\n            if nums[j]==0:\\n                zeros+=1          \\n            elif nums[j]==1:\\n                ones-=1 \\n            j+=1\\n            temp=ones+zeros\\n            if ma==temp:\\n                ans.append(j)   \\n            elif ma<temp:\\n                ans=[]\\n                ma=temp\\n                ans.append(j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        j=0 \\n        ones=nums.count(1)\\n        zeros=0\\n        ma=ones\\n        ans=[0]        \\n        while j<len(nums):\\n            if nums[j]==0:\\n                zeros+=1          \\n            elif nums[j]==1:\\n                ones-=1 \\n            j+=1\\n            temp=ones+zeros\\n            if ma==temp:\\n                ans.append(j)   \\n            elif ma<temp:\\n                ans=[]\\n                ma=temp\\n                ans.append(j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731036,
                "title": "c-prefix-suffix-sum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& a) \\n    {\\n        int i,n=a.size();\\n        vector <int> pre(n),suff(n);\\n        \\n        pre[0]=(a[0]==0);\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==0)\\n                pre[i]=pre[i-1]+1;\\n            else\\n                pre[i]=pre[i-1];\\n        }\\n        \\n        suff[n-1]=(a[n-1]==1);\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(a[i]==1)\\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=suff[i+1];\\n        }\\n        \\n        vector <int> ans(n+1);\\n        ans[0]=suff[0];\\n        for(i=1;i<n;i++)\\n            ans[i]=pre[i-1]+suff[i];\\n        ans[n]=pre[n-1];\\n        \\n        vector <int> answer;\\n        int mx=-1;\\n        for(i=0;i<=n;i++)\\n            mx=max(ans[i],mx);\\n        \\n        for(i=0;i<=n;i++)\\n        {\\n            if(ans[i]==mx)\\n                answer.push_back(i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& a) \\n    {\\n        int i,n=a.size();\\n        vector <int> pre(n),suff(n);\\n        \\n        pre[0]=(a[0]==0);\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==0)\\n                pre[i]=pre[i-1]+1;\\n            else\\n                pre[i]=pre[i-1];\\n        }\\n        \\n        suff[n-1]=(a[n-1]==1);\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(a[i]==1)\\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=suff[i+1];\\n        }\\n        \\n        vector <int> ans(n+1);\\n        ans[0]=suff[0];\\n        for(i=1;i<n;i++)\\n            ans[i]=pre[i-1]+suff[i];\\n        ans[n]=pre[n-1];\\n        \\n        vector <int> answer;\\n        int mx=-1;\\n        for(i=0;i<=n;i++)\\n            mx=max(ans[i],mx);\\n        \\n        for(i=0;i<=n;i++)\\n        {\\n            if(ans[i]==mx)\\n                answer.push_back(i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730279,
                "title": "simple-prefix-and-postfix-approach-c-solution-time-complexity-o-n",
                "content": "Time Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\tApproach -\\n\\tstep 1 :- store count of one\\'s from last index till current index in a vector.\\n\\tstep 2 :- store count of zero\\'s from first till current index in a vector.\\n\\tstep 3 :- store count of zero\\'s till (current -1) index and count of one\\'s from last till current index and store in a vector.\\n\\tstep 4 :- count total maximum elements.\\n\\t\\n\\tvector<int> maxScoreIndices(vector<int>& nums) \\n    {       \\n        int n= nums.size();\\n        vector<int> pre(n+1), post(n+1);\\n        \\n        post[n]=0;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(nums[i]) post[i] = post[i+1]+1;\\n            else post[i] = post[i+1];\\n        }\\n\\n        \\n        vector<int> ans;\\n        if(!nums[0]) pre[0]=1;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(!nums[i]) pre[i]=pre[i-1]+1;\\n            else pre[i]=pre[i-1];\\n        }\\n        \\n        for(int i=0; i<=n; i++)\\n        {\\n            if(i==0)\\n            ans.push_back(post[i]);\\n            else if(i==n)\\n            {\\n                ans.push_back(pre[i-1]);\\n            }\\n            else\\n            {\\n                ans.push_back(pre[i-1]+post[i]);\\n            }\\n        }\\n    \\n        int mx = *max_element(ans.begin(), ans.end());\\n        \\n        vector<int> v;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(ans[i]==mx)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }",
                "solutionTags": [],
                "code": "Time Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\tApproach -\\n\\tstep 1 :- store count of one\\'s from last index till current index in a vector.\\n\\tstep 2 :- store count of zero\\'s from first till current index in a vector.\\n\\tstep 3 :- store count of zero\\'s till (current -1) index and count of one\\'s from last till current index and store in a vector.\\n\\tstep 4 :- count total maximum elements.\\n\\t\\n\\tvector<int> maxScoreIndices(vector<int>& nums) \\n    {       \\n        int n= nums.size();\\n        vector<int> pre(n+1), post(n+1);\\n        \\n        post[n]=0;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(nums[i]) post[i] = post[i+1]+1;\\n            else post[i] = post[i+1];\\n        }\\n\\n        \\n        vector<int> ans;\\n        if(!nums[0]) pre[0]=1;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(!nums[i]) pre[i]=pre[i-1]+1;\\n            else pre[i]=pre[i-1];\\n        }\\n        \\n        for(int i=0; i<=n; i++)\\n        {\\n            if(i==0)\\n            ans.push_back(post[i]);\\n            else if(i==n)\\n            {\\n                ans.push_back(pre[i-1]);\\n            }\\n            else\\n            {\\n                ans.push_back(pre[i-1]+post[i]);\\n            }\\n        }\\n    \\n        int mx = *max_element(ans.begin(), ans.end());\\n        \\n        vector<int> v;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(ans[i]==mx)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3789404,
                "title": "python-3-prefix-sum-hash-table-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        cnt_1 = 0\\n        for num in nums:\\n            if num == 1: cnt_1 += 1\\n        \\n        cnt_0, max_division = 0, cnt_1\\n        d = collections.defaultdict(list)\\n        d[cnt_1].append(0)\\n        for i, num in enumerate(nums):\\n            cnt_0 += int(num == 0)\\n            cnt_1 -= int(num == 1)\\n            d[cnt_0 + cnt_1].append(i + 1)\\n            max_division = max(max_division, cnt_0 + cnt_1)\\n        return d[max_division]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        cnt_1 = 0\\n        for num in nums:\\n            if num == 1: cnt_1 += 1\\n        \\n        cnt_0, max_division = 0, cnt_1\\n        d = collections.defaultdict(list)\\n        d[cnt_1].append(0)\\n        for i, num in enumerate(nums):\\n            cnt_0 += int(num == 0)\\n            cnt_1 -= int(num == 1)\\n            d[cnt_0 + cnt_1].append(i + 1)\\n            max_division = max(max_division, cnt_0 + cnt_1)\\n        return d[max_division]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999819,
                "title": "python-easy-o-n-solution-prefix-sum",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        l,r=0,sum(nums)\\n        n=len(nums)\\n        ans=[0]\\n        m=r\\n        for i in range(n):\\n            if nums[i]==0:\\n                l+=1\\n            else:\\n                r-=1\\n            s=l+r\\n            if s==m:\\n                ans.append(i+1)\\n            elif s>m:\\n                ans=[]\\n                ans.append(i+1)\\n                m=s\\n        return ans                 \\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        l,r=0,sum(nums)\\n        n=len(nums)\\n        ans=[0]\\n        m=r\\n        for i in range(n):\\n            if nums[i]==0:\\n                l+=1\\n            else:\\n                r-=1\\n            s=l+r\\n            if s==m:\\n                ans.append(i+1)\\n            elif s>m:\\n                ans=[]\\n                ans.append(i+1)\\n                m=s\\n        return ans                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897610,
                "title": "prefix-and-suffix-arrays-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing prefix, suffix arrays and storing running count of 0\\'s and 1\\'s\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing  prefix,suffix arrays by storing running count of 1\\'s and 0\\'s\\nand then using a hashmap to map each index with its division score.\\nThen finding the maximum divisionScore and returning those indices which are having max divisionScore.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n3 passes whole array\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(3n) for 2 Lists and 1 HashMap\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        l1=[]\\n        l2=[0]*len(nums)\\n        for i in range(len(nums)):\\n            if i==0:\\n                if nums[i]==0:\\n                    l1.append((1,0))\\n                else:\\n                    l1.append((0,1))\\n            else:\\n                if nums[i]==0:\\n                    l1.append((l1[-1][0]+1,l1[-1][1]))\\n                else:\\n                    l1.append((l1[-1][0],l1[-1][1]+1))\\n        for i in range(len(nums)-1,-1,-1):\\n            if i==len(nums)-1:\\n                if nums[i]==0:\\n                    l2[i]=(1,0)\\n                else:\\n                    l2[i]=(0,1)\\n            else:\\n                if nums[i]==0:\\n                    l2[i]=(l2[i+1][0]+1,l2[i+1][1])\\n                else:\\n                    l2[i]=(l2[i+1][0],l2[i+1][1]+1)\\n        d={}\\n        for i in range(len(nums)):\\n            if i==0:\\n                d[i]=l2[i][1]\\n            elif i==len(nums)-1:\\n                d[i]=l1[i-1][0]+l2[i][1]\\n            else:\\n                d[i]=l1[i-1][0]+l2[i][1]\\n        d[len(nums)]=l1[len(nums)-1][0]\\n        k=max(d.values())\\n        ans=[]\\n        for i in d:\\n            if d[i]==k:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        l1=[]\\n        l2=[0]*len(nums)\\n        for i in range(len(nums)):\\n            if i==0:\\n                if nums[i]==0:\\n                    l1.append((1,0))\\n                else:\\n                    l1.append((0,1))\\n            else:\\n                if nums[i]==0:\\n                    l1.append((l1[-1][0]+1,l1[-1][1]))\\n                else:\\n                    l1.append((l1[-1][0],l1[-1][1]+1))\\n        for i in range(len(nums)-1,-1,-1):\\n            if i==len(nums)-1:\\n                if nums[i]==0:\\n                    l2[i]=(1,0)\\n                else:\\n                    l2[i]=(0,1)\\n            else:\\n                if nums[i]==0:\\n                    l2[i]=(l2[i+1][0]+1,l2[i+1][1])\\n                else:\\n                    l2[i]=(l2[i+1][0],l2[i+1][1]+1)\\n        d={}\\n        for i in range(len(nums)):\\n            if i==0:\\n                d[i]=l2[i][1]\\n            elif i==len(nums)-1:\\n                d[i]=l1[i-1][0]+l2[i][1]\\n            else:\\n                d[i]=l1[i-1][0]+l2[i][1]\\n        d[len(nums)]=l1[len(nums)-1][0]\\n        k=max(d.values())\\n        ans=[]\\n        for i in d:\\n            if d[i]==k:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147180,
                "title": "python-3-dp-easy-to-understand",
                "content": "class Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dp={}\\n        dp[-1]=0\\n        l=[0]\\n        for i in nums:\\n            if i==1:\\n                dp[-1]+=1\\n        x=dp[-1]\\n        for i in range(0,len(nums)):\\n            if nums[i]==0:\\n                dp[i]=dp[i-1]+1\\n            else:\\n                dp[i]=dp[i-1]-1\\n            if x < dp[i]:\\n                x=dp[i]\\n                l=[i+1]\\n            elif x > dp[i]:\\n                continue\\n            else:\\n                l.append(i+1)\\n        return l",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dp={}",
                "codeTag": "Java"
            },
            {
                "id": 1741845,
                "title": "java-solution-time-complexity-o-n",
                "content": "Used a simple approach to check at every iteration about the element and decreament or increment left and right pointers accordingly.\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ones = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            ones += nums[i];\\n        }\\n        int zeroes = nums.length - ones;\\n        int mx = ones;\\n        int i = 1;\\n        int left = 0, right = ones;\\n        while(i<=nums.length)\\n        {\\n            if(nums[i-1] == 0)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            \\n            mx = Math.max(left+right,mx);\\n            i++;\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();\\n        i = 0;\\n        left = 0;\\n        right = ones;\\n        \\n        while(i<nums.length)\\n        {\\n            if(left + right == mx)\\n            {\\n                ans.add(i);\\n                if(nums[i] == 0)\\n                {\\n                    left++;\\n                }\\n                else\\n                {\\n                    right--;\\n                }\\n                \\n                i++;\\n            }\\n            else\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    left++;\\n                }\\n                else\\n                {\\n                    right--;\\n                }\\n                \\n                i++;\\n            }\\n        }\\n        \\n        if(left + right == mx)\\n        {\\n            ans.add(nums.length);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Time Complexity : O(n)**\\n**Space Complexity: O(n)**\\n\\n**Please upvote if you like the solution.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ones = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            ones += nums[i];\\n        }\\n        int zeroes = nums.length - ones;\\n        int mx = ones;\\n        int i = 1;\\n        int left = 0, right = ones;\\n        while(i<=nums.length)\\n        {\\n            if(nums[i-1] == 0)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            \\n            mx = Math.max(left+right,mx);\\n            i++;\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();\\n        i = 0;\\n        left = 0;\\n        right = ones;\\n        \\n        while(i<nums.length)\\n        {\\n            if(left + right == mx)\\n            {\\n                ans.add(i);\\n                if(nums[i] == 0)\\n                {\\n                    left++;\\n                }\\n                else\\n                {\\n                    right--;\\n                }\\n                \\n                i++;\\n            }\\n            else\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    left++;\\n                }\\n                else\\n                {\\n                    right--;\\n                }\\n                \\n                i++;\\n            }\\n        }\\n        \\n        if(left + right == mx)\\n        {\\n            ans.add(nums.length);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732887,
                "title": "python3-scan",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/badfbf601ede2f43ba191b567d6f5c7e0d046286) for solutions of weekly 278. \\n\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        cand = most = nums.count(1)\\n        for i, x in enumerate(nums): \\n            if x == 0: cand += 1\\n            elif x == 1: cand -= 1\\n            if cand > most: ans, most = [i+1], cand\\n            elif cand == most: ans.append(i+1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        cand = most = nums.count(1)\\n        for i, x in enumerate(nums): \\n            if x == 0: cand += 1\\n            elif x == 1: cand -= 1\\n            if cand > most: ans, most = [i+1], cand\\n            elif cand == most: ans.append(i+1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732300,
                "title": "python-3-solutions",
                "content": "# Approach 1:\\nCounted the zeros from left(NumsLeft) and ones from the right(NumsRight).\\nFound the total sum for each index i and if it is the maximum sum, appended the index in a list.\\n# Solution 1:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\t\\tn=len(nums)\\n\\t\\tzero=[0]*(n+1)\\n\\t\\tone=[0]*(n+1)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tzero[i+1]=zero[i]+(nums[i]==0)\\n\\t\\tfor i in range(n-1,-1,-1):\\n\\t\\t\\tone[i]=one[i+1]+(nums[i]==1)\\n\\t\\ttotal = [0]*(n+1)\\n\\t\\tm=0\\n\\t\\tres=[]\\n\\t\\tfor i in range(n+1):\\n\\t\\t\\ttotal[i]=zero[i]+one[i]\\n\\t\\t\\tif total[i]>m:\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tm=total[i]\\n\\t\\t\\tif total[i]==m:\\n\\t\\t\\t\\tres+=[i]\\n\\t\\treturn res\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n# Approach 2:\\nAnother approach was to use PREFIX sum.\\nWe use a prefix sum which calculates the total prefix sum at each index i.\\nThis combines the first two loops from previous solution into one.\\n# Solution 2:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        res=[]\\n        pref=[0]*(n+1)\\n        for i in range(n):\\n            pref[i+1]=pref[i]+nums[i]\\n        zero,total,one=0,0,0\\n        m=-1\\n        for i in range(n+1):\\n            one=pref[n]-pref[i]\\n            zero=i-pref[i]\\n            total=zero+one\\n            if total>m:\\n                m=total\\n                res=[]\\n            if total==m:\\n                res+=[i]\\n        return res\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n# Approach 3:\\nInstead of using a prefix array, we can just count the number of ones and use it to calculate prefix sum at each index i.\\nThis reduces the Space Complexity to O(1).\\n# Solution 3:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        res=[0]\\n        onecount=0\\n        for i in range(n):\\n            onecount+=(nums[i]==1)\\n        m=onecount\\n        for i in range(n):\\n            onecount+=(nums[i]==0)-(nums[i]==1)\\n            if onecount>=m:\\n                if onecount!=m:\\n                    m=onecount\\n                    res=[]\\n                res+=[i+1]\\n        return res\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\t\\tn=len(nums)\\n\\t\\tzero=[0]*(n+1)\\n\\t\\tone=[0]*(n+1)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tzero[i+1]=zero[i]+(nums[i]==0)\\n\\t\\tfor i in range(n-1,-1,-1):\\n\\t\\t\\tone[i]=one[i+1]+(nums[i]==1)\\n\\t\\ttotal = [0]*(n+1)\\n\\t\\tm=0\\n\\t\\tres=[]\\n\\t\\tfor i in range(n+1):\\n\\t\\t\\ttotal[i]=zero[i]+one[i]\\n\\t\\t\\tif total[i]>m:\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tm=total[i]\\n\\t\\t\\tif total[i]==m:\\n\\t\\t\\t\\tres+=[i]\\n\\t\\treturn res\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        res=[]\\n        pref=[0]*(n+1)\\n        for i in range(n):\\n            pref[i+1]=pref[i]+nums[i]\\n        zero,total,one=0,0,0\\n        m=-1\\n        for i in range(n+1):\\n            one=pref[n]-pref[i]\\n            zero=i-pref[i]\\n            total=zero+one\\n            if total>m:\\n                m=total\\n                res=[]\\n            if total==m:\\n                res+=[i]\\n        return res\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        res=[0]\\n        onecount=0\\n        for i in range(n):\\n            onecount+=(nums[i]==1)\\n        m=onecount\\n        for i in range(n):\\n            onecount+=(nums[i]==0)-(nums[i]==1)\\n            if onecount>=m:\\n                if onecount!=m:\\n                    m=onecount\\n                    res=[]\\n                res+=[i+1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730115,
                "title": "accepted-c-solution",
                "content": "Accepted C++ solution\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n      vector<int >v1(n+1,0);\\n          vector<int >v2(n+1,0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                v1[i+1]=v1[i]+1;\\n            }\\n            else {\\n                v1[i+1]=v1[i];\\n            }\\n        }\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                v2[i+1]=v2[i]+1;\\n            }\\n            else {\\n                v2[i+1]=v2[i];\\n            }\\n        }\\n          reverse(v2.begin(),v2.end());\\n        int maxi=0;\\n        for(int i=0;i<v1.size();i++){\\n            maxi=max(v1[i]+v2[i],maxi);\\n        }\\n        vector<int >ans;\\n         for(int i=0;i<v1.size();i++){\\n           if((v1[i]+v2[i])==maxi){\\n               ans.push_back(i);\\n           }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n      vector<int >v1(n+1,0);\\n          vector<int >v2(n+1,0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                v1[i+1]=v1[i]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1730111,
                "title": "c-prefix-sum-suffix-sum-simple-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        // prefix sum\\n        // count number of zeros and ones from left and right respectively.\\n        vector<int> zeros(size),ones(size);\\n        \\n        // zeros array\\n        // from left to right calculate because in the left array we have to see the number of zeros\\n        zeros[0] = nums[0] == 0 ? 1 : 0;\\n        for(int i=1;i<size;i++){\\n            if(nums[i] == 0){ // if current value is 0 then current number of zeros is previous number of zeros + 1\\n                zeros[i] = zeros[i-1] + 1;\\n            }else{ // if current value if 1 then number of zeros are same as previous value for the current value\\n                zeros[i] = zeros[i-1];\\n            }\\n        }\\n        \\n        // ones array\\n        // from right to left calculate because in the right array we have to see the number of ones.\\n        ones[size-1] = nums[size-1] == 1?1:0;\\n        for(int i=size-2;i>=0;i--){\\n            if(nums[i] == 1){ // if current value is 1 then current number of ones is next number of ones + 1\\n                ones[i] = ones[i+1] + 1;\\n            }else{ // if current value is 0 then current number of ones is same as next number of ones;\\n                ones[i] = ones[i+1];\\n            }\\n        }\\n        \\n        //scores for each i = 0 to n\\n        vector<int> score;\\n        \\n        // edge case of i = 0\\n        score.push_back(ones[0]);\\n        \\n        // from i = 1 to n-1\\n        for(int i=1;i<=size-1;i++){\\n            score.push_back(zeros[i-1] + ones[i]);\\n        }\\n        \\n        // edge case of i = n\\n        score.push_back(zeros[size-1]);\\n        \\n        // find the max score\\n        int maxi = *max_element(score.begin(),score.end());\\n        \\n        // inserting max indexes into ans vector\\n        vector<int> ans;\\n        for(int i=0;i<score.size();i++){\\n            if(score[i] == maxi){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote, if you like the solution.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        // prefix sum\\n        // count number of zeros and ones from left and right respectively.\\n        vector<int> zeros(size),ones(size);\\n        \\n        // zeros array\\n        // from left to right calculate because in the left array we have to see the number of zeros\\n        zeros[0] = nums[0] == 0 ? 1 : 0;\\n        for(int i=1;i<size;i++){\\n            if(nums[i] == 0){ // if current value is 0 then current number of zeros is previous number of zeros + 1\\n                zeros[i] = zeros[i-1] + 1;\\n            }else{ // if current value if 1 then number of zeros are same as previous value for the current value\\n                zeros[i] = zeros[i-1];\\n            }\\n        }\\n        \\n        // ones array\\n        // from right to left calculate because in the right array we have to see the number of ones.\\n        ones[size-1] = nums[size-1] == 1?1:0;\\n        for(int i=size-2;i>=0;i--){\\n            if(nums[i] == 1){ // if current value is 1 then current number of ones is next number of ones + 1\\n                ones[i] = ones[i+1] + 1;\\n            }else{ // if current value is 0 then current number of ones is same as next number of ones;\\n                ones[i] = ones[i+1];\\n            }\\n        }\\n        \\n        //scores for each i = 0 to n\\n        vector<int> score;\\n        \\n        // edge case of i = 0\\n        score.push_back(ones[0]);\\n        \\n        // from i = 1 to n-1\\n        for(int i=1;i<=size-1;i++){\\n            score.push_back(zeros[i-1] + ones[i]);\\n        }\\n        \\n        // edge case of i = n\\n        score.push_back(zeros[size-1]);\\n        \\n        // find the max score\\n        int maxi = *max_element(score.begin(),score.end());\\n        \\n        // inserting max indexes into ans vector\\n        vector<int> ans;\\n        for(int i=0;i<score.size();i++){\\n            if(score[i] == maxi){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730109,
                "title": "java-solution-dp-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int[] left=new int[nums.length];\\n        int right[]=new int[nums.length];\\n        for(int i=0;i<left.length;i++){\\n            if(i==0){\\n                if(nums[0]==0){\\n                    left[0]=1;\\n                }else{\\n                    left[0]=0;\\n                }\\n            }else{\\n                if(nums[i]==0){\\n                    left[i]=left[i-1]+1;\\n                }else{\\n                    left[i]=left[i-1];\\n                }\\n            }\\n        }\\n        for(int i=right.length-1;i>=0;i--){\\n            if(i==right.length-1){\\n                if(nums[i]==1){\\n                    right[i]=1;\\n                }else{\\n                    right[i]=0;\\n                }\\n            }else{\\n                if(nums[i]==1){\\n                    right[i]=right[i+1]+1;\\n                }else{\\n                    right[i]=right[i+1];\\n                }\\n            }\\n        }\\n        int maxDiv=-1;\\n        for(int i=0;i<=left.length;i++){\\n            if(i==0){\\n                if(right[i]>maxDiv) maxDiv=right[i];\\n            }else if(i==left.length){\\n                if(left[i-1]>maxDiv) maxDiv=left[i-1];\\n            }else{\\n                if(left[i-1]+right[i]>maxDiv) maxDiv=left[i-1]+right[i];\\n            }\\n        }\\n        List<Integer> al=new ArrayList<Integer>();\\n        for(int i=0;i<=left.length;i++){\\n            if(i==0){\\n                if(right[i]==maxDiv) al.add(i);\\n            }else if(i==left.length){\\n                if(left[i-1]==maxDiv) al.add(i);\\n            }else{\\n                if(left[i-1]+right[i]==maxDiv) al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int[] left=new int[nums.length];\\n        int right[]=new int[nums.length];\\n        for(int i=0;i<left.length;i++){\\n            if(i==0){\\n                if(nums[0]==0){\\n                    left[0]=1;\\n                }else{\\n                    left[0]=0;\\n                }\\n            }else{\\n                if(nums[i]==0){\\n                    left[i]=left[i-1]+1;\\n                }else{\\n                    left[i]=left[i-1];\\n                }\\n            }\\n        }\\n        for(int i=right.length-1;i>=0;i--){\\n            if(i==right.length-1){\\n                if(nums[i]==1){\\n                    right[i]=1;\\n                }else{\\n                    right[i]=0;\\n                }\\n            }else{\\n                if(nums[i]==1){\\n                    right[i]=right[i+1]+1;\\n                }else{\\n                    right[i]=right[i+1];\\n                }\\n            }\\n        }\\n        int maxDiv=-1;\\n        for(int i=0;i<=left.length;i++){\\n            if(i==0){\\n                if(right[i]>maxDiv) maxDiv=right[i];\\n            }else if(i==left.length){\\n                if(left[i-1]>maxDiv) maxDiv=left[i-1];\\n            }else{\\n                if(left[i-1]+right[i]>maxDiv) maxDiv=left[i-1]+right[i];\\n            }\\n        }\\n        List<Integer> al=new ArrayList<Integer>();\\n        for(int i=0;i<=left.length;i++){\\n            if(i==0){\\n                if(right[i]==maxDiv) al.add(i);\\n            }else if(i==left.length){\\n                if(left[i-1]==maxDiv) al.add(i);\\n            }else{\\n                if(left[i-1]+right[i]==maxDiv) al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692264,
                "title": "c-solution-clean-and-easy-code-o-n-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int leftZero = 0, rightOne = count(nums.begin(), nums.end(), 1), mx = 0;\\n        for(int i=0; i<=nums.size(); i++)\\n        {\\n            int val = leftZero + rightOne;\\n            if(val>mx){\\n                mx = val;\\n                ans.clear();\\n                ans.push_back(i);\\n            }\\n            else if(val==mx){\\n                ans.push_back(i);\\n            }\\n            if(i!=nums.size())\\n            {\\n                if(nums[i]==0)\\n                    leftZero++;\\n                if(nums[i]==1)\\n                    rightOne--;\\n            }           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int leftZero = 0, rightOne = count(nums.begin(), nums.end(), 1), mx = 0;\\n        for(int i=0; i<=nums.size(); i++)\\n        {\\n            int val = leftZero + rightOne;\\n            if(val>mx){\\n                mx = val;\\n                ans.clear();\\n                ans.push_back(i);\\n            }\\n            else if(val==mx){\\n                ans.push_back(i);\\n            }\\n            if(i!=nums.size())\\n            {\\n                if(nums[i]==0)\\n                    leftZero++;\\n                if(nums[i]==1)\\n                    rightOne--;\\n            }           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746057,
                "title": "c-no-max-score-calculation-return-result-via-the-input-array",
                "content": "As the result is not related to the score, but to the indeces, 0 can be used as a basis and to increase the score if a \\'1 is shifted ( decrease if \\'0\\').\\n\\nIf the max remains 0 after the loop, index 0 is added to result.\\n\\n\\n\\nint* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    \\n    int i;\\n    \\n    int max = 0;\\n    int score = 0;\\n    int size = 0;\\n    \\n     for(i=0;i<numsSize;i++) {\\n        \\n         nums[i] ? score -- : score ++;\\n                 \\n        if (max < score) {\\n            max = score;\\n            nums[0] = i+1;\\n            size = 1;\\n        } \\n        else if (max == score) {\\n            nums[size] = i+1;\\n            size ++;\\n        }\\n    }\\n    \\n    if (max == 0) {\\n        nums[size] = 0;\\n        size ++;\\n    }\\n    \\n    *returnSize = size;\\n    return nums;\\n}",
                "solutionTags": [],
                "code": "As the result is not related to the score, but to the indeces, 0 can be used as a basis and to increase the score if a \\'1 is shifted ( decrease if \\'0\\').\\n\\nIf the max remains 0 after the loop, index 0 is added to result.\\n\\n\\n\\nint* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    \\n    int i;\\n    \\n    int max = 0;\\n    int score = 0;\\n    int size = 0;\\n    \\n     for(i=0;i<numsSize;i++) {\\n        \\n         nums[i] ? score -- : score ++;\\n                 \\n        if (max < score) {\\n            max = score;\\n            nums[0] = i+1;\\n            size = 1;\\n        } \\n        else if (max == score) {\\n            nums[size] = i+1;\\n            size ++;\\n        }\\n    }\\n    \\n    if (max == 0) {\\n        nums[size] = 0;\\n        size ++;\\n    }\\n    \\n    *returnSize = size;\\n    return nums;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2431609,
                "title": "easy-java-one-pass-prefix-sum-o-n-time-o-1-space",
                "content": "Intuition:\\n\\nLet\\'s say the sum of `nums`  or total number of ones is `sum` and the prefix sum for elements `0` to `i-1` is `prefixSum`.\\n* For the left subarray, the number of elements is `(i-1) - 0 + 1 = i`.  Since the number of ones is `prefixSum`, the number of zeros is `i - prefixSum`.\\n* For the right subarray, the number of ones will be `sum - prefixSum`.\\n* So the score of dividing the array at i will be `(i - prefixSum) + (sum - prefixSum) = sum + i - 2 * prefixSum`.\\n* Please note that `sum` does not change.  We can leave it out and just try to find the max value of `i - 2 * prefixSum` or `s` below in my code.  \\n\\nAs we can see, we only need to calculate the prefix sum at any given index.  A single pass is sufficient.\\n\\nJava:\\n```\\npublic List<Integer> maxScoreIndices(int[] nums) {\\n    List<Integer> ans = new ArrayList<>();\\n    for (int i = 0, n = nums.length, prefixSum = 0, max = 0; i <= n; ++i) {\\n        int s = i - 2 * prefixSum;\\n        if (s > max) ans.clear();\\n        max = Math.max(max, s);\\n        if (s == max) ans.add(i);\\n        if (i < n) prefixSum += nums[i];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> maxScoreIndices(int[] nums) {\\n    List<Integer> ans = new ArrayList<>();\\n    for (int i = 0, n = nums.length, prefixSum = 0, max = 0; i <= n; ++i) {\\n        int s = i - 2 * prefixSum;\\n        if (s > max) ans.clear();\\n        max = Math.max(max, s);\\n        if (s == max) ans.add(i);\\n        if (i < n) prefixSum += nums[i];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224510,
                "title": "python-o-n-step-by-step-solution",
                "content": "Starting with `i=0`, the left array will be empty, so the division score is the number of ones in `nums`, which we can easily get by summing its elements. Let\\'s initialize `max_score` to be this score as well:\\n```python\\nscore = max_score = sum(nums)\\n```\\nWe may create a `highest_scores` list which will hold the indices of the maximum score as we calculate them. For now, it will hold the zeroth index since we are assuming at the start that its score is the maximum score:\\n```python\\nhighest_scores = [0]\\n```\\nThen we may loop over `nums` to calculate the division score of each index. To avoid any redundant calculations, we\\'ll use the score of the previous index to calculate the score of the current index as follows:\\nwhen we move a zero from the right array to the left array, the number of ones in the right array won\\'t change, while the number of zeros on the left will increase by one. Thus, the total score for this index will equal the score of the previous index plus 1. \\nSimilarly, moving a one from the right array to the left array will reduce the total score of the previous index by one.\\n```python\\nfor i, v in enumerate(nums, 1):\\n\\tscore += 1 if v == 0 else -1\\n\\tif score > max_score:\\n\\t\\thighest_scores = [i]\\n\\t\\tmax_score = score\\n\\telif score == max_score:\\n\\t\\thighest_scores.append(i)\\n```\\nwhen `score > max_score`, we set `highest_score` to a list containing the index of the new `max_score`, and when `score == max_score`, we append this index to `highest_score` \\n\\nHere\\'s the full code:\\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        score = max_score = sum(nums)\\n        highest_scores = [0]\\n        \\n        for i, v in enumerate(nums, 1):\\n            score += 1 if v == 0 else -1\\n            if score > max_score:\\n                highest_scores = [i]\\n                max_score = score\\n            elif score == max_score:\\n                highest_scores.append(i)\\n        \\n        return highest_scores\\n```\\n\\nAnother solution is to calculate the division scores first and then find the indices that correspond to the highest score:\\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dev_scores = [0] * (len(nums) + 1)\\n        dev_scores[0] = max_score = sum(nums)\\n        \\n        for i, v in enumerate(nums, 1):\\n            dev_scores[i] = dev_scores[i - 1] + (1 if v == 0 else -1)\\n            max_score = max(max_score, dev_scores[i])\\n        \\n        return [i for i, score in enumerate(dev_scores) if score == max_score]\\n```\\nBoth solutions have `O(n)` time complexity and `O(n)` space complexity, but the first one is slightly more efficient; As it doesn\\'t create a separate list to track the scores, and it builds the `highest_scores` list while looping over `nums`.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```python\\nscore = max_score = sum(nums)\\n```\n```python\\nhighest_scores = [0]\\n```\n```python\\nfor i, v in enumerate(nums, 1):\\n\\tscore += 1 if v == 0 else -1\\n\\tif score > max_score:\\n\\t\\thighest_scores = [i]\\n\\t\\tmax_score = score\\n\\telif score == max_score:\\n\\t\\thighest_scores.append(i)\\n```\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        score = max_score = sum(nums)\\n        highest_scores = [0]\\n        \\n        for i, v in enumerate(nums, 1):\\n            score += 1 if v == 0 else -1\\n            if score > max_score:\\n                highest_scores = [i]\\n                max_score = score\\n            elif score == max_score:\\n                highest_scores.append(i)\\n        \\n        return highest_scores\\n```\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dev_scores = [0] * (len(nums) + 1)\\n        dev_scores[0] = max_score = sum(nums)\\n        \\n        for i, v in enumerate(nums, 1):\\n            dev_scores[i] = dev_scores[i - 1] + (1 if v == 0 else -1)\\n            max_score = max(max_score, dev_scores[i])\\n        \\n        return [i for i, score in enumerate(dev_scores) if score == max_score]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172792,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int c1=0, c0=0;\\n        for(auto& i : nums){\\n            if(i==1) c1++;\\n        }\\n        map<int,vector<int> > m;\\n        int l = nums.size();\\n        for(int i=0; i<=l; ++i){\\n            m[c0+c1].push_back(i);\\n            if(i<l && nums[i]==0){\\n                c0++;\\n            }\\n            else{\\n                c1--;\\n            }\\n        }\\n        auto itr = m.rbegin();\\n        return itr->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int c1=0, c0=0;\\n        for(auto& i : nums){\\n            if(i==1) c1++;\\n        }\\n        map<int,vector<int> > m;\\n        int l = nums.size();\\n        for(int i=0; i<=l; ++i){\\n            m[c0+c1].push_back(i);\\n            if(i<l && nums[i]==0){\\n                c0++;\\n            }\\n            else{\\n                c1--;\\n            }\\n        }\\n        auto itr = m.rbegin();\\n        return itr->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069792,
                "title": "linear-time-with-only-one-traversal-of-the-array-explanation",
                "content": "Most solutions for this problem track both the left **0s** and right **1s**,\\nThe insight is: you dont need to know how much 1s there are to the right from your index, \\nonly how many of them you have already found.\\nLet us look at how the score function changes when we move index through the `nums` array from left to right:\\n- Let the total number of **1**s be equal to **x** and name **zeros** and **ones** the left and right components of our score respectfully.\\n- Let\\'s do a left-to-right traversal of the array with **idx-1** being the rightmost element of the left part. We note, that if we\\'ve encountered a **1** this means that this **1** has moved from the right part to the left part), so **zeros** remains unchanged and **ones** must be decremented by 1.\\n```\\nInput: nums = [0,0,1,0,0,1,0,1]\\nOutput: [6,8]\\nExplanation: Division at index\\nLet the total \\n- 0: numsleft is [] . The score is 0 + x.\\n- 1: numsleft is [0]. The score is 1 + x .\\n- 2: numsleft is [0,0]. The score is 2 + x.\\n- 3: numsleft is [0,0,1]. We found a 1, so the score is 2 + (x-1).\\n- 4: numsleft is [0,0,1,0]. The score is 3 + (x-1).\\n- 5: numsleft is [0,0,1,0,0]. The score is 4 + (x-1).\\n- 6: numsleft is [0,0,1,0,0,1]. We found a 1, so the score is 4 + (x-2).\\nAnd so forth.\\n```\\nWe observe, that total number of 1s = **x** is just a constant that we can safely subtract from our computations, leaving us with a modified score:\\n**newScore** = **zeros** - ***number_of_1s_found***\\nWe know this will not affect the positions of maximums, their value will just be shifted by **x**. Indeed, if we consider **score** a function in mathematical meaning, we know that extremums are found where the derivative of the function is equal to zero, and **d(f)/dx = d(f+c)/dx**.\\nNow, this means that we only need to traverse the array once, keeping track of the current maximum value and corresponding indices.\\nSee the code in Python below:\\n```\\ndef maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\tsize = len(nums)\\n\\tscore = 0\\n\\tidx = [0]         \\n\\tmaxScore = score\\n\\tfor i in range(1,size+1):\\n\\t\\tif nums[i-1]>0:\\n\\t\\t\\tscore = score - 1\\n\\t\\telse:\\n\\t\\t\\tscore = score + 1\\n\\n\\t\\tif score>maxScore:\\n\\t\\t\\t# we found a new maxScore, delete idx of previous max \\n\\t\\t\\tmaxScore = score\\n\\t\\t\\tidx=[i]\\n\\t\\telif score == maxScore:\\n\\t\\t\\tidx.append(i)\\n\\n\\treturn idx\\n```\\nTime complexity: **O(N)**\\nSpace complexity: actually it is **O(N)**. The worst case is [01010101..] pattern, where number of maximums to be stored is N/2.\\n\\nFor further optimisation, one may notice that maximums may occur only at **idx=0 or idx=len(nums)** or at such points, where the current element is **0** and the next one is **1**. So the maximum update part may be moved into the` if nums[i-1]>0:` branch. However, with the Python run time of seconds this does not make any change, and I\\'m curious whether it is sighificant in fast languages like C++. Please try and comment on that.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nInput: nums = [0,0,1,0,0,1,0,1]\\nOutput: [6,8]\\nExplanation: Division at index\\nLet the total \\n- 0: numsleft is [] . The score is 0 + x.\\n- 1: numsleft is [0]. The score is 1 + x .\\n- 2: numsleft is [0,0]. The score is 2 + x.\\n- 3: numsleft is [0,0,1]. We found a 1, so the score is 2 + (x-1).\\n- 4: numsleft is [0,0,1,0]. The score is 3 + (x-1).\\n- 5: numsleft is [0,0,1,0,0]. The score is 4 + (x-1).\\n- 6: numsleft is [0,0,1,0,0,1]. We found a 1, so the score is 4 + (x-2).\\nAnd so forth.\\n```\n```\\ndef maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\tsize = len(nums)\\n\\tscore = 0\\n\\tidx = [0]         \\n\\tmaxScore = score\\n\\tfor i in range(1,size+1):\\n\\t\\tif nums[i-1]>0:\\n\\t\\t\\tscore = score - 1\\n\\t\\telse:\\n\\t\\t\\tscore = score + 1\\n\\n\\t\\tif score>maxScore:\\n\\t\\t\\t# we found a new maxScore, delete idx of previous max \\n\\t\\t\\tmaxScore = score\\n\\t\\t\\tidx=[i]\\n\\t\\telif score == maxScore:\\n\\t\\t\\tidx.append(i)\\n\\n\\treturn idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2032034,
                "title": "c-intuitive-3-approaches-time-complexity-o-n-space-complexity-o-1",
                "content": "**Approach 1**\\nJust storing count of **0\\'s** in left array and **1\\'s** in right array and then calculating the maximum by traversing the array and summing the values.\\nTime Complexity - O(n)\\nSpace Complexity - O(3n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        left.push_back(0);\\n        for(auto &x : nums)\\n            left.push_back(left.back() + (x == 0));\\n        right.push_back(0);\\n        for(int i=n-1;i>=0;i--)\\n            right.push_back(right.back() + (nums[i] == 1));\\n        reverse(right.begin(),right.end());\\n        unordered_map<int,vector<int> > mp;\\n        for(int i=0;i<(int)left.size();i++)\\n            mp[left[i]+right[i]].push_back(i);\\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(auto &x : mp){\\n            if(x.first > maxVal){\\n                maxVal = x.first;\\n                ans = x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2**\\n\\nInstead of using left, right and a Map we can use only a left array for book keeping since given array is binary array, So we can figure out number of ones on the right by finding number of **0\\'s** on the right and subtracting it from array length.\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        int cnt0 = 0;\\n        for(auto &x : nums)\\n            cnt0 += (x == 0);\\n        \\n        left.push_back(0);\\n        for(auto &x : nums)\\n            left.push_back(left.back() + (x == 0));\\n      \\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<(int)left.size();i++){\\n            int val = left[i] + (int)left.size() - i - (cnt0 - left[i]);\\n            if(val > maxVal){\\n                ans.clear();\\n                maxVal = val;\\n                ans.push_back(i);\\n            }\\n            else if(val == maxVal){\\n                ans.push_back(i);\\n            }\\n        }\\n \\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 3**\\n\\nInstead of tracking the left array we can track number of **0\\'s** encountered on the fly, so that space can be optimized.\\nTime Complexity - O(n)\\nSpace Complexity - O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        int cnt0 = 0;\\n        for(auto &x : nums)\\n            cnt0 += (x == 0);\\n        \\n        int leftCount = 0;\\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<=n;i++){\\n            int val = leftCount + n+1 - i - (cnt0 - leftCount);\\n            if(val > maxVal){\\n                ans.clear();\\n                maxVal = val;\\n                ans.push_back(i);\\n            }\\n            else if(val == maxVal){\\n                ans.push_back(i);\\n            }\\n            if(i < n)\\n                leftCount += (nums[i] == 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        left.push_back(0);\\n        for(auto &x : nums)\\n            left.push_back(left.back() + (x == 0));\\n        right.push_back(0);\\n        for(int i=n-1;i>=0;i--)\\n            right.push_back(right.back() + (nums[i] == 1));\\n        reverse(right.begin(),right.end());\\n        unordered_map<int,vector<int> > mp;\\n        for(int i=0;i<(int)left.size();i++)\\n            mp[left[i]+right[i]].push_back(i);\\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(auto &x : mp){\\n            if(x.first > maxVal){\\n                maxVal = x.first;\\n                ans = x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        int cnt0 = 0;\\n        for(auto &x : nums)\\n            cnt0 += (x == 0);\\n        \\n        left.push_back(0);\\n        for(auto &x : nums)\\n            left.push_back(left.back() + (x == 0));\\n      \\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<(int)left.size();i++){\\n            int val = left[i] + (int)left.size() - i - (cnt0 - left[i]);\\n            if(val > maxVal){\\n                ans.clear();\\n                maxVal = val;\\n                ans.push_back(i);\\n            }\\n            else if(val == maxVal){\\n                ans.push_back(i);\\n            }\\n        }\\n \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> left,right;\\n        int n = nums.size();\\n        int cnt0 = 0;\\n        for(auto &x : nums)\\n            cnt0 += (x == 0);\\n        \\n        int leftCount = 0;\\n        vector<int> ans;\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<=n;i++){\\n            int val = leftCount + n+1 - i - (cnt0 - leftCount);\\n            if(val > maxVal){\\n                ans.clear();\\n                maxVal = val;\\n                ans.push_back(i);\\n            }\\n            else if(val == maxVal){\\n                ans.push_back(i);\\n            }\\n            if(i < n)\\n                leftCount += (nums[i] == 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766529,
                "title": "o-1-c-easy-understanding-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n\\t    int tot = accumulate(nums.begin(), nums.end(), 0);\\n        int left_sum = 0;\\n        int right_sum = tot;\\n        int max_sum = left_sum + right_sum;\\n        vector<int> indices { 0 };\\n        for (int idx = 0; idx < nums.size(); ++idx) {\\n            int cur_val = nums[idx];\\n            if (cur_val == 0) {\\n                ++left_sum;\\n            } else {\\n                --right_sum;\\n            }\\n            int cur_sum = left_sum + right_sum;\\n            if (cur_sum > max_sum) {\\n                max_sum = cur_sum;\\n                indices = std::vector<int>{ idx + 1 };\\n            } else if (cur_sum == max_sum) {\\n                indices.push_back(idx + 1);\\n            }\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n\\t    int tot = accumulate(nums.begin(), nums.end(), 0);\\n        int left_sum = 0;\\n        int right_sum = tot;\\n        int max_sum = left_sum + right_sum;\\n        vector<int> indices { 0 };\\n        for (int idx = 0; idx < nums.size(); ++idx) {\\n            int cur_val = nums[idx];\\n            if (cur_val == 0) {\\n                ++left_sum;\\n            } else {\\n                --right_sum;\\n            }\\n            int cur_sum = left_sum + right_sum;\\n            if (cur_sum > max_sum) {\\n                max_sum = cur_sum;\\n                indices = std::vector<int>{ idx + 1 };\\n            } else if (cur_sum == max_sum) {\\n                indices.push_back(idx + 1);\\n            }\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746083,
                "title": "python-o-n-with-two-counters",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        lcounter = {0: 0, 1: 0}\\n        rcounter = collections.Counter(nums)\\n        maxval = rcounter[1]\\n        maxarr = [0]\\n        for i in range(1, len(nums)+1):\\n            lcounter[nums[i-1]] += 1\\n            rcounter[nums[i-1]] -= 1\\n            c = lcounter[0] + rcounter[1]\\n            if c > maxval:\\n                maxval = c\\n                maxarr = [i]\\n            elif c == maxval:\\n                maxarr.append(i) \\n        return maxarr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        lcounter = {0: 0, 1: 0}\\n        rcounter = collections.Counter(nums)\\n        maxval = rcounter[1]\\n        maxarr = [0]\\n        for i in range(1, len(nums)+1):\\n            lcounter[nums[i-1]] += 1\\n            rcounter[nums[i-1]] -= 1\\n            c = lcounter[0] + rcounter[1]\\n            if c > maxval:\\n                maxval = c\\n                maxarr = [i]\\n            elif c == maxval:\\n                maxarr.append(i) \\n        return maxarr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742566,
                "title": "ruby-solution-simple-and-easy",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef max_score_indices(nums)\\n    nl = []\\n    memo = {}\\n    for i in (0..nums.count)\\n        memo[i] = [nl.find_all{|ze| ze == 0 }.count, nums.find_all{|one| one == 1}.count].sum\\n        nl<<nums.shift\\n    end\\n    ans = []\\n    memo.each { |k, v| ans<<k if v == memo.values.max }\\n    ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef max_score_indices(nums)\\n    nl = []\\n    memo = {}\\n    for i in (0..nums.count)\\n        memo[i] = [nl.find_all{|ze| ze == 0 }.count, nums.find_all{|one| one == 1}.count].sum\\n        nl<<nums.shift\\n    end\\n    ans = []\\n    memo.each { |k, v| ans<<k if v == memo.values.max }\\n    ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1737795,
                "title": "c-java-python-update-score-using-math-trick-o-n-time",
                "content": "C++:\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int cur_score = accumulate(nums.begin(), nums.end(), 0);\\n        int cur_max = cur_score;\\n        vector<int> res{0};\\n        for (int i = 1; i <= nums.size(); ++i) {\\n            cur_score += 1 - 2 * nums[i - 1];\\n            if (cur_score > cur_max) {\\n                cur_max = cur_score;\\n                res = {i};\\n            } else if (cur_score == cur_max) {\\n                res.emplace_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nJava:\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int cur_score = Arrays.stream(nums).sum();\\n        int cur_max = cur_score;\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        for (int i = 1; i <= nums.length; ++i) {\\n            cur_score += 1 - 2 * nums[i - 1];\\n            if (cur_score > cur_max) {\\n                cur_max = cur_score;\\n                res.clear();\\n                res.add(i);\\n            } else if (cur_score == cur_max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nPython:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        cur_score = sum(nums)\\n        cur_max = cur_score\\n        res = [0]\\n        for i in range(1, len(nums) + 1):\\n            cur_score += 1 - 2 * nums[i - 1]\\n            if cur_score > cur_max:\\n                cur_max = cur_score\\n                res = [i]\\n            elif cur_score == cur_max:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int cur_score = accumulate(nums.begin(), nums.end(), 0);\\n        int cur_max = cur_score;\\n        vector<int> res{0};\\n        for (int i = 1; i <= nums.size(); ++i) {\\n            cur_score += 1 - 2 * nums[i - 1];\\n            if (cur_score > cur_max) {\\n                cur_max = cur_score;\\n                res = {i};\\n            } else if (cur_score == cur_max) {\\n                res.emplace_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int cur_score = Arrays.stream(nums).sum();\\n        int cur_max = cur_score;\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        for (int i = 1; i <= nums.length; ++i) {\\n            cur_score += 1 - 2 * nums[i - 1];\\n            if (cur_score > cur_max) {\\n                cur_max = cur_score;\\n                res.clear();\\n                res.add(i);\\n            } else if (cur_score == cur_max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        cur_score = sum(nums)\\n        cur_max = cur_score\\n        res = [0]\\n        for i in range(1, len(nums) + 1):\\n            cur_score += 1 - 2 * nums[i - 1]\\n            if cur_score > cur_max:\\n                cur_max = cur_score\\n                res = [i]\\n            elif cur_score == cur_max:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734904,
                "title": "c-easy-o-n-solution-count-0-s-and-1-s-of-left-and-right-side",
                "content": "class Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int c1 = 0;\\n        int c0 = 0;\\n        for(int k =0;k<n;k++)\\n        {\\n            if(nums[k]==1)c1++;\\n            if(nums[k]==0)c0++;\\n        }\\n         \\n        int temp = 0;\\n        int temp1 = c1;\\n        int leftcount = 0;\\n        int rightcount = c1;\\n        int ans = 0;\\n        vector<int>res;\\n        res.push_back(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = 0;\\n            if(nums[i]==0)\\n            {\\n                leftcount++;\\n            }\\n            else\\n            {\\n                rightcount--;\\n            }\\n            ans = leftcount+rightcount;\\n            if(temp1<ans)\\n            {\\n                temp1 = ans;\\n                temp = i+1;\\n                res.clear();\\n                res.push_back(temp);\\n                \\n            }\\n            else if(temp1==ans)\\n            {\\n                temp1 = ans;\\n                temp = i+1;\\n                res.push_back(temp);\\n            }\\n            \\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int c1 = 0;\\n        int c0 = 0;\\n        for(int k =0;k<n;k++)\\n        {\\n            if(nums[k]==1)c1++;\\n            if(nums[k]==0)c0++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1734007,
                "title": "using-prefix-o-n",
                "content": "```\\nvector<int>ans;\\n\\tint n=nums.size();\\n\\tvector<int>left(n+1,0);\\n\\tvector<int>right(n+1,0);\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tleft[i]=left[i-1]+(nums[i-1]==0);\\n\\t}\\n\\tfor(int i=n-1;i>=0;i--){\\n\\t\\tright[i]=right[i+1]+(nums[i]==1);\\n\\t}\\n\\tint maxs=INT_MIN;\\n\\tfor(int i=0;i<=n;i++){\\n\\tint s=left[i]+right[i]; \\n\\tif(s>maxs){\\n\\t\\tmaxs=s;\\n}\\n\\t}\\n\\n\\t for(int i=0;i<=n;i++){\\n\\tint s=left[i]+right[i]; \\n\\tif(s==maxs){\\n\\t\\tans.push_back(i);\\n}\\n\\t}\\n\\n\\treturn ans;\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int>ans;\\n\\tint n=nums.size();\\n\\tvector<int>left(n+1,0);\\n\\tvector<int>right(n+1,0);\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tleft[i]=left[i-1]+(nums[i-1]==0);\\n\\t}\\n\\tfor(int i=n-1;i>=0;i--){\\n\\t\\tright[i]=right[i+1]+(nums[i]==1);\\n\\t}\\n\\tint maxs=INT_MIN;\\n\\tfor(int i=0;i<=n;i++){\\n\\tint s=left[i]+right[i]; \\n\\tif(s>maxs){\\n\\t\\tmaxs=s;\\n}\\n\\t}\\n\\n\\t for(int i=0;i<=n;i++){\\n\\tint s=left[i]+right[i]; \\n\\tif(s==maxs){\\n\\t\\tans.push_back(i);\\n}\\n\\t}\\n\\n\\treturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732524,
                "title": "python3-easy-readable-solution-o-n",
                "content": "Just follow the definition of the problem and create prefix sum for faster lookups.\\n\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums):\\n        cs = [0]\\n        for n in nums:\\n            cs.append(cs[-1] + n)\\n        \\n        d = []\\n        for i, s in enumerate(cs):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0d.append(i + cs[-1] - 2 * s)\\n                \\n        M = max(d)\\n        return [i for i, n in enumerate(d) if n == M]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums):\\n        cs = [0]\\n        for n in nums:\\n            cs.append(cs[-1] + n)\\n        \\n        d = []\\n        for i, s in enumerate(cs):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0d.append(i + cs[-1] - 2 * s)\\n                \\n        M = max(d)\\n        return [i for i, n in enumerate(d) if n == M]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732337,
                "title": "2155-python3-o-n-easy-to-understand-runtime-4529ms-41-67-faster-memory-23-8-mb",
                "content": "When you iterate the array, maintain the number of zeros and ones on the left side. Can you quickly calculate the number of ones on the right side?\\n~\\nThe number of ones on the right side equals the number of ones in the whole array minus the number of ones on the left side.\\n~\\nAlternatively, you can quickly calculate it by using a prefix sum array.\\n\\n```\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\n        ones = nums.count(1)\\n        zeros = 0\\n        res = []\\n        max_division_score = 0\\n\\n        for i in range(len(nums)+1):\\n            division_score = ones + zeros\\n            if max_division_score < division_score:\\n                res = [i]\\n                max_division_score = division_score\\n            elif max_division_score == division_score:\\n                res.append(i)\\n            \\n            if i >= len(nums):\\n                continue\\n                \\n            if nums[i] == 1:\\n                ones -= 1\\n            if nums[i] == 0:\\n                zeros += 1\\n        return res\\n\\n# Time: O(N)\\n# Space: O(1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/18756392-12b0-40a7-b20a-214af4d4cb28_1643568100.4418705.png)\\n\\n--------\\n--------\\n**Find this solution and many others on my Github:** https://github.com/dimon41k2010/LeetCodeTasks/blob/main/2155-all-divisions-with-the-highest-score-of-a-binary-array/2155-all-divisions-with-the-highest-score-of-a-binary-array.py\\n\\n**Please upvote if it makes sence and helpful to you. Let\\'s stay motivated! Peace.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\n        ones = nums.count(1)\\n        zeros = 0\\n        res = []\\n        max_division_score = 0\\n\\n        for i in range(len(nums)+1):\\n            division_score = ones + zeros\\n            if max_division_score < division_score:\\n                res = [i]\\n                max_division_score = division_score\\n            elif max_division_score == division_score:\\n                res.append(i)\\n            \\n            if i >= len(nums):\\n                continue\\n                \\n            if nums[i] == 1:\\n                ones -= 1\\n            if nums[i] == 0:\\n                zeros += 1\\n        return res\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1731828,
                "title": "c-solution-using-vector-and-max-heap",
                "content": "The approach I discussed here is what I thought in my first try and there are many approach that will be more efficient than mine !\\nFirst we created two array one names as left and other as right and here I had used vector as it is dynamic sized array each one of size (n+1) where n is the size of original which we have given as **nums**\\n```\\nvector<int> left(n + 1), right(n + 1);\\n```\\nI stored the count of **0(zero)** till the index **i** in the left array where **i** is basically index in the array iteration \\nFor storing count of **0** in left array\\nfirst I stored **0** at index **0** as if we do partition at **index 0** we left array will be empty and right array contains all the element so value at index **0** will be zero and for other index if check ```nums[i-1]```  is equal to zero then we do ```left[i]=left[i-1]+1``` and if it not equal to zero then we simply store the value which is stored at previous index ```left[i]=left[i-1]```  as count of **0** will remain unchanged and we run this loop for all element of **nums[]**;\\n``` left[0] = 0;```\\n```for (int i = 1; i <= n; i++)```\\n    ```{```\\n       ``` if (nums[i - 1] == 0)```\\n       ``` {```\\n           ``` left[i] = left[i - 1] + 1;```\\n      ```  }```\\n       ``` else```\\n\\t\\t\\t\\t ```   {```\\n\\t\\t\\t\\t```left[i] = left[i - 1];```\\n\\t\\t\\t   ``` }```\\n\\t\\t   \\n ```   }```\\n After this our left array is complete now we have to fix right array we also iterate for **i=0** to **i=n**\\n**right[i] = No. of 1\\'s in whole array - No. of 1\\'s in left side**\\nfor finding the **No. of 1\\'s in whole array** we can use **n-left[n]** as n is the total no. of element in the array and **left[n]** give as total number of zero as in **left[n]** we have done parition at index n and that result all element come in left side making right side empty and in same way for **No. of 1\\'s in left side** we use no. of element in left side - left[i] as left[i] give as no. of zero at that time\\nBut in my code I thought slightly different approach \\nfor calculation of ```right[i] =(n-i) -(left[n]-left[i]);```\\nas **n-i** give size of right array at that instance and **left[n]-left[i]** give number of zeros for that right array and along with that I pushed sum of **(left[i]+right[i])** along with its index in a max heap name pq that helped me in finding max sum with its index and for that I had used ``make_pair()``function and in max heap I pushed **sum of** **left[i]+right[i]** as first element as we all know in case of pair-wise **max heap** **arrange data according to first element** ;\\nafter that I ``pop()``first element form the max heap and its first will contain max sum that we can get through this arrays and second will give us index at which this sum will be obtained and pushed index in answer vector here I named it ``vect`` and to find other index at also have same max sum value I traversed max heap using while loop and if incounter a lower value I simply break the loop and return vect vector to the caller function\\n``vector<int> vect;``\\n   `` for (int i = 0; i <= n; i++)``\\n   `` {``\\n        ``right[i] = (n - i) - (left[n] - left[i])``\\n        ``pq.push(make_pair(left[i] + right[i], i));``\\n   `` }``\\n  ``  int max_num = pq.top().first;``\\n   `` vect.push_back(pq.top().second);``\\n   `` pq.pop();``\\n   `` while (pq.empty() == false)``\\n   `` {``\\n        ``auto itr = pq.top();``\\n       `` if (itr.first == max_num)``\\n        ``{``\\n            ``vect.push_back(itr.second);``\\n            ``pq.pop();``\\n        ``}``\\n        ``else if (itr.first < max_num)``\\n            ``break;``\\n  ``  }``\\n    ``return vect;``",
                "solutionTags": [],
                "code": "```\\nvector<int> left(n + 1), right(n + 1);\\n```\n```nums[i-1]```\n```left[i]=left[i-1]+1```\n```left[i]=left[i-1]```\n``` left[0] = 0;```\n```for (int i = 1; i <= n; i++)```\n```{```\n``` if (nums[i - 1] == 0)```\n``` {```\n``` left[i] = left[i - 1] + 1;```\n```  }```\n``` else```\n```   {```\n```left[i] = left[i - 1];```\n``` }```\n```   }```\n```right[i] =(n-i) -(left[n]-left[i]);```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731602,
                "title": "python-iterative-approch",
                "content": "Example: \\n> 0,0,1,0\\n> For this value as input we can calculate number of zeroes to the left for each index and no of ones to the right of each index.\\n> For zeroes it will be exclusive of the current elelemt and for number of ones it will be inclusive. \\n\\nLeft zeroes (exclusive) = [0,1,2,2,3] (note that this value will be size of input + 1 as it is exclusive of current index. Therefore to count all the zores we need one extra space)\\n\\nRight ones (inclusive) = [2,1,1,0]\\n\\n---\\n\\nNow that we have the vlues we will create a final array with the sum of both the lists. The new array will tell all the left zeroes and right ones for each index and it is linear time. \\n\\nNew array = [1,2,3,2,3] both the index starts from 0. From this point we can just get the max and return the index where it occurs.\\n\\n---\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        values = [0]*(N+1)\\n        \\n        count = 0\\n        for i in range(N):\\n            values[i]=count\\n            if nums[i] == 0:count+=1\\n        values[-1] = count\\n        \\n        count = 0\\n        for i in range(N-1,-1,-1):\\n            count+=nums[i]\\n            values[i] += count\\n        \\n        max_value = max(values)\\n        return [x for x in range(N+1) if values[x] == max_value]\\n    \\n        \\n        \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        values = [0]*(N+1)\\n        \\n        count = 0\\n        for i in range(N):\\n            values[i]=count\\n            if nums[i] == 0:count+=1\\n        values[-1] = count\\n        \\n        count = 0\\n        for i in range(N-1,-1,-1):\\n            count+=nums[i]\\n            values[i] += count\\n        \\n        max_value = max(values)\\n        return [x for x in range(N+1) if values[x] == max_value]\\n    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731539,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>left(nums.size()+1,0);\\n        int countz=0,counto=0;\\n        for(int i=1;i<left.size();i++){\\n            if(nums[i-1] == 0){\\n                countz++;\\n            }\\n            left[i] = countz;\\n        }\\n        \\n        vector<int>right(nums.size()+1,0);\\n        for(int i = right.size()-2;i>=0;i--){\\n            if(nums[i] == 1){\\n                counto++;\\n            }\\n            right[i] = counto;\\n            \\n        }\\n        vector<int>ans;\\n        int maxi = INT_MIN;\\n        for(int i=0;i<left.size();i++){\\n            if(left[i]+right[i] > maxi){\\n                maxi = left[i]+right[i];\\n                ans.clear();\\n                ans.push_back(i);\\n            }else if(left[i]+right[i] == maxi){\\n                ans.push_back(i);\\n            }\\n        }\\n    return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>left(nums.size()+1,0);\\n        int countz=0,counto=0;\\n        for(int i=1;i<left.size();i++){\\n            if(nums[i-1] == 0){\\n                countz++;\\n            }\\n            left[i] = countz;\\n        }\\n        \\n        vector<int>right(nums.size()+1,0);\\n        for(int i = right.size()-2;i>=0;i--){\\n            if(nums[i] == 1){\\n                counto++;\\n            }\\n            right[i] = counto;\\n            \\n        }\\n        vector<int>ans;\\n        int maxi = INT_MIN;\\n        for(int i=0;i<left.size();i++){\\n            if(left[i]+right[i] > maxi){\\n                maxi = left[i]+right[i];\\n                ans.clear();\\n                ans.push_back(i);\\n            }else if(left[i]+right[i] == maxi){\\n                ans.push_back(i);\\n            }\\n        }\\n    return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731510,
                "title": "c-no-extra-space-used",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int zero = 0,ones = 0;\\n        //finding total number of zeroes and ones\\n        for(int i = 0;i<n;i++){\\n            if(nums[i] == 0){\\n                zero++;\\n            }\\n            else{\\n                ones++;\\n            }\\n        }\\n        \\n        int left = 0;\\n        int right = ones ;\\n        \\n        //finding max possible\\n        int temp = INT_MIN ;\\n        temp = max(temp,right);\\n        for(int i = 0;i<n;i++){\\n            if(nums[i] == 0){\\n                left++;\\n            }\\n            else{\\n                //if one reduce right\\n                right--;\\n            }\\n            temp = max(temp,left+right);\\n        }\\n        \\n        vector<int> ans ;\\n        \\n        if(temp == ones){\\n            //checking for 0 index\\n            ans.push_back(0);\\n        }\\n        \\n        left = 0;\\n        right = ones ;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(nums[i]==0){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n            if(left+right == temp){\\n                //storing indexes\\n                ans.push_back(i+1);\\n            }\\n            \\n        }\\n        return ans ;\\n\\t\\t/*\\n\\t\\tTime : O(N)\\n\\t\\tSpace : O(1)\\n\\t\\t*/\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int zero = 0,ones = 0;\\n        //finding total number of zeroes and ones\\n        for(int i = 0;i<n;i++){\\n            if(nums[i] == 0){\\n                zero++;\\n            }\\n            else{\\n                ones++;\\n            }\\n        }\\n        \\n        int left = 0;\\n        int right = ones ;\\n        \\n        //finding max possible\\n        int temp = INT_MIN ;\\n        temp = max(temp,right);\\n        for(int i = 0;i<n;i++){\\n            if(nums[i] == 0){\\n                left++;\\n            }\\n            else{\\n                //if one reduce right\\n                right--;\\n            }\\n            temp = max(temp,left+right);\\n        }\\n        \\n        vector<int> ans ;\\n        \\n        if(temp == ones){\\n            //checking for 0 index\\n            ans.push_back(0);\\n        }\\n        \\n        left = 0;\\n        right = ones ;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(nums[i]==0){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n            if(left+right == temp){\\n                //storing indexes\\n                ans.push_back(i+1);\\n            }\\n            \\n        }\\n        return ans ;\\n\\t\\t/*\\n\\t\\tTime : O(N)\\n\\t\\tSpace : O(1)\\n\\t\\t*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731263,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n   public List<Integer> maxScoreIndices(int[] nums) {\\n\\t\\tint countOne = 0;\\n       //count total 1 present in nums\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 1) {\\n\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t}\\n\\t\\t}\\n       //hold zero count\\n\\t\\tint zeroCount = 0;\\n       //max score\\n\\t\\tint max = countOne;\\n       //hold answer list\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tlist.add(0);\\n       //iterate entire array\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n            //if zero found increment zeroCount\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tzeroCount++; //increment as we need 0 on left side only\\n\\t\\t\\t} else {\\n                //if 1 decrement countOne as we need 1 on right side only\\n\\t\\t\\t\\tcountOne--;\\n\\t\\t\\t}\\n            //calculate answer\\n\\t\\t\\tint ans = zeroCount + countOne;\\n            //if ans already equal max update list with current index\\n            if(ans==max) {\\n                list.add(i+1);\\n            } else if(ans>max) {\\n                //it means new max found. so just delete entire list content\\n                list.clear();\\n                //update max\\n                max=ans;\\n                //add current index to list\\n                list.add(i+1);\\n            }\\n\\t\\t}\\n       //return answer\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public List<Integer> maxScoreIndices(int[] nums) {\\n\\t\\tint countOne = 0;\\n       //count total 1 present in nums\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 1) {\\n\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t}\\n\\t\\t}\\n       //hold zero count\\n\\t\\tint zeroCount = 0;\\n       //max score\\n\\t\\tint max = countOne;\\n       //hold answer list\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tlist.add(0);\\n       //iterate entire array\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n            //if zero found increment zeroCount\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tzeroCount++; //increment as we need 0 on left side only\\n\\t\\t\\t} else {\\n                //if 1 decrement countOne as we need 1 on right side only\\n\\t\\t\\t\\tcountOne--;\\n\\t\\t\\t}\\n            //calculate answer\\n\\t\\t\\tint ans = zeroCount + countOne;\\n            //if ans already equal max update list with current index\\n            if(ans==max) {\\n                list.add(i+1);\\n            } else if(ans>max) {\\n                //it means new max found. so just delete entire list content\\n                list.clear();\\n                //update max\\n                max=ans;\\n                //add current index to list\\n                list.add(i+1);\\n            }\\n\\t\\t}\\n       //return answer\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731243,
                "title": "golang-solution-from-contest-more-optimization-definitely-possible",
                "content": "Approach:\\nones and zeroes counted in preprocess loops.\\nlast two loops can be merged into one.\\n\\n```\\n\\nfunc maxScoreIndices(nums []int) []int {\\n\\tn := len(nums)\\n\\tzerocnt := make([]int, n+1)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tzerocnt[i+1] = zerocnt[i]\\n\\t\\tif nums[i] == 0 {\\n\\t\\t\\tzerocnt[i+1] = zerocnt[i+1] + 1\\n\\t\\t}\\n\\t}\\n\\n\\tonecnt := make([]int, n+1)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tonecnt[i] = onecnt[i+1]\\n\\t\\tif nums[i] == 1 {\\n\\t\\t\\tonecnt[i] = onecnt[i] + 1\\n\\t\\t}\\n\\t}\\n\\n\\tmax := -1\\n\\tfor i := 0; i < n+1; i++ {\\n\\t\\ttmp := zerocnt[i] + onecnt[i]\\n\\t\\tif tmp > max {\\n\\t\\t\\tmax = tmp\\n\\t\\t}\\n\\t}\\n\\n\\t// fmt.Printf(\"zerocnt: %v\\\\n\", zerocnt)\\n\\t// fmt.Printf(\"onecnt: %v\\\\n\", onecnt)\\n\\t// fmt.Printf(\"max : %d\\\\n\", max)\\n\\n\\tarr := make([]int, 0)\\n\\tfor i := 0; i < n+1; i++ {\\n\\t\\tif max == (zerocnt[i] + onecnt[i]) {\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc maxScoreIndices(nums []int) []int {\\n\\tn := len(nums)\\n\\tzerocnt := make([]int, n+1)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tzerocnt[i+1] = zerocnt[i]\\n\\t\\tif nums[i] == 0 {\\n\\t\\t\\tzerocnt[i+1] = zerocnt[i+1] + 1\\n\\t\\t}\\n\\t}\\n\\n\\tonecnt := make([]int, n+1)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tonecnt[i] = onecnt[i+1]\\n\\t\\tif nums[i] == 1 {\\n\\t\\t\\tonecnt[i] = onecnt[i] + 1\\n\\t\\t}\\n\\t}\\n\\n\\tmax := -1\\n\\tfor i := 0; i < n+1; i++ {\\n\\t\\ttmp := zerocnt[i] + onecnt[i]\\n\\t\\tif tmp > max {\\n\\t\\t\\tmax = tmp\\n\\t\\t}\\n\\t}\\n\\n\\t// fmt.Printf(\"zerocnt: %v\\\\n\", zerocnt)\\n\\t// fmt.Printf(\"onecnt: %v\\\\n\", onecnt)\\n\\t// fmt.Printf(\"max : %d\\\\n\", max)\\n\\n\\tarr := make([]int, 0)\\n\\tfor i := 0; i < n+1; i++ {\\n\\t\\tif max == (zerocnt[i] + onecnt[i]) {\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731063,
                "title": "simple-solution-in-java-easy-to-understand-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n = nums.length;\\n        \\n        int oneCount = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 1) oneCount++;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        int one = 0;\\n        int zero = 0;\\n        int maxDivScore = 0;\\n        for(int i=0; i<=n; i++){\\n            int currScore = zero + oneCount - one; // Number of zeroes on the left and the number of zeroes on the right side \\n            \\n            if(i < n && nums[i] == 0) zero++;\\n            else if(i < n) one++;\\n            \\n            if(maxDivScore < currScore){\\n                res.clear();\\n                maxDivScore = currScore;\\n                res.add(i);\\n            }else if(maxDivScore == currScore)  res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n = nums.length;\\n        \\n        int oneCount = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 1) oneCount++;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        int one = 0;\\n        int zero = 0;\\n        int maxDivScore = 0;\\n        for(int i=0; i<=n; i++){\\n            int currScore = zero + oneCount - one; // Number of zeroes on the left and the number of zeroes on the right side \\n            \\n            if(i < n && nums[i] == 0) zero++;\\n            else if(i < n) one++;\\n            \\n            if(maxDivScore < currScore){\\n                res.clear();\\n                maxDivScore = currScore;\\n                res.add(i);\\n            }else if(maxDivScore == currScore)  res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731032,
                "title": "map",
                "content": "```\\n vector<int> maxScoreIndices(vector<int>& nums) {\\n        int o=0,z=0;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(nums[i]==1)\\n                o++;\\n        }\\n        int mx=INT_MIN;\\n        mp[o].push_back(0);\\n        mx=max(mx,o);\\n        \\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(nums[i]==1)\\n                o--;\\n            if(nums[i]==0)\\n                z++;\\n            \\n            mp[o+z].push_back(i+1);\\n            mx=max(mx,o+z);\\n            \\n        }\\n        \\n        return mp[mx];\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n vector<int> maxScoreIndices(vector<int>& nums) {\\n        int o=0,z=0;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(nums[i]==1)\\n                o++;\\n        }\\n        int mx=INT_MIN;\\n        mp[o].push_back(0);\\n        mx=max(mx,o);\\n        \\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(nums[i]==1)\\n                o--;\\n            if(nums[i]==0)\\n                z++;\\n            \\n            mp[o+z].push_back(i+1);\\n            mx=max(mx,o+z);\\n            \\n        }\\n        \\n        return mp[mx];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730700,
                "title": "javascript-o-n-time-space-beat-100-solutions",
                "content": "```\\nvar maxScoreIndices = function(nums) {\\n    let oneCount = 0, zeroCount = 0, score = 0, maxScore = -Infinity;\\n    const map = {};\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === 1) oneCount++;\\n    }\\n    for(let i = 0; i <= nums.length; i++){\\n        const prev = nums[i-1];\\n        if(prev === 1) oneCount--;\\n        if(prev === 0) zeroCount++;\\n        score = oneCount + zeroCount;\\n        if(!map[score]){\\n            map[score] = [i];\\n        } else {\\n            map[score].push(i);\\n        }\\n        maxScore = Math.max(score, maxScore);\\n    }\\n    return map[maxScore];\\n};\\n```\\n</br>\\n\\n**Input:** [0,0,1,0]\\n**map:** { \\'1\\': [ 0 ], \\'2\\': [ 1, 3 ], \\'3\\': [ 2, 4 ] }\\n**output:** [2,4]\\n\\n</br>\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nvar maxScoreIndices = function(nums) {\\n    let oneCount = 0, zeroCount = 0, score = 0, maxScore = -Infinity;\\n    const map = {};\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === 1) oneCount++;\\n    }\\n    for(let i = 0; i <= nums.length; i++){\\n        const prev = nums[i-1];\\n        if(prev === 1) oneCount--;\\n        if(prev === 0) zeroCount++;\\n        score = oneCount + zeroCount;\\n        if(!map[score]){\\n            map[score] = [i];\\n        } else {\\n            map[score].push(i);\\n        }\\n        maxScore = Math.max(score, maxScore);\\n    }\\n    return map[maxScore];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730646,
                "title": "c-o-n",
                "content": "[0,0,1,0] \\nINITIALLY- \\nright sum = total sum  = 1\\nleft sum = 0\\n\\nIn loop - \\nAdd to left sum if current element = 0\\nSubtract from right sum if current element =1\\n[**0**,0,1,0]  here left = 1 and right = 1 [0] [0,1,0]\\n[0,**0**,1,0] left=2 right =1 [0,0] [1,0]\\n[0,0,**1**,0] left=2 right = 0 [0,0,1] [0]\\n[0,0,1,**0**] left=3 right =0 [0,0,1,0] [ ]\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int left=0;\\n        vector<int> v;\\n        vector<int> v1;\\n        int right=accumulate(nums.begin(), nums.end(), 0);\\n        v.push_back(left+right);\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0) left+=1;\\n            if(nums[i]==1) right-=1;\\n            v.push_back(left+right);\\n        }\\n        int a = *max_element(v.begin(), v.end());\\n        cout<<v.size();\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==a) v1.push_back(i);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int left=0;\\n        vector<int> v;\\n        vector<int> v1;\\n        int right=accumulate(nums.begin(), nums.end(), 0);\\n        v.push_back(left+right);\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0) left+=1;\\n            if(nums[i]==1) right-=1;\\n            v.push_back(left+right);\\n        }\\n        int a = *max_element(v.begin(), v.end());\\n        cout<<v.size();\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==a) v1.push_back(i);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1730542,
                "title": "python-easy-to-understand-solution",
                "content": "So simple and straight forward approach would be to first find out number on ones in list and then with progress we check if current element is one then we remove that element from the count else if it is zero then we increase number of 0\\'s.\\nwas pretty easy! I don\\'t know why I was not able to solve it in contest!\\n\\n```\\n def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        ones = nums.count(1)\\n        zeros = 0\\n        maxSum = 0\\n        for i in range(0,len(nums)+1):\\n            if (ones+zeros>maxSum):\\n                maxSum = ones+zeros\\n                ans.clear()\\n                ans.append(i)\\n            elif ones+zeros == maxSum:\\n                ans.append(i)\\n            if i!=len(nums):\\n                if nums[i] == 0:\\n                    zeros+=1\\n                elif nums[i] == 1:\\n                    ones-=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        ones = nums.count(1)\\n        zeros = 0\\n        maxSum = 0\\n        for i in range(0,len(nums)+1):\\n            if (ones+zeros>maxSum):\\n                maxSum = ones+zeros\\n                ans.clear()\\n                ans.append(i)\\n            elif ones+zeros == maxSum:\\n                ans.append(i)\\n            if i!=len(nums):\\n                if nums[i] == 0:\\n                    zeros+=1\\n                elif nums[i] == 1:\\n                    ones-=1\\n        return ans\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730528,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        leftSum = 0\\n        rightSum = sum(nums)\\n        Sum = [leftSum+rightSum]\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                leftSum +=1\\n            if nums[i]==1:\\n                rightSum -= 1\\n            Sum.append(leftSum+rightSum)\\n        maxValue = max(Sum)\\n        return( [i for i, v in enumerate(Sum) if v==maxValue])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        leftSum = 0\\n        rightSum = sum(nums)\\n        Sum = [leftSum+rightSum]\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                leftSum +=1\\n            if nums[i]==1:\\n                rightSum -= 1\\n            Sum.append(leftSum+rightSum)\\n        maxValue = max(Sum)\\n        return( [i for i, v in enumerate(Sum) if v==maxValue])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730498,
                "title": "python-3-o-n-easy-to-understand",
                "content": "* The idea is simple we will iterate the array and store the sum till current index.\\n* for 0 index our score will always be sum of all the values in array.\\n*  the count will maintain length of left part or prefix_sum.\\n*  to get the left_score \"count - prefix_sum\"  i.e number of zeros.\\n*  to get the right_score \"total - prefix_sum\" i.e we will subtract whatever is stored in left from\\nour total to get number of 1 in right.\\n```\\n\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dic = {}\\n        ans = []\\n        prefix_sum = 0\\n        left = 0 \\n        right = 0\\n \\xA0 \\xA0 \\xA0 \\xA0count = 0\\n        total = sum(nums)\\n        dic[0] = total \\n        for i in range(len(nums)):\\n            prefix_sum += nums[i]\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0count += 1\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0left = count - prefix_sum\\n            right = total - prefix_sum\\n            dic[i+1] = left + right\\n        # find highest score\\n        maximum = max(dic.values())\\n        # find index of highest score\\n        for k,v in dic.items():\\n            if v == maximum:\\n                ans.append(k);    \\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        dic = {}\\n        ans = []\\n        prefix_sum = 0\\n        left = 0 \\n        right = 0\\n \\xA0 \\xA0 \\xA0 \\xA0count = 0\\n        total = sum(nums)\\n        dic[0] = total \\n        for i in range(len(nums)):\\n            prefix_sum += nums[i]\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0count += 1\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0left = count - prefix_sum\\n            right = total - prefix_sum\\n            dic[i+1] = left + right\\n        # find highest score\\n        maximum = max(dic.values())\\n        # find index of highest score\\n        for k,v in dic.items():\\n            if v == maximum:\\n                ans.append(k);    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730488,
                "title": "easy-understanding-left-and-right-array-summation-o-n",
                "content": "```\\n// nums = [0,0,1,0]                         index  0,1,2,3,4\\n// left array [] , [0],[0,0],[0,0,1],[0,0,1,0] => [0,1,2,2,3] ; count the zeros\\n// right array[0,0,1,0],[0,0,1], [1,0],[0],[] =>  [1,1,1,0,0]; count the ones\\n// SUM                           (0+1),(1+1),(2+1),(2+0),(3+0)\\nclass Solution {\\n    public static List<Integer> maxScoreIndices(int[] nums) {\\n\\n        int[] left = new int[nums.length + 1 ]; \\n        int[] right = new int[nums.length + 1]; \\n\\n        left[0] = 0;\\n\\n        int prefixSum = 0;\\n\\t\\t// create a left array. \\n        for (int i = 0; i< nums.length; i++) {\\n            if (nums[i] == 0) {\\n                left[i+1] = prefixSum + 1;\\n                prefixSum = left[i+1];\\n            } else {\\n                left[i+1] = prefixSum;\\n            }\\n        }\\n        prefixSum = 0;\\n        right[nums.length] = 0;\\n\\t\\t//create right array\\n        for (int i = nums.length-1; i>= 0; i--) {\\n            if (nums[i] == 1) {\\n                right[i] = prefixSum + 1;\\n                prefixSum = right[i];\\n            } else {\\n                right[i] = prefixSum;\\n            }\\n        }\\n\\n        int max = 0;\\n\\n       List<Integer> res = new ArrayList<>();\\n\\n        int currMax = 0;\\n\\n        for (int i = 0; i <= nums.length ; i++) {\\n            currMax = left[i]  + right[i];\\n            if(max == currMax){\\n                res.add(i);\\n            } else if(max < currMax){\\n                max = currMax;\\n                res.clear();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n// nums = [0,0,1,0]                         index  0,1,2,3,4\\n// left array [] , [0],[0,0],[0,0,1],[0,0,1,0] => [0,1,2,2,3] ; count the zeros\\n// right array[0,0,1,0],[0,0,1], [1,0],[0],[] =>  [1,1,1,0,0]; count the ones\\n// SUM                           (0+1),(1+1),(2+1),(2+0),(3+0)\\nclass Solution {\\n    public static List<Integer> maxScoreIndices(int[] nums) {\\n\\n        int[] left = new int[nums.length + 1 ]; \\n        int[] right = new int[nums.length + 1]; \\n\\n        left[0] = 0;\\n\\n        int prefixSum = 0;\\n\\t\\t// create a left array. \\n        for (int i = 0; i< nums.length; i++) {\\n            if (nums[i] == 0) {\\n                left[i+1] = prefixSum + 1;\\n                prefixSum = left[i+1];\\n            } else {\\n                left[i+1] = prefixSum;\\n            }\\n        }\\n        prefixSum = 0;\\n        right[nums.length] = 0;\\n\\t\\t//create right array\\n        for (int i = nums.length-1; i>= 0; i--) {\\n            if (nums[i] == 1) {\\n                right[i] = prefixSum + 1;\\n                prefixSum = right[i];\\n            } else {\\n                right[i] = prefixSum;\\n            }\\n        }\\n\\n        int max = 0;\\n\\n       List<Integer> res = new ArrayList<>();\\n\\n        int currMax = 0;\\n\\n        for (int i = 0; i <= nums.length ; i++) {\\n            currMax = left[i]  + right[i];\\n            if(max == currMax){\\n                res.add(i);\\n            } else if(max < currMax){\\n                max = currMax;\\n                res.clear();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730464,
                "title": "java-counting-1-s-and-0-s-explained-with-comments",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n       \\n        // Let us create an array to store all the division scores\\n        \\n        int[] arr = new int[nums.length+1];\\n        \\n        // Now, we will count the total number of 1\\'s in the array so that I can calculate the division score as per the formula given below:\\n        \\n        // Division score = zeroes in left side + (total 1\\'s - 1\\'s left)\\n        \\n        int totalOnes = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                totalOnes++;\\n            }\\n        }\\n        \\n        int zeroesInLeft = 0, onesLeft = 0; //initalising them\\n        \\n        arr[0] = zeroesInLeft + (totalOnes - onesLeft);\\n        \\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                zeroesInLeft++;\\n            }\\n            else\\n            {\\n                onesLeft++;\\n            }\\n            \\n            arr[i+1] = zeroesInLeft + (totalOnes - onesLeft);\\n            \\n            // for each time the loop goes, it will calulate the number of 1\\'s and 0\\'s before the ith value that is, in the left side. As we already knew the total number of 1\\'s in the array. By simple mathematics we could also calculate the numbers of 1\\'s in the right side.\\n        }\\n        \\n        // As now, our array of division score - arr[] uis ready. We just have to find the max values with their index\\n        \\n        List<Integer> list = new ArrayList<Integer>();\\n        \\n        int max = -1;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i] > max)\\n            {\\n                max = arr[i];\\n            }\\n        }\\n        \\n        // now, have the max score with us.\\n        \\n        // As there can be multiple max scores, we will once again traverse through the array and add the indices in the list\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i] == max)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n       \\n        // Let us create an array to store all the division scores\\n        \\n        int[] arr = new int[nums.length+1];\\n        \\n        // Now, we will count the total number of 1\\'s in the array so that I can calculate the division score as per the formula given below:\\n        \\n        // Division score = zeroes in left side + (total 1\\'s - 1\\'s left)\\n        \\n        int totalOnes = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                totalOnes++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1730457,
                "title": "java-easy-prefix-suffix-arrays",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] arr) {\\n         int n = arr.length;\\n        //BASE CASES\\n         if(n == 1 && arr[0] == 0) return Arrays.asList(1);\\n         if(n == 1 && arr[0] == 1) return Arrays.asList(0);\\n         List<Integer> res = new ArrayList<>();\\n         int prefix[] = new int[n];\\n         int suffix[] = new int[n];\\n        \\n         prefix[0] = arr[0] == 0 ? 1 : 0;\\n        //Prepare prefix and suffix arrays to avoid recomputation for counting 0\\'s and 1\\'s\\n         for(int i = 1 ; i < n ; i++){\\n              prefix[i] = prefix[i - 1] + (arr[i] == 0 ? 1 : 0);\\n         }\\n        \\n         suffix[n - 1] = arr[n - 1];\\n        \\n         for(int i = n - 2 ; i >= 0 ; i--){\\n              suffix[i] = suffix[i + 1] + arr[i];\\n         }\\n         \\n         int maxScore = 0;\\n        //Calculate the maxscore using the given condition in the problem\\n         for(int i = 1 ; i < n ; i++){\\n              maxScore = Math.max(maxScore,prefix[i - 1] + suffix[i]);\\n             \\n         }\\n          maxScore = Math.max(maxScore,prefix[n - 1]);\\n          maxScore = Math.max(maxScore,suffix[0]);\\n        //Extract the indices having the maxscore \\n         for(int i = 1 ; i < n ; i++){\\n              if(prefix[i - 1] + suffix[i] == maxScore){\\n                   res.add(i);\\n              }\\n         }\\n        if(suffix[0] == maxScore) res.add(0);\\n        if(prefix[n - 1] == maxScore) res.add(n);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] arr) {\\n         int n = arr.length;\\n        //BASE CASES\\n         if(n == 1 && arr[0] == 0) return Arrays.asList(1);\\n         if(n == 1 && arr[0] == 1) return Arrays.asList(0);\\n         List<Integer> res = new ArrayList<>();\\n         int prefix[] = new int[n];\\n         int suffix[] = new int[n];\\n        \\n         prefix[0] = arr[0] == 0 ? 1 : 0;\\n        //Prepare prefix and suffix arrays to avoid recomputation for counting 0\\'s and 1\\'s\\n         for(int i = 1 ; i < n ; i++){\\n              prefix[i] = prefix[i - 1] + (arr[i] == 0 ? 1 : 0);\\n         }\\n        \\n         suffix[n - 1] = arr[n - 1];\\n        \\n         for(int i = n - 2 ; i >= 0 ; i--){\\n              suffix[i] = suffix[i + 1] + arr[i];\\n         }\\n         \\n         int maxScore = 0;\\n        //Calculate the maxscore using the given condition in the problem\\n         for(int i = 1 ; i < n ; i++){\\n              maxScore = Math.max(maxScore,prefix[i - 1] + suffix[i]);\\n             \\n         }\\n          maxScore = Math.max(maxScore,prefix[n - 1]);\\n          maxScore = Math.max(maxScore,suffix[0]);\\n        //Extract the indices having the maxscore \\n         for(int i = 1 ; i < n ; i++){\\n              if(prefix[i - 1] + suffix[i] == maxScore){\\n                   res.add(i);\\n              }\\n         }\\n        if(suffix[0] == maxScore) res.add(0);\\n        if(prefix[n - 1] == maxScore) res.add(n);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730399,
                "title": "cpp-o-n",
                "content": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>ans;\\n        int ones=0;\\n        for(int i:nums){\\n            if(i==1)ones++;\\n        }\\n        int zeros=0;\\n        int last = ones+zeros;\\n        ans.push_back(0);\\n        for(int i=1;i<=nums.size();i++){\\n            if(nums[i-1]==0)zeros++;\\n            else ones--;\\n            if(ones+zeros == last){\\n                ans.pb(i);\\n            }\\n            else if(ones+zeros>last){\\n                ans.clear();\\n                ans.pb(i);\\n                last=ones+zeros;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>ans;\\n        int ones=0;\\n        for(int i:nums){\\n            if(i==1)ones++;\\n        }\\n        int zeros=0;\\n        int last = ones+zeros;\\n        ans.push_back(0);\\n        for(int i=1;i<=nums.size();i++){\\n            if(nums[i-1]==0)zeros++;\\n            else ones--;\\n            if(ones+zeros == last){\\n                ans.pb(i);\\n            }\\n            else if(ones+zeros>last){\\n                ans.clear();\\n                ans.pb(i);\\n                last=ones+zeros;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730390,
                "title": "c-very-easy-o-n-time-learned-all-division-with-the-highest-score-of-binary-array",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<int> maxScoreIndices(std::vector<int> &nums) {\\n        int N = nums.size();\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        int score = total;\\n        int best = total;\\n        vector<int> res(1,0);\\n        for(int i=0; i<N; i++) {\\n            if(nums[i] == 0) {\\n                score += 1;\\n            } else {\\n                score -= 1;\\n            }\\n            \\n            if(best == score) {\\n                res.push_back(i+1);\\n            } else if(best < score) {\\n                best = score;\\n                res.clear();\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> maxScoreIndices(std::vector<int> &nums) {\\n        int N = nums.size();\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        int score = total;\\n        int best = total;\\n        vector<int> res(1,0);\\n        for(int i=0; i<N; i++) {\\n            if(nums[i] == 0) {\\n                score += 1;\\n            } else {\\n                score -= 1;\\n            }\\n            \\n            if(best == score) {\\n                res.push_back(i+1);\\n            } else if(best < score) {\\n                best = score;\\n                res.clear();\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730382,
                "title": "o-n-solution-4-passes-comments",
                "content": "```\\npublic IList<int> MaxScoreIndices(int[] nums)\\n{\\n\\tList<int> result = new List<int>();\\n\\tDictionary<int, int> zeroesLeftDict = new Dictionary<int, int>(); // key=>index value=>zeroCt\\n\\tDictionary<int, int> onesRightDict = new Dictionary<int, int>(); // key=>index value=>onesCt\\n\\t// Do one pass from left to right and load the 1st dict\\n\\tint zeroesCt = 0;\\n\\tzeroesLeftDict.Add(0, 0);\\n\\tfor (int i = 1; i <= nums.Length; i++)\\n\\t{\\n\\t\\tif (nums[i - 1] == 0)\\n\\t\\t{\\n\\t\\t\\tzeroesCt++;\\n\\t\\t\\tzeroesLeftDict.Add(i, zeroesCt);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tzeroesLeftDict.Add(i, zeroesCt);\\n\\t\\t}\\n\\t}\\n\\n\\t// Do one pass from right to left and load the 2nd dict\\n\\tint onesRight = 0;\\n\\tonesRightDict.Add(nums.Length, 0);\\n\\tfor (int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif (nums[i] == 1)\\n\\t\\t{\\n\\t\\t\\tonesRight++;\\n\\t\\t\\tonesRightDict.Add(i, onesRight);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tonesRightDict.Add(i, onesRight);\\n\\t\\t}\\n\\t}\\n\\n\\t// Do one pass from left to right and get the sum of left and right to find the max\\n\\tint max = 0;\\n\\tfor (int i = 0; i <= nums.Length; i++)\\n\\t{\\n\\t\\tint sum = zeroesLeftDict[i] + onesRightDict[i];\\n\\t\\tif (sum > max)\\n\\t\\t\\tmax = sum;\\n\\t}\\n\\n\\t// Do another pass from left to right to find everyone who has that max and push to the list of results\\n\\tfor (int i = 0; i <= nums.Length; i++)\\n\\t{\\n\\t\\tint sum = zeroesLeftDict[i] + onesRightDict[i];\\n\\t\\tif (sum == max)\\n\\t\\t\\tresult.Add(i);\\n\\t}\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<int> MaxScoreIndices(int[] nums)\\n{\\n\\tList<int> result = new List<int>();\\n\\tDictionary<int, int> zeroesLeftDict = new Dictionary<int, int>(); // key=>index value=>zeroCt\\n\\tDictionary<int, int> onesRightDict = new Dictionary<int, int>(); // key=>index value=>onesCt\\n\\t// Do one pass from left to right and load the 1st dict\\n\\tint zeroesCt = 0;\\n\\tzeroesLeftDict.Add(0, 0);\\n\\tfor (int i = 1; i <= nums.Length; i++)\\n\\t{\\n\\t\\tif (nums[i - 1] == 0)\\n\\t\\t{\\n\\t\\t\\tzeroesCt++;\\n\\t\\t\\tzeroesLeftDict.Add(i, zeroesCt);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tzeroesLeftDict.Add(i, zeroesCt);\\n\\t\\t}\\n\\t}\\n\\n\\t// Do one pass from right to left and load the 2nd dict\\n\\tint onesRight = 0;\\n\\tonesRightDict.Add(nums.Length, 0);\\n\\tfor (int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif (nums[i] == 1)\\n\\t\\t{\\n\\t\\t\\tonesRight++;\\n\\t\\t\\tonesRightDict.Add(i, onesRight);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tonesRightDict.Add(i, onesRight);\\n\\t\\t}\\n\\t}\\n\\n\\t// Do one pass from left to right and get the sum of left and right to find the max\\n\\tint max = 0;\\n\\tfor (int i = 0; i <= nums.Length; i++)\\n\\t{\\n\\t\\tint sum = zeroesLeftDict[i] + onesRightDict[i];\\n\\t\\tif (sum > max)\\n\\t\\t\\tmax = sum;\\n\\t}\\n\\n\\t// Do another pass from left to right to find everyone who has that max and push to the list of results\\n\\tfor (int i = 0; i <= nums.Length; i++)\\n\\t{\\n\\t\\tint sum = zeroesLeftDict[i] + onesRightDict[i];\\n\\t\\tif (sum == max)\\n\\t\\t\\tresult.Add(i);\\n\\t}\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730333,
                "title": "easy-c-solution-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n          int n = nums.size();\\n          int maxval = 0;\\n          priority_queue<pair<int, int>> pq;\\n          int count = 0;\\n         for(int i=0; i<n; i++)\\n         {\\n               if(nums[i] == 1)\\n                       count++;\\n         }\\n         if(maxval<=count)\\n         {\\n                 pq.push({count, 0});\\n                 maxval = count;\\n         }\\n         int r = count;\\n         int l = 0;\\n         for(int i=0; i<n; i++)\\n         {\\n               if(nums[i] == 0)\\n                    l++;\\n               else\\n                    r--;\\n              if(maxval<=l+r)\\n              {\\n                 pq.push({l+r, i+1});\\n                 maxval = l+r;\\n              }\\n         }\\n         vector<int> ans;\\n         if(maxval == 0)\\n             return ans;\\n         while(!pq.empty())\\n          {\\n                  pair p = pq.top();\\n                  pq.pop();\\n                   if(p.first == maxval)\\n                   {\\n                         ans.push_back(p.second);\\n                   }\\n          }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n          int n = nums.size();\\n          int maxval = 0;\\n          priority_queue<pair<int, int>> pq;\\n          int count = 0;\\n         for(int i=0; i<n; i++)\\n         {\\n               if(nums[i] == 1)\\n                       count++;\\n         }\\n         if(maxval<=count)\\n         {\\n                 pq.push({count, 0});\\n                 maxval = count;\\n         }\\n         int r = count;\\n         int l = 0;\\n         for(int i=0; i<n; i++)\\n         {\\n               if(nums[i] == 0)\\n                    l++;\\n               else\\n                    r--;\\n              if(maxval<=l+r)\\n              {\\n                 pq.push({l+r, i+1});\\n                 maxval = l+r;\\n              }\\n         }\\n         vector<int> ans;\\n         if(maxval == 0)\\n             return ans;\\n         while(!pq.empty())\\n          {\\n                  pair p = pq.top();\\n                  pq.pop();\\n                   if(p.first == maxval)\\n                   {\\n                         ans.push_back(p.second);\\n                   }\\n          }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730332,
                "title": "not-the-cleanest-but-in-detail",
                "content": "Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int totalOnes=0,totalZero=0;\\n        for(int i:nums){\\n            if(i==1) totalOnes++;\\n            if(i==0) totalZero++;\\n        }\\n        vector<int>ans;\\n        unordered_map<int,int>mp; //idx,score\\n        mp[0]=totalOnes;\\n        int n=nums.size();\\n        int onesSoFar=0, zeroSoFar=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) zeroSoFar++;\\n            else onesSoFar++;\\n            mp[i+1]=zeroSoFar+(totalOnes-onesSoFar);\\n        }        \\n        int maxScore=0;\\n        for(auto i:mp){\\n            if(i.second>maxScore) maxScore=i.second;\\n        }\\n        for(auto i:mp){\\n            if(i.second==maxScore) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nI dont think I need to explain anything, the varable names clear everything there is!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int totalOnes=0,totalZero=0;\\n        for(int i:nums){\\n            if(i==1) totalOnes++;\\n            if(i==0) totalZero++;\\n        }\\n        vector<int>ans;\\n        unordered_map<int,int>mp; //idx,score\\n        mp[0]=totalOnes;\\n        int n=nums.size();\\n        int onesSoFar=0, zeroSoFar=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) zeroSoFar++;\\n            else onesSoFar++;\\n            mp[i+1]=zeroSoFar+(totalOnes-onesSoFar);\\n        }        \\n        int maxScore=0;\\n        for(auto i:mp){\\n            if(i.second>maxScore) maxScore=i.second;\\n        }\\n        for(auto i:mp){\\n            if(i.second==maxScore) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730320,
                "title": "c-very-easy-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ones(n); //number of ones in the binary array till this index\\n        ones[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]) ones[i] = ones[i-1]+1;\\n            else ones[i] = ones[i-1];\\n        }\\n        int mx = 0;\\n        unordered_map<int, vector<int>> scores;\\n        for(int i=0; i<=n; i++){\\n            int score;\\n            if(i>=1)\\n                score = (i-ones[i-1]) + (ones[n-1] - ones[i-1]);\\n                        //0s in left      //ones in right\\n            else score = ones[n-1]; //for i=0, score would only be the number of ones in the right array\\n            scores[score].push_back(i);\\n            mx = max(mx, score);\\n        }\\n        return scores[mx];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ones(n); //number of ones in the binary array till this index\\n        ones[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]) ones[i] = ones[i-1]+1;\\n            else ones[i] = ones[i-1];\\n        }\\n        int mx = 0;\\n        unordered_map<int, vector<int>> scores;\\n        for(int i=0; i<=n; i++){\\n            int score;\\n            if(i>=1)\\n                score = (i-ones[i-1]) + (ones[n-1] - ones[i-1]);\\n                        //0s in left      //ones in right\\n            else score = ones[n-1]; //for i=0, score would only be the number of ones in the right array\\n            scores[score].push_back(i);\\n            mx = max(mx, score);\\n        }\\n        return scores[mx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730278,
                "title": "simple-c-o-n-solution-maintain-zeros-and-ones-array-and-just-add-them-up-at-particular-indexes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones[n+1];\\n        int zeros[n+1];\\n        zeros[0] = 0;\\n        ones[n]=0;\\n        int count =0;\\n          count = nums[0]==0?1:0;\\n        for(int i=1;i<n;i++){\\n             zeros[i]=count;\\n            if(nums[i]==0){\\n              count++;\\n            }\\n            \\n        }\\n        zeros[n]=count;\\n        int count1= nums[n-1]==1?1:0;\\n        for(int i=n-2;i>=0;i--){\\n            ones[i+1]=count1;\\n            if(nums[i]==1){\\n               count1++;\\n            }\\n            \\n        }\\n        ones[0]=count1;\\n      \\n        int mx[n+1];\\n        for(int i=0;i<n+1;i++){\\n            mx[i]=(ones[i]+zeros[i]);\\n        }\\n        int m = *max_element(mx,mx+n+1);\\n        vector<int>ans;\\n        for(int i=0;i<n+1;i++){\\n            if(mx[i]==m){\\n                ans.push_back(i);\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones[n+1];\\n        int zeros[n+1];\\n        zeros[0] = 0;\\n        ones[n]=0;\\n        int count =0;\\n          count = nums[0]==0?1:0;\\n        for(int i=1;i<n;i++){\\n             zeros[i]=count;\\n            if(nums[i]==0){\\n              count++;\\n            }\\n            \\n        }\\n        zeros[n]=count;\\n        int count1= nums[n-1]==1?1:0;\\n        for(int i=n-2;i>=0;i--){\\n            ones[i+1]=count1;\\n            if(nums[i]==1){\\n               count1++;\\n            }\\n            \\n        }\\n        ones[0]=count1;\\n      \\n        int mx[n+1];\\n        for(int i=0;i<n+1;i++){\\n            mx[i]=(ones[i]+zeros[i]);\\n        }\\n        int m = *max_element(mx,mx+n+1);\\n        vector<int>ans;\\n        for(int i=0;i<n+1;i++){\\n            if(mx[i]==m){\\n                ans.push_back(i);\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730246,
                "title": "java-o-n-by-simply-calculating-and-updating-0s-and-1s-in-left-array",
                "content": "```\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class AllDivisionsWithHigherScore {\\n\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int[] divisionScores = new int[nums.length + 1];\\n\\n        int totalOnes = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                totalOnes++;\\n            }\\n        }\\n        int zerosInLeft = 0;\\n        int onesInLeft = 0;\\n        divisionScores[0] = zerosInLeft + (totalOnes - onesInLeft);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                zerosInLeft++;\\n            } else {\\n                onesInLeft++;\\n            }\\n\\n            divisionScores[i + 1] = zerosInLeft + (totalOnes - onesInLeft);\\n\\n        }\\n        int maxScore = -1;\\n\\n        for (int val : divisionScores) {\\n            if (val > maxScore) {\\n                maxScore = val;\\n            }\\n        }\\n\\n        List<Integer> maxScoresList = new ArrayList<>();\\n\\n        for (int i = 0; i < divisionScores.length; i++) {\\n            if (divisionScores[i] == maxScore) {\\n                maxScoresList.add(i);\\n            }\\n        }\\n        return maxScoresList;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class AllDivisionsWithHigherScore {\\n\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int[] divisionScores = new int[nums.length + 1];\\n\\n        int totalOnes = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                totalOnes++;\\n            }\\n        }\\n        int zerosInLeft = 0;\\n        int onesInLeft = 0;\\n        divisionScores[0] = zerosInLeft + (totalOnes - onesInLeft);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                zerosInLeft++;\\n            } else {\\n                onesInLeft++;\\n            }\\n\\n            divisionScores[i + 1] = zerosInLeft + (totalOnes - onesInLeft);\\n\\n        }\\n        int maxScore = -1;\\n\\n        for (int val : divisionScores) {\\n            if (val > maxScore) {\\n                maxScore = val;\\n            }\\n        }\\n\\n        List<Integer> maxScoresList = new ArrayList<>();\\n\\n        for (int i = 0; i < divisionScores.length; i++) {\\n            if (divisionScores[i] == maxScore) {\\n                maxScoresList.add(i);\\n            }\\n        }\\n        return maxScoresList;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730241,
                "title": "easy-c-o-n-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int one=0;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]==1) one++;\\n        }\\n        \\n        vector<int> ans;\\n        int maxx=0;\\n        int zero1=0;\\n        \\n        for(int i=0 ; i<=nums.size() ; i++){\\n            int sum;\\n            if(i==0) sum=one;\\n            else if(i==nums.size()) {\\n                if(nums[i-1]==0)zero1++;\\n                sum=zero1;\\n            }\\n            else{\\n                if(nums[i-1]==0) zero1++;\\n                else one--;    \\n                \\n                sum=zero1+one;\\n            }\\n            \\n            // ans.push_back(sum);\\n            // maxx=max(sum , maxx);\\n            \\n            if(sum>maxx){\\n                ans.clear();\\n                ans.push_back(i);\\n                maxx=sum;\\n            }\\n            else if(sum==maxx){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int one=0;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]==1) one++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730220,
                "title": "java-sliding-window",
                "content": "Get the maximum number of 1 values in the array. From there use the sliding window approach to keep track of 0 values on the left side of the array and the 1 values remaining on the right side of the array. \\n\\nFind the total amount of 1 values available in the array and as our left index increments, if `nums[left] == 1` then that is one less `1` value available on the right side of the array. \\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> ans = new ArrayList();\\n        \\n        int max = 0;\\n        int left = 0;\\n        int right = 0;\\n        int curr = 0;\\n        int ones = 0;\\n        for (int i: nums){\\n            if (i == 1)\\n                ones++; // total amount of 1 values \\n        }\\n        \\n        int rightVal = ones; //the amount of 1 values in the right side of the array\\n        int leftVal = 0;\\n        while (right <= nums.length){\\n            if (right == 0){\\n                curr += ones;\\n                max = curr;\\n            }\\n            else if (right == nums.length){\\n                curr += nums.length - ones;\\n            }\\n            else{\\n                if (nums[left++] == 0){\\n                    leftVal++;\\n                }//if nums[left] is 1 then decrement rightVal as it is one less 1 value available on the right \\n                else{\\n                    rightVal--; \\n                }\\n                curr += Math.max(rightVal, 0);\\n                curr += leftVal;\\n            }\\n            \\n            if (curr == max){\\n                ans.add(right);\\n            }\\n            else if (curr > max){\\n                ans = new ArrayList<Integer>(Arrays.asList(right));\\n                max = curr;\\n            }\\n            \\n            curr = 0;\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> ans = new ArrayList();\\n        \\n        int max = 0;\\n        int left = 0;\\n        int right = 0;\\n        int curr = 0;\\n        int ones = 0;\\n        for (int i: nums){\\n            if (i == 1)\\n                ones++; // total amount of 1 values \\n        }\\n        \\n        int rightVal = ones; //the amount of 1 values in the right side of the array\\n        int leftVal = 0;\\n        while (right <= nums.length){\\n            if (right == 0){\\n                curr += ones;\\n                max = curr;\\n            }\\n            else if (right == nums.length){\\n                curr += nums.length - ones;\\n            }\\n            else{\\n                if (nums[left++] == 0){\\n                    leftVal++;\\n                }//if nums[left] is 1 then decrement rightVal as it is one less 1 value available on the right \\n                else{\\n                    rightVal--; \\n                }\\n                curr += Math.max(rightVal, 0);\\n                curr += leftVal;\\n            }\\n            \\n            if (curr == max){\\n                ans.add(right);\\n            }\\n            else if (curr > max){\\n                ans = new ArrayList<Integer>(Arrays.asList(right));\\n                max = curr;\\n            }\\n            \\n            curr = 0;\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730218,
                "title": "java-simple-o-n-two-loop",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int max = 0;\\n        int maxIndex = 0;\\n        for(int n : nums){\\n            max += n;\\n        }\\n        int l = 0;\\n        int r = max;\\n        List<Integer> out = new ArrayList<>();\\n        out.add(0);\\n        for(int i=1;i<=nums.length;i++){\\n            if(nums[i-1] == 0){\\n                l++;\\n            }else {\\n                r--;\\n            }\\n            if(l + r > max){\\n                max = l+r;\\n                out.clear();\\n                out.add(i);\\n            }else if(l+r == max){\\n                out.add(i);\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int max = 0;\\n        int maxIndex = 0;\\n        for(int n : nums){\\n            max += n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730207,
                "title": "simple-java-solution-linear-time-map",
                "content": "```\\nclass Solution {\\n   public List<Integer> maxScoreIndices(int[] nums) {\\n\\t\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tint countOne = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 1) {\\n\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint zeroCount = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint max = countOne;\\n\\t\\tList<Integer> first = new ArrayList<>();\\n\\t\\tfirst.add(0);\\n\\t\\tmap.put(countOne, first);\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tzeroCount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountOne--;\\n\\t\\t\\t}\\n\\t\\t\\tans = zeroCount + countOne;\\n\\t\\t\\tmax = Math.max(ans, max);\\n\\t\\t\\tList<Integer> list = map.get(ans);\\n\\t\\t\\tif (list == null) {\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t}\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t\\tmap.put(ans, list);\\n\\t\\t}\\n\\n\\t\\treturn map.getOrDefault(max, new ArrayList<>());\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public List<Integer> maxScoreIndices(int[] nums) {\\n\\t\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tint countOne = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 1) {\\n\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint zeroCount = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint max = countOne;\\n\\t\\tList<Integer> first = new ArrayList<>();\\n\\t\\tfirst.add(0);\\n\\t\\tmap.put(countOne, first);\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tzeroCount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountOne--;\\n\\t\\t\\t}\\n\\t\\t\\tans = zeroCount + countOne;\\n\\t\\t\\tmax = Math.max(ans, max);\\n\\t\\t\\tList<Integer> list = map.get(ans);\\n\\t\\t\\tif (list == null) {\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t}\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t\\tmap.put(ans, list);\\n\\t\\t}\\n\\n\\t\\treturn map.getOrDefault(max, new ArrayList<>());\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730157,
                "title": "java-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n=nums.length;\\n        List<Integer> ans=new LinkedList<>();\\n        int sum=0,max=0;\\n        for(int x:nums)\\n        {\\n            sum+=x;\\n        }\\n        max=Math.max(max,sum);\\n        max=Math.max(max,n-sum);\\n        int i=1;\\n        while(i<n)\\n        {\\n            \\n            int noOfOnes=sum-nums[i-1];\\n            int noOfZeroes=i-nums[i-1];\\n            max=Math.max(max,noOfZeroes+noOfOnes);\\n            nums[i]=nums[i-1]+nums[i];\\n            ++i;\\n        }\\n        i=1;\\n        while(i<n)\\n        {\\n            int noOfOnes=sum-nums[i-1];\\n            int noOfZeroes=i-nums[i-1];\\n            if(max==noOfZeroes+noOfOnes)\\n                ans.add(i);\\n            ++i;\\n        }\\n        if(max==sum)\\n            ans.add(0);\\n        if(max==n-sum)\\n            ans.add(n);\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n=nums.length;\\n        List<Integer> ans=new LinkedList<>();\\n        int sum=0,max=0;\\n        for(int x:nums)\\n        {\\n            sum+=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1730120,
                "title": "simple-java-solution",
                "content": "```\\n public static List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[nums.length+1];\\n        int[] right= new int[nums.length+1];\\n        int zc = 0 ,oc = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            int cur = nums[i];\\n            zc  +=  cur == 0 ? 1 : 0;\\n            oc  +=  nums[nums.length-i-1] == 1 ? 1 : 0;\\n            left[i+1]  = zc;\\n            if(nums.length-i-1 >= 0){\\n                right[nums.length-i-1] = oc;\\n            }\\n        }\\n\\n        int max = -1 , score = 0;\\n        for (int i = 0; i <= nums.length ; i++) {\\n            score = left[i]  + right[i];\\n            if(max == score){\\n                result.add(i);\\n            }\\n            if(max < score){\\n                max = score;\\n                result.clear();\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[nums.length+1];\\n        int[] right= new int[nums.length+1];\\n        int zc = 0 ,oc = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            int cur = nums[i];\\n            zc  +=  cur == 0 ? 1 : 0;\\n            oc  +=  nums[nums.length-i-1] == 1 ? 1 : 0;\\n            left[i+1]  = zc;\\n            if(nums.length-i-1 >= 0){\\n                right[nums.length-i-1] = oc;\\n            }\\n        }\\n\\n        int max = -1 , score = 0;\\n        for (int i = 0; i <= nums.length ; i++) {\\n            score = left[i]  + right[i];\\n            if(max == score){\\n                result.add(i);\\n            }\\n            if(max < score){\\n                max = score;\\n                result.clear();\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037767,
                "title": "a-clear-o-n-solution",
                "content": "# Intuition\\nIf we know the score for division at index $$i$$, then calculating the score for $$i + 1$$ is easy.\\n\\nWhen we move from $$i$$ to $$i + 1$$ state, we remove $$nums[i]$$ from $$nums_{right}$$ and then add it to $$nums_{left}$$.\\n\\n- If $$nums[i]$$ is $$0$$, then it is a gain for $$nums_{left}$$. $$nums_{right}$$ isn\\'t affected. So, we increment previous score.\\n- If $$nums[i]$$ is $$1$$, then it is a loss for $$nums_{right}$$. $$nums_{left}$$ isn\\'t affected. So, we decrement previous score.\\n\\nIf we can come up with the score for $$i = 0$$, then we can compute the rest of the scores in one pass.\\n\\n# Approach\\nWhat is the score for $$i = 0$$?\\n\\nIn $$i = 0$$ state, $$nums_{left}$$ is empty. $$nums_{right}$$ is the entire array. So, the score is equal to number of $$1$$s in the entire array:\\n\\n```python\\nscore = sum(nums)\\n```\\n\\nWe also need to keep track of the maximum score found so far and the indices that can give this maximum score. Initially, the maximum score is the score for $$i = 0$$ and the only index that gives this score is index $$0$$:\\n\\n```python\\nmax_score, indices = score, [0]\\n```\\n\\nWe go through the entire array and at each step we compute a new `score`:\\n\\n```python\\nfor i, num in enumerate(nums):\\n    if num == 0:\\n        score += 1\\n    else:\\n        score -= 1\\n```\\n\\nNow with that new score, we may have 3 outcomes:\\n\\n1. New `score` is less than the `max_score`. Nothing needs to be updated.\\n2. New `score` is more than the `max_score`. `max_score` is updated. We just reached this `max_score` and only index that gives this `max_score` is the current one. So, `indices` becomes `[i + 1]`.\\n3. New `score` is equal to the `max_score`. We found a new index that gives this `max_score`. So, we append `i + 1` to `indices`.\\n\\nLet\\'s add this logic:\\n\\n```python\\nfor i, num in enumerate(nums):\\n    .\\n    .\\n    .\\n    if score > max_score:\\n        max_score, indices = score, [i + 1]\\n    elif score == max_score:\\n        indices.append(i + 1)\\n```\\n\\nAt the end, we return `indices`:\\n\\n```python\\nreturn indices\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nWe pass through the array twice. Once for counting $$1$$s and once for figuring out the `max_score` and `indices`.\\n\\n- Space complexity: $$O(n)$$\\nWe only allocate for `indices` and when $$nums$$ has a pattern of $$0, 1, 0, 1, 0, 1$$, `indices` may have $$O(\\\\frac{n}{2})$$ elements.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        score = sum(nums)\\n        max_score, result = score, [0]\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                score += 1\\n            else:\\n                score -= 1\\n\\n            if score > max_score:\\n                max_score, result = score, [i + 1]\\n            elif score == max_score:\\n                result.append(i + 1)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nscore = sum(nums)\\n```\n```python\\nmax_score, indices = score, [0]\\n```\n```python\\nfor i, num in enumerate(nums):\\n    if num == 0:\\n        score += 1\\n    else:\\n        score -= 1\\n```\n```python\\nfor i, num in enumerate(nums):\\n    .\\n    .\\n    .\\n    if score > max_score:\\n        max_score, indices = score, [i + 1]\\n    elif score == max_score:\\n        indices.append(i + 1)\\n```\n```python\\nreturn indices\\n```\n```python\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        score = sum(nums)\\n        max_score, result = score, [0]\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                score += 1\\n            else:\\n                score -= 1\\n\\n            if score > max_score:\\n                max_score, result = score, [i + 1]\\n            elif score == max_score:\\n                result.append(i + 1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036127,
                "title": "c-counting-ones-to-right-zeros-to-left-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int one = 0, zero = 0, max_div = -1;\\n        vector<int> res;\\n\\n        for(auto num: nums) one += num;\\n\\n        for(int i=0; i<=nums.size(); i++)\\n        {\\n            if(one + zero >= max_div)\\n            {\\n                if(one + zero > max_div) res.clear();\\n                res.push_back(i);\\n                max_div = one + zero;\\n            }\\n\\n            if(i < nums.size()) zero = nums[i] == 0 ? zero+1:zero;\\n            if(i < nums.size()) one = nums[i] == 1 ? one-1:one;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int one = 0, zero = 0, max_div = -1;\\n        vector<int> res;\\n\\n        for(auto num: nums) one += num;\\n\\n        for(int i=0; i<=nums.size(); i++)\\n        {\\n            if(one + zero >= max_div)\\n            {\\n                if(one + zero > max_div) res.clear();\\n                res.push_back(i);\\n                max_div = one + zero;\\n            }\\n\\n            if(i < nums.size()) zero = nums[i] == 0 ? zero+1:zero;\\n            if(i < nums.size()) one = nums[i] == 1 ? one-1:one;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032191,
                "title": "python-clean-and-simple",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, A: list[int]) -> list[int]:\\n        output, s = [], -1\\n\\n        for i, score in enumerate(self.generate_scores(A)):\\n            if s < score:\\n                output, s = [i], score\\n            elif s == score:\\n                output.append(i)\\n\\n        return output\\n\\n    @staticmethod\\n    def generate_scores(A: list[int]):\\n        zeros, ones = 0, sum(A)\\n        yield zeros + ones\\n\\n        for a in A:\\n            if a == 0:\\n                zeros += 1\\n            elif a == 1:\\n                ones -= 1\\n\\n            yield zeros + ones\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, A: list[int]) -> list[int]:\\n        output, s = [], -1\\n\\n        for i, score in enumerate(self.generate_scores(A)):\\n            if s < score:\\n                output, s = [i], score\\n            elif s == score:\\n                output.append(i)\\n\\n        return output\\n\\n    @staticmethod\\n    def generate_scores(A: list[int]):\\n        zeros, ones = 0, sum(A)\\n        yield zeros + ones\\n\\n        for a in A:\\n            if a == 0:\\n                zeros += 1\\n            elif a == 1:\\n                ones -= 1\\n\\n            yield zeros + ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021299,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    int *res=malloc(sizeof(int)*numsSize);\\n    int left_zero=0,right_one=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) right_one++;\\n    }\\n    int max_score=right_one;\\n    res[0]=0;\\n    *returnSize=1;\\n    int ans=-1;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==0) left_zero++;\\n        if(nums[i]==1) right_one--;\\n        // printf(\"left_zero:%d | right_one:%d\\\\n\",left_zero,right_one);\\n        if(max_score < (left_zero+right_one)){\\n            *returnSize=0;\\n            res[(*returnSize)++]=i+1;\\n            max_score=left_zero+right_one;\\n        }\\n        else if(max_score == (left_zero+right_one)){\\n            res[(*returnSize)++]=i+1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    int *res=malloc(sizeof(int)*numsSize);\\n    int left_zero=0,right_one=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) right_one++;\\n    }\\n    int max_score=right_one;\\n    res[0]=0;\\n    *returnSize=1;\\n    int ans=-1;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==0) left_zero++;\\n        if(nums[i]==1) right_one--;\\n        // printf(\"left_zero:%d | right_one:%d\\\\n\",left_zero,right_one);\\n        if(max_score < (left_zero+right_one)){\\n            *returnSize=0;\\n            res[(*returnSize)++]=i+1;\\n            max_score=left_zero+right_one;\\n        }\\n        else if(max_score == (left_zero+right_one)){\\n            res[(*returnSize)++]=i+1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018079,
                "title": "java-o-1-space-and-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int one = 0 , zero = 0  , maxd =  -1;\\n        List<Integer> res = new ArrayList<>();\\n\\n        for( var el : nums) if( el == 1) one++;// calc number of 1\\n        \\n        for( int i  = 0 ; i <= nums.length ;i++){\\n            \\n            if( one+zero == maxd ) res.add(i);\\n            else if(one+zero > maxd) {\\n                maxd = one+zero ;\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n            if( i < nums.length && nums[i] == 0) zero++;\\n            if(i < nums.length && nums[i] == 1) one--;\\n            \\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int one = 0 , zero = 0  , maxd =  -1;\\n        List<Integer> res = new ArrayList<>();\\n\\n        for( var el : nums) if( el == 1) one++;// calc number of 1\\n        \\n        for( int i  = 0 ; i <= nums.length ;i++){\\n            \\n            if( one+zero == maxd ) res.add(i);\\n            else if(one+zero > maxd) {\\n                maxd = one+zero ;\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n            if( i < nums.length && nums[i] == 0) zero++;\\n            if(i < nums.length && nums[i] == 1) one--;\\n            \\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898556,
                "title": "using-prefix-sum-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main idea is to build, prefix sum for counting 0es and postfixSum to count 1s.\\n1. we need prefixSum in order to tell the amount of zeroes at a given index in O(1) from left to right\\n2. we need postfixSum in order to tell the number of ones at a given index in O(1) from right to left\\n3. Now we can start iterating over nums and keep track of the maximum sum at each ith position\\n\\n# Complexity\\n- Time complexity:\\n$$O(3n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar maxScoreIndices = function(nums) {\\n    const zeroesPref=[nums[0]===0?1:0], onecePost=Array(nums.length).fill(0);\\n    onecePost[onecePost.length-1]=nums[nums.length-1];\\n\\n    // Build prefix sum of Zeroes (left to right)\\n    for(let i=1;i<nums.length;i++)zeroesPref[i]=zeroesPref[i-1]+(nums[i]===0?1:0);\\n    \\n    // Build postfix sum of Ones (right to left)\\n    for(let i=nums.length-2;i>=0;i--)onecePost[i]=onecePost[i+1]+nums[i];\\n\\n    // e.g: nums=[0,1,0,0], countZeroes(3)=2 (there are 2 zeroes from left)\\n    const countZeroes=(i)=>{\\n        if(i===0) return 0;\\n        return zeroesPref[i-1];\\n    }\\n\\n    // e.g: nums=[1,1,1,0], countZeroes(1)=2 (there are two ones from the right)\\n    const countOnes=(i)=>{\\n        if(i===nums.length) return 0;\\n        return onecePost[i];\\n    }\\n\\n    let sum=Number.MIN_SAFE_INTEGER, resultMap=[], maxS;\\n    for(let i=0;i<=nums.length;i++){\\n        const newSum = countZeroes(i)+countOnes(i);\\n        sum=Math.max(sum, newSum);// track maximum sum\\n        \\n        // track indexes of ALL sums\\n        if(resultMap[newSum]) resultMap[newSum].push(i);\\n        else{resultMap[newSum]=[i];}        \\n    }\\n    return resultMap[sum]; // return maximum sum indexes\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxScoreIndices = function(nums) {\\n    const zeroesPref=[nums[0]===0?1:0], onecePost=Array(nums.length).fill(0);\\n    onecePost[onecePost.length-1]=nums[nums.length-1];\\n\\n    // Build prefix sum of Zeroes (left to right)\\n    for(let i=1;i<nums.length;i++)zeroesPref[i]=zeroesPref[i-1]+(nums[i]===0?1:0);\\n    \\n    // Build postfix sum of Ones (right to left)\\n    for(let i=nums.length-2;i>=0;i--)onecePost[i]=onecePost[i+1]+nums[i];\\n\\n    // e.g: nums=[0,1,0,0], countZeroes(3)=2 (there are 2 zeroes from left)\\n    const countZeroes=(i)=>{\\n        if(i===0) return 0;\\n        return zeroesPref[i-1];\\n    }\\n\\n    // e.g: nums=[1,1,1,0], countZeroes(1)=2 (there are two ones from the right)\\n    const countOnes=(i)=>{\\n        if(i===nums.length) return 0;\\n        return onecePost[i];\\n    }\\n\\n    let sum=Number.MIN_SAFE_INTEGER, resultMap=[], maxS;\\n    for(let i=0;i<=nums.length;i++){\\n        const newSum = countZeroes(i)+countOnes(i);\\n        sum=Math.max(sum, newSum);// track maximum sum\\n        \\n        // track indexes of ALL sums\\n        if(resultMap[newSum]) resultMap[newSum].push(i);\\n        else{resultMap[newSum]=[i];}        \\n    }\\n    return resultMap[sum]; // return maximum sum indexes\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860312,
                "title": "java-arrays-counting",
                "content": "# Intuition\\nCount the numbers of zeros and ones in the array. Again iterate the array and for each index, calculate number of zeros on the left and number of ones in the right. Calculate the score and maintain a hashmap of score as key and indexes of those score as the values. In the end return the indices related to the highest score.\\n\\n# Approach\\n1. Iterate through the array and count number of zeros and ones.\\n2. Again iterate through the array and maintain two variables: zero_left and one_right.\\n3. For each element, if it is zero then increment zero_left otherwise decrement one_right;\\n4. Calculate the score (zero_left + one_right) and maintain a hashmap of scores to indices. \\n5. In the end return the list of indices related to the highest score.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the number of elements in the array.\\n\\n- Space complexity:\\nO(n), where n is the number of elements in the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int total_zero = 0, total_one = 0;\\n        total_zero = (int)Arrays.stream(nums).boxed().filter(i -> i == 0).count();\\n        total_one = (int)Arrays.stream(nums).boxed().filter(i -> i == 1).count();\\n        Map<Integer, List<Integer>> cache = new HashMap<>();\\n        int max = -1, zero_left = 0, one_right = total_one, score = 0;\\n        for(int i = 0; i <= nums.length; i++) {\\n            if(i == 0 ) {\\n                score = total_one;\\n            }\\n            else if(i == nums.length) {\\n                score = total_zero;\\n            }\\n            else {\\n                int num = nums[i - 1];\\n                if(num == 0) {\\n                    zero_left++;\\n                }\\n                else {\\n                    one_right--;\\n                }\\n                score = zero_left + one_right;\\n            }\\n            cache.putIfAbsent(score, new ArrayList<>());\\n            cache.get(score).add(i);\\n            max = Math.max(max, score);\\n        }\\n        return cache.get(max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int total_zero = 0, total_one = 0;\\n        total_zero = (int)Arrays.stream(nums).boxed().filter(i -> i == 0).count();\\n        total_one = (int)Arrays.stream(nums).boxed().filter(i -> i == 1).count();\\n        Map<Integer, List<Integer>> cache = new HashMap<>();\\n        int max = -1, zero_left = 0, one_right = total_one, score = 0;\\n        for(int i = 0; i <= nums.length; i++) {\\n            if(i == 0 ) {\\n                score = total_one;\\n            }\\n            else if(i == nums.length) {\\n                score = total_zero;\\n            }\\n            else {\\n                int num = nums[i - 1];\\n                if(num == 0) {\\n                    zero_left++;\\n                }\\n                else {\\n                    one_right--;\\n                }\\n                score = zero_left + one_right;\\n            }\\n            cache.putIfAbsent(score, new ArrayList<>());\\n            cache.get(score).add(i);\\n            max = Math.max(max, score);\\n        }\\n        return cache.get(max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853498,
                "title": "all-divisions-with-the-highest-score-of-a-binary-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int sum0 = 0;\\n        int sum1 = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            sum0++;\\n            else if(nums[i]==1)\\n            sum1++;\\n        }\\n        int[] nlft = new int[nums.length+1];\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            nlft[i+1] = sum0;\\n            if(nums[i]==0)\\n            sum0--;\\n        }\\n        nlft[0] = 0;\\n        int[] nrgt = new int[nums.length+1];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nrgt[i] = sum1;\\n            if(nums[i]==1)\\n            sum1--;\\n        }\\n        nrgt[nums.length]=0;\\n        int max =0;\\n        for(int i=0;i<nlft.length;i++)\\n        {\\n            max = Math.max(max,nlft[i]+nrgt[i]);\\n        }\\n        ArrayList<Integer> arr1 = new ArrayList<Integer>();\\n        for(int i=0;i<nlft.length;i++)\\n        {\\n            if(max==nlft[i]+nrgt[i])\\n            arr1.add(i);\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int sum0 = 0;\\n        int sum1 = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            sum0++;\\n            else if(nums[i]==1)\\n            sum1++;\\n        }\\n        int[] nlft = new int[nums.length+1];\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            nlft[i+1] = sum0;\\n            if(nums[i]==0)\\n            sum0--;\\n        }\\n        nlft[0] = 0;\\n        int[] nrgt = new int[nums.length+1];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nrgt[i] = sum1;\\n            if(nums[i]==1)\\n            sum1--;\\n        }\\n        nrgt[nums.length]=0;\\n        int max =0;\\n        for(int i=0;i<nlft.length;i++)\\n        {\\n            max = Math.max(max,nlft[i]+nrgt[i]);\\n        }\\n        ArrayList<Integer> arr1 = new ArrayList<Integer>();\\n        for(int i=0;i<nlft.length;i++)\\n        {\\n            if(max==nlft[i]+nrgt[i])\\n            arr1.add(i);\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853134,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums)\\n    {\\n        int zero=0;\\n        int one=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) zero++;\\n            else one++;\\n        }\\n        int curZero=0;\\n        int curOne=0;\\n        int maxi=max(one,zero);\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) curZero++;\\n            else curOne++;\\n            maxi=max(maxi,curZero+one-curOne);\\n        }\\n        vector<int>ans;\\n        curZero=0;\\n        curOne=0;\\n        if (maxi==one) ans.push_back(0);\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) curZero++;\\n            else curOne++;\\n            int cur=curZero+one-curOne;\\n            if (cur==maxi) ans.push_back(i+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums)\\n    {\\n        int zero=0;\\n        int one=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) zero++;\\n            else one++;\\n        }\\n        int curZero=0;\\n        int curOne=0;\\n        int maxi=max(one,zero);\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) curZero++;\\n            else curOne++;\\n            maxi=max(maxi,curZero+one-curOne);\\n        }\\n        vector<int>ans;\\n        curZero=0;\\n        curOne=0;\\n        if (maxi==one) ans.push_back(0);\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]==0) curZero++;\\n            else curOne++;\\n            int cur=curZero+one-curOne;\\n            if (cur==maxi) ans.push_back(i+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814103,
                "title": "very-easy-cpp",
                "content": "vector<int> maxScoreIndices(vector<int>& nums)\\n    {\\n        int o=0,z=0,n=nums.size(),ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(nums[i])\\n                o++;\\n        int tmp=o;\\n        ans=max(ans,o+z);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n                o--;\\n            else\\n                z++;\\n            ans=max(ans,o+z);\\n        }\\n        o=tmp;\\n        z=0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(o+z==ans)\\n                res.push_back(i);\\n            if(nums[i]==1)\\n                o--;\\n            else\\n                z++;\\n        }\\n        if(o+z==ans)\\n            res.push_back(n);\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "vector<int> maxScoreIndices(vector<int>& nums)\\n    {\\n        int o=0,z=0,n=nums.size(),ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(nums[i])\\n                o++;\\n        int tmp=o;\\n        ans=max(ans,o+z);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n                o--;\\n            else\\n                z++;\\n            ans=max(ans,o+z);\\n        }\\n        o=tmp;\\n        z=0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(o+z==ans)\\n                res.push_back(i);\\n            if(nums[i]==1)\\n                o--;\\n            else\\n                z++;\\n        }\\n        if(o+z==ans)\\n            res.push_back(n);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795208,
                "title": "beat-100-with-tc-o-n-and-sc-o-n-in-worst-cases",
                "content": "# Intuition\\nCaculate the right and left score and loop through again and find the number if equals to 0 then do leftscrore increment and if not do right score decreament\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in worst cases\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxScoreIndices(nums []int) []int {\\n\\tmaxIndices := []int{0}\\n\\tleftScore, rightScore, noOfOnes, maxScore := 0, 0, 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tif num == 1 {\\n\\t\\t\\tnoOfOnes++\\n\\t\\t}\\n\\t}\\n\\trightScore = noOfOnes\\n\\tmaxScore = leftScore + rightScore\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == 0 {\\n\\t\\t\\tleftScore++\\n\\t\\t} else if nums[i] == 1 {\\n\\t\\t\\trightScore--\\n\\t\\t}\\n\\n\\t\\tcurrentScore := leftScore + rightScore\\n\\t\\tif currentScore > maxScore {\\n\\t\\t\\tmaxScore = currentScore\\n\\t\\t\\tmaxIndices = []int{i + 1}\\n\\t\\t} else if currentScore == maxScore {\\n\\t\\t\\tmaxIndices = append(maxIndices, i+1)\\n\\t\\t}\\n\\t}\\n\\treturn maxIndices\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxScoreIndices(nums []int) []int {\\n\\tmaxIndices := []int{0}\\n\\tleftScore, rightScore, noOfOnes, maxScore := 0, 0, 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tif num == 1 {\\n\\t\\t\\tnoOfOnes++\\n\\t\\t}\\n\\t}\\n\\trightScore = noOfOnes\\n\\tmaxScore = leftScore + rightScore\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == 0 {\\n\\t\\t\\tleftScore++\\n\\t\\t} else if nums[i] == 1 {\\n\\t\\t\\trightScore--\\n\\t\\t}\\n\\n\\t\\tcurrentScore := leftScore + rightScore\\n\\t\\tif currentScore > maxScore {\\n\\t\\t\\tmaxScore = currentScore\\n\\t\\t\\tmaxIndices = []int{i + 1}\\n\\t\\t} else if currentScore == maxScore {\\n\\t\\t\\tmaxIndices = append(maxIndices, i+1)\\n\\t\\t}\\n\\t}\\n\\treturn maxIndices\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628657,
                "title": "o-2n-nearly-exceeded-time-limit",
                "content": "# Intuition\\nTHE SUBMISSON IS ACCEPTED AFTER I COMMENTED MY PRINT() FUNCTIONS, OTHERWISE IT WILL EXCEED TIME LIMIT\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScoreIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        if len(nums) == 0:\\n            return [0]\\n        if len(nums) == 1:\\n            if nums[0] == 0:\\n                return [1]\\n            if nums[0] == 1:\\n                return[0]\\n            return [0,1]\\n\\n        arr_nums = [-1] + nums + [-1]\\n        fixed_length = len(arr_nums)\\n        arr_zeros = fixed_length * [0]\\n        arr_ones = fixed_length * [0]\\n        \\n        arr_sum = 0\\n        for i in range(len(arr_nums)):\\n            if arr_nums[i] == 0:\\n                arr_sum += 1\\n            arr_zeros[i] = arr_sum\\n\\n        arr_sum = 0\\n        for i in range(len(arr_nums)-1,-1,-1):\\n            if arr_nums[i] == 1:\\n                arr_sum += 1\\n            arr_ones[i] = arr_sum\\n\\n        arr_zeros = arr_zeros[0:-1]\\n        arr_ones = arr_ones[1:]\\n        solution_arr = []\\n        solution_val = -1\\n        for i in range(fixed_length-1):\\n            check_point = arr_ones[i] + arr_zeros[i]\\n            if check_point >= solution_val:\\n                if check_point == solution_val:\\n                    solution_arr.append(i)\\n                    continue\\n                else:\\n                    solution_val = check_point\\n                    solution_arr = [i]\\n                    continue\\n        #print(arr_nums)\\n        #print(arr_zeros)\\n        #print(arr_ones)\\n        #print(solution_arr)\\n        return solution_arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScoreIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        if len(nums) == 0:\\n            return [0]\\n        if len(nums) == 1:\\n            if nums[0] == 0:\\n                return [1]\\n            if nums[0] == 1:\\n                return[0]\\n            return [0,1]\\n\\n        arr_nums = [-1] + nums + [-1]\\n        fixed_length = len(arr_nums)\\n        arr_zeros = fixed_length * [0]\\n        arr_ones = fixed_length * [0]\\n        \\n        arr_sum = 0\\n        for i in range(len(arr_nums)):\\n            if arr_nums[i] == 0:\\n                arr_sum += 1\\n            arr_zeros[i] = arr_sum\\n\\n        arr_sum = 0\\n        for i in range(len(arr_nums)-1,-1,-1):\\n            if arr_nums[i] == 1:\\n                arr_sum += 1\\n            arr_ones[i] = arr_sum\\n\\n        arr_zeros = arr_zeros[0:-1]\\n        arr_ones = arr_ones[1:]\\n        solution_arr = []\\n        solution_val = -1\\n        for i in range(fixed_length-1):\\n            check_point = arr_ones[i] + arr_zeros[i]\\n            if check_point >= solution_val:\\n                if check_point == solution_val:\\n                    solution_arr.append(i)\\n                    continue\\n                else:\\n                    solution_val = check_point\\n                    solution_arr = [i]\\n                    continue\\n        #print(arr_nums)\\n        #print(arr_zeros)\\n        #print(arr_ones)\\n        #print(solution_arr)\\n        return solution_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626328,
                "title": "toadyismyday-tc-o-n-sc-o-n-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n         vector<int>one(n),zero(n);\\n          int z=0,o=0;\\n        for( int i=0;i<n;++i)\\n        {\\n            if(nums[i]==0)\\n            z++;\\n            \\n             zero[i]=z;\\n\\n             if(nums[n-1-i]==1)\\n             {\\n                 o++;\\n             }\\n             one[n-1-i]=o;\\n        }\\n        vector<int>ans;\\n       \\n        int maxi=0;\\n        for( int i=0;i<=n;++i)\\n        {\\n           if(i==0)\\n           {\\n               if(one[i]>maxi)\\n               {\\n                   maxi=one[i];\\n                   ans.clear();\\n                   ans.push_back(i);\\n               }else if(one[i]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n           }else if(i==n)\\n           {\\n               if(zero[n-1]>maxi)\\n               { \\n                   ans.clear();\\n                   ans.push_back(i);\\n               } else if(zero[i-1]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n           }else\\n           {\\n               if(zero[i-1]+one[i]>maxi)\\n               {maxi=zero[i-1]+one[i];\\n                   ans.clear();\\n                   ans.push_back(i);\\n               }else if(zero[i-1]+one[i]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n             \\n           }\\n        }\\n          return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n         vector<int>one(n),zero(n);\\n          int z=0,o=0;\\n        for( int i=0;i<n;++i)\\n        {\\n            if(nums[i]==0)\\n            z++;\\n            \\n             zero[i]=z;\\n\\n             if(nums[n-1-i]==1)\\n             {\\n                 o++;\\n             }\\n             one[n-1-i]=o;\\n        }\\n        vector<int>ans;\\n       \\n        int maxi=0;\\n        for( int i=0;i<=n;++i)\\n        {\\n           if(i==0)\\n           {\\n               if(one[i]>maxi)\\n               {\\n                   maxi=one[i];\\n                   ans.clear();\\n                   ans.push_back(i);\\n               }else if(one[i]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n           }else if(i==n)\\n           {\\n               if(zero[n-1]>maxi)\\n               { \\n                   ans.clear();\\n                   ans.push_back(i);\\n               } else if(zero[i-1]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n           }else\\n           {\\n               if(zero[i-1]+one[i]>maxi)\\n               {maxi=zero[i-1]+one[i];\\n                   ans.clear();\\n                   ans.push_back(i);\\n               }else if(zero[i-1]+one[i]==maxi)\\n               {\\n                   ans.push_back(i);\\n               }\\n             \\n           }\\n        }\\n          return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574974,
                "title": "ruby-suffix-sum-array",
                "content": "# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef max_score_indices(nums)\\n  b = Array.new(nums.length+1, 0)\\n  b_sum = 0\\n  i = nums.length\\n  while i > 0\\n    b[i-1] = b_sum += nums[i-1]\\n    i -= 1\\n  end\\n  results = [0]\\n  m = b_sum\\n  a_sum = 0\\n  i = 0\\n  while i < nums.length\\n    n = i + 1\\n    a_sum += nums[i]^1\\n    s = a_sum + b[n]\\n    if s > m\\n      m = s\\n      results.clear()\\n      results.push(n)\\n    elsif s == m\\n      results.push(n)\\n    end\\n    i += 1\\n  end\\n  return results\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Suffix Array"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef max_score_indices(nums)\\n  b = Array.new(nums.length+1, 0)\\n  b_sum = 0\\n  i = nums.length\\n  while i > 0\\n    b[i-1] = b_sum += nums[i-1]\\n    i -= 1\\n  end\\n  results = [0]\\n  m = b_sum\\n  a_sum = 0\\n  i = 0\\n  while i < nums.length\\n    n = i + 1\\n    a_sum += nums[i]^1\\n    s = a_sum + b[n]\\n    if s > m\\n      m = s\\n      results.clear()\\n      results.push(n)\\n    elsif s == m\\n      results.push(n)\\n    end\\n    i += 1\\n  end\\n  return results\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3567181,
                "title": "simple-count-value-one-and-zeros",
                "content": "# Intuition\\ncount zero and one at each index \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size(),zero=0,one=0;\\n        for(int i=0;i<n;i++)\\n            one+=nums[i];\\n        unordered_map<int,vector<int>>um;\\n        um[one].push_back(0);\\n        // vector<int>res(n+1,0);\\n        // res[0]=one;\\n        int ans=one;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                zero++;\\n            else\\n               one--;\\n            um[zero+one].push_back(i+1);\\n            // res[i+1]=zero+one;\\n            ans=max(ans,zero+one);\\n        }\\n        return um[ans];\\n        // vector<int>index;\\n        // for(int i=0;i<n+1;i++)\\n        //    if(res[i]==ans)\\n            //    index.push_back(i);\\n        // return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size(),zero=0,one=0;\\n        for(int i=0;i<n;i++)\\n            one+=nums[i];\\n        unordered_map<int,vector<int>>um;\\n        um[one].push_back(0);\\n        // vector<int>res(n+1,0);\\n        // res[0]=one;\\n        int ans=one;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                zero++;\\n            else\\n               one--;\\n            um[zero+one].push_back(i+1);\\n            // res[i+1]=zero+one;\\n            ans=max(ans,zero+one);\\n        }\\n        return um[ans];\\n        // vector<int>index;\\n        // for(int i=0;i<n+1;i++)\\n        //    if(res[i]==ans)\\n            //    index.push_back(i);\\n        // return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553779,
                "title": "java-clear-and-clean-code",
                "content": "# Approach\\n1. Count number of ones from array\\n2. From i = 0 to n\\n    - determine the current score my adding countOfZero and countOfOne\\n    - if currentScore >= maxScore, add i to the list of maxScores (flush the list if current > max)\\n    - increment countOfZero (if current nr is 0)\\n    - decrement countOfOne (if current nr is 1)\\n3. Return the list of max indices.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int numsOfOne = getNumsOfOne(nums);\\n        return getMaxScoreIndices(nums, numsOfOne);\\n    }\\n\\n    private List<Integer> getMaxScoreIndices(int[] nums, int ones) {\\n        List<Integer> maxScoreIndices = new ArrayList<>();\\n        int maxScore = 0, currentScore = 0;\\n        int countOfZero = 0;\\n        for (int i = 0; i <= nums.length; i++) {\\n            currentScore = countOfZero + ones;\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                maxScoreIndices.clear();\\n                maxScoreIndices.add(i);\\n            } else if (currentScore == maxScore) {\\n                maxScoreIndices.add(i);\\n            }\\n            countOfZero += i < nums.length ? 1 - nums[i] : 0;\\n            ones -= i < nums.length ? nums[i] : 0;\\n        }\\n        return maxScoreIndices;\\n    }\\n\\n    private int getNumsOfOne(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums) {\\n            ones += num;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int numsOfOne = getNumsOfOne(nums);\\n        return getMaxScoreIndices(nums, numsOfOne);\\n    }\\n\\n    private List<Integer> getMaxScoreIndices(int[] nums, int ones) {\\n        List<Integer> maxScoreIndices = new ArrayList<>();\\n        int maxScore = 0, currentScore = 0;\\n        int countOfZero = 0;\\n        for (int i = 0; i <= nums.length; i++) {\\n            currentScore = countOfZero + ones;\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                maxScoreIndices.clear();\\n                maxScoreIndices.add(i);\\n            } else if (currentScore == maxScore) {\\n                maxScoreIndices.add(i);\\n            }\\n            countOfZero += i < nums.length ? 1 - nums[i] : 0;\\n            ones -= i < nums.length ? nums[i] : 0;\\n        }\\n        return maxScoreIndices;\\n    }\\n\\n    private int getNumsOfOne(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums) {\\n            ones += num;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517015,
                "title": "all-divisions-with-the-highest-score-of-a-binary-array-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        zeros , ones = 0, 0\\n        \\n        for num in nums:\\n            ones += num\\n        \\n        index, max_sum = 0, 0\\n        \\n        max_sum = max(max_sum, ones + zeros)\\n        \\n        indices = defaultdict(list)\\n        indices[ones + zeros].append(index)\\n        \\n        while index < len(nums):\\n            if nums[index] == 1:\\n                ones -= 1\\n            else:\\n                zeros += 1\\n                \\n            max_sum = max(max_sum, ones + zeros)\\n            index += 1\\n            indices[ones + zeros].append(index)\\n            \\n        return indices[max_sum]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        zeros , ones = 0, 0\\n        \\n        for num in nums:\\n            ones += num\\n        \\n        index, max_sum = 0, 0\\n        \\n        max_sum = max(max_sum, ones + zeros)\\n        \\n        indices = defaultdict(list)\\n        indices[ones + zeros].append(index)\\n        \\n        while index < len(nums):\\n            if nums[index] == 1:\\n                ones -= 1\\n            else:\\n                zeros += 1\\n                \\n            max_sum = max(max_sum, ones + zeros)\\n            index += 1\\n            indices[ones + zeros].append(index)\\n            \\n        return indices[max_sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497989,
                "title": "python3-prefix-and-suffix",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        left=0\\n        right=nums.count(1)\\n        \\n        \\n        scores=[]\\n        n=len(nums)\\n        \\n        for i in range(n):\\n            scores.append(left+right)\\n            if nums[i]==0:\\n                left+=1\\n            if nums[i]==1:\\n                right-=1\\n        \\n        scores.append(left+right)\\n        mx=max(scores)\\n        \\n        m=len(scores)\\n        \\n        return [i for i in range(m) if scores[i]==mx]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        left=0\\n        right=nums.count(1)\\n        \\n        \\n        scores=[]\\n        n=len(nums)\\n        \\n        for i in range(n):\\n            scores.append(left+right)\\n            if nums[i]==0:\\n                left+=1\\n            if nums[i]==1:\\n                right-=1\\n        \\n        scores.append(left+right)\\n        mx=max(scores)\\n        \\n        m=len(scores)\\n        \\n        return [i for i in range(m) if scores[i]==mx]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454155,
                "title": "easy-o-n-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int right = accumulate(nums.begin(), nums.end(), 0);\\n        int left=0, maxi=0;\\n        vector<int> res;\\n\\n        for(int i=0; i<=nums.size(); i++){\\n            if(left+right > maxi){\\n                maxi = left+right;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            else if(left+right == maxi) res.push_back(i);\\n\\n            if(i!=nums.size()){\\n                if(nums[i]==0) left++;\\n                else right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int right = accumulate(nums.begin(), nums.end(), 0);\\n        int left=0, maxi=0;\\n        vector<int> res;\\n\\n        for(int i=0; i<=nums.size(); i++){\\n            if(left+right > maxi){\\n                maxi = left+right;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            else if(left+right == maxi) res.push_back(i);\\n\\n            if(i!=nums.size()){\\n                if(nums[i]==0) left++;\\n                else right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439943,
                "title": "python-o-n-solution-beat-94-no-need-to-count-0-and-1",
                "content": "# Intuition\\nLet\\'s assume that $$nums$$ contains $$S$$ 1s, then score=$$S$$ when $$i=0$$ (i.e $$nums_{[left]}$$ is empty and $$nums_{[right]}$$ contains $$S$$ 1s). \\nWhen we move the spliting position $$i$$ from left to right, the score increases by 1 if the value is 0 and decreases by 1 if the value is 1. Moving a 0 to left will increase $$nums_{[left]}$$ score while $$nums_{[right]}$$ score is not changed. On the other hand, moving 1 to left will decrease $$nums_{[right]}$$ score. See illustration below:\\nassume when split at i, $$Score_{[left]}=sl_i, Score_{[right]}=sr_i, Score_i=sl_i+sr_i$$\\n\\n**case#1 $$nums[i+1]==0$$:**\\n$$ ....i,i+1,...$$\\n$$ ....| 0,.......$$\\n$$ ....0,|.......$$ => split at $$i+1, Score_{[left]}=sl_i+1, Score_{[right]}=sr_i, Score_{i+1}=sl_i+1+sr_i=Score_i+1$$\\n\\n**case#2 $$nums[i+1]==1$$:**\\n$$ ....i,i+1,...$$\\n$$ ....| 1,.......$$ => \\n$$ ....1,|.......$$ => split at $$i+1, Score_{[left]}=sl_i, Score_{[right]}=sr_i-1, Score_{i+1}=sl_i+sr_i-1=Score_i-1$$\\n\\n# Approach\\nInstead of keeping track of actual score, we can just keep track the difference between the actual score and $$S$$\\n- initiate starting score as 0\\n- loop through $$nums$$\\n- when value is 0, increase score by 1, otherwise, decrease by 1\\n- compare the score with highest score seen so far\\n- if current score is higher than the highest one, set output to current position\\n- if current score is equal to the highest one, append current position to output\\n- at end, return output\\n\\n# Complexity\\n- Time complexity: $$O(n)$$: we go through $$nums$$ once\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        \\n        # initiate maxScore, ret, currScore\\n        maxScore = 0\\n        ret=[0]\\n        currScore=0\\n\\n        # loop through nums\\n        i=0\\n        while (i<n):\\n            if (nums[i]==0):\\n                currScore+=1\\n            else:\\n                currScore-=1\\n\\n            if (currScore>maxScore):\\n                maxScore = currScore\\n                ret=[i+1]\\n            elif currScore==maxScore:\\n                ret.append(i+1)\\n            i+=1\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        \\n        # initiate maxScore, ret, currScore\\n        maxScore = 0\\n        ret=[0]\\n        currScore=0\\n\\n        # loop through nums\\n        i=0\\n        while (i<n):\\n            if (nums[i]==0):\\n                currScore+=1\\n            else:\\n                currScore-=1\\n\\n            if (currScore>maxScore):\\n                maxScore = currScore\\n                ret=[i+1]\\n            elif currScore==maxScore:\\n                ret.append(i+1)\\n            i+=1\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431876,
                "title": "c-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int largest = 0, l = 0, r = 0;\\n        for (auto& n : nums) r += n == 1;\\n        int oldR = r;\\n        for (int i = 0; i <= nums.size(); ++i){\\n            largest = max(largest, l + r);\\n            if (i < nums.size()){\\n                l += nums[i] == 0;\\n                r -= nums[i] == 1;\\n            } \\n        }\\n        l = 0, r = oldR;\\n        vector<int> ans;\\n        for (int i = 0; i <= nums.size(); ++i){\\n            if (l + r == largest) ans.push_back(i);\\n             if (i < nums.size()){\\n                l += nums[i] == 0;\\n                r -= nums[i] == 1;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int largest = 0, l = 0, r = 0;\\n        for (auto& n : nums) r += n == 1;\\n        int oldR = r;\\n        for (int i = 0; i <= nums.size(); ++i){\\n            largest = max(largest, l + r);\\n            if (i < nums.size()){\\n                l += nums[i] == 0;\\n                r -= nums[i] == 1;\\n            } \\n        }\\n        l = 0, r = oldR;\\n        vector<int> ans;\\n        for (int i = 0; i <= nums.size(); ++i){\\n            if (l + r == largest) ans.push_back(i);\\n             if (i < nums.size()){\\n                l += nums[i] == 0;\\n                r -= nums[i] == 1;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406145,
                "title": "o-n-solution-by-counting-number-of-ones-and-zeroes",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        int total_one=0;\\n        vector<int> zeroes(n);\\n        vector<int> ones(n);\\n        zeroes[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            zeroes[i]=zeroes[i-1];\\n            if(nums[i-1]==0)\\n            {\\n                zeroes[i]+=1;\\n            }\\n        }\\n        ones[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ones[i]=ones[i-1];\\n            if(nums[i-1]==1)\\n            {\\n                ones[i]+=1;\\n            }\\n        }\\n        int total_zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            total_one++;\\n            else\\n            total_zero++;\\n        }\\n        vector<int> temp;\\n        temp.push_back(total_one);\\n        for(int i=1;i<n;i++)\\n        {\\n            temp.push_back(zeroes[i]+(total_one-ones[i]));\\n        }\\n        temp.push_back(total_zero);\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            maxi=max(temp[i],maxi);\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(temp[i]==maxi)\\n            ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        int total_one=0;\\n        vector<int> zeroes(n);\\n        vector<int> ones(n);\\n        zeroes[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            zeroes[i]=zeroes[i-1];\\n            if(nums[i-1]==0)\\n            {\\n                zeroes[i]+=1;\\n            }\\n        }\\n        ones[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ones[i]=ones[i-1];\\n            if(nums[i-1]==1)\\n            {\\n                ones[i]+=1;\\n            }\\n        }\\n        int total_zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            total_one++;\\n            else\\n            total_zero++;\\n        }\\n        vector<int> temp;\\n        temp.push_back(total_one);\\n        for(int i=1;i<n;i++)\\n        {\\n            temp.push_back(zeroes[i]+(total_one-ones[i]));\\n        }\\n        temp.push_back(total_zero);\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            maxi=max(temp[i],maxi);\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(temp[i]==maxi)\\n            ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385746,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int sum=0;\\n        for(auto x:nums)\\n            sum+=x;\\n        vector<int>v;\\n        v.push_back(sum);\\n        int res=0,countz=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+=nums[i];\\n            if(nums[i]==0)\\n                countz++;\\n            int ele=countz+(sum-res);\\n            v.push_back(ele);\\n        }\\n        vector<int>ans;\\n        vector<pair<int,int>>f;\\n        for(int i=0;i<v.size();i++){\\n            f.push_back(make_pair(v[i],i));\\n        }\\n        sort(f.begin(),f.end());\\n        reverse(f.begin(),f.end());\\n        int d=f[0].first;\\n        for(int i=0;i<f.size();i++){\\n            if(f[i].first==d){\\n                ans.push_back(f[i].second);\\n            }\\n            else\\n                break;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int sum=0;\\n        for(auto x:nums)\\n            sum+=x;\\n        vector<int>v;\\n        v.push_back(sum);\\n        int res=0,countz=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+=nums[i];\\n            if(nums[i]==0)\\n                countz++;\\n            int ele=countz+(sum-res);\\n            v.push_back(ele);\\n        }\\n        vector<int>ans;\\n        vector<pair<int,int>>f;\\n        for(int i=0;i<v.size();i++){\\n            f.push_back(make_pair(v[i],i));\\n        }\\n        sort(f.begin(),f.end());\\n        reverse(f.begin(),f.end());\\n        int d=f[0].first;\\n        for(int i=0;i<f.size();i++){\\n            if(f[i].first==d){\\n                ans.push_back(f[i].second);\\n            }\\n            else\\n                break;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383164,
                "title": "o-n-python-solution-with-a-linear-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        n=len(nums)\\n        \\n        tot0=nums.count(0)\\n        tot1=n-tot0\\n        \\n        arr=[]\\n        zero=0\\n        one=tot1\\n        arr.append(tot1)\\n        for i in range(n):\\n            if(nums[i]==0):\\n                zero+=1\\n            else:\\n                one-=1\\n            arr.append(zero+one)\\n\\n#        print(arr)\\n\\n        res=[]\\n        k=max(arr)\\n        \\n        for i in range(len(arr)):\\n            if(arr[i]==k):\\n                res.append(i)\\n\\n        return(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        n=len(nums)\\n        \\n        tot0=nums.count(0)\\n        tot1=n-tot0\\n        \\n        arr=[]\\n        zero=0\\n        one=tot1\\n        arr.append(tot1)\\n        for i in range(n):\\n            if(nums[i]==0):\\n                zero+=1\\n            else:\\n                one-=1\\n            arr.append(zero+one)\\n\\n#        print(arr)\\n\\n        res=[]\\n        k=max(arr)\\n        \\n        for i in range(len(arr)):\\n            if(arr[i]==k):\\n                res.append(i)\\n\\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379328,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cntZ(n),cntO(n);\\n        if(nums[0]==0)\\n        cntZ[0] = 1;\\n        if(nums[0]==1)\\n        cntO[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                cntZ[i] = cntZ[i-1]+1;\\n            }\\n            else\\n            cntZ[i] = cntZ[i-1];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                cntO[i] = cntO[i-1]+1;\\n            }\\n            else\\n            cntO[i] = cntO[i-1];\\n        }\\n        int maxSum = max(cntZ[n-1],cntO[n-1]);\\n        for(int i=1;i<n;i++)\\n        {\\n            int z = cntZ[i-1];\\n            int o = cntO[n-1]-cntO[i-1];\\n            maxSum = max(maxSum,z+o);\\n        }\\n        vector<int> ans;\\n        if(cntZ[n-1]==maxSum)\\n        ans.push_back(n);\\n        if(cntO[n-1]==maxSum)\\n        ans.push_back(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            int z = cntZ[i-1];\\n            int o = cntO[n-1]-cntO[i-1];\\n            if(z+o==maxSum)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cntZ(n),cntO(n);\\n        if(nums[0]==0)\\n        cntZ[0] = 1;\\n        if(nums[0]==1)\\n        cntO[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                cntZ[i] = cntZ[i-1]+1;\\n            }\\n            else\\n            cntZ[i] = cntZ[i-1];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                cntO[i] = cntO[i-1]+1;\\n            }\\n            else\\n            cntO[i] = cntO[i-1];\\n        }\\n        int maxSum = max(cntZ[n-1],cntO[n-1]);\\n        for(int i=1;i<n;i++)\\n        {\\n            int z = cntZ[i-1];\\n            int o = cntO[n-1]-cntO[i-1];\\n            maxSum = max(maxSum,z+o);\\n        }\\n        vector<int> ans;\\n        if(cntZ[n-1]==maxSum)\\n        ans.push_back(n);\\n        if(cntO[n-1]==maxSum)\\n        ans.push_back(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            int z = cntZ[i-1];\\n            int o = cntO[n-1]-cntO[i-1];\\n            if(z+o==maxSum)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361661,
                "title": "c-very-easy-solution-o-n-only-use-vector",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    #define pb push_back\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>zero( n+1 , 0 );\\n        vector<int>ones( n+1 , 0 );\\n        int sum = 0;\\n        for( int i=1 ; i<=n ; i++ )\\n        {\\n            if( nums[i-1]==0 )\\n            {\\n                sum++;\\n            }\\n            zero[i] = sum;\\n        }\\n        sum = 0;\\n        for( int i=n-1 ; i>=0 ; i-- )\\n        {\\n            if( nums[i]==1 )\\n            {\\n                sum++;\\n            }\\n            ones[i] = sum;\\n        }\\n        vector<int>ans;\\n        ans.push_back( 0 );\\n        int max = ones[0];\\n        for( int i=1 ; i<=n ; i++ )\\n        {\\n            if( i==n )\\n            {\\n                if( zero[n]==max )\\n                {\\n                    ans.push_back( n );\\n                }\\n                else if( zero[n] > max )\\n                {\\n                    ans.clear();\\n                    ans.push_back( n );\\n                }\\n                break;\\n            }\\n            else if( (zero[i] + ones[i]) == max )\\n            {\\n                ans.push_back( i );\\n            }\\n            else if( (zero[i] + ones[i]) > max )\\n            {\\n                ans.clear();\\n                ans.push_back( i );\\n                max= (zero[i] + ones[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define pb push_back\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>zero( n+1 , 0 );\\n        vector<int>ones( n+1 , 0 );\\n        int sum = 0;\\n        for( int i=1 ; i<=n ; i++ )\\n        {\\n            if( nums[i-1]==0 )\\n            {\\n                sum++;\\n            }\\n            zero[i] = sum;\\n        }\\n        sum = 0;\\n        for( int i=n-1 ; i>=0 ; i-- )\\n        {\\n            if( nums[i]==1 )\\n            {\\n                sum++;\\n            }\\n            ones[i] = sum;\\n        }\\n        vector<int>ans;\\n        ans.push_back( 0 );\\n        int max = ones[0];\\n        for( int i=1 ; i<=n ; i++ )\\n        {\\n            if( i==n )\\n            {\\n                if( zero[n]==max )\\n                {\\n                    ans.push_back( n );\\n                }\\n                else if( zero[n] > max )\\n                {\\n                    ans.clear();\\n                    ans.push_back( n );\\n                }\\n                break;\\n            }\\n            else if( (zero[i] + ones[i]) == max )\\n            {\\n                ans.push_back( i );\\n            }\\n            else if( (zero[i] + ones[i]) > max )\\n            {\\n                ans.clear();\\n                ans.push_back( i );\\n                max= (zero[i] + ones[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358624,
                "title": "c-easy-to-understand-linear-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep track of 0\\'s and 1\\'s\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n+1,0),right(n+1,0);\\n// At ith index left[i] give no. of 0\\'s till (i-1) index and right[i]give no. of 1\\'s from i to nums.size() \\n        for(int i=1; i<=n; i++){\\n            left[i]=left[i-1];\\n            if(nums[i-1]==0) left[i]+=1;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            right[i]=right[i+1];\\n            if(nums[i]==1) right[i]+=1;\\n        }\\n        int maxi=0;\\n        vector<int> ans;\\n        for(int i=0; i<=n; i++) maxi=max(maxi,left[i]+right[i]);\\n        for(int i=0; i<=n; i++){\\n            if(maxi==left[i]+right[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n+1,0),right(n+1,0);\\n// At ith index left[i] give no. of 0\\'s till (i-1) index and right[i]give no. of 1\\'s from i to nums.size() \\n        for(int i=1; i<=n; i++){\\n            left[i]=left[i-1];\\n            if(nums[i-1]==0) left[i]+=1;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            right[i]=right[i+1];\\n            if(nums[i]==1) right[i]+=1;\\n        }\\n        int maxi=0;\\n        vector<int> ans;\\n        for(int i=0; i<=n; i++) maxi=max(maxi,left[i]+right[i]);\\n        for(int i=0; i<=n; i++){\\n            if(maxi==left[i]+right[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347604,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        unordered_map<int, vector<int>>Map ; //{score, idx}\\n        int n = nums.size() ;\\n        vector<int>PreZero(n+1) ;\\n        vector<int>SuffOne(n+1) ;\\n        for(int i = 0; i < n; i++){\\n            PreZero[i+1] = PreZero[i] ;\\n            if(nums[i] == 0)\\n                PreZero[i+1]++ ;\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            SuffOne[i] = SuffOne[i+1] ;\\n            if(nums[i] == 1)\\n                SuffOne[i]++ ;    \\n        }  \\n        int maxScore = 0 ;\\n        for(int i = 0; i <= n; i++){\\n            int score = PreZero[i] + SuffOne[i] ;\\n            Map[score].push_back(i) ;\\n            maxScore = max(maxScore, score) ;\\n        }\\n        return Map[maxScore] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        unordered_map<int, vector<int>>Map ; //{score, idx}\\n        int n = nums.size() ;\\n        vector<int>PreZero(n+1) ;\\n        vector<int>SuffOne(n+1) ;\\n        for(int i = 0; i < n; i++){\\n            PreZero[i+1] = PreZero[i] ;\\n            if(nums[i] == 0)\\n                PreZero[i+1]++ ;\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            SuffOne[i] = SuffOne[i+1] ;\\n            if(nums[i] == 1)\\n                SuffOne[i]++ ;    \\n        }  \\n        int maxScore = 0 ;\\n        for(int i = 0; i <= n; i++){\\n            int score = PreZero[i] + SuffOne[i] ;\\n            Map[score].push_back(i) ;\\n            maxScore = max(maxScore, score) ;\\n        }\\n        return Map[maxScore] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339852,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        int max=0;\\n        int left=0,right=0;\\n        for(int j=0;j<nums.length;j++) if(nums[j]==1) right++;\\n\\n        for(int i=-1;i<nums.length;i++){\\n            if(i>=0 && i<nums.length){\\n                if(nums[i]==0) left++;\\n                if(nums[i]==1) right--;\\n            }\\n            int sum=left+right;\\n            if(sum>max){\\n                list.clear();\\n                list.add(i+1);\\n            }\\n            if(sum==max) list.add(i+1);\\n            max=Math.max(max,sum);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        int max=0;\\n        int left=0,right=0;\\n        for(int j=0;j<nums.length;j++) if(nums[j]==1) right++;\\n\\n        for(int i=-1;i<nums.length;i++){\\n            if(i>=0 && i<nums.length){\\n                if(nums[i]==0) left++;\\n                if(nums[i]==1) right--;\\n            }\\n            int sum=left+right;\\n            if(sum>max){\\n                list.clear();\\n                list.add(i+1);\\n            }\\n            if(sum==max) list.add(i+1);\\n            max=Math.max(max,sum);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332314,
                "title": "python3-2-solutions-beats-92-users-with-and-without-hashmap-very-intuitive",
                "content": "WITH HASHMAP:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        prefixZeroes,suffixOnes=[0]*(n+1),[0]*(n+1)\\n        for i in range(1,len(nums)+1):\\n            prefixZeroes[i]=prefixZeroes[i-1]\\n            if nums[i-1]==0:\\n                prefixZeroes[i]+=1\\n        for i in range(len(nums)-1,-1,-1):\\n            suffixOnes[i]=suffixOnes[i+1]\\n            if nums[i]:\\n                suffixOnes[i]+=1\\n        hashMap=defaultdict(list)\\n        for i in range(len(nums)+1):\\n            hashMap[prefixZeroes[i]+suffixOnes[i]].append(i)\\n        return hashMap[max(hashMap.keys())]\\n```\\nWITHOUT HASHMAP:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        totalOnes=sum(nums)\\n        leftZeroes=0\\n        res=[0]\\n        maxScore=totalOnes\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                leftZeroes+=1\\n            else:\\n                totalOnes-=1\\n            curScore=leftZeroes+totalOnes\\n            if curScore>maxScore:\\n                res=[]\\n                res.append(i+1)\\n                maxScore=curScore\\n            elif curScore==maxScore:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        prefixZeroes,suffixOnes=[0]*(n+1),[0]*(n+1)\\n        for i in range(1,len(nums)+1):\\n            prefixZeroes[i]=prefixZeroes[i-1]\\n            if nums[i-1]==0:\\n                prefixZeroes[i]+=1\\n        for i in range(len(nums)-1,-1,-1):\\n            suffixOnes[i]=suffixOnes[i+1]\\n            if nums[i]:\\n                suffixOnes[i]+=1\\n        hashMap=defaultdict(list)\\n        for i in range(len(nums)+1):\\n            hashMap[prefixZeroes[i]+suffixOnes[i]].append(i)\\n        return hashMap[max(hashMap.keys())]\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        totalOnes=sum(nums)\\n        leftZeroes=0\\n        res=[0]\\n        maxScore=totalOnes\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                leftZeroes+=1\\n            else:\\n                totalOnes-=1\\n            curScore=leftZeroes+totalOnes\\n            if curScore>maxScore:\\n                res=[]\\n                res.append(i+1)\\n                maxScore=curScore\\n            elif curScore==maxScore:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331713,
                "title": "fastest-c-solution-full-explanation-simplest-approach",
                "content": "# Please UPVOTE..!! Motivates a lot.. \\uD83D\\uDE07\\uD83E\\uDEF1\\uD83C\\uDFFC\\u200D\\uD83E\\uDEF2\\uD83C\\uDFFC\\n\\n# Approach\\n- Traverse array once and store total no. of ones and zeroes\\n- Traverse again and check if sum of no. of zeroes to the left and ones to the right is greater than current max, store its index.\\n- Return index vector\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (traversal of complete array twice)\\n\\n- Space complexity: $$O(1)$$ (no extra space required except indices vector)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        // store total number of zeroes and ones in the array\\n        int zeronum = 0, onenum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                zeronum++;\\n            }\\n            else {onenum++;}\\n        }\\n\\n        // for every i, check and store number of 0 on left and 1 on right side of i\\n        int leftzero = 0, rightone = onenum;\\n        int maxval = 0;\\n        vector<int> indices;\\n\\n        for (int i = 0; i <= nums.size(); i++) {\\n            if (leftzero + rightone > maxval) {\\n                indices.clear();\\n                indices.push_back(i);\\n                maxval = leftzero + rightone;\\n            }\\n            else if (leftzero + rightone == maxval) {\\n                indices.push_back(i);\\n            }\\n            // else, do nothing.\\n\\n            if (i < nums.size()) { // i == nums.size() will throw IndexOutOfBounds exception\\n                if (nums[i] == 0) {\\n                    // increase leftzero\\n                    leftzero++;\\n                }\\n                else {\\n                    // decrease rightone\\n                    rightone--;\\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        // store total number of zeroes and ones in the array\\n        int zeronum = 0, onenum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                zeronum++;\\n            }\\n            else {onenum++;}\\n        }\\n\\n        // for every i, check and store number of 0 on left and 1 on right side of i\\n        int leftzero = 0, rightone = onenum;\\n        int maxval = 0;\\n        vector<int> indices;\\n\\n        for (int i = 0; i <= nums.size(); i++) {\\n            if (leftzero + rightone > maxval) {\\n                indices.clear();\\n                indices.push_back(i);\\n                maxval = leftzero + rightone;\\n            }\\n            else if (leftzero + rightone == maxval) {\\n                indices.push_back(i);\\n            }\\n            // else, do nothing.\\n\\n            if (i < nums.size()) { // i == nums.size() will throw IndexOutOfBounds exception\\n                if (nums[i] == 0) {\\n                    // increase leftzero\\n                    leftzero++;\\n                }\\n                else {\\n                    // decrease rightone\\n                    rightone--;\\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329461,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_score_indices(nums: Vec<i32>) -> Vec<i32> {\\n        let mut onex_prefix = vec![0; nums.len()];\\n        for i in (0..nums.len()).rev() {\\n            if nums[i] == 1 {\\n                onex_prefix[i] += 1;\\n            }\\n            if i < nums.len() - 1 {\\n                onex_prefix[i] += onex_prefix[i + 1];\\n            }\\n        }\\n\\n        let mut zeros_count = 0;\\n        let mut scores = vec![0; nums.len() + 1];\\n        let mut max_score = 0;\\n        for i in 0..=nums.len() {\\n            if i == nums.len() {\\n                scores[i] = zeros_count;\\n            } else {\\n                scores[i] = (zeros_count + onex_prefix[i]);\\n                if nums[i] == 0 {\\n                    zeros_count += 1;\\n                }\\n            }\\n            max_score = max_score.max(scores[i]);\\n        }\\n        scores[nums.len()] = zeros_count;\\n\\n        scores\\n            .into_iter()\\n            .enumerate()\\n            .filter(|(_, x)| *x == max_score)\\n            .map(|(i, _)| i as i32)\\n            .collect()        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_score_indices(nums: Vec<i32>) -> Vec<i32> {\\n        let mut onex_prefix = vec![0; nums.len()];\\n        for i in (0..nums.len()).rev() {\\n            if nums[i] == 1 {\\n                onex_prefix[i] += 1;\\n            }\\n            if i < nums.len() - 1 {\\n                onex_prefix[i] += onex_prefix[i + 1];\\n            }\\n        }\\n\\n        let mut zeros_count = 0;\\n        let mut scores = vec![0; nums.len() + 1];\\n        let mut max_score = 0;\\n        for i in 0..=nums.len() {\\n            if i == nums.len() {\\n                scores[i] = zeros_count;\\n            } else {\\n                scores[i] = (zeros_count + onex_prefix[i]);\\n                if nums[i] == 0 {\\n                    zeros_count += 1;\\n                }\\n            }\\n            max_score = max_score.max(scores[i]);\\n        }\\n        scores[nums.len()] = zeros_count;\\n\\n        scores\\n            .into_iter()\\n            .enumerate()\\n            .filter(|(_, x)| *x == max_score)\\n            .map(|(i, _)| i as i32)\\n            .collect()        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328647,
                "title": "javascript-left-and-right",
                "content": "```\\nconst maxScoreIndices = (nums) => {\\n  let [l, r] = [0, nums.reduce((a, c) => (a += c), 0)];\\n  let max = l + r;\\n  let map = { [max]: [0] };\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    nums[i] ? r-- : l++;\\n\\n    if (l + r == max) {\\n      map[max].push(i + 1);\\n    }\\n    if (l + r > max) {\\n      max = l + r;\\n      map[max] = [i + 1];\\n    }\\n  }\\n\\n  return map[max];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxScoreIndices = (nums) => {\\n  let [l, r] = [0, nums.reduce((a, c) => (a += c), 0)];\\n  let max = l + r;\\n  let map = { [max]: [0] };\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    nums[i] ? r-- : l++;\\n\\n    if (l + r == max) {\\n      map[max].push(i + 1);\\n    }\\n    if (l + r > max) {\\n      max = l + r;\\n      map[max] = [i + 1];\\n    }\\n  }\\n\\n  return map[max];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306105,
                "title": "c-solution-80-faster",
                "content": "# Intuition\\nWhen first thinking about how to solve this problem, it is clear that we need to find the division indices that maximize the sum of the number of 0\\'s on the left side and the number of 1\\'s on the right side. The intuition is to iterate through all possible divisions and maintain counters for the number of 0\\'s in the left part and the number of 1\\'s in the right part. As we move from one division to the next, we can update these counters and calculate the current division score. We can then compare the current division score with the highest score found so far to find the indices with the highest possible division score.\\n\\n\\n# Approach\\nTo solve this problem, we will use a single-pass approach with two counters: one for the number of 0\\'s on the left side and one for the number of 1\\'s on the right side. We will also maintain a variable to store the highest score found so far and a vector to store the indices corresponding to the highest scores.\\n\\n    1:  Initialize an empty vector all_divisions to store the \\n        indices with the highest scores.\\n    2:  Initialize variables highest_score and score to 0.\\n    3:  Initialize left_zeros to 0 and right_ones to the total\\n        count of 1\\'s in the input vector nums.\\n    4:  Iterate through all possible divisions from 0 to the\\n        length of the input vector nums (inclusive). For each\\n        division index i:\\n        a:  Calculate the current division score as the sum of\\n            left_zeros and right_ones.\\n        b:  If the current score is greater than the highest score\\n            found so far, update the highest score and clear the\\n            all_divisions vector.\\n        c:  If the current score is equal to the highest score,\\n            add the current index i to the all_divisions vector.\\n        d:  If i is less than the size of nums, update the\\n            left_zeros and right_ones counters based on the\\n            current element at index i in nums.\\n    5:  Return the all_divisions vector containing the indices with\\n        the highest possible division scores.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nThe algorithm iterates through the input vector nums once, updating the counters and checking the scores at each step. Since the input size is n, the time complexity is linear.\\n\\n- Space complexity: $$O(n)$$\\nIn the worst case, all division indices might have the highest score, requiring the all_divisions vector to store all n indices. Additionally, we have a few constant-size variables. Therefore, the space complexity is linear in terms of the input size n.\\n\\n# Code\\n```\\n// Author: Kamol Nazarov\\n\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> maxScoreIndices( vector<int>& nums ) {\\n\\n        vector<int> all_divisions; // Stores indices with the highest division score\\n        int highest_score = 0; // Stores the highest division score\\n        int score = 0; // Current division score\\n        int left_zeros = 0; // Count of 0\\'s in numsleft\\n        int right_ones = count( nums.begin( ), nums.end( ), 1 ); // Count of 1\\'s in numsright\\n\\n        // Iterate through all possible divisions\\n        for ( int i = 0; i <= nums.size(); ++i ) {\\n\\n            // Calculate the current division score\\n            score = left_zeros + right_ones;\\n\\n            // Update the highest_score and clear all_divisions if the current score is greater\\n            if ( score > highest_score ) {\\n\\n                highest_score = score;\\n                all_divisions.clear( );\\n\\n            }\\n\\n            // If the current score is equal to the highest_score, add the index to all_divisions\\n            if ( score == highest_score ) {\\n\\n                all_divisions.push_back( i );\\n\\n            }\\n\\n            // Update left_zeros and right_ones counters based on the current element\\n            if ( i < nums.size( ) && nums[i] == 1 ) {\\n\\n                --right_ones;\\n\\n            } else if ( i < nums.size( ) && nums[i] == 0 ) {\\n\\n                ++left_zeros;\\n\\n            }\\n\\n        }\\n\\n        return all_divisions;\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Author: Kamol Nazarov\\n\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> maxScoreIndices( vector<int>& nums ) {\\n\\n        vector<int> all_divisions; // Stores indices with the highest division score\\n        int highest_score = 0; // Stores the highest division score\\n        int score = 0; // Current division score\\n        int left_zeros = 0; // Count of 0\\'s in numsleft\\n        int right_ones = count( nums.begin( ), nums.end( ), 1 ); // Count of 1\\'s in numsright\\n\\n        // Iterate through all possible divisions\\n        for ( int i = 0; i <= nums.size(); ++i ) {\\n\\n            // Calculate the current division score\\n            score = left_zeros + right_ones;\\n\\n            // Update the highest_score and clear all_divisions if the current score is greater\\n            if ( score > highest_score ) {\\n\\n                highest_score = score;\\n                all_divisions.clear( );\\n\\n            }\\n\\n            // If the current score is equal to the highest_score, add the index to all_divisions\\n            if ( score == highest_score ) {\\n\\n                all_divisions.push_back( i );\\n\\n            }\\n\\n            // Update left_zeros and right_ones counters based on the current element\\n            if ( i < nums.size( ) && nums[i] == 1 ) {\\n\\n                --right_ones;\\n\\n            } else if ( i < nums.size( ) && nums[i] == 0 ) {\\n\\n                ++left_zeros;\\n\\n            }\\n\\n        }\\n\\n        return all_divisions;\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291544,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxScoreIndices(_ nums: [Int]) -> [Int] {\\n        \\n        var s0 = 0\\n        var s1 = nums.reduce(0, +)\\n\\n        var ma = s1\\n        var mc = [0]\\n\\n        for i in nums.indices {\\n\\n            let c = nums[i]\\n\\n            s0 += 1 - c\\n            s1 -= c\\n\\n            if s0 + s1 > ma {\\n                ma = s0 + s1\\n                mc = [i + 1]\\n            }\\n            else if s0 + s1 == ma {\\n                mc.append(i + 1)\\n            }\\n        }\\n\\n        return mc\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxScoreIndices(_ nums: [Int]) -> [Int] {\\n        \\n        var s0 = 0\\n        var s1 = nums.reduce(0, +)\\n\\n        var ma = s1\\n        var mc = [0]\\n\\n        for i in nums.indices {\\n\\n            let c = nums[i]\\n\\n            s0 += 1 - c\\n            s1 -= c\\n\\n            if s0 + s1 > ma {\\n                ma = s0 + s1\\n                mc = [i + 1]\\n            }\\n            else if s0 + s1 == ma {\\n                mc.append(i + 1)\\n            }\\n        }\\n\\n        return mc\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276767,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        {\\n            if(nums[0]==0)\\n                return {1};\\n            else\\n                return {0};\\n        }\\n        int one=0,zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n                one++;\\n        }\\n        if(nums[0]==0)\\n            zero++;\\n        vector<int> v;\\n        v.push_back(one);\\n        int ans=one;\\n        if(nums[0]==1)\\n            one--;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                v.push_back(zero+one);\\n                one--;\\n            }\\n            else\\n            {\\n                v.push_back(zero+one);\\n                zero++;\\n            }\\n            ans=max(ans,zero+one);   \\n        }\\n        \\n        v.push_back(zero);\\n        vector<int> res;\\n        for(int i=0;i<=n;i++)\\n        {\\n            // cout<<v[i]<<\" \";\\n            if(v[i]==ans)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        {\\n            if(nums[0]==0)\\n                return {1};\\n            else\\n                return {0};\\n        }\\n        int one=0,zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n                one++;\\n        }\\n        if(nums[0]==0)\\n            zero++;\\n        vector<int> v;\\n        v.push_back(one);\\n        int ans=one;\\n        if(nums[0]==1)\\n            one--;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                v.push_back(zero+one);\\n                one--;\\n            }\\n            else\\n            {\\n                v.push_back(zero+one);\\n                zero++;\\n            }\\n            ans=max(ans,zero+one);   \\n        }\\n        \\n        v.push_back(zero);\\n        vector<int> res;\\n        for(int i=0;i<=n;i++)\\n        {\\n            // cout<<v[i]<<\" \";\\n            if(v[i]==ans)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3272344,
                "title": "worst-case-senario",
                "content": "# **Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        ArrayList<Integer> al1=new ArrayList<>();\\n        ArrayList<Integer> al0=new ArrayList<>();\\n        int number1=0,number0=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                number1++;\\n            }else{\\n                number0++;\\n            }\\n        }\\n        int i=0,j,zerocount=0,onecount=number1;\\n        while(i<=nums.length){\\n            j=i-1;\\n            if(j<0){\\n             al0.add(0);\\n            }else{\\n                if(nums[j]==0 && zerocount<number0){\\n                    zerocount++;\\n                    al0.add(zerocount);\\n                }else if(nums[j]!=0){\\n                    al0.add(zerocount);\\n                }\\n\\n                 \\n            }\\n            i++;\\n        }\\n        i=0;\\n        while(i<=nums.length){\\n            if(i==nums.length || onecount==0){\\n                al1.add(0);\\n            }else if(nums[i]==0 && onecount>0){\\n                al1.add(onecount);\\n            }else if(nums[i]==1 && onecount>0){\\n                al1.add(onecount);\\n                onecount--;\\n            }\\n            i++;\\n        }\\n        int max=0;\\n         ArrayList<Integer> pre=new ArrayList<>();\\n        for(int k=0;k<al1.size();k++){\\n           pre.add(al1.get(k)+al0.get(k));\\n           if(max<al1.get(k)+al0.get(k)){\\n               max=al1.get(k)+al0.get(k);\\n           }\\n\\n        }\\n        ArrayList<Integer> result=new ArrayList<>();\\n        for(int k=0;k<pre.size();k++){\\n            if(max==pre.get(k)){\\n                result.add(k);\\n            }\\n        }\\n       return result;\\n\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        ArrayList<Integer> al1=new ArrayList<>();\\n        ArrayList<Integer> al0=new ArrayList<>();\\n        int number1=0,number0=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                number1++;\\n            }else{\\n                number0++;\\n            }\\n        }\\n        int i=0,j,zerocount=0,onecount=number1;\\n        while(i<=nums.length){\\n            j=i-1;\\n            if(j<0){\\n             al0.add(0);\\n            }else{\\n                if(nums[j]==0 && zerocount<number0){\\n                    zerocount++;\\n                    al0.add(zerocount);\\n                }else if(nums[j]!=0){\\n                    al0.add(zerocount);\\n                }\\n\\n                 \\n            }\\n            i++;\\n        }\\n        i=0;\\n        while(i<=nums.length){\\n            if(i==nums.length || onecount==0){\\n                al1.add(0);\\n            }else if(nums[i]==0 && onecount>0){\\n                al1.add(onecount);\\n            }else if(nums[i]==1 && onecount>0){\\n                al1.add(onecount);\\n                onecount--;\\n            }\\n            i++;\\n        }\\n        int max=0;\\n         ArrayList<Integer> pre=new ArrayList<>();\\n        for(int k=0;k<al1.size();k++){\\n           pre.add(al1.get(k)+al0.get(k));\\n           if(max<al1.get(k)+al0.get(k)){\\n               max=al1.get(k)+al0.get(k);\\n           }\\n\\n        }\\n        ArrayList<Integer> result=new ArrayList<>();\\n        for(int k=0;k<pre.size();k++){\\n            if(max==pre.get(k)){\\n                result.add(k);\\n            }\\n        }\\n       return result;\\n\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269299,
                "title": "o-n-time-o-1-space-c-most-easiest",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        //to count no. of ones you don\\'t need to traverse seperately\\n        //just add all elements the sum itself will give count of ones.\\n\\n        int score=0, left=0, right=accumulate(nums.begin(), nums.end(), 0);\\n        int ans=0, n = nums.size();\\n        vector<int> res;\\n        score = left+right;//when left subarry is empty []. left=0 and right=sum_of_ones.\\n\\n        for(int i=0; i<=n; i++)\\n        {\\n            if(score > ans){\\n                ans = score;\\n                res.clear();//if new max is found then no use of keeping old one\\'s index\\n                res.push_back(i);\\n            }\\n            else if(score == ans)\\n            {\\n                res.push_back(i);\\n            }\\n\\n            if(i == n)\\n            {\\n                right = 0;\\n                break;\\n            }\\n            //This is the case when right array becomes empty\\n            if(nums[i] == 0)\\n            {\\n                left++;\\n                score = left+right;\\n            }\\n            //devrement right when we get one in the array\\n            else{\\n                right--;\\n                score = left+right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        //to count no. of ones you don\\'t need to traverse seperately\\n        //just add all elements the sum itself will give count of ones.\\n\\n        int score=0, left=0, right=accumulate(nums.begin(), nums.end(), 0);\\n        int ans=0, n = nums.size();\\n        vector<int> res;\\n        score = left+right;//when left subarry is empty []. left=0 and right=sum_of_ones.\\n\\n        for(int i=0; i<=n; i++)\\n        {\\n            if(score > ans){\\n                ans = score;\\n                res.clear();//if new max is found then no use of keeping old one\\'s index\\n                res.push_back(i);\\n            }\\n            else if(score == ans)\\n            {\\n                res.push_back(i);\\n            }\\n\\n            if(i == n)\\n            {\\n                right = 0;\\n                break;\\n            }\\n            //This is the case when right array becomes empty\\n            if(nums[i] == 0)\\n            {\\n                left++;\\n                score = left+right;\\n            }\\n            //devrement right when we get one in the array\\n            else{\\n                right--;\\n                score = left+right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265866,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int l=0,r=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]) r++;\\n        }\\n        map<int,vector<int>,greater<int>>m;\\n        for(int i=0;i<nums.size();++i){\\n            m[r+l].push_back(i);\\n            if(nums[i]==0) l++;\\n            if(nums[i]) r--;\\n        }\\n        m[r+l].push_back(nums.size());\\n        return m.begin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int l=0,r=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]) r++;\\n        }\\n        map<int,vector<int>,greater<int>>m;\\n        for(int i=0;i<nums.size();++i){\\n            m[r+l].push_back(i);\\n            if(nums[i]==0) l++;\\n            if(nums[i]) r--;\\n        }\\n        m[r+l].push_back(nums.size());\\n        return m.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255957,
                "title": "prefix-and-suffix-array-simple-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> left(n+1,0), right(n+1,0);\\n        right[n-1]=nums[n-1];\\n        \\n        for(int x=1; x<=n; x++)\\n        {\\n            left[x]=left[x-1]+(nums[x-1]==0?1:0);\\n        }\\n        for(int x=n-1; x>=0; x--)\\n        {\\n            right[x]=right[x+1]+(nums[x]==1?1:0);\\n        }\\n\\n        vector<int> v(n+1), ans;\\n\\n        for(int x=0; x<=n; x++) \\n        {\\n            v[x]=left[x]+right[x];\\n        }\\n\\n        int mx=*max_element(v.begin(),v.end());\\n\\n        for(int x=0; x<=n; x++)\\n        {\\n            if(v[x]==mx) ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> left(n+1,0), right(n+1,0);\\n        right[n-1]=nums[n-1];\\n        \\n        for(int x=1; x<=n; x++)\\n        {\\n            left[x]=left[x-1]+(nums[x-1]==0?1:0);\\n        }\\n        for(int x=n-1; x>=0; x--)\\n        {\\n            right[x]=right[x+1]+(nums[x]==1?1:0);\\n        }\\n\\n        vector<int> v(n+1), ans;\\n\\n        for(int x=0; x<=n; x++) \\n        {\\n            v[x]=left[x]+right[x];\\n        }\\n\\n        int mx=*max_element(v.begin(),v.end());\\n\\n        for(int x=0; x<=n; x++)\\n        {\\n            if(v[x]==mx) ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241698,
                "title": "c-count-number-one-brute-force",
                "content": "# Count number one\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        if (nums.empty()) return res;\\n\\n        int left = 0, right = 0;\\n        for (auto& n : nums) {\\n            right += n;\\n        }\\n\\n        int sum = left + right;\\n        int temp;\\n        res.push_back(0);\\n        for (int i = 0; i < n; i++) {\\n            temp = 0;\\n            if (nums[i] == 0) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n\\n            temp = left + right;\\n            if (temp == sum) {\\n                res.push_back(i + 1);\\n            } else if (temp > sum) {\\n                sum = temp;\\n                res.clear();\\n                res.push_back(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Brute force\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> division_score(n + 1, 0);\\n        int max_score = -1;\\n        \\n        // Precompute the prefix sum of 0\\'s and 1\\'s\\n        vector<int> zeros(n + 1, 0);\\n        vector<int> ones(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            zeros[i] = zeros[i-1] + (nums[i-1] == 0 ? 1 : 0);\\n            ones[n-i] = ones[n-i+1] + (nums[n-i] == 1 ? 1 : 0);\\n        }\\n        \\n        // Calculate the division score for each i\\n        for (int i = 0; i <= n; i++) {\\n            division_score[i] = zeros[i] + ones[i];\\n            if (division_score[i] > max_score) {\\n                max_score = division_score[i];\\n            }\\n        }\\n        \\n        // Find all indices with the maximum division score\\n        vector<int> result;\\n        for (int i = 0; i <= n; i++) {\\n            if (division_score[i] == max_score) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        if (nums.empty()) return res;\\n\\n        int left = 0, right = 0;\\n        for (auto& n : nums) {\\n            right += n;\\n        }\\n\\n        int sum = left + right;\\n        int temp;\\n        res.push_back(0);\\n        for (int i = 0; i < n; i++) {\\n            temp = 0;\\n            if (nums[i] == 0) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n\\n            temp = left + right;\\n            if (temp == sum) {\\n                res.push_back(i + 1);\\n            } else if (temp > sum) {\\n                sum = temp;\\n                res.clear();\\n                res.push_back(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> division_score(n + 1, 0);\\n        int max_score = -1;\\n        \\n        // Precompute the prefix sum of 0\\'s and 1\\'s\\n        vector<int> zeros(n + 1, 0);\\n        vector<int> ones(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            zeros[i] = zeros[i-1] + (nums[i-1] == 0 ? 1 : 0);\\n            ones[n-i] = ones[n-i+1] + (nums[n-i] == 1 ? 1 : 0);\\n        }\\n        \\n        // Calculate the division score for each i\\n        for (int i = 0; i <= n; i++) {\\n            division_score[i] = zeros[i] + ones[i];\\n            if (division_score[i] > max_score) {\\n                max_score = division_score[i];\\n            }\\n        }\\n        \\n        // Find all indices with the maximum division score\\n        vector<int> result;\\n        for (int i = 0; i <= n; i++) {\\n            if (division_score[i] == max_score) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225475,
                "title": "step-by-step-explained-solution-java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n    $$O(n)$$ \\n\\n- Space complexity:\\n  $$O(n)$$  for level storing\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> a = new ArrayList<>();\\n        \\n        int z = 0,o = 0;\\n\\n        //counting 1 in the 0 level\\n        for(int i = 0;i < nums.length;i ++) {\\n            if(nums[i] == 1) {\\n                o++;\\n            }\\n        }\\n        \\n        int max = 0,o1 = o;\\n        int l = 0,r = l + 1;\\n        //Store level with sum;\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        while(l < nums.length){\\n            //0 counting\\n            if(nums[l] == 0) {\\n                z ++;\\n            }else if(nums[l] == 1) {//if found any 1 in left decrease 1\\'s count \\n                o1 --;\\n            }\\n            if(z + o1 >= max) { //sum up of left and right\\n                max = z + o1;\\n            }\\n            mp.put(l+1,z + o1);\\n            l++;            \\n        }\\n        //check if 0 level is holding max\\n        if(o >= max) a.add(0);\\n\\n        for(Map.Entry<Integer,Integer> m : mp.entrySet()){\\n            //check wheather any values equal to max if yes add it to result\\n            if(m.getValue() >= o && m.getValue() == max) {\\n                a.add(m.getKey());\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> a = new ArrayList<>();\\n        \\n        int z = 0,o = 0;\\n\\n        //counting 1 in the 0 level\\n        for(int i = 0;i < nums.length;i ++) {\\n            if(nums[i] == 1) {\\n                o++;\\n            }\\n        }\\n        \\n        int max = 0,o1 = o;\\n        int l = 0,r = l + 1;\\n        //Store level with sum;\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        while(l < nums.length){\\n            //0 counting\\n            if(nums[l] == 0) {\\n                z ++;\\n            }else if(nums[l] == 1) {//if found any 1 in left decrease 1\\'s count \\n                o1 --;\\n            }\\n            if(z + o1 >= max) { //sum up of left and right\\n                max = z + o1;\\n            }\\n            mp.put(l+1,z + o1);\\n            l++;            \\n        }\\n        //check if 0 level is holding max\\n        if(o >= max) a.add(0);\\n\\n        for(Map.Entry<Integer,Integer> m : mp.entrySet()){\\n            //check wheather any values equal to max if yes add it to result\\n            if(m.getValue() >= o && m.getValue() == max) {\\n                a.add(m.getKey());\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170221,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n\\n        // 0 1 2 2 3\\n        // 1 1 1 0 0\\n        int n = nums.size();\\n\\n        vector<int> zero(n+1, 0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 0){\\n                zero[i+1] = zero[i] + 1;\\n            }\\n            else{\\n                zero[i+1] = zero[i];\\n            }\\n        }\\n\\n        vector<int> ones(n+1, 0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] == 1){\\n                ones[i] = ones[i+1] + 1;\\n            }\\n            else{\\n                ones[i] = ones[i+1];\\n            }\\n        }\\n\\n        int mscore = INT_MIN;\\n        for(int i=0;i<=n;i++){\\n            mscore = max(mscore, ones[i]+zero[i]);\\n        }\\n        cout << mscore << endl;\\n        vector<int> ans;\\n\\n        for(int i=0;i<=n;i++){\\n            if(mscore ==  ones[i]+zero[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n\\n        // 0 1 2 2 3\\n        // 1 1 1 0 0\\n        int n = nums.size();\\n\\n        vector<int> zero(n+1, 0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 0){\\n                zero[i+1] = zero[i] + 1;\\n            }\\n            else{\\n                zero[i+1] = zero[i];\\n            }\\n        }\\n\\n        vector<int> ones(n+1, 0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] == 1){\\n                ones[i] = ones[i+1] + 1;\\n            }\\n            else{\\n                ones[i] = ones[i+1];\\n            }\\n        }\\n\\n        int mscore = INT_MIN;\\n        for(int i=0;i<=n;i++){\\n            mscore = max(mscore, ones[i]+zero[i]);\\n        }\\n        cout << mscore << endl;\\n        vector<int> ans;\\n\\n        for(int i=0;i<=n;i++){\\n            if(mscore ==  ones[i]+zero[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3169320,
                "title": "solution-for-all-divisions-with-the-highest-score-of-a-binary-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the amount of ones located in the given array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst count the ones that located in the given array and then assign the value as a max posible outcome and assign it as the first binary hight score. initate for loop start\\'s from 0 up to array length. then cout up the zeros that found int the left side and count down the ones if it exist in the left side then sum up the two values and push it to the assined array and check the max value changed. after doing this loacte the index which contain the max value from the assign array and push it to the result array. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(s) {\\n       var ones = s.reduce((total, current) => { return total + current }, 0)\\n        var maxValue = ones;\\n        var arr = [ones];\\n        var numleft = 0;\\n        var result = [];\\n\\n        for (var i = 0; i < s.length; i++) {\\n            if (s[i] === 0) numleft++;\\n            if (s[i] === 1) ones--;\\n            var sum = numleft + ones\\n            arr.push(sum);\\n            if (maxValue < sum) maxValue = sum;\\n        }\\n        for (var i = 0; i < arr.length; i++) {\\n            if (arr[i] === maxValue) result.push(i)\\n        }\\n        return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(s) {\\n       var ones = s.reduce((total, current) => { return total + current }, 0)\\n        var maxValue = ones;\\n        var arr = [ones];\\n        var numleft = 0;\\n        var result = [];\\n\\n        for (var i = 0; i < s.length; i++) {\\n            if (s[i] === 0) numleft++;\\n            if (s[i] === 1) ones--;\\n            var sum = numleft + ones\\n            arr.push(sum);\\n            if (maxValue < sum) maxValue = sum;\\n        }\\n        for (var i = 0; i < arr.length; i++) {\\n            if (arr[i] === maxValue) result.push(i)\\n        }\\n        return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3166783,
                "title": "cpp-prefix-sum-count-ones-o-n-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep count of number of ones at every index. Subtract from total sum to get zeros, ones;\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size(),s=0,mx=0;\\n        vector<int> one,res,score;\\n\\n        for(int i:nums){\\n            s+=i;\\n            one.push_back(s);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int zL=i-one[i] + (nums[i]==1); //zL -> zeros on left\\n            int oR=one[n-1] - one[i] + (nums[i]==1); //oR -> ones on RIght\\n\\n            score.push_back(zL+oR);\\n        }\\n        score.push_back(n-s);\\n\\n        mx=*max_element(score.begin(),score.end());\\n\\n        for(int i=0;i<=n;i++)\\n        if(score[i]==mx)\\n        res.push_back(i);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size(),s=0,mx=0;\\n        vector<int> one,res,score;\\n\\n        for(int i:nums){\\n            s+=i;\\n            one.push_back(s);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int zL=i-one[i] + (nums[i]==1); //zL -> zeros on left\\n            int oR=one[n-1] - one[i] + (nums[i]==1); //oR -> ones on RIght\\n\\n            score.push_back(zL+oR);\\n        }\\n        score.push_back(n-s);\\n\\n        mx=*max_element(score.begin(),score.end());\\n\\n        for(int i=0;i<=n;i++)\\n        if(score[i]==mx)\\n        res.push_back(i);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165407,
                "title": "cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>zero;\\n        vector<int>one;\\n        vector<int>score;\\n        int count=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)count++;\\n            zero.push_back(count);\\n        }\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)count++;\\n            one.push_back(count);\\n        }\\n        \\n        reverse(one.begin(),one.end());\\n        int maxi=0;\\n        int i=1;\\n        maxi=max(maxi,one[0]);\\n        score.push_back(one[0]);\\n        while(i<n){\\n            maxi=max(maxi,one[i]+zero[i-1]);\\n            score.push_back(one[i]+zero[i-1]);\\n            i++;\\n        }\\n        maxi=max(maxi,zero[n-1]);\\n        score.push_back(zero[n-1]);\\n        i=0;\\n        vector<int>ans;\\n        while(i<score.size()){\\n            if(score[i]==maxi)ans.push_back(i);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>zero;\\n        vector<int>one;\\n        vector<int>score;\\n        int count=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)count++;\\n            zero.push_back(count);\\n        }\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1)count++;\\n            one.push_back(count);\\n        }\\n        \\n        reverse(one.begin(),one.end());\\n        int maxi=0;\\n        int i=1;\\n        maxi=max(maxi,one[0]);\\n        score.push_back(one[0]);\\n        while(i<n){\\n            maxi=max(maxi,one[i]+zero[i-1]);\\n            score.push_back(one[i]+zero[i-1]);\\n            i++;\\n        }\\n        maxi=max(maxi,zero[n-1]);\\n        score.push_back(zero[n-1]);\\n        i=0;\\n        vector<int>ans;\\n        while(i<score.size()){\\n            if(score[i]==maxi)ans.push_back(i);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151439,
                "title": "c-one-sweep-solution-clean-and-clean-code-no-extra-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>ans;\\n        int zeroes = count(nums.begin(), nums.end(), 0);\\n        int ones = count(nums.begin(), nums.end(), 1);\\n\\n        int maxiscore = INT_MIN;\\n        int currz = 0;\\n        int curro = 0;\\n        int i = 0;\\n        for(int x: nums){\\n            \\n            int currscore = currz+(ones-curro);\\n\\n            if(currscore>maxiscore){\\n                ans.clear();\\n                ans.push_back(i);\\n                maxiscore = currscore;\\n            }\\n\\n            else if(currscore==maxiscore){\\n                ans.push_back(i);\\n            }\\n\\n            if(x == 0){\\n                currz++;\\n            }\\n            else{\\n                curro++;\\n            }\\n            i++;\\n        }\\n\\n        if(currz+(ones-curro)>maxiscore){\\n            ans.clear();\\n            ans.push_back(i);\\n            maxiscore = currz+(ones-curro);\\n        }\\n\\n        else if(currz+(ones-curro)==maxiscore){\\n            ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int>ans;\\n        int zeroes = count(nums.begin(), nums.end(), 0);\\n        int ones = count(nums.begin(), nums.end(), 1);\\n\\n        int maxiscore = INT_MIN;\\n        int currz = 0;\\n        int curro = 0;\\n        int i = 0;\\n        for(int x: nums){\\n            \\n            int currscore = currz+(ones-curro);\\n\\n            if(currscore>maxiscore){\\n                ans.clear();\\n                ans.push_back(i);\\n                maxiscore = currscore;\\n            }\\n\\n            else if(currscore==maxiscore){\\n                ans.push_back(i);\\n            }\\n\\n            if(x == 0){\\n                currz++;\\n            }\\n            else{\\n                curro++;\\n            }\\n            i++;\\n        }\\n\\n        if(currz+(ones-curro)>maxiscore){\\n            ans.clear();\\n            ans.push_back(i);\\n            maxiscore = currz+(ones-curro);\\n        }\\n\\n        else if(currz+(ones-curro)==maxiscore){\\n            ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136934,
                "title": "java-o-n-time-prefix-sum-explained-well",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] a) {\\n        int n=a.length;\\n        // used to store number of zeros\\n        int pre[]=new int [n];\\n        // used to store number of ones\\n        int suf[]=new int [n];\\n        \\n        pre[0]=a[0]==1?0:1;\\n        suf[n-1]=a[n-1]==1?1:0;\\n        for(int i=1;i<n;i++) {\\n            if(a[i]==1)pre[i]=pre[i-1];\\n            else pre[i]=1+pre[i-1];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]==1)suf[i]=suf[i+1]+1;\\n            else suf[i]=suf[i+1];\\n        }\\n        // get max value of the zeros+ones\\n        int max=0;\\n        for(int i=0;i<=n;i++){\\n            int zeros=i-1>=0?pre[i-1]:0;\\n            int ones=i<n?suf[i]:0;\\n            max=Math.max(max,ones+zeros);\\n        }\\n        List<Integer> ans= new ArrayList<>();\\n        \\n        // add the index which max==ones+zeros\\n        for(int i=0;i<=n;i++){\\n            int zeros=i-1>=0?pre[i-1]:0;\\n            int ones=i<n?suf[i]:0;\\n            if(max==ones+zeros) ans.add(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] a) {\\n        int n=a.length;\\n        // used to store number of zeros\\n        int pre[]=new int [n];\\n        // used to store number of ones\\n        int suf[]=new int [n];\\n        \\n        pre[0]=a[0]==1?0:1;\\n        suf[n-1]=a[n-1]==1?1:0;\\n        for(int i=1;i<n;i++) {\\n            if(a[i]==1)pre[i]=pre[i-1];\\n            else pre[i]=1+pre[i-1];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]==1)suf[i]=suf[i+1]+1;\\n            else suf[i]=suf[i+1];\\n        }\\n        // get max value of the zeros+ones\\n        int max=0;\\n        for(int i=0;i<=n;i++){\\n            int zeros=i-1>=0?pre[i-1]:0;\\n            int ones=i<n?suf[i]:0;\\n            max=Math.max(max,ones+zeros);\\n        }\\n        List<Integer> ans= new ArrayList<>();\\n        \\n        // add the index which max==ones+zeros\\n        for(int i=0;i<=n;i++){\\n            int zeros=i-1>=0?pre[i-1]:0;\\n            int ones=i<n?suf[i]:0;\\n            if(max==ones+zeros) ans.add(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121499,
                "title": "count-ones-and-subtract-while-traversal",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums):\\n        rightones = nums.count(1)\\n        leftzeroes = 0\\n        mscore = leftzeroes + rightones\\n        res = [0]\\n        for i, el in enumerate(nums):\\n            if el == 0:\\n                leftzeroes += 1\\n            else:\\n                rightones -= 1\\n            if leftzeroes + rightones > mscore:\\n                mscore = leftzeroes + rightones\\n                res = [i + 1]\\n            elif mscore == leftzeroes + rightones:\\n                res.append(i + 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums):\\n        rightones = nums.count(1)\\n        leftzeroes = 0\\n        mscore = leftzeroes + rightones\\n        res = [0]\\n        for i, el in enumerate(nums):\\n            if el == 0:\\n                leftzeroes += 1\\n            else:\\n                rightones -= 1\\n            if leftzeroes + rightones > mscore:\\n                mscore = leftzeroes + rightones\\n                res = [i + 1]\\n            elif mscore == leftzeroes + rightones:\\n                res.append(i + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086869,
                "title": "very-simple-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Count zeros and ones \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> score(nums.size()+1,0);\\n        vector<int> ans;\\n        int zero = 0, tone = 0;\\n        for(int i=1;i<=nums.size();i++){\\n            if(nums[i-1] == 0) zero++;\\n            else tone++;\\n            score[i] = zero;\\n        }\\n        score[0] = tone;\\n        int mxs = score[0];\\n        for(int i=1;i<=nums.size();i++){ \\n            score[i] = score[i] + (tone - (i - score[i]));\\n            mxs = max(mxs,score[i]);\\n        }\\n        for(int i=0;i<=nums.size();i++) if(score[i] == mxs) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> score(nums.size()+1,0);\\n        vector<int> ans;\\n        int zero = 0, tone = 0;\\n        for(int i=1;i<=nums.size();i++){\\n            if(nums[i-1] == 0) zero++;\\n            else tone++;\\n            score[i] = zero;\\n        }\\n        score[0] = tone;\\n        int mxs = score[0];\\n        for(int i=1;i<=nums.size();i++){ \\n            score[i] = score[i] + (tone - (i - score[i]));\\n            mxs = max(mxs,score[i]);\\n        }\\n        for(int i=0;i<=nums.size();i++) if(score[i] == mxs) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070338,
                "title": "python-one-pass-o-n",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        nums.append(0)\\n        counter = Counter(nums)\\n        curzeros = 0\\n        curmax = 0\\n        res = []\\n        for i, num in enumerate(nums):\\n            if curmax < curzeros + counter[1]:\\n                res = [i]\\n                curmax = curzeros + counter[1]\\n            elif curmax == curzeros + counter[1]:\\n                res.append(i)\\n            if num == 0:\\n                curzeros += 1\\n            else:\\n                counter[1] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        nums.append(0)\\n        counter = Counter(nums)\\n        curzeros = 0\\n        curmax = 0\\n        res = []\\n        for i, num in enumerate(nums):\\n            if curmax < curzeros + counter[1]:\\n                res = [i]\\n                curmax = curzeros + counter[1]\\n            elif curmax == curzeros + counter[1]:\\n                res.append(i)\\n            if num == 0:\\n                curzeros += 1\\n            else:\\n                counter[1] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048801,
                "title": "javascript-solution-with-prefix-sum",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(nums) {\\n    let res = [];\\n    let sum = [0,0];\\n    let arr = [[0,0]];\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0){\\n            sum[0] ++;\\n        }else if(nums[i] === 1){\\n            sum[1] ++;\\n        }\\n\\n        arr.push([...sum]);\\n    }\\n\\n    let max = -1;\\n    for(let i=0; i<=nums.length; i++){\\n        let left = calcLeft(arr[0], arr[i]);\\n        let right = calcRight(arr[i], arr[nums.length]);\\n        let m = left + right;\\n        if(m > max){\\n            max = m;\\n            res = [i];\\n        }else if(m === max){\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n\\nfunction calcLeft(a1, a2){\\n    let res = a2[0] - a1[0];\\n    return res;\\n}\\n\\nfunction calcRight(a1, a2){\\n    let res = a2[1] - a1[1];\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar maxScoreIndices = function(nums) {\\n    let res = [];\\n    let sum = [0,0];\\n    let arr = [[0,0]];\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0){\\n            sum[0] ++;\\n        }else if(nums[i] === 1){\\n            sum[1] ++;\\n        }\\n\\n        arr.push([...sum]);\\n    }\\n\\n    let max = -1;\\n    for(let i=0; i<=nums.length; i++){\\n        let left = calcLeft(arr[0], arr[i]);\\n        let right = calcRight(arr[i], arr[nums.length]);\\n        let m = left + right;\\n        if(m > max){\\n            max = m;\\n            res = [i];\\n        }else if(m === max){\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n\\nfunction calcLeft(a1, a2){\\n    let res = a2[0] - a1[0];\\n    return res;\\n}\\n\\nfunction calcRight(a1, a2){\\n    let res = a2[1] - a1[1];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3020388,
                "title": "hashmap-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ZeroCnt=0,OneCnt=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) ZeroCnt++;\\n        }\\n        int maxDivision=Integer.MIN_VALUE;\\n        OneCnt=nums.length-ZeroCnt;\\n        map.put(0,OneCnt);\\n        int cnt=ZeroCnt;\\n        maxDivision=Math.max(maxDivision,OneCnt);\\n        ZeroCnt=0;\\n        for(int i=1;i<nums.length;i++){\\n           if(nums[i-1]==0){\\n               ZeroCnt++;\\n           }\\n           else{\\n               OneCnt--;\\n           }\\n            map.put(i,ZeroCnt+OneCnt);\\n            maxDivision=Math.max(maxDivision,ZeroCnt+OneCnt);\\n        }\\n        map.put(nums.length,cnt);\\n        maxDivision=Math.max(maxDivision,cnt);\\n        List<Integer>list=new ArrayList<>();\\n        for(int x:map.keySet()){\\n           if(map.get(x)==maxDivision) list.add(x);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ZeroCnt=0,OneCnt=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) ZeroCnt++;\\n        }\\n        int maxDivision=Integer.MIN_VALUE;\\n        OneCnt=nums.length-ZeroCnt;\\n        map.put(0,OneCnt);\\n        int cnt=ZeroCnt;\\n        maxDivision=Math.max(maxDivision,OneCnt);\\n        ZeroCnt=0;\\n        for(int i=1;i<nums.length;i++){\\n           if(nums[i-1]==0){\\n               ZeroCnt++;\\n           }\\n           else{\\n               OneCnt--;\\n           }\\n            map.put(i,ZeroCnt+OneCnt);\\n            maxDivision=Math.max(maxDivision,ZeroCnt+OneCnt);\\n        }\\n        map.put(nums.length,cnt);\\n        maxDivision=Math.max(maxDivision,cnt);\\n        List<Integer>list=new ArrayList<>();\\n        for(int x:map.keySet()){\\n           if(map.get(x)==maxDivision) list.add(x);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002904,
                "title": "easiest-solution-c-easy-to-understand-just-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> zeros(nums.size()+1,0),ones(nums.size()+1,0),vec(nums.size()+1,0);\\n        int zero = 0;\\n        for(int i=0;i<nums.size();i++){\\n            zeros[i]=zero;\\n            if(nums[i]==0) zero++;\\n        }\\n        zeros[nums.size()]=zero;\\n        int one = 0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]==1) one++;\\n            ones[i]=one;\\n        }\\n        ones[nums.size()]=0;\\n        for(int i=0;i<=nums.size();i++) vec[i]=ones[i]+zeros[i];\\n        int a = *max_element(vec.begin(),vec.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size()+1;i++) if(vec[i]==a) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> zeros(nums.size()+1,0),ones(nums.size()+1,0),vec(nums.size()+1,0);\\n        int zero = 0;\\n        for(int i=0;i<nums.size();i++){\\n            zeros[i]=zero;\\n            if(nums[i]==0) zero++;\\n        }\\n        zeros[nums.size()]=zero;\\n        int one = 0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]==1) one++;\\n            ones[i]=one;\\n        }\\n        ones[nums.size()]=0;\\n        for(int i=0;i<=nums.size();i++) vec[i]=ones[i]+zeros[i];\\n        int a = *max_element(vec.begin(),vec.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size()+1;i++) if(vec[i]==a) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964183,
                "title": "easy-and-simple-beginner-friendly-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n= nums.size();\\n        int cnt2=0,cnt1=0;\\n        vector<int>ans(0);\\n        for(int i=0;i<n; i++) {\\n            if(nums[i]==1) cnt2++;\\n        }\\n        int max=cnt2;\\n        for(int i=0;i<=n; i++) {\\n            if(cnt1+cnt2>max) {\\n                max=cnt1+cnt2;\\n                ans.clear();\\n            }\\n             if(max==cnt1+cnt2) ans.push_back(i);\\n           if(i<n) {\\n            if(nums[i]==0) cnt1++;\\n           if(nums[i]==1) cnt2--;\\n           }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n= nums.size();\\n        int cnt2=0,cnt1=0;\\n        vector<int>ans(0);\\n        for(int i=0;i<n; i++) {\\n            if(nums[i]==1) cnt2++;\\n        }\\n        int max=cnt2;\\n        for(int i=0;i<=n; i++) {\\n            if(cnt1+cnt2>max) {\\n                max=cnt1+cnt2;\\n                ans.clear();\\n            }\\n             if(max==cnt1+cnt2) ans.push_back(i);\\n           if(i<n) {\\n            if(nums[i]==0) cnt1++;\\n           if(nums[i]==1) cnt2--;\\n           }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948334,
                "title": "c-99-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStoring those pairs (score,index) with score more than or equal to the max score found so far and then finally return the indices with final max score.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<pair<int,int>> v;\\n        vector<int> ans;\\n        int a,max=INT_MIN,s=0,sum=0,i;\\n        for(auto x:nums) s += x;\\n        for(i=0;i<=nums.size();i++){\\n            a = i-sum+s-sum;\\n            if(a>=max) {\\n                max = a;\\n                v.push_back({a,i});\\n            }\\n            if(i == nums.size()) break;\\n            sum += nums[i];\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].first == max) ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<pair<int,int>> v;\\n        vector<int> ans;\\n        int a,max=INT_MIN,s=0,sum=0,i;\\n        for(auto x:nums) s += x;\\n        for(i=0;i<=nums.size();i++){\\n            a = i-sum+s-sum;\\n            if(a>=max) {\\n                max = a;\\n                v.push_back({a,i});\\n            }\\n            if(i == nums.size()) break;\\n            sum += nums[i];\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].first == max) ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912116,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int ones = 0, zeros = 0, maxn = 0;\\n        vector<int>ans;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i])ones++;\\n        \\n        nums.push_back(-1);//adding one element extra so won\\'t have to add condition after loop\\n\\n        for(int i = 0; i < nums.size(); i++){ \\n            int sum = zeros + ones;\\n            if(maxn == sum) ans.push_back(i);\\n            else if(maxn < sum){\\n                ans = {};\\n                ans.push_back(i);\\n                maxn = sum;\\n            }\\n\\n            if(nums[i] == 0)zeros++;\\n            else ones--;\\n        }\\n\\n        nums.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int ones = 0, zeros = 0, maxn = 0;\\n        vector<int>ans;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i])ones++;\\n        \\n        nums.push_back(-1);//adding one element extra so won\\'t have to add condition after loop\\n\\n        for(int i = 0; i < nums.size(); i++){ \\n            int sum = zeros + ones;\\n            if(maxn == sum) ans.push_back(i);\\n            else if(maxn < sum){\\n                ans = {};\\n                ans.push_back(i);\\n                maxn = sum;\\n            }\\n\\n            if(nums[i] == 0)zeros++;\\n            else ones--;\\n        }\\n\\n        nums.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895618,
                "title": "o-n-presum-solution-in-python3",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        curr, preSum = 0, [0]\\n        for i in range(len(nums)):\\n            curr += 1 if nums[i] == 0 else 0 \\n            preSum.append(curr)\\n        \\n        curr, temp = 0, [0]\\n        for i in range(len(nums)-1, -1, -1):\\n            curr += 1 if nums[i] == 1 else 0\\n            temp.append(curr)\\n        postSum = temp[::-1]\\n            \\n        arr = []\\n        for i in range(len(preSum)):\\n            arr.append(preSum[i] + postSum[i])\\n        \\n        maxVal = max(arr)\\n        return [k[0] for k in list(enumerate (arr)) if k[1] == maxVal]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        curr, preSum = 0, [0]\\n        for i in range(len(nums)):\\n            curr += 1 if nums[i] == 0 else 0 \\n            preSum.append(curr)\\n        \\n        curr, temp = 0, [0]\\n        for i in range(len(nums)-1, -1, -1):\\n            curr += 1 if nums[i] == 1 else 0\\n            temp.append(curr)\\n        postSum = temp[::-1]\\n            \\n        arr = []\\n        for i in range(len(preSum)):\\n            arr.append(preSum[i] + postSum[i])\\n        \\n        maxVal = max(arr)\\n        return [k[0] for k in list(enumerate (arr)) if k[1] == maxVal]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894561,
                "title": "java",
                "content": "# Intuition\\ncounting no.of ones and zeros make it easy\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ones =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                ones++;\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        int rightScore = ones;\\n        int leftScore = 0;\\n        int maxScore = rightScore+leftScore;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                leftScore++;\\n            }else if (nums[i]==1){\\n                rightScore--;\\n            }\\n            int currentScore = rightScore+leftScore;\\n\\n            if(currentScore>maxScore){\\n                ans =new ArrayList<>();\\n                maxScore=currentScore;\\n                ans.add(i+1);\\n            }else if(currentScore==maxScore){\\n                ans.add(i+1);\\n            }\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int ones =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                ones++;\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        int rightScore = ones;\\n        int leftScore = 0;\\n        int maxScore = rightScore+leftScore;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                leftScore++;\\n            }else if (nums[i]==1){\\n                rightScore--;\\n            }\\n            int currentScore = rightScore+leftScore;\\n\\n            if(currentScore>maxScore){\\n                ans =new ArrayList<>();\\n                maxScore=currentScore;\\n                ans.add(i+1);\\n            }else if(currentScore==maxScore){\\n                ans.add(i+1);\\n            }\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857514,
                "title": "c-solution",
                "content": "\\tvector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, zero = 0, one = 0;;\\n        vector<int> v, res;\\n        for(int i = 0; i < n; i++)\\n            one += nums[i] == 1;\\n        v.push_back(one);\\n        for(int i = 0; i < n; i++){\\n            zero += nums[i] == 0;\\n            one -= nums[i] == 1;\\n            v.push_back(zero + one);\\n            mx = max(mx , v[i]);\\n        }\\n        mx = max(mx , v.back());\\n        for(int i = 0; i < v.size(); i++)\\n            if(v[i] == mx)\\n                res.push_back(i);\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tvector<int> maxScoreIndices(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, zero = 0, one = 0;;\\n        vector<int> v, res;\\n        for(int i = 0; i < n; i++)\\n            one += nums[i] == 1;\\n        v.push_back(one);\\n        for(int i = 0; i < n; i++){\\n            zero += nums[i] == 0;\\n            one -= nums[i] == 1;\\n            v.push_back(zero + one);\\n            mx = max(mx , v[i]);\\n        }\\n        mx = max(mx , v.back());\\n        for(int i = 0; i < v.size(); i++)\\n            if(v[i] == mx)\\n                res.push_back(i);\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2857025,
                "title": "c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int left = 0;\\n        int right = nums.size();\\n        vector<int> res;\\n        int rightOne=0,leftZero=0,maxScore=0;\\n        for(int i=left;i<right;i++){\\n            if(nums[i]==1) rightOne++;\\n        }\\n\\n        for(int i=left;i<=right;i++){\\n            // cout<<leftZero<<\" \"<<rightOne<<endl;\\n            if(leftZero+rightOne>maxScore){\\n                maxScore=leftZero+rightOne;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            else if(leftZero+rightOne==maxScore){\\n                res.push_back(i);\\n            }\\n            if(i<nums.size()){\\n                if(nums[i]==0) leftZero++;\\n                if(nums[i]==1) rightOne--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int left = 0;\\n        int right = nums.size();\\n        vector<int> res;\\n        int rightOne=0,leftZero=0,maxScore=0;\\n        for(int i=left;i<right;i++){\\n            if(nums[i]==1) rightOne++;\\n        }\\n\\n        for(int i=left;i<=right;i++){\\n            // cout<<leftZero<<\" \"<<rightOne<<endl;\\n            if(leftZero+rightOne>maxScore){\\n                maxScore=leftZero+rightOne;\\n                res.clear();\\n                res.push_back(i);\\n            }\\n            else if(leftZero+rightOne==maxScore){\\n                res.push_back(i);\\n            }\\n            if(i<nums.size()){\\n                if(nums[i]==0) leftZero++;\\n                if(nums[i]==1) rightOne--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2847537,
                "title": "c-simple-implementation-o-n",
                "content": "\\n\\n       \\n\\t    vector<pair<int, int>> score;\\n        int n = nums.size(), sum = 0, maxi;\\n\\t\\tvector<int> L;\\n        sum = accumulate(nums.begin(), nums.end(), 0);     // calculating score at index 0(sum of all ones)\\n        maxi = sum;\\n        score.push_back({0, sum});   //pushing score to vector pair for index 0\\n        \\n\\t\\tfor(int i = 1; i <= n; i++)\\n        {\\n            if(nums[i-1] == 0)  sum++;\\n            if(nums[i-1] == 1)  sum--;          // calculating no of zeroes to the left and no of ones to the right\\n            score.push_back({i, sum});\\n            maxi = max(maxi, sum);            // calculating maximum score that can be obtained \\n        }\\n      \\n\\t\\tfor(int i = 0; i < score.size(); i++)\\n        {\\n            if(score[i].second == maxi)    L.push_back(score[i].first);     // pushing indexes that has maximum score\\n        }\\n        return L;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n       \\n\\t    vector<pair<int, int>> score;\\n        int n = nums.size(), sum = 0, maxi;\\n\\t\\tvector<int> L;\\n        sum = accumulate(nums.begin(), nums.end(), 0);     // calculating score at index 0(sum of all ones)\\n        maxi = sum;\\n        score.push_back({0, sum});   //pushing score to vector pair for index 0\\n        \\n\\t\\tfor(int i = 1; i <= n; i++)\\n        {\\n            if(nums[i-1] == 0)  sum++;\\n            if(nums[i-1] == 1)  sum--;          // calculating no of zeroes to the left and no of ones to the right\\n            score.push_back({i, sum});\\n            maxi = max(maxi, sum);            // calculating maximum score that can be obtained \\n        }\\n      \\n\\t\\tfor(int i = 0; i < score.size(); i++)\\n        {\\n            if(score[i].second == maxi)    L.push_back(score[i].first);     // pushing indexes that has maximum score\\n        }\\n        return L;",
                "codeTag": "Unknown"
            },
            {
                "id": 2841824,
                "title": "java-solution-hashmap",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n = nums.length;\\n\\n        int ones = 0;\\n        int zeros = 0;\\n        for (int num: nums) {\\n            if (num == 1) {\\n                ones++;\\n            } else {\\n                zeros++;\\n            }\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        this.addToMap(map, ones, 0);\\n        this.addToMap(map, zeros, n);\\n        \\n        int leftZeros = 0;\\n        int rightOnes = ones;\\n        int maxSum = Math.max(ones, zeros);\\n        for (int i = 1; i <= n - 1; i++) {\\n            int num = nums[i - 1];\\n\\n            if (num == 0) {\\n                leftZeros++;\\n            } else {\\n                rightOnes--;\\n            }\\n\\n            int sum = leftZeros + rightOnes;\\n            this.addToMap(map, sum, i);\\n\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n\\n        return map.get(maxSum);\\n    }\\n\\n    private void addToMap(Map<Integer, List<Integer>> map, int key, int value) {\\n        List<Integer> list = map.getOrDefault(key, new ArrayList<>());\\n        list.add(value);\\n        map.put(key, list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int n = nums.length;\\n\\n        int ones = 0;\\n        int zeros = 0;\\n        for (int num: nums) {\\n            if (num == 1) {\\n                ones++;\\n            } else {\\n                zeros++;\\n            }\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        this.addToMap(map, ones, 0);\\n        this.addToMap(map, zeros, n);\\n        \\n        int leftZeros = 0;\\n        int rightOnes = ones;\\n        int maxSum = Math.max(ones, zeros);\\n        for (int i = 1; i <= n - 1; i++) {\\n            int num = nums[i - 1];\\n\\n            if (num == 0) {\\n                leftZeros++;\\n            } else {\\n                rightOnes--;\\n            }\\n\\n            int sum = leftZeros + rightOnes;\\n            this.addToMap(map, sum, i);\\n\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n\\n        return map.get(maxSum);\\n    }\\n\\n    private void addToMap(Map<Integer, List<Integer>> map, int key, int value) {\\n        List<Integer> list = map.getOrDefault(key, new ArrayList<>());\\n        list.add(value);\\n        map.put(key, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777453,
                "title": "c-counting-precalculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to prcalculate count of ones as we will need count of ones to right of i.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount no of 1s in the array.\\nRun a loop from 0 to n while maintaining count of zeroes and ones.\\nScore of current index will be zeroes_left + ones_total - ones_left.\\nUpdate max score and ans array accordingly.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        int o = 0;\\n        // count total ones\\n        for(auto i:nums){\\n            if(i) o++;\\n        }\\n        int mx = 0, z1 = 0, o1 = 0, z2, o2;\\n        for(int i=0; i<n; i++){\\n            // o2 is the count of 1 in right\\n            o2 = o - o1;\\n            int curr = z1 + o2;\\n            if(curr >= mx){\\n                if(curr > mx) ans.clear();\\n                ans.push_back(i);\\n                mx = curr;\\n            }\\n            if(nums[i]) o1++;\\n            else z1++;\\n        }\\n        // check for i=n too\\n        if(z1 >= mx){\\n            if(z1 > mx) ans.clear();\\n            ans.push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        int o = 0;\\n        // count total ones\\n        for(auto i:nums){\\n            if(i) o++;\\n        }\\n        int mx = 0, z1 = 0, o1 = 0, z2, o2;\\n        for(int i=0; i<n; i++){\\n            // o2 is the count of 1 in right\\n            o2 = o - o1;\\n            int curr = z1 + o2;\\n            if(curr >= mx){\\n                if(curr > mx) ans.clear();\\n                ans.push_back(i);\\n                mx = curr;\\n            }\\n            if(nums[i]) o1++;\\n            else z1++;\\n        }\\n        // check for i=n too\\n        if(z1 >= mx){\\n            if(z1 > mx) ans.clear();\\n            ans.push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774458,
                "title": "python3-commented-and-concise-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to go over the array and check for the score of each split value. As soon as we find a higher score we reset al previously saved indices and put in the current index. If we find an equal score we append its index to the list.\\n\\nIn order to save time, we do not recompute the score for every split by counting zeros right and ones left. Instead we use a sliding window that we update accoring to the last element, which has been transfered from righ to left.\\nIn case it is a 1 we decrease from the score of the right array and in case it is a zeros, increase the left array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to initialize the values with Score[0] as we need an initial value for the sliding window. Other than that we just update the scores and append/delete/ignore list according to our score in comparisong with the max score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), we need two passes one to count the ones for initialization and one to do the sliding window.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we neglect solution space\\n# Code\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\n        # make two variables for a sliding window\\n        left_zeros = 0\\n        right_ones = nums.count(1)\\n\\n        # make a list to save the indices\\n        indices = [0]\\n        # make a variable to save the max amount of score\\n        max_score = left_zeros + right_ones\\n\\n        # go through the array\\n        for idx in range(len(nums)):\\n\\n            # check if prev was a one\\n            if nums[idx] == 1:\\n                right_ones -= 1\\n            else:\\n                left_zeros += 1\\n            \\n            # update the indices\\n            score = right_ones + left_zeros\\n            if score > max_score:\\n                indices = [idx+1]\\n                max_score = score\\n            elif score == max_score:\\n                indices.append(idx+1)\\n        return indices\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\n        # make two variables for a sliding window\\n        left_zeros = 0\\n        right_ones = nums.count(1)\\n\\n        # make a list to save the indices\\n        indices = [0]\\n        # make a variable to save the max amount of score\\n        max_score = left_zeros + right_ones\\n\\n        # go through the array\\n        for idx in range(len(nums)):\\n\\n            # check if prev was a one\\n            if nums[idx] == 1:\\n                right_ones -= 1\\n            else:\\n                left_zeros += 1\\n            \\n            # update the indices\\n            score = right_ones + left_zeros\\n            if score > max_score:\\n                indices = [idx+1]\\n                max_score = score\\n            elif score == max_score:\\n                indices.append(idx+1)\\n        return indices\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773840,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int highestScore = 0;\\n        List<Integer> result = new ArrayList<>();\\n        int oneScore = (int)Arrays.stream(nums,0,nums.length).filter(x -> x == 1).count();\\n        int zeroScore = 0;\\n        for(int i = 0;i <= nums.length;i++){\\n            int tmp;\\n            try{\\n                tmp = nums[i-1];\\n            }catch(Exception e){\\n                tmp = -1;\\n            }\\n            if(tmp == 1){\\n                oneScore--;\\n            }else if(tmp == 0){\\n                zeroScore++;\\n            }\\n            if((oneScore+zeroScore) > highestScore){\\n                highestScore = oneScore + zeroScore;\\n                result.clear();\\n                result.add(i);\\n            }else if((oneScore+zeroScore) == highestScore){\\n                result.add(i);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int highestScore = 0;\\n        List<Integer> result = new ArrayList<>();\\n        int oneScore = (int)Arrays.stream(nums,0,nums.length).filter(x -> x == 1).count();\\n        int zeroScore = 0;\\n        for(int i = 0;i <= nums.length;i++){\\n            int tmp;\\n            try{\\n                tmp = nums[i-1];\\n            }catch(Exception e){\\n                tmp = -1;\\n            }\\n            if(tmp == 1){\\n                oneScore--;\\n            }else if(tmp == 0){\\n                zeroScore++;\\n            }\\n            if((oneScore+zeroScore) > highestScore){\\n                highestScore = oneScore + zeroScore;\\n                result.clear();\\n                result.add(i);\\n            }else if((oneScore+zeroScore) == highestScore){\\n                result.add(i);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762892,
                "title": "python-3-o-n-count-ones-and-zeros",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        res = []\\n        one = nums.count(1)\\n        zero = 0\\n        maxi = 0\\n        \\n        for idx, i in enumerate(nums):\\n            if zero + one > maxi:\\n                maxi = zero + one\\n                res = [idx]\\n            elif zero + one == maxi:\\n                res.append(idx)\\n            \\n            if i == 0:\\n                zero += 1\\n            else:\\n                one -= 1\\n                \\n        if zero + one > maxi:\\n            maxi = zero + one\\n            res = [idx + 1]\\n        elif zero + one == maxi:\\n            res.append(idx + 1)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        res = []\\n        one = nums.count(1)\\n        zero = 0\\n        maxi = 0\\n        \\n        for idx, i in enumerate(nums):\\n            if zero + one > maxi:\\n                maxi = zero + one\\n                res = [idx]\\n            elif zero + one == maxi:\\n                res.append(idx)\\n            \\n            if i == 0:\\n                zero += 1\\n            else:\\n                one -= 1\\n                \\n        if zero + one > maxi:\\n            maxi = zero + one\\n            res = [idx + 1]\\n        elif zero + one == maxi:\\n            res.append(idx + 1)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762032,
                "title": "golang-go-solution",
                "content": "```\\nfunc maxScoreIndices(nums []int) []int {\\n\\tvar arr []int\\n\\tmax := -999999\\n\\tvar ZeroCount, OneCount int\\n\\tfor _, v := range nums {\\n\\t\\tif v != 0 {\\n\\t\\t\\tOneCount++\\n\\t\\t} else {\\n\\t\\t\\tZeroCount++\\n\\t\\t}\\n\\t}\\n\\tOnes := 0\\n\\tZeros := ZeroCount\\n\\tfor i, v := range nums {\\n\\t\\tsum := (ZeroCount - Zeros) + (OneCount - Ones)\\n\\t\\tif v == 0 {\\n\\t\\t\\tZeros--\\n\\t\\t} else {\\n\\t\\t\\tOnes++\\n\\t\\t}\\n\\t\\tif sum > max {\\n\\t\\t\\tmax = sum\\n\\t\\t\\tarr = nil\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t} else if sum == max {\\n\\t\\t\\tmax = sum\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t}\\n\\t}\\n\\tsum := (ZeroCount - Zeros) + (OneCount - Ones)\\n\\tif sum > max {\\n\\t\\tarr = nil\\n\\t\\tarr = append(arr, len(nums))\\n\\t} else if sum == max {\\n\\t\\tarr = append(arr, len(nums))\\n\\t}\\n\\treturn arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxScoreIndices(nums []int) []int {\\n\\tvar arr []int\\n\\tmax := -999999\\n\\tvar ZeroCount, OneCount int\\n\\tfor _, v := range nums {\\n\\t\\tif v != 0 {\\n\\t\\t\\tOneCount++\\n\\t\\t} else {\\n\\t\\t\\tZeroCount++\\n\\t\\t}\\n\\t}\\n\\tOnes := 0\\n\\tZeros := ZeroCount\\n\\tfor i, v := range nums {\\n\\t\\tsum := (ZeroCount - Zeros) + (OneCount - Ones)\\n\\t\\tif v == 0 {\\n\\t\\t\\tZeros--\\n\\t\\t} else {\\n\\t\\t\\tOnes++\\n\\t\\t}\\n\\t\\tif sum > max {\\n\\t\\t\\tmax = sum\\n\\t\\t\\tarr = nil\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t} else if sum == max {\\n\\t\\t\\tmax = sum\\n\\t\\t\\tarr = append(arr, i)\\n\\t\\t}\\n\\t}\\n\\tsum := (ZeroCount - Zeros) + (OneCount - Ones)\\n\\tif sum > max {\\n\\t\\tarr = nil\\n\\t\\tarr = append(arr, len(nums))\\n\\t} else if sum == max {\\n\\t\\tarr = append(arr, len(nums))\\n\\t}\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759034,
                "title": "java-o-n-time-complexityy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> arr=new ArrayList<Integer>();\\n        int cOnes=0;\\n        int cZeros=0;\\n        for(int i: nums)\\n        cOnes+=i;\\n        int max=cOnes;\\n        for(int i=0;i<=nums.length;i++)\\n        {\\n           if(cZeros+cOnes>max)\\n           {\\n               arr.clear();\\n               max=cZeros+cOnes;\\n           }\\n           if(cZeros+cOnes==max)\\n           {\\n           max=cZeros+cOnes;\\n           arr.add(i);\\n           }\\n           if(i<nums.length)\\n           {\\n           if(nums[i]==0)\\n           cZeros+=1;\\n           else\\n           cOnes--;    \\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> arr=new ArrayList<Integer>();\\n        int cOnes=0;\\n        int cZeros=0;\\n        for(int i: nums)\\n        cOnes+=i;\\n        int max=cOnes;\\n        for(int i=0;i<=nums.length;i++)\\n        {\\n           if(cZeros+cOnes>max)\\n           {\\n               arr.clear();\\n               max=cZeros+cOnes;\\n           }\\n           if(cZeros+cOnes==max)\\n           {\\n           max=cZeros+cOnes;\\n           arr.add(i);\\n           }\\n           if(i<nums.length)\\n           {\\n           if(nums[i]==0)\\n           cZeros+=1;\\n           else\\n           cOnes--;    \\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755878,
                "title": "python-o-n-time-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(nums)\\n        \\n        # hashmap to track scores\\n        hashmap = collections.defaultdict(list)\\n        \\n        # prefix sums for 0\\'s and 1\\'s\\n        prefixSum0, prefixSum1 = [0] * n, [0] * n\\n        \\n        currentSum0, currentSum1 = 0, 0\\n        \\n        # fill prefixSum0 left to right\\n        for i in range(n):\\n            \\n            if nums[i] == 0:\\n                currentSum0 += 1 \\n                \\n            prefixSum0[i] = currentSum0\\n        \\n        # fill prefixSum1 right to left\\n        for i in range(n - 1, -1, -1):\\n            \\n            if nums[i] == 1:\\n                currentSum1 += 1\\n                \\n            prefixSum1[i] = currentSum1\\n        \\n        # edge cases i == 0 and i == n\\n        hashmap[prefixSum1[0]].append(0)\\n        hashmap[prefixSum0[-1]].append(n)\\n        \\n        max_score = max(prefixSum1[0], prefixSum0[-1])\\n        \\n        # calculate scores\\n        for i in range(n - 1):\\n            score = prefixSum0[i] + prefixSum1[i + 1]\\n            \\n            if score >= max_score:\\n                max_score = score\\n                hashmap[score].append(i + 1)\\n        \\n        return hashmap[max_score]     \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(nums)\\n        \\n        # hashmap to track scores\\n        hashmap = collections.defaultdict(list)\\n        \\n        # prefix sums for 0\\'s and 1\\'s\\n        prefixSum0, prefixSum1 = [0] * n, [0] * n\\n        \\n        currentSum0, currentSum1 = 0, 0\\n        \\n        # fill prefixSum0 left to right\\n        for i in range(n):\\n            \\n            if nums[i] == 0:\\n                currentSum0 += 1 \\n                \\n            prefixSum0[i] = currentSum0\\n        \\n        # fill prefixSum1 right to left\\n        for i in range(n - 1, -1, -1):\\n            \\n            if nums[i] == 1:\\n                currentSum1 += 1\\n                \\n            prefixSum1[i] = currentSum1\\n        \\n        # edge cases i == 0 and i == n\\n        hashmap[prefixSum1[0]].append(0)\\n        hashmap[prefixSum0[-1]].append(n)\\n        \\n        max_score = max(prefixSum1[0], prefixSum0[-1])\\n        \\n        # calculate scores\\n        for i in range(n - 1):\\n            score = prefixSum0[i] + prefixSum1[i + 1]\\n            \\n            if score >= max_score:\\n                max_score = score\\n                hashmap[score].append(i + 1)\\n        \\n        return hashmap[max_score]     \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754141,
                "title": "c-easy-code-beat-90",
                "content": "# C++ Easy code beat 90%\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n`````\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int right = 0, left = 0;\\n        vector<int> temp(nums.size()+1);\\n        for(int num : nums){\\n            if(num == 1){\\n                ++right;\\n            }\\n        }\\n        temp[0] = right;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] == 0){++left;}\\n            else if(nums[i] == 1){--right;}\\n            temp[i+1] = left+right;\\n        }\\n        int max = -1;\\n        for(int j = 0; j < temp.size(); ++j){\\n            if(temp[j] > max){\\n                ans.clear();\\n                ans.emplace_back(j);\\n                max = temp[j];                \\n            }\\n            else if(temp[j] == max){\\n                ans.emplace_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "`````\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        vector<int> ans;\\n        int right = 0, left = 0;\\n        vector<int> temp(nums.size()+1);\\n        for(int num : nums){\\n            if(num == 1){\\n                ++right;\\n            }\\n        }\\n        temp[0] = right;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] == 0){++left;}\\n            else if(nums[i] == 1){--right;}\\n            temp[i+1] = left+right;\\n        }\\n        int max = -1;\\n        for(int j = 0; j < temp.size(); ++j){\\n            if(temp[j] > max){\\n                ans.clear();\\n                ans.emplace_back(j);\\n                max = temp[j];                \\n            }\\n            else if(temp[j] == max){\\n                ans.emplace_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747198,
                "title": "best-solution-in-c-prefix-sum",
                "content": "# Code\\n**Please Upvote if it helps**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int size=nums.size(),count=0;\\n        vector<int> count_zero(size+1),count_one(size+1),ans;\\n        for(int i=1;i<size+1;i++){\\n            if(nums[i-1]==0)\\n                count++;\\n            count_zero[i]=count;\\n        }\\n        count=0;\\n        int maxi=0;\\n        for(int i=size-1;i>=0;i--){\\n            if(nums[i]==1)\\n                count++;\\n            count_one[i]=count;\\n        }\\n        for(int i=0;i<size+1;i++){\\n            count_zero[i]=count_zero[i]+count_one[i];\\n            maxi=max(maxi,count_zero[i]);\\n        }\\n        for(int i=0;i<size+1;i++){\\n            if(maxi==count_zero[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int size=nums.size(),count=0;\\n        vector<int> count_zero(size+1),count_one(size+1),ans;\\n        for(int i=1;i<size+1;i++){\\n            if(nums[i-1]==0)\\n                count++;\\n            count_zero[i]=count;\\n        }\\n        count=0;\\n        int maxi=0;\\n        for(int i=size-1;i>=0;i--){\\n            if(nums[i]==1)\\n                count++;\\n            count_one[i]=count;\\n        }\\n        for(int i=0;i<size+1;i++){\\n            count_zero[i]=count_zero[i]+count_one[i];\\n            maxi=max(maxi,count_zero[i]);\\n        }\\n        for(int i=0;i<size+1;i++){\\n            if(maxi==count_zero[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737946,
                "title": "one-variable",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int totalzeroes = 0, zeroes = 0;\\n        for(auto it: nums)\\n        {\\n            if(it==0)\\n            {\\n                totalzeroes++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>> pq;\\n        pq.push({totalzeroes, nums.size()});\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            int bin = nums[i], left = zeroes, right = nums.size() - i - (totalzeroes - zeroes);\\n            pq.push({left + right,i});\\n            if(bin==0)\\n                zeroes++;\\n        }\\n        \\n        vector<int> ans;\\n        int t = pq.top().first;\\n        while(!pq.empty() && pq.top().first==t)\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) \\n    {\\n        int totalzeroes = 0, zeroes = 0;\\n        for(auto it: nums)\\n        {\\n            if(it==0)\\n            {\\n                totalzeroes++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>> pq;\\n        pq.push({totalzeroes, nums.size()});\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            int bin = nums[i], left = zeroes, right = nums.size() - i - (totalzeroes - zeroes);\\n            pq.push({left + right,i});\\n            if(bin==0)\\n                zeroes++;\\n        }\\n        \\n        vector<int> ans;\\n        int t = pq.top().first;\\n        while(!pq.empty() && pq.top().first==t)\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722444,
                "title": "python-one-pass-solution-with-explanation-runtime-99-memory-usage-95",
                "content": "# Problem Analysis\\nLet\\'s see this example first:\\n```\\n\\t# array = [0 0 1 0 0 1 1 0]\\n\\t0: (0)[]  [0 0 1 0 0 1 1 0](3) > 3\\n\\t1: (1)[0]   [0 1 0 0 1 1 0](3) > 4\\n\\t2: (2)[0 0]   [1 0 0 1 1 0](3) > 5\\n\\t3: (2)[0 0 1]   [0 0 1 1 0](2) > 4\\n\\t4: (3)[0 0 1 0]   [0 1 1 0](2) > 5\\n\\t5: (4)[0 0 1 0 0]   [1 1 0](2) > 6 (max)\\n\\t6: (4)[0 0 1 0 0 1]   [1 0](1) > 5\\n\\t7: (4)[0 0 1 0 0 1 1]   [0](0) > 4\\n\\t8: (5)[0 0 1 0 0 1 1 0]  [](0) > 5\\n```\\nWe can see:\\n* when moving **0** to left, **numsleft** increases\\n* when moving **1** to left, **numsright** decreases\\n<br>\\n\\nNow, we set the default value as 0 and read the arry, only +1 at 0 and -1 at 1.\\n```\\n\\t#      [0 0 1 0 0 1 1 0]\\n\\t0: []  [0 0 1 0 0 1 1 0] > 0\\n\\t1: [0]   [0 1 0 0 1 1 0] > 1\\n\\t2: [0 0]   [1 0 0 1 1 0] > 2\\n\\t3: [0 0 1]   [0 0 1 1 0] > 1\\n\\t4: [0 0 1 0]   [0 1 1 0] > 2\\n\\t5: [0 0 1 0 0]   [1 1 0] > 3 (max)\\n\\t6: [0 0 1 0 0 1]   [1 0] > 2\\n\\t7: [0 0 1 0 0 1 1]   [0] > 1\\n\\t8: [0 0 1 0 0 1 1 0]  [] > 2\\n```\\nWe can see that the true **numsleft + numsright** value doesn\\'t really matter.\\nBased on this, we can write the solution as this:\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\t\\tm = 0                           # max number\\n        n = 0                           # current number\\n        arr = [0]                       # indices which all have the max number\\n        for i, b in enumerate(nums, 1):\\n            n -= b or -1                # +1 at 0, -1 at 0\\n            if n > m:\\n                arr = [i]               # reset indices list\\n\\t\\t\\t\\tm = n                   # update max number\\n            elif n == m:\\n                arr.append(i)           # add index to list\\n        return arr\\n```\\n<br>\\n\\n# Some Optimization\\nConsidering the low efficiency of *list.append*, I tried to make a list with constant length, so that I don\\'t have to change it\\'s length. And also, I want to minimize the memory usage, so I need to know what the maximum length it would be.\\nNow we see these 2 examples:\\n```\\n\\t#      [0 1 0 1 0 1 0]\\n\\t0: []  [0 1 0 1 0 1 0] >  0\\n\\t1: [0]   [1 0 1 0 1 0] >  1 (max)\\n\\t2: [0 1]   [0 1 0 1 0] >  0\\n\\t3: [0 1 0]   [1 0 1 0] >  1 (max)\\n\\t4: [0 1 0 1]   [0 1 0] >  0\\n\\t5: [0 1 0 1 0]   [1 0] >  1 (max)\\n\\t6: [0 1 0 1 0 1]   [0] >  0\\n\\t7: [0 1 0 1 0 1 0]  [] >  1 (max)\\n\\t\\n\\t#      [1 0 1 0 1 0 1 0]\\n\\t0: []  [1 0 1 0 1 0 1 0] >   0 (max)\\n\\t1: [1]   [0 1 0 1 0 1 0] >  -1\\n\\t2: [1 0]   [1 0 1 0 1 0] >   0 (max)\\n\\t3: [1 0 1]   [0 1 0 1 0] >  -1\\n\\t4: [1 0 1 0]   [1 0 1 0] >   0 (max)\\n\\t5: [1 0 1 0 1]   [0 1 0] >  -1\\n\\t6: [1 0 1 0 1 0]   [1 0] >   0 (max)\\n\\t7: [1 0 1 0 1 0 1]   [0] >  -1\\n\\t8: [1 0 1 0 1 0 1 0]  [] >   0 (max)\\n```\\nWe see that the maximum length of max numbers would be half of **nums**\\' length **+1**. Therefore, we can initialize the answer with a list with such length, and only return those what we need.\\n<br>\\n\\n# My Solution\\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        m = 0                             # max number\\n        n = 0                             # current number\\n        arr = [0] + [-1]*(len(nums)//2)   # indices list with initial length\\n        k = 1                             # answer length\\n        for i, b in enumerate(nums, 1):\\n            n -= b or -1                  # +1 at 0, -1 at 0\\n            if n > m:\\n                arr[0] = i                # reset list\\n                k = 1                     # reset answer length\\n                m = n                     # update maximum\\n            elif n == m:\\n                arr[k] = i                # add index to list\\n                k += 1                    # increase answer length\\n        return arr[:k]\\n```\\nHere\\'s my [submission](https://leetcode.com/submissions/detail/825925970/).\\n![image](https://assets.leetcode.com/users/images/9d7feb0a-82cd-485b-9898-4b2f1a62f76d_1666191237.6711586.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t# array = [0 0 1 0 0 1 1 0]\\n\\t0: (0)[]  [0 0 1 0 0 1 1 0](3) > 3\\n\\t1: (1)[0]   [0 1 0 0 1 1 0](3) > 4\\n\\t2: (2)[0 0]   [1 0 0 1 1 0](3) > 5\\n\\t3: (2)[0 0 1]   [0 0 1 1 0](2) > 4\\n\\t4: (3)[0 0 1 0]   [0 1 1 0](2) > 5\\n\\t5: (4)[0 0 1 0 0]   [1 1 0](2) > 6 (max)\\n\\t6: (4)[0 0 1 0 0 1]   [1 0](1) > 5\\n\\t7: (4)[0 0 1 0 0 1 1]   [0](0) > 4\\n\\t8: (5)[0 0 1 0 0 1 1 0]  [](0) > 5\\n```\n```\\n\\t#      [0 0 1 0 0 1 1 0]\\n\\t0: []  [0 0 1 0 0 1 1 0] > 0\\n\\t1: [0]   [0 1 0 0 1 1 0] > 1\\n\\t2: [0 0]   [1 0 0 1 1 0] > 2\\n\\t3: [0 0 1]   [0 0 1 1 0] > 1\\n\\t4: [0 0 1 0]   [0 1 1 0] > 2\\n\\t5: [0 0 1 0 0]   [1 1 0] > 3 (max)\\n\\t6: [0 0 1 0 0 1]   [1 0] > 2\\n\\t7: [0 0 1 0 0 1 1]   [0] > 1\\n\\t8: [0 0 1 0 0 1 1 0]  [] > 2\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n\\t\\tm = 0                           # max number\\n        n = 0                           # current number\\n        arr = [0]                       # indices which all have the max number\\n        for i, b in enumerate(nums, 1):\\n            n -= b or -1                # +1 at 0, -1 at 0\\n            if n > m:\\n                arr = [i]               # reset indices list\\n\\t\\t\\t\\tm = n                   # update max number\\n            elif n == m:\\n                arr.append(i)           # add index to list\\n        return arr\\n```\n```\\n\\t#      [0 1 0 1 0 1 0]\\n\\t0: []  [0 1 0 1 0 1 0] >  0\\n\\t1: [0]   [1 0 1 0 1 0] >  1 (max)\\n\\t2: [0 1]   [0 1 0 1 0] >  0\\n\\t3: [0 1 0]   [1 0 1 0] >  1 (max)\\n\\t4: [0 1 0 1]   [0 1 0] >  0\\n\\t5: [0 1 0 1 0]   [1 0] >  1 (max)\\n\\t6: [0 1 0 1 0 1]   [0] >  0\\n\\t7: [0 1 0 1 0 1 0]  [] >  1 (max)\\n\\t\\n\\t#      [1 0 1 0 1 0 1 0]\\n\\t0: []  [1 0 1 0 1 0 1 0] >   0 (max)\\n\\t1: [1]   [0 1 0 1 0 1 0] >  -1\\n\\t2: [1 0]   [1 0 1 0 1 0] >   0 (max)\\n\\t3: [1 0 1]   [0 1 0 1 0] >  -1\\n\\t4: [1 0 1 0]   [1 0 1 0] >   0 (max)\\n\\t5: [1 0 1 0 1]   [0 1 0] >  -1\\n\\t6: [1 0 1 0 1 0]   [1 0] >   0 (max)\\n\\t7: [1 0 1 0 1 0 1]   [0] >  -1\\n\\t8: [1 0 1 0 1 0 1 0]  [] >   0 (max)\\n```\n```\\nclass Solution:\\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        m = 0                             # max number\\n        n = 0                             # current number\\n        arr = [0] + [-1]*(len(nums)//2)   # indices list with initial length\\n        k = 1                             # answer length\\n        for i, b in enumerate(nums, 1):\\n            n -= b or -1                  # +1 at 0, -1 at 0\\n            if n > m:\\n                arr[0] = i                # reset list\\n                k = 1                     # reset answer length\\n                m = n                     # update maximum\\n            elif n == m:\\n                arr[k] = i                # add index to list\\n                k += 1                    # increase answer length\\n        return arr[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714301,
                "title": "easy-solution-faster-than-96-submissions",
                "content": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        \\n        int [] a = new int [nums.length+1];\\n        \\n        int mx = -1;\\n        \\n        int z = 0;\\n        int o = 0;\\n        \\n        int [] b = new int [nums.length+1];\\n        \\n        int [] sc = new int [nums.length+1];\\n        \\n        for(int i = 1; i<a.length; i++){\\n            if(nums[i-1] == 0){\\n                z++;\\n            }\\n            a[i] = z;\\n        }\\n        \\n        for(int i = b.length-2; i>-1; i--){\\n            if(nums[i] == 1){\\n                o++;\\n            }\\n            b[i] = o;\\n        }\\n        \\n        for(int i = 0; i<sc.length; i++){\\n            sc[i] = a[i]+b[i];\\n            mx = Math.max(mx, sc[i]);\\n        }\\n        \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i<sc.length; i++){\\n            if(mx == sc[i]){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        \\n        int [] a = new int [nums.length+1];\\n        \\n        int mx = -1;\\n        \\n        int z = 0;\\n        int o = 0;\\n        \\n        int [] b = new int [nums.length+1];\\n        \\n        int [] sc = new int [nums.length+1];\\n        \\n        for(int i = 1; i<a.length; i++){\\n            if(nums[i-1] == 0){\\n                z++;\\n            }\\n            a[i] = z;\\n        }\\n        \\n        for(int i = b.length-2; i>-1; i--){\\n            if(nums[i] == 1){\\n                o++;\\n            }\\n            b[i] = o;\\n        }\\n        \\n        for(int i = 0; i<sc.length; i++){\\n            sc[i] = a[i]+b[i];\\n            mx = Math.max(mx, sc[i]);\\n        }\\n        \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i<sc.length; i++){\\n            if(mx == sc[i]){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711168,
                "title": "java-o-n-time-complexity-o-1-space-complexity-2-times-traversal",
                "content": "\\tpublic List<Integer> maxScoreIndices(int[] nums) {\\n        int total_ones = 0, total_zeros = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 0)\\n                total_zeros += 1;\\n            else \\n                total_ones += 1;\\n        }\\n        \\n        int division = total_ones, maxDivision = total_ones;\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n            \\n        int left_zeros = 0, left_ones = 0;\\n            \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 0)\\n                left_zeros += 1;\\n            else \\n                left_ones += 1;\\n            \\n            division = left_zeros + total_ones - left_ones;\\n            if(division > maxDivision) {\\n                maxDivision = division;\\n                ans = new ArrayList<>();\\n                ans.add(i+1);\\n            } else if(division == maxDivision) {\\n                ans.add(i+1);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic List<Integer> maxScoreIndices(int[] nums) {\\n        int total_ones = 0, total_zeros = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 0)\\n                total_zeros += 1;\\n            else \\n                total_ones += 1;\\n        }\\n        \\n        int division = total_ones, maxDivision = total_ones;\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n            \\n        int left_zeros = 0, left_ones = 0;\\n            \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 0)\\n                left_zeros += 1;\\n            else \\n                left_ones += 1;\\n            \\n            division = left_zeros + total_ones - left_ones;\\n            if(division > maxDivision) {\\n                maxDivision = division;\\n                ans = new ArrayList<>();\\n                ans.add(i+1);\\n            } else if(division == maxDivision) {\\n                ans.add(i+1);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2705402,
                "title": "easy-c-beginner-friendly-96-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n+1,0);\\n        vector<int>q(n+1,0);\\n        vector<int>d;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) v[i+1]=v[i]+1;\\n            else v[i+1]=v[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]==1) q[i]=q[i+1]+1;\\n            else q[i]=q[i+1];\\n        }\\n        for(int i=0;i<n+1;i++){\\n            v[i]=v[i]+q[i];\\n        }\\n        int z=*max_element(v.begin(),v.end());\\n        for(int i=0;i<n+1;i++){\\n            if(v[i]==z){\\n                d.push_back(i);\\n            }\\n        }\\n        return d;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxScoreIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n+1,0);\\n        vector<int>q(n+1,0);\\n        vector<int>d;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) v[i+1]=v[i]+1;\\n            else v[i+1]=v[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2676665,
                "title": "java-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int a;\\n        int b;\\n        Pair(int a , int b){\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = nums.length;\\n        \\n        int[] ones = new int[n];\\n        int[] zeros = new int[n];\\n        \\n        zeros[0] = (nums[0] == 0) ? 1 : 0;\\n        for(int i = 1 ; i < n ; i++){\\n            if(nums[i] == 0){\\n                zeros[i] = zeros[i - 1] + 1;\\n            }\\n            else{\\n                zeros[i] = zeros[i - 1];\\n            }\\n        }\\n        \\n        ones[n - 1] = nums[n - 1];\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(nums[i] == 1){\\n                ones[i] = ones[i + 1] + 1;\\n            }\\n            else{\\n                ones[i] = ones[i + 1];\\n            }\\n        }\\n        // for(int i = 0 ; i < n ; i++){\\n        //     System.out.println(ones[i]);\\n        // }\\n        ArrayList<Pair> p = new ArrayList<>();\\n        int max = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i == 0){\\n                int left = 0;\\n                int right = ones[i];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n            else if(i == n){\\n                int right = 0;\\n                int left = zeros[i - 1];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n            else{\\n                int left = zeros[i - 1];\\n                int right = ones[i];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n        }\\n        \\n        for(Pair i : p){\\n            int idx = i.a;\\n            int val = i.b;\\n           // System.out.println(idx + \" \"+ val);\\n            if(val == max)\\n                ans.add(idx);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int a;\\n        int b;\\n        Pair(int a , int b){\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = nums.length;\\n        \\n        int[] ones = new int[n];\\n        int[] zeros = new int[n];\\n        \\n        zeros[0] = (nums[0] == 0) ? 1 : 0;\\n        for(int i = 1 ; i < n ; i++){\\n            if(nums[i] == 0){\\n                zeros[i] = zeros[i - 1] + 1;\\n            }\\n            else{\\n                zeros[i] = zeros[i - 1];\\n            }\\n        }\\n        \\n        ones[n - 1] = nums[n - 1];\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(nums[i] == 1){\\n                ones[i] = ones[i + 1] + 1;\\n            }\\n            else{\\n                ones[i] = ones[i + 1];\\n            }\\n        }\\n        // for(int i = 0 ; i < n ; i++){\\n        //     System.out.println(ones[i]);\\n        // }\\n        ArrayList<Pair> p = new ArrayList<>();\\n        int max = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i == 0){\\n                int left = 0;\\n                int right = ones[i];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n            else if(i == n){\\n                int right = 0;\\n                int left = zeros[i - 1];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n            else{\\n                int left = zeros[i - 1];\\n                int right = ones[i];\\n                int res = left + right;\\n                p.add(new Pair(i , res));\\n                max = Math.max(max , res);\\n            }\\n        }\\n        \\n        for(Pair i : p){\\n            int idx = i.a;\\n            int val = i.b;\\n           // System.out.println(idx + \" \"+ val);\\n            if(val == max)\\n                ans.add(idx);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653228,
                "title": "scala-solution",
                "content": "```\\nimport scala.language.postfixOps\\n    val zeroFromLeft = nums.scanLeft(0)((ans, cur)=>{\\n      if(cur == 0) ans + 1\\n      else ans\\n    })\\n    val oneFromRight = nums.scanRight(0)((cur, ans)=>{\\n      if(cur == 1) ans + 1\\n      else ans\\n    })\\n\\n    val t = (zeroFromLeft zip oneFromRight).map(n => n._2 + n._1).max\\n    ((zeroFromLeft zip oneFromRight).map(n => n._2 + n._1) zipWithIndex).filter(_._1 == t).map(_._2).toList\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.language.postfixOps\\n    val zeroFromLeft = nums.scanLeft(0)((ans, cur)=>{\\n      if(cur == 0) ans + 1\\n      else ans\\n    })\\n    val oneFromRight = nums.scanRight(0)((cur, ans)=>{\\n      if(cur == 1) ans + 1\\n      else ans\\n    })\\n\\n    val t = (zeroFromLeft zip oneFromRight).map(n => n._2 + n._1).max\\n    ((zeroFromLeft zip oneFromRight).map(n => n._2 + n._1) zipWithIndex).filter(_._1 == t).map(_._2).toList\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 2036897,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "Should be marked easy \\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one took me a lot of thinking!"
                    }
                ]
            },
            {
                "id": 1948641,
                "content": [
                    {
                        "username": "stellarhuman09",
                        "content": "Should be marked easy \\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one took me a lot of thinking!"
                    }
                ]
            }
        ]
    }
]