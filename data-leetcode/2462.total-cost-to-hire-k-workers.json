[
    {
        "title": "Total Cost to Hire K Workers",
        "question_content": "You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n\n\tYou will run k sessions and hire exactly one worker in each session.\n\tIn each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n\t\n\t\tFor example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\n\t\tIn the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n\t\n\t\n\tIf there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n\tA worker can only be chosen once.\n\nReturn the total cost to hire exactly k workers.\n&nbsp;\nExample 1:\n\nInput: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\nOutput: 11\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.\n\nExample 2:\n\nInput: costs = [1,2,4,1], k = 3, candidates = 3\nOutput: 4\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= costs.length <= 105 \n\t1 <= costs[i] <= 105\n\t1 <= k, candidates <= costs.length",
        "solutions": [
            {
                "id": 3683067,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "\\n# Intuition:\\n\\n1. To Intuition is to maintains two priority queues (`pq1` and `pq2`) that store the `candidates` smallest costs from the beginning and end of the list. \\n2. In each iteration, the code compares the smallest costs from `pq1` and `pq2` and selects the one with the lowest value. The corresponding cost is added to the total cost (`ans`), and the element is removed from the respective priority queue. \\n3. This process continues for `k` iterations, and at the end, the accumulated `ans` value represents the minimum total cost required to hire `k` workers.\\n\\n# Explanation:\\n\\n1. Two integer variables `i` and `j` are initialized to track the start and end indices of the `costs` vector, respectively. These indices will be used to iterate over the vector.\\n2. Two priority queues, `pq1` and `pq2`, are created. Priority queues are data structures that allow efficient insertion and retrieval of elements while maintaining a specific order. In this case, the elements are integers, and the order is ascending (`greater<int>`).\\n3. A `long long` variable `ans` is initialized to store the total cost.\\n4. The code enters a loop that executes `k` times, where `k` is the number of workers to be hired.\\n5. Inside the loop, two nested `while` loops are used to populate `pq1` and `pq2` with candidates from the `costs` vector. The conditions for these loops are as follows:\\n   - `pq1` should contain at most `candidates` elements, and `i` should be less than or equal to `j`.\\n   - `pq2` should also contain at most `candidates` elements, and `i` should be less than or equal to `j`.\\n   These loops essentially fill the priority queues with the smallest `candidates` elements from the `costs` vector, taking elements from both ends of the vector (`i` and `j`).\\n6. After the `while` loops, the code compares the top elements (`t1` and `t2`) of `pq1` and `pq2` to determine which one is smaller. If both queues are empty, `INT_MAX` (maximum value for an `int`) is used as a placeholder.\\n7. If `t1` is smaller than or equal to `t2`, the cost of the worker represented by `t1` is added to `ans`, and the top element is removed from `pq1` using `pq1.pop()`. Otherwise, the cost of the worker represented by `t2` is added to `ans`, and the top element is removed from `pq2` using `pq2.pop()`.\\n8. The loop continues until `k` workers have been hired.\\n9. Finally, the function returns the accumulated total cost (`ans`).\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.size() - 1;\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n\\n        long long ans = 0;\\n        while(k--){\\n            while(pq1.size() < candidates && i <= j){\\n                pq1.push(costs[i++]);\\n            }\\n            while(pq2.size() < candidates && i <= j){\\n                pq2.push(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int t2 = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n            if(t1 <= t2){\\n                ans += t1;\\n                pq1.pop();\\n            }\\n            else{\\n                ans += t2;\\n                pq2.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def totalCost(self, costs, k, candidates):\\n        i = 0\\n        j = len(costs) - 1\\n        pq1 = []\\n        pq2 = []\\n\\n        ans = 0\\n        while k > 0:\\n            while len(pq1) < candidates and i <= j:\\n                heapq.heappush(pq1, costs[i])\\n                i += 1\\n            while len(pq2) < candidates and i <= j:\\n                heapq.heappush(pq2, costs[j])\\n                j -= 1\\n\\n            t1 = pq1[0] if pq1 else float(\\'inf\\')\\n            t2 = pq2[0] if pq2 else float(\\'inf\\')\\n\\n            if t1 <= t2:\\n                ans += t1\\n                heapq.heappop(pq1)\\n            else:\\n                ans += t2\\n                heapq.heappop(pq2)\\n\\n            k -= 1\\n        return ans\\n```\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.size() - 1;\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n\\n        long long ans = 0;\\n        while(k--){\\n            while(pq1.size() < candidates && i <= j){\\n                pq1.push(costs[i++]);\\n            }\\n            while(pq2.size() < candidates && i <= j){\\n                pq2.push(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int t2 = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n            if(t1 <= t2){\\n                ans += t1;\\n                pq1.pop();\\n            }\\n            else{\\n                ans += t2;\\n                pq2.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def totalCost(self, costs, k, candidates):\\n        i = 0\\n        j = len(costs) - 1\\n        pq1 = []\\n        pq2 = []\\n\\n        ans = 0\\n        while k > 0:\\n            while len(pq1) < candidates and i <= j:\\n                heapq.heappush(pq1, costs[i])\\n                i += 1\\n            while len(pq2) < candidates and i <= j:\\n                heapq.heappush(pq2, costs[j])\\n                j -= 1\\n\\n            t1 = pq1[0] if pq1 else float(\\'inf\\')\\n            t2 = pq2[0] if pq2 else float(\\'inf\\')\\n\\n            if t1 <= t2:\\n                ans += t1\\n                heapq.heappop(pq1)\\n            else:\\n                ans += t2\\n                heapq.heappop(pq2)\\n\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783150,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n        long long ans=0;\\n        int cnt = 0,i=0,j=costs.size()-1;\\n        while(cnt<k){\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n            int a=pq1.size()>0?pq1.top():INT_MAX;\\n            int b=pq2.size()>0?pq2.top():INT_MAX;\\n            // cout<<a<<\" \"<<b<<\"\\\\n\";\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n        long long ans=0;\\n        int cnt = 0,i=0,j=costs.size()-1;\\n        while(cnt<k){\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n            int a=pq1.size()>0?pq1.top():INT_MAX;\\n            int b=pq2.size()>0?pq2.top():INT_MAX;\\n            // cout<<a<<\" \"<<b<<\"\\\\n\";\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783147,
                "title": "python3-priority-queues",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6a94b729b8594be1319f14da1cf3c97ddb12a427) for solutions of weekly 318.\\n\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        q = costs[:candidates]\\n        qq = costs[max(candidates, len(costs)-candidates):]\\n        heapify(q)\\n        heapify(qq)\\n        ans = 0 \\n        i, ii = candidates, len(costs)-candidates-1\\n        for _ in range(k): \\n            if not qq or q and q[0] <= qq[0]: \\n                ans += heappop(q)\\n                if i <= ii: \\n                    heappush(q, costs[i])\\n                    i += 1\\n            else: \\n                ans += heappop(qq)\\n                if i <= ii: \\n                    heappush(qq, costs[ii])\\n                    ii -= 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        q = costs[:candidates]\\n        qq = costs[max(candidates, len(costs)-candidates):]\\n        heapify(q)\\n        heapify(qq)\\n        ans = 0 \\n        i, ii = candidates, len(costs)-candidates-1\\n        for _ in range(k): \\n            if not qq or q and q[0] <= qq[0]: \\n                ans += heappop(q)\\n                if i <= ii: \\n                    heappush(q, costs[i])\\n                    i += 1\\n            else: \\n                ans += heappop(qq)\\n                if i <= ii: \\n                    heappush(qq, costs[ii])\\n                    ii -= 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783491,
                "title": "c-two-min-heaps-nlogn-approach",
                "content": "**Intuition:** \\n* We will use `two` `min` heaps to store the cost of the first and last candidates in the current window of size k.\\n* We will add the first `k` candidates to the `window` and then we will add the `first` and `last` candidates to the window `one` by `one`. \\n* We will add the candidate with the `minimum` cost to the window. \\n* We will `repeat` this process until we have added all the `candidates` to the window. \\n* We will return the `total` cost of the candidates in the window.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        // using min heap to store the cost of each candidate in the current window of size k\\n        priority_queue<int,vector<int>,greater<int>> pq1; \\n        priority_queue<int,vector<int>,greater<int>> pq2; \\n        long long ans=0; // total cost\\n        int l=0,r=costs.size()-1; // left and right pointer of the window\\n        int cnt=0; // number of candidates in the current window\\n        while(cnt<k){ // add the first k candidates to the window\\n            while(pq1.size()<candidates && l<=r) // add the first candidates to the window\\n                pq1.push(costs[l++]); \\n            while(pq2.size()<candidates && r>=l) // add the last candidates to the window\\n                pq2.push(costs[r--]);\\n            \\n            int top1 = pq1.size()>0?pq1.top():INT_MAX; // if the first window is full, then the top of the first window is the minimum cost of the first candidates\\n            int top2 = pq2.size()>0?pq2.top():INT_MAX; // if the last window is full, then the top of the last window is the minimum cost of the last candidates\\n            \\n            if(top1<=top2){ // if the first window is cheaper, then add the first candidate to the window\\n                ans+=top1;\\n                pq1.pop(); \\n            }\\n            else{ // if the last window is cheaper, then add the last candidate to the window\\n                ans+=top2;\\n                pq2.pop();\\n            }\\n            cnt++; // increase the number of candidates in the window\\n        }\\n        return ans; // return the total cost\\n    }\\n};\\n```\\n----\\n**Complexity Analysis:**\\n\\n**Time Complexity** : `O(nlogn)`\\n**Space Complexity** : `O(n)`",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        // using min heap to store the cost of each candidate in the current window of size k\\n        priority_queue<int,vector<int>,greater<int>> pq1; \\n        priority_queue<int,vector<int>,greater<int>> pq2; \\n        long long ans=0; // total cost\\n        int l=0,r=costs.size()-1; // left and right pointer of the window\\n        int cnt=0; // number of candidates in the current window\\n        while(cnt<k){ // add the first k candidates to the window\\n            while(pq1.size()<candidates && l<=r) // add the first candidates to the window\\n                pq1.push(costs[l++]); \\n            while(pq2.size()<candidates && r>=l) // add the last candidates to the window\\n                pq2.push(costs[r--]);\\n            \\n            int top1 = pq1.size()>0?pq1.top():INT_MAX; // if the first window is full, then the top of the first window is the minimum cost of the first candidates\\n            int top2 = pq2.size()>0?pq2.top():INT_MAX; // if the last window is full, then the top of the last window is the minimum cost of the last candidates\\n            \\n            if(top1<=top2){ // if the first window is cheaper, then add the first candidate to the window\\n                ans+=top1;\\n                pq1.pop(); \\n            }\\n            else{ // if the last window is cheaper, then add the last candidate to the window\\n                ans+=top2;\\n                pq2.pop();\\n            }\\n            cnt++; // increase the number of candidates in the window\\n        }\\n        return ans; // return the total cost\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784368,
                "title": "java-2-solutions-heap-treeset",
                "content": "# 2.PriorityQueue\\n```\\n//2.PriorityQueue\\n    //Runtime: 113 ms, faster than 80.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Memory Usage: 52.8 MB, less than 100.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Time: O(N * 2*log(2*N) + K * 2*log(2*N)); Space: O(N)\\n    //Time: O((N + K) * log(N)); Space: O(N)\\n    //let N be the number of candidates; K is the k;\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int left = 0, right = costs.length - 1;\\n\\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((a, b) -> (costs[a] - costs[b] != 0 ? costs[a] - costs[b] : a - b));\\n        for (int i = 0; i < candidates && left <= right; i++) {\\n            priorityQueue.add(left++);\\n            if (left <= right) priorityQueue.add(right--);\\n        }\\n\\n        long res = 0;\\n        while (k > 0) {\\n            int idx = priorityQueue.poll();\\n            if (left <= right && left < costs.length && right >= 0) {\\n                if (idx <= left) priorityQueue.add(left++);\\n                else priorityQueue.add(right--);\\n            }\\n            res += costs[idx];\\n            k--;\\n        }\\n        return res;\\n    }\\n```\\n# 1.TreeSet\\n```\\n    //1.TreeSet\\n    //Runtime: 363 ms, faster than 20.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Memory Usage: 113.4 MB, less than 20.00% of Java online submissions for Total Cost to Hire K Workers.\\n    public long totalCost_1(int[] costs, int k, int candidates) {\\n        int[][] data = new int[costs.length][2];\\n        for (int i = 0; i < costs.length; i++) {\\n            data[i][0] = costs[i];\\n            data[i][1] = i;\\n        }\\n\\n        TreeSet<int[]> treeSet = new TreeSet<>((a, b) -> (a[0] - b[0] != 0 ? a[0] - b[0] : a[1] - b[1]));\\n        for (int i = 0; i < candidates; i++) {\\n            treeSet.add(data[i]);\\n            treeSet.add(data[costs.length - 1 - i]);\\n        }\\n\\n        long res = 0;\\n        int left = candidates, right = costs.length - 1 - candidates;\\n\\n        Set<int[]> seen = new HashSet<>();\\n        while (k > 0) {\\n            int[] element = treeSet.first();\\n            treeSet.remove(element);\\n            if (left < costs.length && right >= 0) {\\n                if (element[1] < left) {\\n                    if (!seen.contains(data[left])) treeSet.add(data[left]);\\n                    left++;\\n                } else {\\n                    if (!seen.contains(data[right])) treeSet.add(data[right]);\\n                    right--;\\n                }\\n            }\\n            res += element[0];\\n            seen.add(element);\\n            k--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//2.PriorityQueue\\n    //Runtime: 113 ms, faster than 80.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Memory Usage: 52.8 MB, less than 100.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Time: O(N * 2*log(2*N) + K * 2*log(2*N)); Space: O(N)\\n    //Time: O((N + K) * log(N)); Space: O(N)\\n    //let N be the number of candidates; K is the k;\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int left = 0, right = costs.length - 1;\\n\\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((a, b) -> (costs[a] - costs[b] != 0 ? costs[a] - costs[b] : a - b));\\n        for (int i = 0; i < candidates && left <= right; i++) {\\n            priorityQueue.add(left++);\\n            if (left <= right) priorityQueue.add(right--);\\n        }\\n\\n        long res = 0;\\n        while (k > 0) {\\n            int idx = priorityQueue.poll();\\n            if (left <= right && left < costs.length && right >= 0) {\\n                if (idx <= left) priorityQueue.add(left++);\\n                else priorityQueue.add(right--);\\n            }\\n            res += costs[idx];\\n            k--;\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.TreeSet\\n    //Runtime: 363 ms, faster than 20.00% of Java online submissions for Total Cost to Hire K Workers.\\n    //Memory Usage: 113.4 MB, less than 20.00% of Java online submissions for Total Cost to Hire K Workers.\\n    public long totalCost_1(int[] costs, int k, int candidates) {\\n        int[][] data = new int[costs.length][2];\\n        for (int i = 0; i < costs.length; i++) {\\n            data[i][0] = costs[i];\\n            data[i][1] = i;\\n        }\\n\\n        TreeSet<int[]> treeSet = new TreeSet<>((a, b) -> (a[0] - b[0] != 0 ? a[0] - b[0] : a[1] - b[1]));\\n        for (int i = 0; i < candidates; i++) {\\n            treeSet.add(data[i]);\\n            treeSet.add(data[costs.length - 1 - i]);\\n        }\\n\\n        long res = 0;\\n        int left = candidates, right = costs.length - 1 - candidates;\\n\\n        Set<int[]> seen = new HashSet<>();\\n        while (k > 0) {\\n            int[] element = treeSet.first();\\n            treeSet.remove(element);\\n            if (left < costs.length && right >= 0) {\\n                if (element[1] < left) {\\n                    if (!seen.contains(data[left])) treeSet.add(data[left]);\\n                    left++;\\n                } else {\\n                    if (!seen.contains(data[right])) treeSet.add(data[right]);\\n                    right--;\\n                }\\n            }\\n            res += element[0];\\n            seen.add(element);\\n            k--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783088,
                "title": "c-solution-using-priority-queue-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nApproach is to store the candidates from front and back in two diff. priority queue.\\nThen remove the smallest cost candidate among both the queue and push a new candidate to the same\\nqueue from where we removed last time.\\n*/\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;\\n        priority_queue<int, vector<int>, greater<int>> pqf, pqb;  // pqf - front pq,stores cost from front ; pqb -  back pq, stores cost from back\\n        int i = 0, j = costs.size() - 1;\\n        while( i < candidates && i <= j){  //push first and last candidate cost to both pq\\n            pqf.push(costs[i]);\\n            if(i != j) pqb.push(costs[j]);\\n            i++; j--;\\n        }\\n        int lastpop = 0; //keep track of which pq is used last, 0 - taken from front pq, 1 - taken from back pq\\n        \\n        //get smallest cost\\n        if(pqb.size() == 0 || (pqf.size() != 0 && pqf.top() <= pqb.top() ) ){\\n            ans += pqf.top(); pqf.pop();\\n            lastpop = 0;\\n        }else{\\n            ans += pqb.top(); pqb.pop();\\n            lastpop = 1;\\n        }\\n        \\n        while(--k){\\n            if(i <= j){   //push new cost to pq\\n                if(lastpop == 0 ) { pqf.push(costs[i]);  ++i; }\\n                else { pqb.push(costs[j]); --j; }\\n            }\\n            \\n            //get smallest cost\\n            if(pqb.size() == 0 || (pqf.size() != 0 && pqf.top() <= pqb.top() ) ){\\n                ans += pqf.top(); pqf.pop();\\n                lastpop = 0;\\n            }else{\\n                ans += pqb.top(); pqb.pop();\\n                lastpop = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nApproach is to store the candidates from front and back in two diff. priority queue.\\nThen remove the smallest cost candidate among both the queue and push a new candidate to the same\\nqueue from where we removed last time.\\n*/\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;\\n        priority_queue<int, vector<int>, greater<int>> pqf, pqb;  // pqf - front pq,stores cost from front ; pqb -  back pq, stores cost from back\\n        int i = 0, j = costs.size() - 1;\\n        while( i < candidates && i <= j){  //push first and last candidate cost to both pq\\n            pqf.push(costs[i]);\\n            if(i != j) pqb.push(costs[j]);\\n            i++; j--;\\n        }\\n        int lastpop = 0; //keep track of which pq is used last, 0 - taken from front pq, 1 - taken from back pq\\n        \\n        //get smallest cost\\n        if(pqb.size() == 0 || (pqf.size() != 0 && pqf.top() <= pqb.top() ) ){\\n            ans += pqf.top(); pqf.pop();\\n            lastpop = 0;\\n        }else{\\n            ans += pqb.top(); pqb.pop();\\n            lastpop = 1;\\n        }\\n        \\n        while(--k){\\n            if(i <= j){   //push new cost to pq\\n                if(lastpop == 0 ) { pqf.push(costs[i]);  ++i; }\\n                else { pqb.push(costs[j]); --j; }\\n            }\\n            \\n            //get smallest cost\\n            if(pqb.size() == 0 || (pqf.size() != 0 && pqf.top() <= pqb.top() ) ){\\n                ans += pqf.top(); pqf.pop();\\n                lastpop = 0;\\n            }else{\\n                ans += pqb.top(); pqb.pop();\\n                lastpop = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788033,
                "title": "python-c-rust-few-lines-with-just-one-heap-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a single binary heap (priority queue) to extract minimal values. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** A natural choice for extracting minimal numbers in a less-than-linear time is to use a binary heap data structure (with **logN** time complexity). However, we should also keep track of which half the number was extracted from. One possible solution is to use two heaps. However, it turns out that using just one heap is possible. All we need is to store additional identification data with each number, e.g., it\\'s index in the original array.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def totalCost(self, cst, k, c):\\n        \\n        n, res = len(cst), 0                           # to use just one heap, we have to be \\n        pairs  = [(t, i) for i, t in enumerate(cst)]   # able to extract the origin of a number\\n        l, r   = min(c,n//2), max(n-c,n//2)            # (left/right) when popping from the heap,\\n        pq     = pairs[:l] + pairs[r:]                 # thus, we save index for each number\\n        \\n        heapify(pq)\\n\\n        for _ in range(k):                             # the smallest number comes first; if there\\n            cost, i = heappop(pq)                      # are several such numbers then the one with\\n            if i < l  : i, l = l, l+1                  # the smallest index (from the left) is taken\\n            if i >= r : i, r = r-1, r-1                \\n            if l <= r : heappush(pq, pairs[i])         # push numbers until they are depleted\\n            res += cost\\n        \\n        return res\\n```\\n\\nSolutions in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/APUUDvnt/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalCost(self, cst, k, c):\\n        \\n        n, res = len(cst), 0                           # to use just one heap, we have to be \\n        pairs  = [(t, i) for i, t in enumerate(cst)]   # able to extract the origin of a number\\n        l, r   = min(c,n//2), max(n-c,n//2)            # (left/right) when popping from the heap,\\n        pq     = pairs[:l] + pairs[r:]                 # thus, we save index for each number\\n        \\n        heapify(pq)\\n\\n        for _ in range(k):                             # the smallest number comes first; if there\\n            cost, i = heappop(pq)                      # are several such numbers then the one with\\n            if i < l  : i, l = l, l+1                  # the smallest index (from the left) is taken\\n            if i >= r : i, r = r-1, r-1                \\n            if l <= r : heappush(pq, pairs[i])         # push numbers until they are depleted\\n            res += cost\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783153,
                "title": "two-min-priority-queues-explained",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake 2 min priority queues one for first candidates and second for back candidates and initialise with first candidates and last candidates number of candidates. Now check which priority queue has lower element on top. If first has lower element , pop the element and add the next element(use pointers to keep a track of what to put next in queue). A make a visit vector so that you dont push same element again in the queue.\\n# Complexity\\n- Time complexity: O((candidate+k) log(candidate+k))\\n*because we will push atmost 2(candidates)+k elements in priority queue , each push takes O(log(pq.size()) time*\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(candidate)\\n*because there will be atmost 2(candidates) number of elements including both queues*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n   priority_queue<int,vector<int>,greater<int>> pq1,pq2; //** min pq\\n        \\n        vector<int> visit(costs.size(),0);  // to track whats already in queue\\n        int l ,r;      //** pointers to see what will be put next(l for first and r for last candidates)\\n        for(int i =0;i<can && i<costs.size();i++){\\n            pq1.push(costs[i]);\\n            visit[i]=1;\\n            l = i;\\n        }\\n        l++;\\n        for(int i = costs.size()-can;i<costs.size();i++){\\n            if(visit[i]==1)continue;\\n            pq2.push(costs[i]);\\n            visit[i]=1;\\n            r = i;\\n        }\\n        r= costs.size()-can-1;\\n        \\n            //****now pq1 has first candidates and pq2 has last\\n        int ans = 0;\\n        long long sum = 0;\\n    \\n        while(ans<k){\\n              \\n            if((pq1.size()!=0) && (pq2.size()==0|| pq1.top()<=pq2.top())  ){ //*/ if pq1 has lower on top\\n                int a = pq1.top();\\n                 pq1.pop();    \\n                 ans++;                                 //*** add to ans\\n                 sum+= a;\\n                if( l>=0 &&  l<costs.size() && visit[l]==0 ){ // *** if next element is not already visited\\n                    pq1.push(costs[l]);\\n                    visit[l]=1;\\n                    l++;\\n                }\\n            }\\n            \\n            else{\\n                int a = pq2.top();\\n                pq2.pop();\\n                ans++;\\n                sum+= a;\\n                if(r>=0 &&  r<costs.size() && visit[r]==0 ){\\n                    pq2.push(costs[r]);\\n                   \\n                    visit[r]=1;\\n                    r--;\\n                }  \\n            }    }\\n        \\n        return sum;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   priority_queue<int,vector<int>,greater<int>> pq1,pq2; //** min pq\\n        \\n        vector<int> visit(costs.size(),0);  // to track whats already in queue\\n        int l ,r;      //** pointers to see what will be put next(l for first and r for last candidates)\\n        for(int i =0;i<can && i<costs.size();i++){\\n            pq1.push(costs[i]);\\n            visit[i]=1;\\n            l = i;\\n        }\\n        l++;\\n        for(int i = costs.size()-can;i<costs.size();i++){\\n            if(visit[i]==1)continue;\\n            pq2.push(costs[i]);\\n            visit[i]=1;\\n            r = i;\\n        }\\n        r= costs.size()-can-1;\\n        \\n            //****now pq1 has first candidates and pq2 has last\\n        int ans = 0;\\n        long long sum = 0;\\n    \\n        while(ans<k){\\n              \\n            if((pq1.size()!=0) && (pq2.size()==0|| pq1.top()<=pq2.top())  ){ //*/ if pq1 has lower on top\\n                int a = pq1.top();\\n                 pq1.pop();    \\n                 ans++;                                 //*** add to ans\\n                 sum+= a;\\n                if( l>=0 &&  l<costs.size() && visit[l]==0 ){ // *** if next element is not already visited\\n                    pq1.push(costs[l]);\\n                    visit[l]=1;\\n                    l++;\\n                }\\n            }\\n            \\n            else{\\n                int a = pq2.top();\\n                pq2.pop();\\n                ans++;\\n                sum+= a;\\n                if(r>=0 &&  r<costs.size() && visit[r]==0 ){\\n                    pq2.push(costs[r]);\\n                   \\n                    visit[r]=1;\\n                    r--;\\n                }  \\n            }    }\\n        \\n        return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802767,
                "title": "c-two-min-priority-queues-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0,i,j,end,start,n;\\n        \\n        n = costs.size();\\n        \\n        priority_queue<int,vector<int>,greater<int>> s,e;\\n        \\n        for(i=0;i<candidates;i++){\\n            s.push(costs[i]);\\n        }\\n        \\n        for(i = n-1;i>=candidates&& i >= n-candidates;i--){\\n            e.push(costs[i]);\\n        }\\n        \\n        start = candidates;\\n        end = n- candidates-1;\\n        \\n        while(k > 0){\\n            if(s.empty() == false && e.empty() == false)\\n            {\\n                if(s.top() <= e.top())\\n                {\\n                    ans= ans + s.top();\\n                    s.pop();\\n                    \\n                    if(start <= end){\\n                        s.push(costs[start]);\\n                        start++;\\n                    }\\n                }\\n                else\\n                {\\n                    ans=ans+e.top();\\n                e.pop();\\n                \\n                if(start<=end){\\n                    e.push(costs[end]);\\n                    end--;\\n                }\\n              }\\n            }\\n            else if(s.empty() == false){\\n                ans = ans + s.top();\\n                s.pop();\\n            }\\n            else if(e.empty() == false)\\n            {\\n                ans = ans + e.top();\\n                e.pop();\\n            }\\n               k--; \\n            }\\n        return ans;\\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0,i,j,end,start,n;\\n        \\n        n = costs.size();\\n        \\n        priority_queue<int,vector<int>,greater<int>> s,e;\\n        \\n        for(i=0;i<candidates;i++){\\n            s.push(costs[i]);\\n        }\\n        \\n        for(i = n-1;i>=candidates&& i >= n-candidates;i--){\\n            e.push(costs[i]);\\n        }\\n        \\n        start = candidates;\\n        end = n- candidates-1;\\n        \\n        while(k > 0){\\n            if(s.empty() == false && e.empty() == false)\\n            {\\n                if(s.top() <= e.top())\\n                {\\n                    ans= ans + s.top();\\n                    s.pop();\\n                    \\n                    if(start <= end){\\n                        s.push(costs[start]);\\n                        start++;\\n                    }\\n                }\\n                else\\n                {\\n                    ans=ans+e.top();\\n                e.pop();\\n                \\n                if(start<=end){\\n                    e.push(costs[end]);\\n                    end--;\\n                }\\n              }\\n            }\\n            else if(s.empty() == false){\\n                ans = ans + s.top();\\n                s.pop();\\n            }\\n            else if(e.empty() == false)\\n            {\\n                ans = ans + e.top();\\n                e.pop();\\n            }\\n               k--; \\n            }\\n        return ans;\\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783277,
                "title": "priority-queue-easy-easy-to-understand",
                "content": "```\\nclass Pair{\\n    int val, index;\\n    Pair(int val, int index)\\n    {\\n        this.val = val;\\n        this.index = index;\\n    }   \\n}\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int len) \\n    {\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            if (a.val != b.val) return (a.val - b.val);\\n            else return (a.index - b.index);\\n        });\\n        //===========================================\\n        int n = costs.length;\\n        int i, j;\\n        for (i = 0, j = n - 1; i <= j && i < len; i++, j--)\\n        {\\n            pq.add(new Pair(costs[i], i));\\n            if (i != j) pq.add(new Pair(costs[j], j));\\n        }\\n        int low = i, high = j;\\n        //==============================================\\n        long ans = 0;\\n        while(!pq.isEmpty() && k > 0)\\n        {\\n            Pair minPair = pq.poll();\\n            int minVal = minPair.val;\\n            int minIndex = minPair.index;\\n            \\n            ans += minPair.val;\\n            k--;\\n            \\n            if (low > high) continue;\\n            \\n            int dist1 = Math.abs(low - minIndex);\\n            int dist2 = Math.abs(high - minIndex);\\n            if (dist1 < dist2) pq.add(new Pair(costs[low], low++));\\n            else pq.add(new Pair(costs[high], high--));\\n        }\\n        //======================================================\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair{\\n    int val, index;\\n    Pair(int val, int index)\\n    {\\n        this.val = val;\\n        this.index = index;\\n    }   \\n}\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int len) \\n    {\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            if (a.val != b.val) return (a.val - b.val);\\n            else return (a.index - b.index);\\n        });\\n        //===========================================\\n        int n = costs.length;\\n        int i, j;\\n        for (i = 0, j = n - 1; i <= j && i < len; i++, j--)\\n        {\\n            pq.add(new Pair(costs[i], i));\\n            if (i != j) pq.add(new Pair(costs[j], j));\\n        }\\n        int low = i, high = j;\\n        //==============================================\\n        long ans = 0;\\n        while(!pq.isEmpty() && k > 0)\\n        {\\n            Pair minPair = pq.poll();\\n            int minVal = minPair.val;\\n            int minIndex = minPair.index;\\n            \\n            ans += minPair.val;\\n            k--;\\n            \\n            if (low > high) continue;\\n            \\n            int dist1 = Math.abs(low - minIndex);\\n            int dist2 = Math.abs(high - minIndex);\\n            if (dist1 < dist2) pq.add(new Pair(costs[low], low++));\\n            else pq.add(new Pair(costs[high], high--));\\n        }\\n        //======================================================\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683271,
                "title": "c-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The given code seems to calculate the total cost based on the following approach:\\n\\n1. Two priority queues, `q1` and `q2`, are used to store the lowest costs from the beginning and the highest costs from the end of the `costs` array, respectively.\\n2. The variable `low` is used to keep track of the beginning of the array, and `high` is used to keep track of the end of the array.\\n3. Initially, the `candidates` number of costs from the beginning of the array are inserted into `q1`, and the `candidates` number of costs from the end of the array are inserted into `q2`.\\n4. The code then enters a loop where it performs the following steps `k` times:\\n   - If `q1` is empty, it means that all the lowest costs from the beginning of the array have been used. In this case, the lowest cost from `q2` is added to the total cost, and a new cost from the end of the array (`costs[high]`) is inserted into `q2`. The `high` pointer is decremented.\\n   - If `q2` is empty, it means that all the highest costs from the end of the array have been used. In this case, the lowest cost from `q1` is added to the total cost, and a new cost from the beginning of the array (`costs[low]`) is inserted into `q1`. The `low` pointer is incremented.\\n   - If both `q1` and `q2` are non-empty, the lowest cost between the tops of the two queues is added to the total cost. If the lowest cost belongs to `q1`, a new cost from the beginning of the array is inserted into `q1` and the `low` pointer is incremented. If the lowest cost belongs to `q2`, a new cost from the end of the array is inserted into `q2` and the `high` pointer is decremented.\\n\\nFinally, the total cost is returned.\\n\\nTo upgrade this code and add comments, please provide the problem statement or a brief explanation of the desired functionality.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The given code appears to be a solution to a problem that involves finding the total cost of selecting `k` candidates from an array of costs, where the candidates can be chosen from both the beginning and the end of the array. The code uses two priority queues, `q1` and `q2`, to maintain the lowest costs from the beginning and the highest costs from the end of the array, respectively. The `candidates` parameter determines how many candidates are selected from each end.\\n\\nTo upgrade and add comments to the code, I would follow these steps:\\n\\n1. Add a problem statement or a brief explanation of the desired functionality.\\n2. Revise and improve the variable names to make them more descriptive.\\n3. Add comments to explain the purpose and logic of each section of the code.\\n4. Refactor the code if necessary to improve readability or optimize performance.\\n5. Ensure that the upgraded code remains functionally equivalent to the original code.\\n\\nPlease provide the problem statement or a brief explanation of the desired functionality, and I will proceed with upgrading the code and adding comments.\\n\\n# Complexity\\n- Time complexity: O(k + candidates)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(candidates)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;  // Variable to store the total cost\\n        priority_queue<int, vector<int>, greater<int>> q1;  // Priority queue to store the lowest costs from the beginning of the array\\n        priority_queue<int, vector<int>, greater<int>> q2;  // Priority queue to store the highest costs from the end of the array\\n        int low = 0;  // Pointer to track the beginning of the array\\n\\n        // Insert \\'candidates\\' number of costs into q1\\n        while (low < candidates) {\\n            q1.push(costs[low]);\\n            low++;\\n        }\\n\\n        int cnt = 0;\\n        int high = (int)costs.size() - 1;  // Pointer to track the end of the array\\n\\n        // Adjust \\'candidates\\' if it is greater than the number of elements from the end of the array\\n        if (candidates > costs.size() - candidates) {\\n            candidates = costs.size() - candidates;\\n        }  \\n\\n        // Insert \\'candidates\\' number of costs into q2 from the end of the array\\n        while (cnt < candidates) {\\n            q2.push(costs[high]);\\n            cnt++;\\n            high--;\\n        }    \\n\\n        while (k--) {\\n            if (q1.empty()) {  // If q1 is empty, take the lowest cost from q2\\n                ans += q2.top();\\n                q2.pop();\\n                if (low <= high) {\\n                    q2.push(costs[high]);\\n                    high--;\\n                }        \\n            } else if (q2.empty()) {  // If q2 is empty, take the lowest cost from q1\\n                ans += q1.top();\\n                q1.pop();\\n                if (low <= high) {\\n                    q1.push(costs[low]);\\n                    low++;\\n                } \\n            } else if (q1.top() <= q2.top()) {  // If the lowest cost in q1 is less than or equal to the lowest cost in q2, take the lowest cost from q1\\n                ans += q1.top();\\n                q1.pop();\\n                if (low <= high) {\\n                    q1.push(costs[low]);\\n                    low++;\\n                }\\n            } else {  // If the lowest cost in q2 is less than the lowest cost in q1, take the lowest cost from q2\\n                ans += q2.top();\\n                q2.pop();\\n                if (low <= high) {\\n                    q2.push(costs[high]);\\n                    high--;\\n                }           \\n            }\\n        }\\n        return ans;  // Return the total cost\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/53923a33-f886-42a7-8a8c-ddff8768c434_1687751417.2231622.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;  // Variable to store the total cost\\n        priority_queue<int, vector<int>, greater<int>> q1;  // Priority queue to store the lowest costs from the beginning of the array\\n        priority_queue<int, vector<int>, greater<int>> q2;  // Priority queue to store the highest costs from the end of the array\\n        int low = 0;  // Pointer to track the beginning of the array\\n\\n        // Insert \\'candidates\\' number of costs into q1\\n        while (low < candidates) {\\n            q1.push(costs[low]);\\n            low++;\\n        }\\n\\n        int cnt = 0;\\n        int high = (int)costs.size() - 1;  // Pointer to track the end of the array\\n\\n        // Adjust \\'candidates\\' if it is greater than the number of elements from the end of the array\\n        if (candidates > costs.size() - candidates) {\\n            candidates = costs.size() - candidates;\\n        }  \\n\\n        // Insert \\'candidates\\' number of costs into q2 from the end of the array\\n        while (cnt < candidates) {\\n            q2.push(costs[high]);\\n            cnt++;\\n            high--;\\n        }    \\n\\n        while (k--) {\\n            if (q1.empty()) {  // If q1 is empty, take the lowest cost from q2\\n                ans += q2.top();\\n                q2.pop();\\n                if (low <= high) {\\n                    q2.push(costs[high]);\\n                    high--;\\n                }        \\n            } else if (q2.empty()) {  // If q2 is empty, take the lowest cost from q1\\n                ans += q1.top();\\n                q1.pop();\\n                if (low <= high) {\\n                    q1.push(costs[low]);\\n                    low++;\\n                } \\n            } else if (q1.top() <= q2.top()) {  // If the lowest cost in q1 is less than or equal to the lowest cost in q2, take the lowest cost from q1\\n                ans += q1.top();\\n                q1.pop();\\n                if (low <= high) {\\n                    q1.push(costs[low]);\\n                    low++;\\n                }\\n            } else {  // If the lowest cost in q2 is less than the lowest cost in q1, take the lowest cost from q2\\n                ans += q2.top();\\n                q2.pop();\\n                if (low <= high) {\\n                    q2.push(costs[high]);\\n                    high--;\\n                }           \\n            }\\n        }\\n        return ans;  // Return the total cost\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783183,
                "title": "single-min-heap-clean-code-c-o-nlogn",
                "content": "The Key in this question is to ensure that duplicate elements are not inserted into Priority Queue.\\n\\nJust insert candidate number of element from both side into priority queue. wheneve you pop element push element of that side into priority queue.\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int cand) {\\n        long long ans = 0;\\n        priority_queue<pair<int,pair<int,char>>, vector<pair<int,pair<int,char>>>, greater<pair<int,pair<int,char>>>> pq;\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        \\n        for(int i=0;i<cand;i++)\\n        {\\n            pq.push({nums[left],{left,\\'L\\'}});\\n            left++;\\n        }\\n        \\n        for(int i=0;i<cand && left <= right;i++)\\n        {\\n            pq.push({nums[right],{right,\\'R\\'}});\\n            right--;\\n        }\\n        while(k-- && !pq.empty())\\n        {\\n            auto pat = pq.top();\\n            pq.pop();\\n            \\n            char x = pat.second.second;\\n            ans += pat.first;\\n            \\n            if(left <= right)\\n            {\\n                if(x == \\'L\\')\\n                {\\n                    pq.push({nums[left],{left,\\'L\\'}});\\n                    left++;\\n                }\\n                else\\n                {\\n                    pq.push({nums[right],{right,\\'R\\'}});\\n                    right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote If You Like.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int cand) {\\n        long long ans = 0;\\n        priority_queue<pair<int,pair<int,char>>, vector<pair<int,pair<int,char>>>, greater<pair<int,pair<int,char>>>> pq;\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        \\n        for(int i=0;i<cand;i++)\\n        {\\n            pq.push({nums[left],{left,\\'L\\'}});\\n            left++;\\n        }\\n        \\n        for(int i=0;i<cand && left <= right;i++)\\n        {\\n            pq.push({nums[right],{right,\\'R\\'}});\\n            right--;\\n        }\\n        while(k-- && !pq.empty())\\n        {\\n            auto pat = pq.top();\\n            pq.pop();\\n            \\n            char x = pat.second.second;\\n            ans += pat.first;\\n            \\n            if(left <= right)\\n            {\\n                if(x == \\'L\\')\\n                {\\n                    pq.push({nums[left],{left,\\'L\\'}});\\n                    left++;\\n                }\\n                else\\n                {\\n                    pq.push({nums[right],{right,\\'R\\'}});\\n                    right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783093,
                "title": "multisets-two-pointer-c-explained-with-code",
                "content": "<h5>Main Idea</h5>\\nLet\\'s maintain two multisets to keep track of  the first <b>candidates</b> workers and last<b> candidate </b>workers. We will also maintain two pointers <b>L</b> and <b>R</b>.\\n<b>L</b> indicates that first<b>L</b> workers are inserted into the multiset. Similarly, <b>R</b> indicates that last <b>R</b> workers are inserted into the multiset.\\n\\nNow we will keep taking workers from the sets for k sessions.Each time we take the worker with less cost and minimum index by checking the first elements of both set. We will update the multiset by erasing the taken element and inserting new elements (if required) and move the pointer accordingly.\\n\\n<b>Time Complexity: O(nlog(n)) </b><br><br>\\n<h5>Sample Code</h5>\\n\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        multiset<long long>first,last;\\n        int n = costs.size();\\n        for(int i=0;i<candidates;i++){\\n            first.insert(costs[i]);\\n        }\\n        for(int i=max(candidates,n-candidates);i<n;i++){\\n                last.insert(costs[i]);\\n        }\\n        int l = candidates;\\n        int r = n-1-candidates;\\n        long long ans =0;\\n        for(int i=0;i<k;i++){\\n           long long front = INT_MAX,back = INT_MAX;\\n            if(first.size())front = *first.begin();\\n            if(last.size()) back = *last.begin();\\n            if(front<=back){\\n                first.erase(first.begin());\\n                ans+=front;\\n                if(l<=r){\\n                    first.insert(costs[l]);\\n                    l++;\\n                }\\n            }else{\\n                ans+=back;\\n                last.erase(last.begin());\\n                if(r>=l){\\n                    last.insert(costs[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Please upvote if you liked the solution. </b>\\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        multiset<long long>first,last;\\n        int n = costs.size();\\n        for(int i=0;i<candidates;i++){\\n            first.insert(costs[i]);\\n        }\\n        for(int i=max(candidates,n-candidates);i<n;i++){\\n                last.insert(costs[i]);\\n        }\\n        int l = candidates;\\n        int r = n-1-candidates;\\n        long long ans =0;\\n        for(int i=0;i<k;i++){\\n           long long front = INT_MAX,back = INT_MAX;\\n            if(first.size())front = *first.begin();\\n            if(last.size()) back = *last.begin();\\n            if(front<=back){\\n                first.erase(first.begin());\\n                ans+=front;\\n                if(l<=r){\\n                    first.insert(costs[l]);\\n                    l++;\\n                }\\n            }else{\\n                ans+=back;\\n                last.erase(last.begin());\\n                if(r>=l){\\n                    last.insert(costs[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783503,
                "title": "python-easy-to-understand-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        from heapq import heappush, heappop\\n\\n        heap = []\\n\\n        p1 = 0\\n        p2 = len(costs)-1\\n\\n        while(p1 < candidates):\\n            heappush(heap, (costs[p1], p1))\\n            p1 += 1\\n\\n        while(p2 >= len(costs)-candidates and p2 >= p1):\\n            heappush(heap, (costs[p2], p2))\\n            p2 -= 1\\n\\n        res = 0\\n        for i in range(k):\\n            c, idx = heappop(heap)\\n\\n            res += c\\n\\n            if idx < p1:\\n                if p1 <= p2:\\n                    heappush(heap, (costs[p1], p1))\\n                    p1 += 1\\n            else:\\n                if p1 <= p2:\\n                    heappush(heap, (costs[p2], p2))\\n                    p2 -= 1\\n\\n        return res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        from heapq import heappush, heappop\\n\\n        heap = []\\n\\n        p1 = 0\\n        p2 = len(costs)-1\\n\\n        while(p1 < candidates):\\n            heappush(heap, (costs[p1], p1))\\n            p1 += 1\\n\\n        while(p2 >= len(costs)-candidates and p2 >= p1):\\n            heappush(heap, (costs[p2], p2))\\n            p2 -= 1\\n\\n        res = 0\\n        for i in range(k):\\n            c, idx = heappop(heap)\\n\\n            res += c\\n\\n            if idx < p1:\\n                if p1 <= p2:\\n                    heappush(heap, (costs[p1], p1))\\n                    p1 += 1\\n            else:\\n                if p1 <= p2:\\n                    heappush(heap, (costs[p2], p2))\\n                    p2 -= 1\\n\\n        return res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783060,
                "title": "isn-t-it-means-smallest-in-the-array",
                "content": "isn\\'t it means smallest in the array?\\n\\n\\n\\n**update :**\\n\\n***Thanks to everyone who cleared my doubt below in comments section***\\n\\n```\\nclass Solution {\\n    PriorityQueue<Integer> pq1;\\n    PriorityQueue<Integer> pq2;\\n    int INF = Integer.MAX_VALUE;\\n\\n    public long totalCost(int[] costs, int k, int candi) {\\n        pq1 = new PriorityQueue<>();\\n        pq2 = new PriorityQueue<>();\\n        int i = 0, j = costs.length - 1;\\n        long ans = 0;\\n        while (true && k != 0) {\\n            if (pq1.size() < candi) {\\n                if (costs[i] == -1) return overlapped(ans, k); //if we encounter any of choosen cost this means we have overlapped \\n                pq1.offer(costs[i++]);\\n                costs[i - 1] = -1; //mark as choosen\\n            }\\n            if (pq2.size() < candi) {\\n                if (costs[j] == -1) return overlapped(ans, k);\\n                pq2.offer(costs[j--]);\\n                costs[j + 1] = -1;\\n            }\\n\\n            if (pq1.size() < candi || pq2.size() < candi) continue; \\n            \\n            int min1 = pq1.peek();\\n            int min2 = pq2.peek();\\n\\n            if (min1 <= min2) {\\n                pq1.poll();\\n                ans += min1;\\n            } else {\\n                pq2.poll();\\n                ans += min2;\\n            }\\n            k--;\\n        }\\n\\n        return overlapped(ans, k);\\n    }\\n\\n    long overlapped(long ans, int k) {\\n\\n        while (k-- > 0) {\\n            int min1 = pq1.size() == 0 ? INF : pq1.peek();\\n            int min2 = pq2.size() == 0 ? INF : pq2.peek();\\n            if (min1 <= min2) {\\n                pq1.poll();\\n                ans += min1;\\n            } else {\\n                pq2.poll();\\n                ans += min2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n\\n![](https://gifimage.net/wp-content/uploads/2018/11/sad-man-gif-4.gif)\\n\\n\\n\\n***let\\'s connect :***\\n\\n\\uD83D\\uDE80 [www.linkedin.com/in/harshitmaurya](https://www.linkedin.com/in/harshitmaurya/)\\n\\uD83D\\uDE80 [twitter.com/HarshitMaurya_](https://twitter.com/HarshitMaurya_)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    PriorityQueue<Integer> pq1;\\n    PriorityQueue<Integer> pq2;\\n    int INF = Integer.MAX_VALUE;\\n\\n    public long totalCost(int[] costs, int k, int candi) {\\n        pq1 = new PriorityQueue<>();\\n        pq2 = new PriorityQueue<>();\\n        int i = 0, j = costs.length - 1;\\n        long ans = 0;\\n        while (true && k != 0) {\\n            if (pq1.size() < candi) {\\n                if (costs[i] == -1) return overlapped(ans, k); //if we encounter any of choosen cost this means we have overlapped \\n                pq1.offer(costs[i++]);\\n                costs[i - 1] = -1; //mark as choosen\\n            }\\n            if (pq2.size() < candi) {\\n                if (costs[j] == -1) return overlapped(ans, k);\\n                pq2.offer(costs[j--]);\\n                costs[j + 1] = -1;\\n            }\\n\\n            if (pq1.size() < candi || pq2.size() < candi) continue; \\n            \\n            int min1 = pq1.peek();\\n            int min2 = pq2.peek();\\n\\n            if (min1 <= min2) {\\n                pq1.poll();\\n                ans += min1;\\n            } else {\\n                pq2.poll();\\n                ans += min2;\\n            }\\n            k--;\\n        }\\n\\n        return overlapped(ans, k);\\n    }\\n\\n    long overlapped(long ans, int k) {\\n\\n        while (k-- > 0) {\\n            int min1 = pq1.size() == 0 ? INF : pq1.peek();\\n            int min2 = pq2.size() == 0 ? INF : pq2.peek();\\n            if (min1 <= min2) {\\n                pq1.poll();\\n                ans += min1;\\n            } else {\\n                pq2.poll();\\n                ans += min2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684459,
                "title": "c-only-1-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int k, int c) {\\n        priority_queue<pair<int,int>>pq;\\n        map<int,int>m;\\n        for(int i=0;i<c;i++){\\n            m[i]++;\\n            pq.push({-cost[i],1});\\n        }\\n        int i=cost.size()-1;\\n        for(int j=0;j<c;j++){\\n            if(m[i]==0){\\n                m[i]++;\\n                pq.push({-cost[i],0});\\n                i--;\\n            }\\n            else break;\\n        }\\n        int l = c;\\n        int r = cost.size()-1-c;\\n        long long ans=0;\\n        for(int j=0;j<k;j++){\\n            ans += abs(pq.top().first);\\n            int h = pq.top().second;\\n            pq.pop();\\n            if(h){\\n                if(m[l]==0 && l<cost.size()){\\n                    m[l]++;\\n                    pq.push({-cost[l],1});\\n                    l++;\\n                }\\n            } \\n            else{\\n                 if(m[r]==0 && r>=0){\\n                    m[r]++;\\n                    pq.push({-cost[r],0});\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/bf01251f-d603-4e1f-8cf8-eefcfa6bab5f_1687772283.8754158.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int k, int c) {\\n        priority_queue<pair<int,int>>pq;\\n        map<int,int>m;\\n        for(int i=0;i<c;i++){\\n            m[i]++;\\n            pq.push({-cost[i],1});\\n        }\\n        int i=cost.size()-1;\\n        for(int j=0;j<c;j++){\\n            if(m[i]==0){\\n                m[i]++;\\n                pq.push({-cost[i],0});\\n                i--;\\n            }\\n            else break;\\n        }\\n        int l = c;\\n        int r = cost.size()-1-c;\\n        long long ans=0;\\n        for(int j=0;j<k;j++){\\n            ans += abs(pq.top().first);\\n            int h = pq.top().second;\\n            pq.pop();\\n            if(h){\\n                if(m[l]==0 && l<cost.size()){\\n                    m[l]++;\\n                    pq.push({-cost[l],1});\\n                    l++;\\n                }\\n            } \\n            else{\\n                 if(m[r]==0 && r>=0){\\n                    m[r]++;\\n                    pq.push({-cost[r],0});\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683494,
                "title": "easiest-c-code-see-comments-in-code-for-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& a, int k, int x) {\\n        unsigned long long int i,j,c=0,s=0;\\n        priority_queue<int,vector<int>,greater<int>>pq1,pq2;\\n        \\n        for(i=0;i<x;i++)  //first k elements in pq1\\n        pq1.push(a[i]);\\n\\n        if(2*x<=a.size()){    //if array elements are more than 2x then last x elements in pq2\\n        for(i=a.size()-1;i>=a.size()-x;i--)\\n        pq2.push(a[i]);\\n        j=i;\\n        i=x;        //initialize for pq1 and pq2\\n\\n        } else{             //else put last elements discluding first x elements\\n            for(;i<a.size();i++){\\n                pq2.push(a[i]);\\n            }\\n            i=2;  //so  that i<=j is always false\\n            j=1;\\n        }\\n\\n        while(k--){\\n            int m1=pq1.size()!=0 ? pq1.top():INT_MAX;\\n            int m2=pq2.size()!=0 ? pq2.top():INT_MAX;\\n            \\n            if(m1<=m2){\\n                c+=m1;\\n                pq1.pop();\\n                if(i<=j)\\n                pq1.push(a[i++]);\\n            } else{\\n                c+=m2;\\n                pq2.pop();\\n                if(i<=j)\\n                pq2.push(a[j--]);\\n            }\\n          \\n        }\\n        return c;\\n\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& a, int k, int x) {\\n        unsigned long long int i,j,c=0,s=0;\\n        priority_queue<int,vector<int>,greater<int>>pq1,pq2;\\n        \\n        for(i=0;i<x;i++)  //first k elements in pq1\\n        pq1.push(a[i]);\\n\\n        if(2*x<=a.size()){    //if array elements are more than 2x then last x elements in pq2\\n        for(i=a.size()-1;i>=a.size()-x;i--)\\n        pq2.push(a[i]);\\n        j=i;\\n        i=x;        //initialize for pq1 and pq2\\n\\n        } else{             //else put last elements discluding first x elements\\n            for(;i<a.size();i++){\\n                pq2.push(a[i]);\\n            }\\n            i=2;  //so  that i<=j is always false\\n            j=1;\\n        }\\n\\n        while(k--){\\n            int m1=pq1.size()!=0 ? pq1.top():INT_MAX;\\n            int m2=pq2.size()!=0 ? pq2.top():INT_MAX;\\n            \\n            if(m1<=m2){\\n                c+=m1;\\n                pq1.pop();\\n                if(i<=j)\\n                pq1.push(a[i++]);\\n            } else{\\n                c+=m2;\\n                pq2.pop();\\n                if(i<=j)\\n                pq2.push(a[j--]);\\n            }\\n          \\n        }\\n        return c;\\n\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783228,
                "title": "easy-approach-multiset-pair-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First , Last candidates checking with two multiset.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we need two multiset (named: left and right)\\n2. Insert left candidates to left multiset and right candidates two right one. Here left candidates means \\'candidates\\' amount element from the costs vector from the beginning. Also right candidates from the end of the costs vector.\\n3. Now just check which element is less than other, then add that element to SUM. And insert the next element to the respective multiset. \\n4. Do the \\'3no\\' approach until k becomes 0.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        multiset<pair<int, int>>left, right; /// two multiset for 2 candidates\\n        int l=0, r=costs.size()-1;\\n        \\n        for(int i=0; i<candidates; i++)\\n        {\\n            left.insert( {costs[l], l }); \\n            l++;\\n        }\\n        l--; /// As l indices not inserted to left multiset and we need the last indices inserted...\\n        bool ok=false;\\n        for(int i=0; i<candidates; i++)\\n        {\\n            if(l<r){  /// Don\\'t need to store an element into two multiset\\n              right.insert({costs[r], r }); \\n              r--; \\n              ok=true; /// That\\'s because we are checking if right multiset inserted or not\\n            } \\n        }\\n       if(ok) r++;\\n        long long sum=0;\\n        while(k)\\n        {\\n            if(left.empty()){ /// if only right multiset exists\\n                 auto pr = *right.begin();\\n                  sum+=pr.first;\\n                  k--;\\n                right.erase(right.begin());\\n                  \\n            }else if(right.empty())/// if only left multiset exists\\n            {\\n                auto pl = *left.begin();\\n                sum+=pl.first;\\n                k--;\\n                left.erase(left.begin());\\n            }\\n            \\n          else { \\n            auto pl = *left.begin();\\n            auto pr = *right.begin();\\n            \\n            \\n            \\n            if(pl.first <= pr.first ){ /// just checking less then or equal, because indices in left multiset is lower than right multiset , so when it is equal we just consider the left one\\n                sum+=pl.first; \\n                k--;\\n                l++;\\n                left.erase(left.begin());\\n                if(l<r) left.insert( {costs[l], l }) ;\\n            }else if(pr.first < pl.first) /// if min value of right multiset is less\\n            {\\n                sum+=pr.first; \\n                k--;\\n                r--;\\n                right.erase(right.begin());\\n                if(l<r) right.insert({costs[r] , r});\\n            }\\n           \\n       }\\n            \\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        multiset<pair<int, int>>left, right; /// two multiset for 2 candidates\\n        int l=0, r=costs.size()-1;\\n        \\n        for(int i=0; i<candidates; i++)\\n        {\\n            left.insert( {costs[l], l }); \\n            l++;\\n        }\\n        l--; /// As l indices not inserted to left multiset and we need the last indices inserted...\\n        bool ok=false;\\n        for(int i=0; i<candidates; i++)\\n        {\\n            if(l<r){  /// Don\\'t need to store an element into two multiset\\n              right.insert({costs[r], r }); \\n              r--; \\n              ok=true; /// That\\'s because we are checking if right multiset inserted or not\\n            } \\n        }\\n       if(ok) r++;\\n        long long sum=0;\\n        while(k)\\n        {\\n            if(left.empty()){ /// if only right multiset exists\\n                 auto pr = *right.begin();\\n                  sum+=pr.first;\\n                  k--;\\n                right.erase(right.begin());\\n                  \\n            }else if(right.empty())/// if only left multiset exists\\n            {\\n                auto pl = *left.begin();\\n                sum+=pl.first;\\n                k--;\\n                left.erase(left.begin());\\n            }\\n            \\n          else { \\n            auto pl = *left.begin();\\n            auto pr = *right.begin();\\n            \\n            \\n            \\n            if(pl.first <= pr.first ){ /// just checking less then or equal, because indices in left multiset is lower than right multiset , so when it is equal we just consider the left one\\n                sum+=pl.first; \\n                k--;\\n                l++;\\n                left.erase(left.begin());\\n                if(l<r) left.insert( {costs[l], l }) ;\\n            }else if(pr.first < pl.first) /// if min value of right multiset is less\\n            {\\n                sum+=pr.first; \\n                k--;\\n                r--;\\n                right.erase(right.begin());\\n                if(l<r) right.insert({costs[r] , r});\\n            }\\n           \\n       }\\n            \\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783151,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        priority_queue<long long, vector<long long>, greater<long long>> pql, pqr;\\n        int n = costs.size(), s = 0, e = n - 1, cnt = 0;\\n        while(s < can && cnt < n) pql.push(costs[s++]), cnt++;\\n        while(e >= n - can && cnt < n) pqr.push(costs[e--]), cnt++;\\n        \\n        long long ans = 0, t = 0;\\n        while(t < k) {\\n            long long a = INT_MAX, b = INT_MAX;\\n            if(pql.size()) a = pql.top();\\n            if(pqr.size()) b = pqr.top();\\n            if(a > b) {\\n                ans += b;\\n                pqr.pop();\\n                if(s <= e && cnt < n) pqr.push(costs[e--]), cnt++;\\n            }\\n            else {\\n                ans += a;\\n                pql.pop();\\n                if(s <= e && cnt < n) pql.push(costs[s++]), cnt++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        priority_queue<long long, vector<long long>, greater<long long>> pql, pqr;\\n        int n = costs.size(), s = 0, e = n - 1, cnt = 0;\\n        while(s < can && cnt < n) pql.push(costs[s++]), cnt++;\\n        while(e >= n - can && cnt < n) pqr.push(costs[e--]), cnt++;\\n        \\n        long long ans = 0, t = 0;\\n        while(t < k) {\\n            long long a = INT_MAX, b = INT_MAX;\\n            if(pql.size()) a = pql.top();\\n            if(pqr.size()) b = pqr.top();\\n            if(a > b) {\\n                ans += b;\\n                pqr.pop();\\n                if(s <= e && cnt < n) pqr.push(costs[e--]), cnt++;\\n            }\\n            else {\\n                ans += a;\\n                pql.pop();\\n                if(s <= e && cnt < n) pql.push(costs[s++]), cnt++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683084,
                "title": "java-priorityqueue-17-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((k + candidates) * log(candidates))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(candidates)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    var n = costs.length;\\n    var queue = new PriorityQueue<int[]>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n    if (2 * candidates >= n) {\\n      for (var i=0; i<n; i++)\\n        queue.offer(new int[] {costs[i], 0});\\n    } else {\\n      for (var i=0; i < candidates; i++) {\\n        queue.offer(new int[] {costs[i], 0});\\n        queue.offer(new int[] {costs[n-1-i], 1});\\n      }\\n    }\\n    int l = candidates, r = n - 1 - candidates;\\n    var cost = 0L;\\n\\n    for (var i=0; i<k; i++) {\\n      var a = queue.poll();\\n      cost += a[0];\\n\\n      if (l > r) continue;\\n\\n      queue.offer(new int[] {costs[a[1] == 0 ? l++ : r--], a[1]});\\n    }\\n    return cost;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    var n = costs.length;\\n    var queue = new PriorityQueue<int[]>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n    if (2 * candidates >= n) {\\n      for (var i=0; i<n; i++)\\n        queue.offer(new int[] {costs[i], 0});\\n    } else {\\n      for (var i=0; i < candidates; i++) {\\n        queue.offer(new int[] {costs[i], 0});\\n        queue.offer(new int[] {costs[n-1-i], 1});\\n      }\\n    }\\n    int l = candidates, r = n - 1 - candidates;\\n    var cost = 0L;\\n\\n    for (var i=0; i<k; i++) {\\n      var a = queue.poll();\\n      cost += a[0];\\n\\n      if (l > r) continue;\\n\\n      queue.offer(new int[] {costs[a[1] == 0 ? l++ : r--], a[1]});\\n    }\\n    return cost;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564644,
                "title": "golang-using-single-minheap",
                "content": "# Complexity\\n- Time complexity:\\nO(ClogC) + O(ClogC) + O(Klogc) -> O((C+K) logC)\\n\\n- Space complexity:\\nO(C) + O(C) -> O(C)\\n\\n# Code\\n```\\nfunc totalCost(costs []int, k int, candidates int) int64 {\\n    minHeap := &MinHeap{}\\n\\n    // Add first candidates to heap\\n    for i := 0; i < candidates; i++ {\\n        heap.Push(minHeap, []int{costs[i], 0})\\n    }\\n\\n    // Add last candidates to heap\\n    for i := max(candidates, len(costs) - candidates); i < len(costs); i++ {\\n        heap.Push(minHeap, []int{costs[i], 1})\\n    }\\n\\n    left, right := candidates, len(costs) - 1 - candidates\\n    res := 0\\n\\n    for i := 0; i < k; i++ {\\n        candidate := heap.Pop(minHeap).([]int)\\n        res += candidate[0]\\n        idx := candidate[1]\\n\\n        if left <= right {\\n            if idx == 0 {\\n                heap.Push(minHeap, []int{costs[left], 0})\\n                left++\\n            } else {\\n                heap.Push(minHeap, []int{costs[right], 1})\\n                right--\\n            }\\n        }\\n    }\\n\\n    return int64(res)\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int           { return len(h) }\\n\\nfunc (h MinHeap) Less(i, j int) bool { \\n    if h[i][0] == h[j][0] {\\n        return h[i][1] < h[j][1] \\n    }\\n    return h[i][0] < h[j][0] \\n}\\n\\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc totalCost(costs []int, k int, candidates int) int64 {\\n    minHeap := &MinHeap{}\\n\\n    // Add first candidates to heap\\n    for i := 0; i < candidates; i++ {\\n        heap.Push(minHeap, []int{costs[i], 0})\\n    }\\n\\n    // Add last candidates to heap\\n    for i := max(candidates, len(costs) - candidates); i < len(costs); i++ {\\n        heap.Push(minHeap, []int{costs[i], 1})\\n    }\\n\\n    left, right := candidates, len(costs) - 1 - candidates\\n    res := 0\\n\\n    for i := 0; i < k; i++ {\\n        candidate := heap.Pop(minHeap).([]int)\\n        res += candidate[0]\\n        idx := candidate[1]\\n\\n        if left <= right {\\n            if idx == 0 {\\n                heap.Push(minHeap, []int{costs[left], 0})\\n                left++\\n            } else {\\n                heap.Push(minHeap, []int{costs[right], 1})\\n                right--\\n            }\\n        }\\n    }\\n\\n    return int64(res)\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int           { return len(h) }\\n\\nfunc (h MinHeap) Less(i, j int) bool { \\n    if h[i][0] == h[j][0] {\\n        return h[i][1] < h[j][1] \\n    }\\n    return h[i][0] < h[j][0] \\n}\\n\\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2787373,
                "title": "using-priority-queues",
                "content": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int c) {\\n        long sum=0;int n=costs.length;\\n        Queue<Integer> q1=new PriorityQueue<>();\\n        Queue<Integer> q2=new PriorityQueue<>();\\n        int start=c;\\n        for(int i=0;i<c;i++){\\n            q1.add(costs[i]);\\n        }\\n        int end=Math.max(n-c,c)-1;\\n        for(int i=n-1;i>=end+1;i--){\\n            q2.add(costs[i]);\\n        }\\n        while(k-->0){\\n            if((q1.isEmpty()?(int)1e9:q1.peek())<=(q2.isEmpty()?(int)1e9:q2.peek())){\\n                sum+=q1.poll();\\n                if(start<=end){\\n                    q1.add(costs[start]);\\n                    \\n                    start++;\\n                }\\n            }\\n            else{\\n                sum+=q2.poll();\\n                if(start<=end){\\n                   \\n                    q2.add(costs[end]);\\n                    end--;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int c) {\\n        long sum=0;int n=costs.length;\\n        Queue<Integer> q1=new PriorityQueue<>();\\n        Queue<Integer> q2=new PriorityQueue<>();\\n        int start=c;\\n        for(int i=0;i<c;i++){\\n            q1.add(costs[i]);\\n        }\\n        int end=Math.max(n-c,c)-1;\\n        for(int i=n-1;i>=end+1;i--){\\n            q2.add(costs[i]);\\n        }\\n        while(k-->0){\\n            if((q1.isEmpty()?(int)1e9:q1.peek())<=(q2.isEmpty()?(int)1e9:q2.peek())){\\n                sum+=q1.poll();\\n                if(start<=end){\\n                    q1.add(costs[start]);\\n                    \\n                    start++;\\n                }\\n            }\\n            else{\\n                sum+=q2.poll();\\n                if(start<=end){\\n                   \\n                    q2.add(costs[end]);\\n                    end--;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783360,
                "title": "c-using-two-min-heaps-solved-the-mistake",
                "content": "##### Edit:- \\n<hr>\\nI was not able to solve it in the contest because I was not properly checking the elements that are being pushed into the \\npriority queues  in the first for loop \\n<hr>\\nAfter reading many posts I found the mistake. gonna keep the other failed codes cause they might help someone \\n\\n##### Post that helped me find the mistake The most : [this one](https://leetcode.com/problems/total-cost-to-hire-k-workers/discuss/2783256/Faster-than-80ororsimple-c%2B%2B-solution-oror-priority-queue(min-heap))\\n##### Solution :- \\n\\n```c++\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &nums, int k, int can)\\n    {\\n        long long ans = 0;\\n        if (nums.size() == 1)\\n            return nums[0];\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        int start = 0, end = nums.size() - 1;\\n        for (int i = 1; i <= can; i++)\\n        {\\n            if (i - 1 >= nums.size() - i)\\n                break;\\n            pq1.push(nums[i - 1]);\\n            start = i;\\n            pq2.push(nums[nums.size() - i]);\\n            end = nums.size() - i - 1;\\n        }\\n        bool flag = 1;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (start > end)\\n                flag = 0;\\n            int a = !pq1.empty() ? pq1.top() : INT_MAX;\\n            int b = !pq2.empty() ? pq2.top() : INT_MAX;\\n            if (a <= b)\\n            {\\n                ans += a;\\n                pq1.pop();\\n                if (flag)\\n                    pq1.push(nums[start++]);\\n            }\\n            else\\n            {\\n                ans += b;\\n                pq2.pop();\\n                if (flag)\\n                    pq2.push(nums[end--]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`Time complexity :- O(n logc)`\\n`Space complexity :- O(n)`\\n\\n<h5> Why O(nlogc) </h5> because heaps take time to arrange themselves into proper structure \\nThere are at most c elements in the heap so it takes log c time for all operations in the least\\n\\nThe first idea that i got is to use two min heaps so I put them \\n\\nThen i inserted the elements and made sure how and where I insert the middle remaining elements \\n<hr> \\n1st try :- \\n\\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int, vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere I thought maybe if c > n / 2 then I am inserting the duplicates \\n\\nSo I changed my Approach and came up with other \\n<hr>\\n2nd try:- \\n\\nCheck this one out better solution :- <b>[LINK](https://leetcode.com/problems/total-cost-to-hire-k-workers/discuss/2783360/C++-oror-using-two-min-heaps-oror-solved-the-mistake/1673035)</b>  \\n\\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int , vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            if(p1.size() + p2.size() == n)\\n                break;\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<hr>\\nThis didn\\'t work Then I came up with if else one thinking I might be doing some mistake\\n\\n\\n3rd try :- \\n\\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int , vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        if(2* c >= n){\\n            while(start < end){\\n                p1.push(nums[start++]);\\n                p2.push(nums[end--]);\\n            }\\n            if(n % 2 != 0) p1.push(nums[start++]);\\n        }\\n        else\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            if(p1.size() + p2.size() == n)\\n                break;\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<hr>\\n\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &nums, int k, int can)\\n    {\\n        long long ans = 0;\\n        if (nums.size() == 1)\\n            return nums[0];\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        int start = 0, end = nums.size() - 1;\\n        for (int i = 1; i <= can; i++)\\n        {\\n            if (i - 1 >= nums.size() - i)\\n                break;\\n            pq1.push(nums[i - 1]);\\n            start = i;\\n            pq2.push(nums[nums.size() - i]);\\n            end = nums.size() - i - 1;\\n        }\\n        bool flag = 1;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (start > end)\\n                flag = 0;\\n            int a = !pq1.empty() ? pq1.top() : INT_MAX;\\n            int b = !pq2.empty() ? pq2.top() : INT_MAX;\\n            if (a <= b)\\n            {\\n                ans += a;\\n                pq1.pop();\\n                if (flag)\\n                    pq1.push(nums[start++]);\\n            }\\n            else\\n            {\\n                ans += b;\\n                pq2.pop();\\n                if (flag)\\n                    pq2.push(nums[end--]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int, vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int , vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            if(p1.size() + p2.size() == n)\\n                break;\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& nums, int k, int c) {\\n       long long ans = 0;\\n        int n = nums.size();\\n        priority_queue<int , vector<int> , greater<int>> p1, p2;\\n        int start = 0, end = n - 1;\\n        if(2* c >= n){\\n            while(start < end){\\n                p1.push(nums[start++]);\\n                p2.push(nums[end--]);\\n            }\\n            if(n % 2 != 0) p1.push(nums[start++]);\\n        }\\n        else\\n        for(int i =0 ; i < c ; i++){\\n            p1.push(nums[i]);\\n            if(p1.size() + p2.size() == n)\\n                break;\\n            p2.push(nums[n - i - 1]);\\n            start++;\\n            end--;\\n        }\\n        for(int i = 0; i < k; i++){\\n            int a =p1.top() , b = p2.top();\\n            if(a > b){\\n                ans += b;\\n                p2.pop();\\n                if(start <= end){\\n                    p2.push(nums[end--]);\\n                }\\n            }else{\\n                ans += a;\\n                p1.pop();\\n                if(start <= end){\\n                    p1.push(nums[start++]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783355,
                "title": "min-heap",
                "content": "We add `candidates` workers from the left and right to the min heap, with their indexes.\\n\\nWe also track how many candidates we pushed from left (`i`) and right (`j`).\\n\\nThen, we pull the next workers with the minimum cost. Based on their index, we push another worker from left or right to the heap.\\n\\n# C++\\n```cpp\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n    long long i = 0, j = costs.size() - 1, res = 0;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for(; i <= j && candidates; --candidates) {\\n        pq.push({costs[i], i++});\\n        if (i < j)\\n            pq.push({costs[j], j--});\\n    }\\n    while (--k >= 0) {\\n        auto [sum, p] = pq.top(); pq.pop();\\n        res += sum;\\n        if (i <= j) {\\n            if (p < i)\\n                pq.push({costs[i], i++});\\n            else \\n                pq.push({costs[j], j--});\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n    long long i = 0, j = costs.size() - 1, res = 0;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for(; i <= j && candidates; --candidates) {\\n        pq.push({costs[i], i++});\\n        if (i < j)\\n            pq.push({costs[j], j--});\\n    }\\n    while (--k >= 0) {\\n        auto [sum, p] = pq.top(); pq.pop();\\n        res += sum;\\n        if (i <= j) {\\n            if (p < i)\\n                pq.push({costs[i], i++});\\n            else \\n                pq.push({costs[j], j--});\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783208,
                "title": "java-easy-solution-clean-and-short-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        if(costs.length==1){\\n            return costs[0];\\n        }\\n        System.out.println(costs.length);\\n        int min1=0;\\n        int min2=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<costs.length;i++){\\n            list.add(costs[i]);\\n        }\\n        long cost=0;\\n        int win1=0;\\n        int win2=0;\\n        PriorityQueue<Integer> pq1=new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2=new PriorityQueue<>();      \\n        if(candidates*2<=costs.length){  //if candidates are less than half of array then we are including elements of candiates size in both priority queue\\n            for(int i=0,j=costs.length-1;i<candidates;i++){\\n                pq1.add(costs[i]);\\n                pq2.add(costs[j]);\\n                win2=j;             //store idx where window2 ends\\n                j--;\\n                win1=i;              //stores idx where window1 ends\\n            }\\n        }\\n        else{\\n            for(int i=0,j=costs.length-1;i<costs.length/2;i++){   // if candidates are more than half of arraysize then we are including half half elements of array in both priority queue\\n                pq1.add(costs[i]);\\n                pq2.add(costs[j]);\\n                win2=j;\\n                j--;\\n                win1=i;\\n            }\\n        }\\n        \\n        for(int i=0;i<k;i++){  // now for k workers\\n         if(!pq1.isEmpty() && !pq2.isEmpty()){   \\n            min1=pq1.peek();\\n            min2=pq2.peek();\\n           \\n             if(min2<min1){  //if pq1 has min cost\\n                cost+=min2;\\n                pq2.remove();\\n                if(win1!=win2-1){ //window 1 needs to be updated since one candidate is included and remove next candidate will be added if condition is met\\n                    win2=win2-1;\\n                    pq2.add(costs[win2]);\\n                    \\n                }\\n                 \\n            }\\n            else{\\n                cost+=min1;\\n                pq1.remove();\\n                if(win1+1!=win2){ //window 2 needs to be updated since one candidate is included and remove next candidate will be added if condition is met\\n                    win1=win1+1;\\n                    pq1.add(costs[win1]);\\n                    \\n                }\\n            }\\n          \\n          }\\n          else if(!pq1.isEmpty()){ \\n                cost+=pq1.remove();\\n\\n          }\\n          else if(!pq2.isEmpty()){\\n                cost+=pq2.remove();\\n                \\n          }\\n          else{\\n                break;\\n          }\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        if(costs.length==1){\\n            return costs[0];\\n        }\\n        System.out.println(costs.length);\\n        int min1=0;\\n        int min2=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<costs.length;i++){\\n            list.add(costs[i]);\\n        }\\n        long cost=0;\\n        int win1=0;\\n        int win2=0;\\n        PriorityQueue<Integer> pq1=new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2=new PriorityQueue<>();      \\n        if(candidates*2<=costs.length){  //if candidates are less than half of array then we are including elements of candiates size in both priority queue\\n            for(int i=0,j=costs.length-1;i<candidates;i++){\\n                pq1.add(costs[i]);\\n                pq2.add(costs[j]);\\n                win2=j;             //store idx where window2 ends\\n                j--;\\n                win1=i;              //stores idx where window1 ends\\n            }\\n        }\\n        else{\\n            for(int i=0,j=costs.length-1;i<costs.length/2;i++){   // if candidates are more than half of arraysize then we are including half half elements of array in both priority queue\\n                pq1.add(costs[i]);\\n                pq2.add(costs[j]);\\n                win2=j;\\n                j--;\\n                win1=i;\\n            }\\n        }\\n        \\n        for(int i=0;i<k;i++){  // now for k workers\\n         if(!pq1.isEmpty() && !pq2.isEmpty()){   \\n            min1=pq1.peek();\\n            min2=pq2.peek();\\n           \\n             if(min2<min1){  //if pq1 has min cost\\n                cost+=min2;\\n                pq2.remove();\\n                if(win1!=win2-1){ //window 1 needs to be updated since one candidate is included and remove next candidate will be added if condition is met\\n                    win2=win2-1;\\n                    pq2.add(costs[win2]);\\n                    \\n                }\\n                 \\n            }\\n            else{\\n                cost+=min1;\\n                pq1.remove();\\n                if(win1+1!=win2){ //window 2 needs to be updated since one candidate is included and remove next candidate will be added if condition is met\\n                    win1=win1+1;\\n                    pq1.add(costs[win1]);\\n                    \\n                }\\n            }\\n          \\n          }\\n          else if(!pq1.isEmpty()){ \\n                cost+=pq1.remove();\\n\\n          }\\n          else if(!pq2.isEmpty()){\\n                cost+=pq2.remove();\\n                \\n          }\\n          else{\\n                break;\\n          }\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783139,
                "title": "python-min-heap-commented-o-nlg-candidates-time-o-candidates-space",
                "content": "We maintain a heap of candidates, and whenever we remove an element from the heap we\\'ve to replenish it from same side.  \\nRemaining elements (which are not yet candidates) will be a contiguous block in the middle so we just need to store left and right indices of remaining elements (instead of using a deque or something to store all the individual elements).  \\nHeap element is (cost, index) so that first it\\'s compared by cost then by index to break ties. Index changes due to removal does not matter as index is only used for comparison and the removal does not alter the relative ordering of other indices. The index is also useful for knowing whether the element was taken from left side candidates or right side candidates so that we can replenish from same side.   \\nLastly, in the case of fewer than candidate workers remaining, the heap is no longer replenished, but removing from the heap still takes the element with smallest cost so the problem constraint is automatically satisfied.\\n\\n### Complexity analysis\\nHeap size is at most `2*candidates` at any point of time.\\nTime complexity: `O(n lg(candidates))` -> k can be at most n and for each iteration, we\\'re doing heap pop/push which takes `O(lg(2*candidates)) = O(lg(candidates))` \\nSpace complexity: `O(candidates)` -> we\\'re only maintaining heap which is bounded by `2*candidates`\\n\\n```python\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        cand_heap = [] # Heap of candidates; hp elem (cost, inx)\\n        \\n        # remaining elems bounds\\n        left_bound, right_bound = candidates, n-candidates-1\\n        \\n        # add left candidates\\n        for i in range(candidates):\\n            heapq.heappush(cand_heap, (costs[i], i))\\n        \\n        # add right candidates, (exclude already taken from left)\\n        for i in reversed(range(n-candidates, n)):\\n            if i < left_bound:\\n                break\\n            heapq.heappush(cand_heap, (costs[i], i))\\n        \\n        total_cost = 0\\n        for _ in range(k):\\n            cost, inx = heapq.heappop(cand_heap)\\n            total_cost += cost\\n            if left_bound <= right_bound: # if there are remaining elements\\n                if inx < left_bound: # if cur elem was from left, replenish from left\\n                    heapq.heappush(cand_heap, (costs[left_bound], left_bound))\\n                    left_bound += 1\\n                elif inx > right_bound: # if cur elem was from right, replenish from right\\n                    heapq.heappush(cand_heap, (costs[right_bound], right_bound))\\n                    right_bound -= 1\\n        return total_cost                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        cand_heap = [] # Heap of candidates; hp elem (cost, inx)\\n        \\n        # remaining elems bounds\\n        left_bound, right_bound = candidates, n-candidates-1\\n        \\n        # add left candidates\\n        for i in range(candidates):\\n            heapq.heappush(cand_heap, (costs[i], i))\\n        \\n        # add right candidates, (exclude already taken from left)\\n        for i in reversed(range(n-candidates, n)):\\n            if i < left_bound:\\n                break\\n            heapq.heappush(cand_heap, (costs[i], i))\\n        \\n        total_cost = 0\\n        for _ in range(k):\\n            cost, inx = heapq.heappop(cand_heap)\\n            total_cost += cost\\n            if left_bound <= right_bound: # if there are remaining elements\\n                if inx < left_bound: # if cur elem was from left, replenish from left\\n                    heapq.heappush(cand_heap, (costs[left_bound], left_bound))\\n                    left_bound += 1\\n                elif inx > right_bound: # if cur elem was from right, replenish from right\\n                    heapq.heappush(cand_heap, (costs[right_bound], right_bound))\\n                    right_bound -= 1\\n        return total_cost                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686676,
                "title": "99-java-easy-solution",
                "content": "Time complexity: O(n logn)\\nSpace complexity: O(n)\\n\\n```\\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long sum = 0L;\\n\\n        if (candidates * 2 >= costs.length) {\\n            Arrays.sort(costs);\\n            for (int i = 0; i < k; i++) {\\n                sum += costs[i];\\n            }\\n            return sum;\\n        }\\n\\n        Queue<int[]> queue = new PriorityQueue<>((o1, o2) -> {\\n            int compare = Integer.compare(o1[0], o2[0]);\\n            if (compare == 0) {\\n                return Integer.compare(o1[1], o2[1]); // Break the tie by the smallest index.\\n            } else {\\n                return compare;\\n            }\\n        });\\n        \\n        int left = 0;\\n        int right = costs.length - 1;\\n        for (int i = 0; i < candidates; i++) {\\n            queue.offer(new int[]{costs[left++], -1}); // -1 = left side\\n            queue.offer(new int[]{costs[right--], 1}); // 1 = right side\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] poll = queue.poll();\\n            sum += poll[0];\\n            if (left <= right) {\\n                if (poll[1] == -1) {\\n                    queue.offer(new int[]{costs[left++], -1});\\n                } else {\\n                    queue.offer(new int[]{costs[right--], 1});\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0e55b66b-d6aa-4eb2-8d3b-7b56eaa95b77_1687812014.3176045.png)\\n\\n\\nupvote if you find my solution helpful",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long sum = 0L;\\n\\n        if (candidates * 2 >= costs.length) {\\n            Arrays.sort(costs);\\n            for (int i = 0; i < k; i++) {\\n                sum += costs[i];\\n            }\\n            return sum;\\n        }\\n\\n        Queue<int[]> queue = new PriorityQueue<>((o1, o2) -> {\\n            int compare = Integer.compare(o1[0], o2[0]);\\n            if (compare == 0) {\\n                return Integer.compare(o1[1], o2[1]); // Break the tie by the smallest index.\\n            } else {\\n                return compare;\\n            }\\n        });\\n        \\n        int left = 0;\\n        int right = costs.length - 1;\\n        for (int i = 0; i < candidates; i++) {\\n            queue.offer(new int[]{costs[left++], -1}); // -1 = left side\\n            queue.offer(new int[]{costs[right--], 1}); // 1 = right side\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] poll = queue.poll();\\n            sum += poll[0];\\n            if (left <= right) {\\n                if (poll[1] == -1) {\\n                    queue.offer(new int[]{costs[left++], -1});\\n                } else {\\n                    queue.offer(new int[]{costs[right--], 1});\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685802,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// TC - O((Candidates + k)Log(Candidates+k))\\n// SC - O(Candidates)\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        long long ans=0;\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n\\n        int cnt = 0;\\n        int i=0;\\n        int j=costs.size()-1;\\n\\n        while(cnt<k){\\n\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int cost1 = pq1.size()>0?pq1.top():INT_MAX;\\n            int cost2 = pq2.size()>0?pq2.top():INT_MAX;\\n\\n            if(cost1<=cost2){\\n\\n               ans += cost1;\\n               pq1.pop();\\n            }\\n            else{\\n\\n              ans += cost2;\\n              pq2.pop();\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// TC - O((Candidates + k)Log(Candidates+k))\\n// SC - O(Candidates)\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        long long ans=0;\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n\\n        int cnt = 0;\\n        int i=0;\\n        int j=costs.size()-1;\\n\\n        while(cnt<k){\\n\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int cost1 = pq1.size()>0?pq1.top():INT_MAX;\\n            int cost2 = pq2.size()>0?pq2.top():INT_MAX;\\n\\n            if(cost1<=cost2){\\n\\n               ans += cost1;\\n               pq1.pop();\\n            }\\n            else{\\n\\n              ans += cost2;\\n              pq2.pop();\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685785,
                "title": "java-python-c",
                "content": "# Code :\\n---\\n```java []\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n       PriorityQueue<Integer> leftPq = new PriorityQueue<>();\\n       PriorityQueue<Integer> rightPq = new PriorityQueue<>();\\n       long totalCost = 0;\\n       int iter = 0;\\n       int left = 0;\\n       int right = costs.length-1;\\n       while(iter<k)\\n       {\\n           while(leftPq.size() < candidates && left<=right)\\n           {\\n               leftPq.offer(costs[left]);\\n               left++;\\n           }\\n           while(rightPq.size() < candidates && right>=left)\\n           {\\n               rightPq.offer(costs[right]);\\n               right--;\\n           }\\n           int ele1 = (leftPq.size() > 0)?leftPq.peek():Integer.MAX_VALUE;\\n           int ele2 = (rightPq.size() > 0)?rightPq.peek():Integer.MAX_VALUE;\\n           if(ele1 <= ele2)\\n           {\\n               totalCost += ele1;\\n               leftPq.poll();\\n           }\\n           else\\n           {\\n               totalCost += ele2;\\n               rightPq.remove();\\n           }\\n           iter++; \\n       }\\n       return totalCost;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        leftPq = []\\n        rightPq = []\\n        totalCost = 0\\n        iter = 0\\n        left = 0\\n        right = len(costs)-1\\n        while(iter<k):\\n            while(len(leftPq) < candidates and left<=right):\\n                heapq.heappush(leftPq, costs[left])\\n                left+=1\\n            while(len(rightPq) < candidates and right>=left):\\n                heapq.heappush(rightPq, -costs[right])\\n                right-=1\\n            ele1 = leftPq[0] if len(leftPq) > 0 else float(\\'inf\\')\\n            ele2 = -rightPq[0] if len(rightPq) > 0 else float(\\'inf\\')\\n            if(ele1 <= ele2):\\n                totalCost += ele1\\n                heapq.heappop(leftPq)\\n            else:\\n                totalCost += ele2\\n                heapq.heappop(rightPq)\\n            iter+=1 \\n        return totalCost\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long totalCost(std::vector<int>& costs, int k, int candidates) {\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> leftPq;\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> rightPq;\\n        long totalCost = 0;\\n        int iter = 0;\\n        int left = 0;\\n        int right = costs.size()-1;\\n        while(iter<k)\\n        {\\n            while(leftPq.size() < candidates && left<=right)\\n            {\\n                leftPq.push(costs[left]);\\n                left++;\\n            }\\n            while(rightPq.size() < candidates && right>=left)\\n            {\\n                rightPq.push(costs[right]);\\n                right--;\\n            }\\n            int ele1 = (leftPq.size() > 0)?leftPq.top():INT_MAX;\\n            int ele2 = (rightPq.size() > 0)?rightPq.top():INT_MAX;\\n            if(ele1 <= ele2)\\n            {\\n                totalCost += ele1;\\n                leftPq.pop();\\n            }\\n            else\\n            {\\n                totalCost += ele2;\\n                rightPq.pop();\\n            }\\n            iter++; \\n        }\\n        return totalCost;\\n    }\\n};\\n```\\n---\\n#### *Please don\\'t forget to upvote .* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n       PriorityQueue<Integer> leftPq = new PriorityQueue<>();\\n       PriorityQueue<Integer> rightPq = new PriorityQueue<>();\\n       long totalCost = 0;\\n       int iter = 0;\\n       int left = 0;\\n       int right = costs.length-1;\\n       while(iter<k)\\n       {\\n           while(leftPq.size() < candidates && left<=right)\\n           {\\n               leftPq.offer(costs[left]);\\n               left++;\\n           }\\n           while(rightPq.size() < candidates && right>=left)\\n           {\\n               rightPq.offer(costs[right]);\\n               right--;\\n           }\\n           int ele1 = (leftPq.size() > 0)?leftPq.peek():Integer.MAX_VALUE;\\n           int ele2 = (rightPq.size() > 0)?rightPq.peek():Integer.MAX_VALUE;\\n           if(ele1 <= ele2)\\n           {\\n               totalCost += ele1;\\n               leftPq.poll();\\n           }\\n           else\\n           {\\n               totalCost += ele2;\\n               rightPq.remove();\\n           }\\n           iter++; \\n       }\\n       return totalCost;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        leftPq = []\\n        rightPq = []\\n        totalCost = 0\\n        iter = 0\\n        left = 0\\n        right = len(costs)-1\\n        while(iter<k):\\n            while(len(leftPq) < candidates and left<=right):\\n                heapq.heappush(leftPq, costs[left])\\n                left+=1\\n            while(len(rightPq) < candidates and right>=left):\\n                heapq.heappush(rightPq, -costs[right])\\n                right-=1\\n            ele1 = leftPq[0] if len(leftPq) > 0 else float(\\'inf\\')\\n            ele2 = -rightPq[0] if len(rightPq) > 0 else float(\\'inf\\')\\n            if(ele1 <= ele2):\\n                totalCost += ele1\\n                heapq.heappop(leftPq)\\n            else:\\n                totalCost += ele2\\n                heapq.heappop(rightPq)\\n            iter+=1 \\n        return totalCost\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long totalCost(std::vector<int>& costs, int k, int candidates) {\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> leftPq;\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> rightPq;\\n        long totalCost = 0;\\n        int iter = 0;\\n        int left = 0;\\n        int right = costs.size()-1;\\n        while(iter<k)\\n        {\\n            while(leftPq.size() < candidates && left<=right)\\n            {\\n                leftPq.push(costs[left]);\\n                left++;\\n            }\\n            while(rightPq.size() < candidates && right>=left)\\n            {\\n                rightPq.push(costs[right]);\\n                right--;\\n            }\\n            int ele1 = (leftPq.size() > 0)?leftPq.top():INT_MAX;\\n            int ele2 = (rightPq.size() > 0)?rightPq.top():INT_MAX;\\n            if(ele1 <= ele2)\\n            {\\n                totalCost += ele1;\\n                leftPq.pop();\\n            }\\n            else\\n            {\\n                totalCost += ele2;\\n                rightPq.pop();\\n            }\\n            iter++; \\n        }\\n        return totalCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682973,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        q=costs[:candidates]\\n        r=costs[max(candidates,len(costs)-candidates):]\\n        heapify(q)\\n        heapify(r)\\n        res=0\\n        i=candidates\\n        j=len(costs)-candidates-1\\n        for _  in range(k):\\n            if not r or q and q[0]<=r[0]:\\n                res+=heappop(q)\\n                if i<=j:\\n                    heappush(q,costs[i])\\n                    i+=1\\n\\n            else:\\n                res+=heappop(r)\\n                if i<=j:\\n                    heappush(r,costs[j])\\n                    j-=1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        q=costs[:candidates]\\n        r=costs[max(candidates,len(costs)-candidates):]\\n        heapify(q)\\n        heapify(r)\\n        res=0\\n        i=candidates\\n        j=len(costs)-candidates-1\\n        for _  in range(k):\\n            if not r or q and q[0]<=r[0]:\\n                res+=heappop(q)\\n                if i<=j:\\n                    heappush(q,costs[i])\\n                    i+=1\\n\\n            else:\\n                res+=heappop(r)\\n                if i<=j:\\n                    heappush(r,costs[j])\\n                    j-=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555164,
                "title": "c-using-heap-easy-to-understnad",
                "content": "make min heap for prefix ad suffux pq1 & pq2\\nif(pq1.top < pq2.top)\\n    add in ans pq1.top\\n    in pq1. add one element from prefix \\nelse if(pq1.top() > pq1.top)\\n    add in ans pq2.top\\n    in pq2. add one element from suffix\\nelse \\n    given choose min index size\\nmake constarints for heap is empty of not\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &costs, int k, int m)\\n    {\\n        long long ans = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        int n = costs.size();\\n        int i = 0, j = n - 1;\\n        while (i < n && i < m)//make prefix queue to get minimum element from prefix\\n        {\\n            pq1.push(costs[i++]);\\n        }\\n        while (j >= i && j >= n - m)//make suffix queue to get minimum element from suffix\\n        {\\n            pq2.push(costs[j--]);\\n        }\\n        // cout << pq1.size() << \" \" << pq2.size() << endl;\\n        // cout<<\"#\\\\n\";\\n        while (k--)//repeat k time\\n        {\\n            if (!pq1.empty() && !pq2.empty())//both queue are not empty\\n            {\\n                if (pq1.top() < pq2.top())//pq1 have minimum cost so hire this employee add new emplyee\\'s cost into prefix min heap\\n                {\\n                    ans += pq1.top();\\n                    // cout << pq1.top() << \" \";\\n                    pq1.pop();\\n                    if (i <= j)\\n                    {\\n                        pq1.push(costs[i++]);\\n                    }\\n                }\\n                else if (pq1.top() > pq2.top())//pq2 have minimum cost so hire this employee add new emplyee\\'s cost into suffix min heap\\n                {\\n                    ans += pq2.top();\\n                    // cout << pq2.top() << \" \";\\n                    pq2.pop();\\n                    if (i <= j)\\n                    {\\n                        pq2.push(costs[j--]);\\n                    }\\n                }\\n                else//if pq1 and pq2 both have hiring cost same fo hire from pq1(given in question)\\n                {\\n                    ans += pq1.top();\\n                    // cout << pq1.top() << \" \";\\n                    pq1.pop();\\n                    if (i <= j)\\n                    {\\n                        pq1.push(costs[i++]);\\n                    }\\n                }\\n            }\\n            else if (pq1.empty())//if we hired all employee from prefix than queue than hring is possible from pq2\\n            {\\n                ans += pq2.top();\\n                // cout << pq2.top() << \" \";\\n                pq2.pop();\\n                if (i <= j)\\n                {\\n                    pq2.push(costs[j--]);\\n                }\\n            }\\n            else//if we hired all employee from suffix than queue than hring is possible from pq1\\n            {\\n                ans += pq1.top();\\n                // cout << pq1.top() << \" \";\\n                pq1.pop();\\n                if (i <= j)\\n                {\\n                    pq1.push(costs[i++]);\\n                }\\n            }\\n        }\\n        // cout<<\"#\\\\n\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &costs, int k, int m)\\n    {\\n        long long ans = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        int n = costs.size();\\n        int i = 0, j = n - 1;\\n        while (i < n && i < m)//make prefix queue to get minimum element from prefix\\n        {\\n            pq1.push(costs[i++]);\\n        }\\n        while (j >= i && j >= n - m)//make suffix queue to get minimum element from suffix\\n        {\\n            pq2.push(costs[j--]);\\n        }\\n        // cout << pq1.size() << \" \" << pq2.size() << endl;\\n        // cout<<\"#\\\\n\";\\n        while (k--)//repeat k time\\n        {\\n            if (!pq1.empty() && !pq2.empty())//both queue are not empty\\n            {\\n                if (pq1.top() < pq2.top())//pq1 have minimum cost so hire this employee add new emplyee\\'s cost into prefix min heap\\n                {\\n                    ans += pq1.top();\\n                    // cout << pq1.top() << \" \";\\n                    pq1.pop();\\n                    if (i <= j)\\n                    {\\n                        pq1.push(costs[i++]);\\n                    }\\n                }\\n                else if (pq1.top() > pq2.top())//pq2 have minimum cost so hire this employee add new emplyee\\'s cost into suffix min heap\\n                {\\n                    ans += pq2.top();\\n                    // cout << pq2.top() << \" \";\\n                    pq2.pop();\\n                    if (i <= j)\\n                    {\\n                        pq2.push(costs[j--]);\\n                    }\\n                }\\n                else//if pq1 and pq2 both have hiring cost same fo hire from pq1(given in question)\\n                {\\n                    ans += pq1.top();\\n                    // cout << pq1.top() << \" \";\\n                    pq1.pop();\\n                    if (i <= j)\\n                    {\\n                        pq1.push(costs[i++]);\\n                    }\\n                }\\n            }\\n            else if (pq1.empty())//if we hired all employee from prefix than queue than hring is possible from pq2\\n            {\\n                ans += pq2.top();\\n                // cout << pq2.top() << \" \";\\n                pq2.pop();\\n                if (i <= j)\\n                {\\n                    pq2.push(costs[j--]);\\n                }\\n            }\\n            else//if we hired all employee from suffix than queue than hring is possible from pq1\\n            {\\n                ans += pq1.top();\\n                // cout << pq1.top() << \" \";\\n                pq1.pop();\\n                if (i <= j)\\n                {\\n                    pq1.push(costs[i++]);\\n                }\\n            }\\n        }\\n        // cout<<\"#\\\\n\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2787046,
                "title": "java-easy-to-understand-with-explanation-o-nlogn",
                "content": "Intution:\\n1. whenever, a  problem is asking about min/max in subarray or min/max in first/last k, u can consider using PriorityQueue.\\n2. In this problem, we have select minimum form first and last candidates.\\n\\nApproach:\\n1. we will declare 2 priorityQueue , first will have candiadates values from first and second will have candidates values from last.\\n2. we will run loop \"k\" times, every time we will compare peek of both , lesser will be added to the answer.\\n3. If any priorityQueue becomes empty, we will have next left candiates from non-empty priorityQueue.\\n\\n\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int n=costs.length;\\n        Queue<Integer>pq1=new PriorityQueue<>();\\n        Queue<Integer>pq2=new PriorityQueue<>();\\n        int i=0;\\n\\t\\t// adding candidates for 1st pq\\n        while(i<candidates && i<n){\\n            pq1.add(costs[i]);\\n            i++;\\n        }\\n        int j=n-1;\\n\\t\\t// adding candidates from last to 2nd pq\\n        while(j>=i && n-j<=candidates){\\n            pq2.add(costs[j]);\\n            j--;\\n        }\\n        long ans=0;\\n        while(k>0){\\n\\t\\t// checking if both are non-empty\\n           if(!pq1.isEmpty() && !pq2.isEmpty()){\\n\\t\\t   // checek for minimum\\n               if(pq1.peek()<=pq2.peek()){\\n                   ans+=pq1.peek();\\n                   pq1.poll();\\n                   if(i<=j){\\n\\t\\t\\t\\t   // adding new element after popping\\n                       pq1.add(costs[i]);\\n                       i++;\\n                   }\\n               }else{\\n                   ans+=pq2.peek();\\n                   pq2.poll();\\n                   if(j>=i){\\n\\t\\t\\t\\t   // adding new element after popping\\n                       pq2.add(costs[j]);\\n                       j--;\\n                   }\\n               }\\n           }else if(!pq1.isEmpty() && pq2.isEmpty()){\\n\\t\\t   // if second becomes empty\\n               ans+=pq1.peek();\\n               pq1.poll();\\n               if(i<=j){\\n                   pq1.add(costs[i]);\\n                   i++;\\n               }\\n           }else if(pq1.isEmpty() && !pq2.isEmpty()){\\n\\t\\t   // if first becomes empty\\n               ans+=pq2.peek();\\n               pq2.poll();\\n               if(j>=i){\\n                   pq2.add(costs[j]);\\n                   j--;\\n               }\\n           }\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int n=costs.length;\\n        Queue<Integer>pq1=new PriorityQueue<>();\\n        Queue<Integer>pq2=new PriorityQueue<>();\\n        int i=0;\\n\\t\\t// adding candidates for 1st pq\\n        while(i<candidates && i<n){\\n            pq1.add(costs[i]);\\n            i++;\\n        }\\n        int j=n-1;\\n\\t\\t// adding candidates from last to 2nd pq\\n        while(j>=i && n-j<=candidates){\\n            pq2.add(costs[j]);\\n            j--;\\n        }\\n        long ans=0;\\n        while(k>0){\\n\\t\\t// checking if both are non-empty\\n           if(!pq1.isEmpty() && !pq2.isEmpty()){\\n\\t\\t   // checek for minimum\\n               if(pq1.peek()<=pq2.peek()){\\n                   ans+=pq1.peek();\\n                   pq1.poll();\\n                   if(i<=j){\\n\\t\\t\\t\\t   // adding new element after popping\\n                       pq1.add(costs[i]);\\n                       i++;\\n                   }\\n               }else{\\n                   ans+=pq2.peek();\\n                   pq2.poll();\\n                   if(j>=i){\\n\\t\\t\\t\\t   // adding new element after popping\\n                       pq2.add(costs[j]);\\n                       j--;\\n                   }\\n               }\\n           }else if(!pq1.isEmpty() && pq2.isEmpty()){\\n\\t\\t   // if second becomes empty\\n               ans+=pq1.peek();\\n               pq1.poll();\\n               if(i<=j){\\n                   pq1.add(costs[i]);\\n                   i++;\\n               }\\n           }else if(pq1.isEmpty() && !pq2.isEmpty()){\\n\\t\\t   // if first becomes empty\\n               ans+=pq2.peek();\\n               pq2.poll();\\n               if(j>=i){\\n                   pq2.add(costs[j]);\\n                   j--;\\n               }\\n           }\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783303,
                "title": "java-two-priorityqueue-min-heap-o-nlogn-with-time-complexity-analysis",
                "content": "**Time complexty analysis**\\nn = length of costs\\nHeap insertion: O(log n)\\nFind min in heap: O(1)\\nAt most n insertions to the heap, so the overall time complexity is O(nlogn).\\n\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long totalCost = 0L;\\n        int round = 0;\\n        \\n        int l = 0;\\n        int r = costs.length - 1;\\n        \\n        PriorityQueue<Integer> left = new PriorityQueue<>();\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        for (l = 0; l < candidates; l++) left.add(costs[l]);\\n        for (r = costs.length - 1; r >= costs.length - candidates && r >= l; r--) right.add(costs[r]);\\n        while (l <= r && round < k) {\\n            if (left.peek() <= right.peek()) {\\n                totalCost += left.poll();\\n                left.add(costs[l]);\\n                l++;\\n            } else {\\n                totalCost += right.poll();\\n                right.add(costs[r]);\\n                r--;\\n            }\\n            round++;\\n        }\\n        while (round < k) {\\n            if (left.size() == 0) totalCost += right.poll();\\n            else if (right.size() == 0) totalCost += left.poll();\\n            else if (left.peek() <= right.peek()) totalCost += left.poll();\\n            else totalCost += right.poll();\\n            round++;\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long totalCost = 0L;\\n        int round = 0;\\n        \\n        int l = 0;\\n        int r = costs.length - 1;\\n        \\n        PriorityQueue<Integer> left = new PriorityQueue<>();\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        for (l = 0; l < candidates; l++) left.add(costs[l]);\\n        for (r = costs.length - 1; r >= costs.length - candidates && r >= l; r--) right.add(costs[r]);\\n        while (l <= r && round < k) {\\n            if (left.peek() <= right.peek()) {\\n                totalCost += left.poll();\\n                left.add(costs[l]);\\n                l++;\\n            } else {\\n                totalCost += right.poll();\\n                right.add(costs[r]);\\n                r--;\\n            }\\n            round++;\\n        }\\n        while (round < k) {\\n            if (left.size() == 0) totalCost += right.poll();\\n            else if (right.size() == 0) totalCost += left.poll();\\n            else if (left.peek() <= right.peek()) totalCost += left.poll();\\n            else totalCost += right.poll();\\n            round++;\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783211,
                "title": "easy-c-solution-one-heap-only",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n         int l = candidates , r = ((int)costs.size() - 1) - candidates;\\n         for(int i=0; i<candidates; i++) pq.push({costs[i],0});\\n         for(int i=costs.size()-1; i>=max(candidates,r+1); i--) pq.push({costs[i],1});\\n         long long ans = 0;\\n         while(k>0) {\\n              ans+=pq.top().first;\\n              k--;\\n              if(l>r) {\\n                  pq.pop();   \\n                  continue;\\n              }\\n              if(pq.top().second) {\\n                  pq.pop();\\n                  pq.push({costs[r],1});      // if smallest element belongs to end part , take the previous r and & remove the current element\\n                  r--;\\n              }else {\\n                  pq.pop();\\n                  pq.push({costs[l],0});     // if smallest element belongs to start part , take the next l and & remove the current element\\n                  l++;\\n              }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n         int l = candidates , r = ((int)costs.size() - 1) - candidates;\\n         for(int i=0; i<candidates; i++) pq.push({costs[i],0});\\n         for(int i=costs.size()-1; i>=max(candidates,r+1); i--) pq.push({costs[i],1});\\n         long long ans = 0;\\n         while(k>0) {\\n              ans+=pq.top().first;\\n              k--;\\n              if(l>r) {\\n                  pq.pop();   \\n                  continue;\\n              }\\n              if(pq.top().second) {\\n                  pq.pop();\\n                  pq.push({costs[r],1});      // if smallest element belongs to end part , take the previous r and & remove the current element\\n                  r--;\\n              }else {\\n                  pq.pop();\\n                  pq.push({costs[l],0});     // if smallest element belongs to start part , take the next l and & remove the current element\\n                  l++;\\n              }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783092,
                "title": "java-simulation-with-heap-and-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimulate the process and sort the candidates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two pointer and two heap to simulate the process.\\n\\n# Complexity\\n- Time complexity: $$O(k*log(candidates))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(candidates)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  // cost, index\\n  static final Comparator<int[]> comparator =\\n      (a, b) -> {\\n        int diff = Integer.compare(a[0], b[0]);\\n        if (diff == 0) {\\n          return Integer.compare(a[1], b[1]);\\n        }\\n        return diff;\\n      };\\n\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    final int n = costs.length;\\n\\n    long result = 0;\\n    int start = 0;\\n    int end = n - 1;\\n\\n    Queue<int[]> front = new PriorityQueue<>(comparator);\\n    Queue<int[]> tail = new PriorityQueue<>(comparator);\\n    for (int i = 0; i < k; i++) {\\n      while (front.size() < candidates && start <= end) {\\n        front.offer(new int[] {costs[start], start});\\n        start++;\\n      }\\n\\n      while (tail.size() < candidates && start <= end) {\\n        tail.offer(new int[] {costs[end], end});\\n        end--;\\n      }\\n\\n      if (front.isEmpty()) {\\n        result += tail.poll()[0];\\n        continue;\\n      }\\n\\n      if (tail.isEmpty()) {\\n        result += front.poll()[0];\\n        continue;\\n      }\\n\\n      if (front.peek()[0] > tail.peek()[0]) {\\n        result += tail.poll()[0];\\n      } else {\\n        result += front.poll()[0];\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  // cost, index\\n  static final Comparator<int[]> comparator =\\n      (a, b) -> {\\n        int diff = Integer.compare(a[0], b[0]);\\n        if (diff == 0) {\\n          return Integer.compare(a[1], b[1]);\\n        }\\n        return diff;\\n      };\\n\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    final int n = costs.length;\\n\\n    long result = 0;\\n    int start = 0;\\n    int end = n - 1;\\n\\n    Queue<int[]> front = new PriorityQueue<>(comparator);\\n    Queue<int[]> tail = new PriorityQueue<>(comparator);\\n    for (int i = 0; i < k; i++) {\\n      while (front.size() < candidates && start <= end) {\\n        front.offer(new int[] {costs[start], start});\\n        start++;\\n      }\\n\\n      while (tail.size() < candidates && start <= end) {\\n        tail.offer(new int[] {costs[end], end});\\n        end--;\\n      }\\n\\n      if (front.isEmpty()) {\\n        result += tail.poll()[0];\\n        continue;\\n      }\\n\\n      if (tail.isEmpty()) {\\n        result += front.poll()[0];\\n        continue;\\n      }\\n\\n      if (front.peek()[0] > tail.peek()[0]) {\\n        result += tail.poll()[0];\\n      } else {\\n        result += front.poll()[0];\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783063,
                "title": "python-heap-solution",
                "content": "# Intuition\\nWhen you are required to iteratively find the \"lowest\" or \"highest\" element in an array you should consider using a heap\\n\\n# Approach\\nWe need to create our intial hiring pool of candidates that we are considering, so we use two pointers since we can select n candidates from the left side of the costs array and n candidate from the right side of the array. After the heap is populated, we pop from it k times and add any new candidates into the heap that previously were not considered.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        output = 0\\n        heap = []\\n        \\n        l, r = 0, len(costs) - 1\\n        j = candidates\\n        while l <= r and j:\\n            heapq.heappush(heap, (costs[l], l))\\n            # If l and r point to the same cell in costs don\\'t push it twice\\n            if l != r:\\n                heapq.heappush(heap, (costs[r], r))\\n            l += 1\\n            r -= 1\\n            j -= 1\\n\\n        while k:\\n            val, idx = heapq.heappop(heap)\\n            output += val\\n            if l <= r:\\n                # After every hire a new spot in the hiring pool opens we need to fill\\n                # We must figure out if the last candidate that was popped was from the left side\\n                # or the right side\\n                if abs(idx - l) <= abs(idx - r):\\n                    heapq.heappush(heap, (costs[l], l))\\n                    l += 1\\n                else:\\n                    heapq.heappush(heap, (costs[r], r))\\n                    r -= 1\\n        \\n            k -= 1\\n            \\n        \\n        return output           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        output = 0\\n        heap = []\\n        \\n        l, r = 0, len(costs) - 1\\n        j = candidates\\n        while l <= r and j:\\n            heapq.heappush(heap, (costs[l], l))\\n            # If l and r point to the same cell in costs don\\'t push it twice\\n            if l != r:\\n                heapq.heappush(heap, (costs[r], r))\\n            l += 1\\n            r -= 1\\n            j -= 1\\n\\n        while k:\\n            val, idx = heapq.heappop(heap)\\n            output += val\\n            if l <= r:\\n                # After every hire a new spot in the hiring pool opens we need to fill\\n                # We must figure out if the last candidate that was popped was from the left side\\n                # or the right side\\n                if abs(idx - l) <= abs(idx - r):\\n                    heapq.heappush(heap, (costs[l], l))\\n                    l += 1\\n                else:\\n                    heapq.heappush(heap, (costs[r], r))\\n                    r -= 1\\n        \\n            k -= 1\\n            \\n        \\n        return output           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686513,
                "title": "concise-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        long long ans = 0;\\n        int n = costs.size(), i = 0, j = n-1, c1, c2;\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        while(k--) {\\n            while(pq1.size() < c && i <= j) pq1.push(costs[i++]);\\n            while(pq2.size() < c && i <= j) pq2.push(costs[j--]);\\n                \\n            c1 = pq1.empty() ? INT_MAX : pq1.top();\\n            c2 = pq2.empty() ? INT_MAX : pq2.top();\\n            ans += c1 <= c2 ? c1 : c2;\\n            c1 <= c2 ? pq1.pop() : pq2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        long long ans = 0;\\n        int n = costs.size(), i = 0, j = n-1, c1, c2;\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        while(k--) {\\n            while(pq1.size() < c && i <= j) pq1.push(costs[i++]);\\n            while(pq2.size() < c && i <= j) pq2.push(costs[j--]);\\n                \\n            c1 = pq1.empty() ? INT_MAX : pq1.top();\\n            c2 = pq2.empty() ? INT_MAX : pq2.top();\\n            ans += c1 <= c2 ? c1 : c2;\\n            c1 <= c2 ? pq1.pop() : pq2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685253,
                "title": "easy-c-peiority-queue-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n = costs.size();\\n        priority_queue<int, vector<int>, greater<int>> left,right;\\n        int low=0,high=n-1;\\n        long long ans=0;\\n        while(k--)\\n        {\\n            while(left.size()<c && low<=high)\\n            {\\n                left.push(costs[low]);\\n                low++;\\n            }\\n            while(right.size()<c && low<=high)\\n            {\\n                right.push(costs[high]);\\n                high--;\\n            }\\n            int min1=INT_MAX,min2=INT_MAX;\\n            if(left.size())\\n            min1 = left.top();\\n            if(right.size())\\n            min2=right.top();\\n            if(min1<=min2)\\n            {\\n                ans+=min1;\\n                left.pop();\\n            }\\n            else\\n            {\\n                ans+=min2;\\n                right.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n = costs.size();\\n        priority_queue<int, vector<int>, greater<int>> left,right;\\n        int low=0,high=n-1;\\n        long long ans=0;\\n        while(k--)\\n        {\\n            while(left.size()<c && low<=high)\\n            {\\n                left.push(costs[low]);\\n                low++;\\n            }\\n            while(right.size()<c && low<=high)\\n            {\\n                right.push(costs[high]);\\n                high--;\\n            }\\n            int min1=INT_MAX,min2=INT_MAX;\\n            if(left.size())\\n            min1 = left.top();\\n            if(right.size())\\n            min2=right.top();\\n            if(min1<=min2)\\n            {\\n                ans+=min1;\\n                left.pop();\\n            }\\n            else\\n            {\\n                ans+=min2;\\n                right.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684279,
                "title": "c-basic-2-pointer-min-heap-approach",
                "content": "# Complexity\\n- Time complexity: O(n(logn)): To store n candidates in min-heap and internal sorting for each candidate.\\n\\n- Space complexity: O(n) for auxillary min-heap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue <vector<int>, vector<vector<int>>, greater<vector<int>>>pq; \\n        //Min heap, also sorts on basis of index as element stored in form {cost,index,whether picked from first \\'candidates\\' candidates or last \\'candidates\\' candidates}\\n        int n=costs.size();\\n        int s=0,e=n-1; //Starting and ending pointer\\n        for(int i=0;(i<candidates)&&s<=e;i++){ //Putting first and last \\'candidates\\' candidates or all of them if no of candidates is smaller than sum of first and last \\'candidates\\'\\n            pq.push({costs[s],s,1});\\n            s++;\\n            if(s<=e){ //To ensure that a single candidate in pushed only once in queue.\\n                pq.push({costs[e],e,-1});\\n                e--;\\n            }\\n            \\n        }\\n        long long ans=0;\\n        while(k--&&pq.size()){    // Conducting rounds \\n            vector<int>ele=pq.top();  //Picked the cheapest candidate and breaking the tie\\n            pq.pop();\\n            ans+=ele[0]; //Added their hiring cost\\n            if(s<=e){    //Checking whether it is possible to push unique new candidates into queue and pushing them.\\n                if(ele[2]==1){\\n                    pq.push({costs[s],s,1});\\n                    s++;\\n                }\\n                else{\\n                    pq.push({costs[e],e,-1});\\n                    e--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue <vector<int>, vector<vector<int>>, greater<vector<int>>>pq; \\n        //Min heap, also sorts on basis of index as element stored in form {cost,index,whether picked from first \\'candidates\\' candidates or last \\'candidates\\' candidates}\\n        int n=costs.size();\\n        int s=0,e=n-1; //Starting and ending pointer\\n        for(int i=0;(i<candidates)&&s<=e;i++){ //Putting first and last \\'candidates\\' candidates or all of them if no of candidates is smaller than sum of first and last \\'candidates\\'\\n            pq.push({costs[s],s,1});\\n            s++;\\n            if(s<=e){ //To ensure that a single candidate in pushed only once in queue.\\n                pq.push({costs[e],e,-1});\\n                e--;\\n            }\\n            \\n        }\\n        long long ans=0;\\n        while(k--&&pq.size()){    // Conducting rounds \\n            vector<int>ele=pq.top();  //Picked the cheapest candidate and breaking the tie\\n            pq.pop();\\n            ans+=ele[0]; //Added their hiring cost\\n            if(s<=e){    //Checking whether it is possible to push unique new candidates into queue and pushing them.\\n                if(ele[2]==1){\\n                    pq.push({costs[s],s,1});\\n                    s++;\\n                }\\n                else{\\n                    pq.push({costs[e],e,-1});\\n                    e--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684217,
                "title": "java-solution-it-will-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683901,
                "title": "rust-with-binaryheap-and-iterator",
                "content": "# Code\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\\n        let mut iter = costs.iter();\\n        let mut heap = BinaryHeap::new();\\n        for _ in 0..candidates {\\n            if let Some(&x) = iter.next() {\\n                heap.push((Reverse(x), true));\\n            }\\n            if let Some(&x) = iter.next_back() {\\n                heap.push((Reverse(x), false));\\n            }\\n        }\\n\\n        let mut ans = 0i64;\\n        for _ in 0..k {\\n            if let Some((Reverse(x), is_front)) = heap.pop() {\\n                ans += x as i64;\\n                let opt = if is_front { iter.next() } else { iter.next_back() };\\n                if let Some(&y) = opt {\\n                    heap.push((Reverse(y), is_front));\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\\n        let mut iter = costs.iter();\\n        let mut heap = BinaryHeap::new();\\n        for _ in 0..candidates {\\n            if let Some(&x) = iter.next() {\\n                heap.push((Reverse(x), true));\\n            }\\n            if let Some(&x) = iter.next_back() {\\n                heap.push((Reverse(x), false));\\n            }\\n        }\\n\\n        let mut ans = 0i64;\\n        for _ in 0..k {\\n            if let Some((Reverse(x), is_front)) = heap.pop() {\\n                ans += x as i64;\\n                let opt = if is_front { iter.next() } else { iter.next_back() };\\n                if let Some(&y) = opt {\\n                    heap.push((Reverse(y), is_front));\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683715,
                "title": "javascript-shortest-possible-solution-4-lines-with-comments-minpriorityqueue",
                "content": "# Code\\n``` JavaScript\\nvar totalCost = function(costs, k, candidates) {\\n    let ans=0, l=0, r=costs.length-1, max=1e5+1;\\n    const h1 = new MinPriorityQueue(), h2 = new MinPriorityQueue();\\n    h1.enqueue(max), h2.enqueue(max); // Insert (max possible elemets + 1) in both queue\\n\\n    for(let i=0; i<k; ++i) {\\n        // Add elements until candidates size reached or both sides overlaps\\n        while(h1.size()<=candidates && l<=r) h1.enqueue(costs[l++]);\\n        while(h2.size()<=candidates && l<=r) h2.enqueue(costs[r--]);\\n        // Remove smallest element and add it to ans\\n        ans += (h1.front().element<=h2.front().element ? h1 : h2).dequeue().element;\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "``` JavaScript\\nvar totalCost = function(costs, k, candidates) {\\n    let ans=0, l=0, r=costs.length-1, max=1e5+1;\\n    const h1 = new MinPriorityQueue(), h2 = new MinPriorityQueue();\\n    h1.enqueue(max), h2.enqueue(max); // Insert (max possible elemets + 1) in both queue\\n\\n    for(let i=0; i<k; ++i) {\\n        // Add elements until candidates size reached or both sides overlaps\\n        while(h1.size()<=candidates && l<=r) h1.enqueue(costs[l++]);\\n        while(h2.size()<=candidates && l<=r) h2.enqueue(costs[r--]);\\n        // Remove smallest element and add it to ans\\n        ans += (h1.front().element<=h2.front().element ? h1 : h2).dequeue().element;\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683287,
                "title": "java-solution-for-total-cost-to-hire-k-workers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The solution starts by adding the first candidates workers with section id 0 (representing the first candidates) and the last candidates workers with section id 1 (representing the last candidates) to the priority queue.\\n- It then iteratively selects the worker with the lowest cost from the priority queue, updates the total cost, and refills the priority queue with the next available workers from the corresponding section (0 or 1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a priority queue pq with a custom comparator to prioritize workers based on their cost and break ties using their indices.\\n1. Add the first candidates workers with section id 0 and the last candidates workers with section id 1 to pq.\\n1. Initialize variables nextHead to candidates and nextTail to costs.length - candidates to keep track of the next available workers outside the current sections.\\n1. Iterate k times:\\n- Extract the worker with the lowest cost from pq.\\n- Add the worker\\'s cost to the total cost.\\n- If there are more workers available outside the current sections:\\n- If the extracted worker is from section 0, add the next available worker from section 0 to pq and update nextHead.\\n- If the extracted worker is from section 1, add the next available worker from section 1 to pq and update nextTail.\\n1. Return the total cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k log n), where n is the length of the costs array. The time complexity is dominated by the k iterations, and each iteration involves operations on the priority queue, which takes O(log n) time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the costs array. The space is used to store the priority queue, which can store up to n workers.\\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        // The worker with the lowest cost has the highest priority, if two players has the\\n        // same cost, break the tie by their indices (0 or 1).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];});\\n        \\n        // Add the first k workers with section id of 0 and \\n        // the last k workers with section id of 1 (without duplication) to pq.\\n        for (int i = 0; i < candidates; i++) {\\n            pq.offer(new int[] {costs[i], 0});\\n        }\\n        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\\n            pq.offer(new int[] {costs[i], 1});\\n        }\\n\\n        long answer = 0;\\n        int nextHead = candidates;\\n        int nextTail = costs.length - 1 - candidates;\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] curWorker = pq.poll();\\n            int curCost = curWorker[0], curSectionId = curWorker[1];\\n            answer += curCost;\\n            \\n            // Only refill pq if there are workers outside.\\n            if (nextHead <= nextTail) {\\n                if (curSectionId == 0) {\\n                    pq.offer(new int[]{costs[nextHead], 0});\\n                    nextHead++;\\n                } else {\\n                    pq.offer(new int[]{costs[nextTail], 1});\\n                    nextTail--;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        // The worker with the lowest cost has the highest priority, if two players has the\\n        // same cost, break the tie by their indices (0 or 1).\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];});\\n        \\n        // Add the first k workers with section id of 0 and \\n        // the last k workers with section id of 1 (without duplication) to pq.\\n        for (int i = 0; i < candidates; i++) {\\n            pq.offer(new int[] {costs[i], 0});\\n        }\\n        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\\n            pq.offer(new int[] {costs[i], 1});\\n        }\\n\\n        long answer = 0;\\n        int nextHead = candidates;\\n        int nextTail = costs.length - 1 - candidates;\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] curWorker = pq.poll();\\n            int curCost = curWorker[0], curSectionId = curWorker[1];\\n            answer += curCost;\\n            \\n            // Only refill pq if there are workers outside.\\n            if (nextHead <= nextTail) {\\n                if (curSectionId == 0) {\\n                    pq.offer(new int[]{costs[nextHead], 0});\\n                    nextHead++;\\n                } else {\\n                    pq.offer(new int[]{costs[nextTail], 1});\\n                    nextTail--;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683104,
                "title": "c-two-pointers-min-heap-priority-queue-solution-o-n-logn",
                "content": "Just take two pointers, first i(+tive pointer) starting from 0 going till candidates-1 and second j(-tive pointer) starting from costs.size() going till costs.size()-candidates (as given in question). Also apply restrictions so that j always remain >= i and push all elements in min heap.\\nMy min heap has a special comp comparator function to satisfy the tie break for smaller index as mentioned in question.\\nnow for k iterations, just add top and pop and then push the next element accordingly to the position of the popped element index and always keep j>=i(So that no elements with same index in the heap). Easy\\n```\\nclass Comp{\\n    public:\\n    bool operator()(pair<int,int> a, pair<int,int> b){\\n        if(a.first!=b.first) return a.first>b.first;\\n        return a.second>b.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, Comp> pq;\\n        int i,j;\\n        for(i=0;i<=candidates-1 && i<costs.size();i++){\\n            pq.push({costs[i],i});\\n        }\\n        for(j=costs.size()-1;j>=costs.size()-candidates && j>candidates-1;j--){\\n            pq.push({costs[j],j});\\n        }\\n        long long ans=0;\\n        while(k--){\\n            pair<int,int> temp = pq.top();\\n            pq.pop();\\n            ans += temp.first;\\n            if(temp.second>j && j>=i){\\n                pq.push({costs[j],j});\\n                j--;\\n            }\\n            else if(temp.second<i && i<=j){\\n                pq.push({costs[i],i});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please upvote for your continuous support\\uD83D\\uDE0A. If you don\\'t understand something, comment down and i will try to explain. Have a good day!",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Comp{\\n    public:\\n    bool operator()(pair<int,int> a, pair<int,int> b){\\n        if(a.first!=b.first) return a.first>b.first;\\n        return a.second>b.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, Comp> pq;\\n        int i,j;\\n        for(i=0;i<=candidates-1 && i<costs.size();i++){\\n            pq.push({costs[i],i});\\n        }\\n        for(j=costs.size()-1;j>=costs.size()-candidates && j>candidates-1;j--){\\n            pq.push({costs[j],j});\\n        }\\n        long long ans=0;\\n        while(k--){\\n            pair<int,int> temp = pq.top();\\n            pq.pop();\\n            ans += temp.first;\\n            if(temp.second>j && j>=i){\\n                pq.push({costs[j],j});\\n                j--;\\n            }\\n            else if(temp.second<i && i<=j){\\n                pq.push({costs[i],i});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683096,
                "title": "26-06-23-c-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans=0;\\n        priority_queue<int, vector<int>, greater<int> > q1;\\n        priority_queue<int, vector<int>, greater<int> > q2;\\n        int low=0;\\n        while(low<candidates){\\n            q1.push(costs[low]);\\n            low++;\\n        }\\n        int cnt=0;\\n        int high= (int)costs.size()-1;\\n        if(candidates > costs.size()- candidates){\\n            candidates= costs.size()- candidates;\\n        }  \\n        while(cnt<candidates){\\n            q2.push(costs[high]);\\n            cnt++;\\n            high--;\\n        }    \\n        while(k--){\\n            if((int)q1.size()==0){\\n                ans+=q2.top();\\n                q2.pop();\\n                if(low<=high){\\n                   q2.push(costs[high]);\\n                    high--;\\n                }        \\n            }\\n            else if((int)q2.size()==0){\\n                ans+=q1.top();\\n                q1.pop();\\n                if(low<=high){\\n                    q1.push(costs[low]);\\n                    low++;\\n                } \\n            }\\n            else if(q1.top()<=q2.top()){\\n                ans+=q1.top();\\n                q1.pop();\\n                if(low<=high){\\n                    q1.push(costs[low]);\\n                    low++;\\n                }\\n            }\\n            else{\\n                ans+=q2.top();\\n                q2.pop();\\n                if(low<=high){\\n                 q2.push(costs[high]);\\n                    high--;\\n                }           \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans=0;\\n        priority_queue<int, vector<int>, greater<int> > q1;\\n        priority_queue<int, vector<int>, greater<int> > q2;\\n        int low=0;\\n        while(low<candidates){\\n            q1.push(costs[low]);\\n            low++;\\n        }\\n        int cnt=0;\\n        int high= (int)costs.size()-1;\\n        if(candidates > costs.size()- candidates){\\n            candidates= costs.size()- candidates;\\n        }  \\n        while(cnt<candidates){\\n            q2.push(costs[high]);\\n            cnt++;\\n            high--;\\n        }    \\n        while(k--){\\n            if((int)q1.size()==0){\\n                ans+=q2.top();\\n                q2.pop();\\n                if(low<=high){\\n                   q2.push(costs[high]);\\n                    high--;\\n                }        \\n            }\\n            else if((int)q2.size()==0){\\n                ans+=q1.top();\\n                q1.pop();\\n                if(low<=high){\\n                    q1.push(costs[low]);\\n                    low++;\\n                } \\n            }\\n            else if(q1.top()<=q2.top()){\\n                ans+=q1.top();\\n                q1.pop();\\n                if(low<=high){\\n                    q1.push(costs[low]);\\n                    low++;\\n                }\\n            }\\n            else{\\n                ans+=q2.top();\\n                q2.pop();\\n                if(low<=high){\\n                 q2.push(costs[high]);\\n                    high--;\\n                }           \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683014,
                "title": "w-explanation-c-solution-using-priority-queue-beats-92-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates the total cost of selecting items from a vector, excluding certain elements from both ends. Use 2 prior queues to implement.\\n```\\nList the top for these 2 priority queues for test case\\ncosts =[57,33,26,76,14,67,24,90,72,37,30]\\nk=11\\nn=2\\n\\n33,30\\n33,37\\n26,37\\n57,37\\n57,72\\n14,72\\n67,72\\n24,72\\n76,72\\n76,90\\n2147483647,90\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given C++ code defines a class Solution with a function totalCost. It calculates the total cost of selecting k items from a vector costs, excluding n items from both ends. If the size of costs is less than or equal to 2 * n, it sorts the vector and returns the sum of the first k elements. Otherwise, it uses two priority queues to store the smallest elements from the ignored regions and selects the smallest elements alternately until k items are chosen. The selected elements are accumulated to calculate the total cost, which is then returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with Explanation in comments Runtime 187 ms Beats 92.50%\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int n) {\\n        // The function takes three parameters:\\n        // - costs: a vector of integers representing the costs of different items\\n        // - k: an integer representing the number of items to be selected\\n        // - n: an integer representing the number of items at both ends to be ignored\\n        \\n        int len = costs.size(); // Get the size of the costs vector\\n        \\n        if (len <= 2 * n) {\\n            // If the size of the costs vector is less than or equal to 2 times n,\\n            // it means there are not enough items to ignore on both ends.\\n            // In this case, sort the costs vector and return the sum of the first k elements.\\n            sort(costs.begin(), costs.end());\\n            return accumulate(costs.begin(), costs.begin() + k, 0LL);\\n        }\\n\\n        // Create two priority queues:\\n        // - pq0: to store the n smallest elements from the beginning of the costs vector\\n        // - pq1: to store the n smallest elements from the end of the costs vector\\n        priority_queue<int, vector<int>, greater<int>> \\n        pq0(costs.begin(), costs.begin() + n),\\n        pq1(costs.end() - n, costs.end());\\n\\n        long long sum = 0; // Variable to store the sum of selected elements\\n        for (int l = n, r = len - 1 - n; k > 0; k--) {\\n            // Iterate until k items have been selected\\n            \\n            int x = pq0.empty() ? INT_MAX : pq0.top(); // Get the smallest element from pq0\\n            int y = pq1.empty() ? INT_MAX : pq1.top(); // Get the smallest element from pq1\\n            \\n            if (x <= y) {\\n                // If the smallest element from pq0 is smaller than or equal to the smallest element from pq1,\\n                // select the smallest element from pq0 and update the sum.\\n                sum += x;\\n                pq0.pop(); // Remove the selected element from pq0\\n                if (l <= r)\\n                    pq0.push(costs[l++]); // Add the next element from the ignored region to pq0\\n            } else {\\n                // If the smallest element from pq1 is smaller than the smallest element from pq0,\\n                // select the smallest element from pq1 and update the sum.\\n                sum += y;\\n                pq1.pop(); // Remove the selected element from pq1\\n                if (l <= r)\\n                    pq1.push(costs[r--]); // Add the next element from the ignored region to pq1\\n            }\\n        }\\n        \\n        return sum; // Return the total cost\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nList the top for these 2 priority queues for test case\\ncosts =[57,33,26,76,14,67,24,90,72,37,30]\\nk=11\\nn=2\\n\\n33,30\\n33,37\\n26,37\\n57,37\\n57,72\\n14,72\\n67,72\\n24,72\\n76,72\\n76,90\\n2147483647,90\\n```\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int n) {\\n        // The function takes three parameters:\\n        // - costs: a vector of integers representing the costs of different items\\n        // - k: an integer representing the number of items to be selected\\n        // - n: an integer representing the number of items at both ends to be ignored\\n        \\n        int len = costs.size(); // Get the size of the costs vector\\n        \\n        if (len <= 2 * n) {\\n            // If the size of the costs vector is less than or equal to 2 times n,\\n            // it means there are not enough items to ignore on both ends.\\n            // In this case, sort the costs vector and return the sum of the first k elements.\\n            sort(costs.begin(), costs.end());\\n            return accumulate(costs.begin(), costs.begin() + k, 0LL);\\n        }\\n\\n        // Create two priority queues:\\n        // - pq0: to store the n smallest elements from the beginning of the costs vector\\n        // - pq1: to store the n smallest elements from the end of the costs vector\\n        priority_queue<int, vector<int>, greater<int>> \\n        pq0(costs.begin(), costs.begin() + n),\\n        pq1(costs.end() - n, costs.end());\\n\\n        long long sum = 0; // Variable to store the sum of selected elements\\n        for (int l = n, r = len - 1 - n; k > 0; k--) {\\n            // Iterate until k items have been selected\\n            \\n            int x = pq0.empty() ? INT_MAX : pq0.top(); // Get the smallest element from pq0\\n            int y = pq1.empty() ? INT_MAX : pq1.top(); // Get the smallest element from pq1\\n            \\n            if (x <= y) {\\n                // If the smallest element from pq0 is smaller than or equal to the smallest element from pq1,\\n                // select the smallest element from pq0 and update the sum.\\n                sum += x;\\n                pq0.pop(); // Remove the selected element from pq0\\n                if (l <= r)\\n                    pq0.push(costs[l++]); // Add the next element from the ignored region to pq0\\n            } else {\\n                // If the smallest element from pq1 is smaller than the smallest element from pq0,\\n                // select the smallest element from pq1 and update the sum.\\n                sum += y;\\n                pq1.pop(); // Remove the selected element from pq1\\n                if (l <= r)\\n                    pq1.push(costs[r--]); // Add the next element from the ignored region to pq1\\n            }\\n        }\\n        \\n        return sum; // Return the total cost\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793104,
                "title": "c-most-easy-detailed-solution-priority-queue-with-vis-array",
                "content": "```\\ntypedef long long ll;\\ntypedef pair<ll,ll> pi;\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;//for storing the starting candidates no of indexes\\n         priority_queue<pi,vector<pi>,greater<pi>>pq1;//for storing the ending candidates no of indexes\\n        int n=costs.size();\\n        int s,e;\\n        vector<int> vis(n,0);//for storing the visited indexes\\n        for(int i=0;i<min(n,candidates);i++)\\n        {\\n            pq.push({costs[i],i});\\n            vis[i]=1;\\n            s=i;\\n        }\\n        for(int j=n-1;j>=n-candidates;j--)\\n        {\\n            if(!vis[j])\\n            {\\n                pq1.push({costs[j],j});\\n                vis[j]=1;\\n                e=j;\\n            }\\n        }\\n        s++;\\n        e--;\\n        ll sum=0;\\n        while(k--)\\n        {\\n            if(!pq.empty() and !pq1.empty())\\n            {\\n                if(pq.top().first<pq1.top().first or pq.top().first==pq1.top().first)//if element at top pq is less than top of pq1\\n                //or if both the elements are same then we need to select from pq since index of pq will always be less than that\\n\\t\\t\\t\\t//of pq1\\n\\t\\t\\t\\t{\\n                sum+=pq.top().first;\\n                pq.pop();\\n                if(!vis[s])\\n                {\\n                    pq.push({costs[s],s});\\n                    vis[s]=1;\\n                    s++;\\n                   \\n                }\\n                 }\\n                else if(pq.top().first>pq1.top().first)\\n                {\\n                    sum+=pq1.top().first;\\n                    pq1.pop();\\n                    if(!vis[e])\\n                    {\\n                        pq1.push({costs[e],e});\\n                        vis[e]=1;\\n                        e--;\\n                    }\\n                }\\n            }\\n            else if(pq.empty())\\n            {\\n                sum+=pq1.top().first;\\n                pq1.pop();\\n            }\\n            else\\n            {\\n                sum+=pq.top().first;\\n                pq.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\ntypedef pair<ll,ll> pi;\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;//for storing the starting candidates no of indexes\\n         priority_queue<pi,vector<pi>,greater<pi>>pq1;//for storing the ending candidates no of indexes\\n        int n=costs.size();\\n        int s,e;\\n        vector<int> vis(n,0);//for storing the visited indexes\\n        for(int i=0;i<min(n,candidates);i++)\\n        {\\n            pq.push({costs[i],i});\\n            vis[i]=1;\\n            s=i;\\n        }\\n        for(int j=n-1;j>=n-candidates;j--)\\n        {\\n            if(!vis[j])\\n            {\\n                pq1.push({costs[j],j});\\n                vis[j]=1;\\n                e=j;\\n            }\\n        }\\n        s++;\\n        e--;\\n        ll sum=0;\\n        while(k--)\\n        {\\n            if(!pq.empty() and !pq1.empty())\\n            {\\n                if(pq.top().first<pq1.top().first or pq.top().first==pq1.top().first)//if element at top pq is less than top of pq1\\n                //or if both the elements are same then we need to select from pq since index of pq will always be less than that\\n\\t\\t\\t\\t//of pq1\\n\\t\\t\\t\\t{\\n                sum+=pq.top().first;\\n                pq.pop();\\n                if(!vis[s])\\n                {\\n                    pq.push({costs[s],s});\\n                    vis[s]=1;\\n                    s++;\\n                   \\n                }\\n                 }\\n                else if(pq.top().first>pq1.top().first)\\n                {\\n                    sum+=pq1.top().first;\\n                    pq1.pop();\\n                    if(!vis[e])\\n                    {\\n                        pq1.push({costs[e],e});\\n                        vis[e]=1;\\n                        e--;\\n                    }\\n                }\\n            }\\n            else if(pq.empty())\\n            {\\n                sum+=pq1.top().first;\\n                pq1.pop();\\n            }\\n            else\\n            {\\n                sum+=pq.top().first;\\n                pq.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791105,
                "title": "c-2-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy using priority queues always get min priority item from *begin* and *end* range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two priority queues from begin and end using two pointers (i, j)\\nWhen Dequeue element from queue, Enqueue new element to fill candidates range (i++, j--) until $$i<=j$$\\n\\n# Complexity\\n- Time complexity: $$O(NLogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int candidates) {\\n        var pq1 = new PriorityQueue<int, int>();\\n        var pq2 = new PriorityQueue<int, int>();\\n        int i = 0, j = costs.Length - 1;\\n        long totalCost = 0;\\n\\n        while (k > 0) {\\n            while (pq1.Count < candidates && i <= j) {\\n                pq1.Enqueue(costs[i], costs[i]);\\n                i++;\\n            }\\n\\n            while (pq2.Count < candidates && j >= i) {\\n                pq2.Enqueue(costs[j], costs[j]);\\n                j--;\\n            }\\n\\n            int p1 = pq1.Count > 0 ? pq1.Peek() : int.MaxValue;\\n            int p2 = pq2.Count > 0 ? pq2.Peek() : int.MaxValue;\\n\\n            if (p1 <= p2) {\\n                totalCost += p1;\\n                pq1.TryDequeue(out int e, out int p);\\n            }\\n            else {\\n                totalCost += p2;\\n                pq2.TryDequeue(out int e, out int p);\\n            }\\n\\n            k--;\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int candidates) {\\n        var pq1 = new PriorityQueue<int, int>();\\n        var pq2 = new PriorityQueue<int, int>();\\n        int i = 0, j = costs.Length - 1;\\n        long totalCost = 0;\\n\\n        while (k > 0) {\\n            while (pq1.Count < candidates && i <= j) {\\n                pq1.Enqueue(costs[i], costs[i]);\\n                i++;\\n            }\\n\\n            while (pq2.Count < candidates && j >= i) {\\n                pq2.Enqueue(costs[j], costs[j]);\\n                j--;\\n            }\\n\\n            int p1 = pq1.Count > 0 ? pq1.Peek() : int.MaxValue;\\n            int p2 = pq2.Count > 0 ? pq2.Peek() : int.MaxValue;\\n\\n            if (p1 <= p2) {\\n                totalCost += p1;\\n                pq1.TryDequeue(out int e, out int p);\\n            }\\n            else {\\n                totalCost += p2;\\n                pq2.TryDequeue(out int e, out int p);\\n            }\\n\\n            k--;\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783439,
                "title": "javascript-min-heap-pq-476ms",
                "content": "```\\nconst totalCost = (a, k, m) => {\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    let n = a.length, l = 0, r = n - 1, res = 0;\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([a[l], l]);\\n            l++;\\n        }\\n    }\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([a[r], r]);\\n            r--;\\n        }\\n    }\\n    for (let i = 0; i < k; i++) {\\n        let cur = pq.dequeue();\\n        res += cur[0];\\n        if (cur[1] < l && l <= r) {\\n            pq.enqueue([a[l], l]);\\n            l++;\\n        } else if (cur[1] > r && l <= r) {\\n            pq.enqueue([a[r], r]);\\n            r--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst totalCost = (a, k, m) => {\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    let n = a.length, l = 0, r = n - 1, res = 0;\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([a[l], l]);\\n            l++;\\n        }\\n    }\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([a[r], r]);\\n            r--;\\n        }\\n    }\\n    for (let i = 0; i < k; i++) {\\n        let cur = pq.dequeue();\\n        res += cur[0];\\n        if (cur[1] < l && l <= r) {\\n            pq.enqueue([a[l], l]);\\n            l++;\\n        } else if (cur[1] > r && l <= r) {\\n            pq.enqueue([a[r], r]);\\n            r--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783375,
                "title": "python3-heap",
                "content": "# Intuition\\nWe want to keep adding hiring candidates into our priority queue and popping the least costing candidates one by one from the queue according to the conditions.\\n\\n# Complexity\\n- Time complexity: $$O(candidates + klog(candidates))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(candidates)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        total = 0\\n        i, j = candidates, len(costs)-candidates-1\\n        if len(costs) <= 2 * candidates:\\n            heap = [(x,0) for x in costs]\\n        else:\\n            heap = [(x,0) for x in costs[:candidates]] + [(x,1) for x in costs[len(costs)-candidates:]]\\n        heapq.heapify(heap)\\n        \\n        for _ in range(k):\\n            cost, direction = heapq.heappop(heap)\\n            total += cost\\n            if i <= j:\\n                if direction:\\n                    heapq.heappush(heap, (costs[j], 1))\\n                    j -= 1\\n                else:\\n                    heapq.heappush(heap, (costs[i], 0))\\n                    i += 1\\n                    \\n        return total\\n                \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        total = 0\\n        i, j = candidates, len(costs)-candidates-1\\n        if len(costs) <= 2 * candidates:\\n            heap = [(x,0) for x in costs]\\n        else:\\n            heap = [(x,0) for x in costs[:candidates]] + [(x,1) for x in costs[len(costs)-candidates:]]\\n        heapq.heapify(heap)\\n        \\n        for _ in range(k):\\n            cost, direction = heapq.heappop(heap)\\n            total += cost\\n            if i <= j:\\n                if direction:\\n                    heapq.heappush(heap, (costs[j], 1))\\n                    j -= 1\\n                else:\\n                    heapq.heappush(heap, (costs[i], 0))\\n                    i += 1\\n                    \\n        return total\\n                \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783256,
                "title": "faster-than-80-simple-c-solution-priority-queue-min-heap",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(canditates)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& c, int k, int can) {\\n        long long ans=0;\\n        if(c.size()==1) return c[0];\\n        priority_queue<int,vector<int>,greater<int>> l;\\n        priority_queue<int,vector<int>,greater<int>> r;\\n        int left = 0,right=c.size()-1;\\n        for(int i=1;i<=can;i++){\\n            if(i-1 >= c.size()-i) break;\\n            l.push(c[i-1]);left = i;\\n            r.push(c[c.size()-i]);right = c.size()-i-1;\\n        }\\n        bool f=1;\\n        while(k--){\\n            if(left>right) f=0;\\n            int a=!l.empty()?l.top():INT_MAX;\\n            int b=!r.empty()?r.top():INT_MAX;\\n            if(a<=b){\\n                ans+=a;\\n                l.pop();\\n                if(f) l.push(c[left]);\\n                if(f) left++;\\n            }else{\\n                ans+=b;\\n                r.pop();\\n                if(f) r.push(c[right]);\\n                if(f) right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& c, int k, int can) {\\n        long long ans=0;\\n        if(c.size()==1) return c[0];\\n        priority_queue<int,vector<int>,greater<int>> l;\\n        priority_queue<int,vector<int>,greater<int>> r;\\n        int left = 0,right=c.size()-1;\\n        for(int i=1;i<=can;i++){\\n            if(i-1 >= c.size()-i) break;\\n            l.push(c[i-1]);left = i;\\n            r.push(c[c.size()-i]);right = c.size()-i-1;\\n        }\\n        bool f=1;\\n        while(k--){\\n            if(left>right) f=0;\\n            int a=!l.empty()?l.top():INT_MAX;\\n            int b=!r.empty()?r.top():INT_MAX;\\n            if(a<=b){\\n                ans+=a;\\n                l.pop();\\n                if(f) l.push(c[left]);\\n                if(f) left++;\\n            }else{\\n                ans+=b;\\n                r.pop();\\n                if(f) r.push(c[right]);\\n                if(f) right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783177,
                "title": "min-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n-Put candidate elements from start in priority min queue pq1\\n-Put canddiate elements from end in priority min queue pq2, in case of overlap put only non overlapping elements.\\n\\nMaintain i and j as remaining elements in middle. In case of overlap i > j condition will suffice.\\n\\ncheck top of each pq, and add to sum if smaller. Give weightage to pq1 in case elements are equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<>> pq1, pq2;\\n        int n = costs.size();\\n        long long sum = 0;\\n        for (int i = 0; i < candidates && i < n; i++) {\\n            pq1.push(costs[i]);\\n        }\\n        \\n        for (int i = n - 1, j = 0; i >= candidates && j < candidates; j++, i--) {\\n            pq2.push(costs[i]);\\n        }\\n        \\n        int i = candidates, j = n - candidates - 1;\\n        while (k) {\\n            int v1 = INT_MAX, v2 = INT_MAX;\\n            if (!pq1.empty()) v1 = pq1.top(); \\n            if (!pq2.empty()) v2 = pq2.top();\\n\\n            if (v1 <= v2) {\\n                sum += v1; pq1.pop();\\n                if (i <= j) {\\n                    pq1.push(costs[i]);\\n                    i++;\\n                }\\n            } else if (v1 > v2) {\\n                sum += v2; pq2.pop();  \\n                if (i <= j) {\\n                    pq2.push(costs[j]);\\n                    j--;\\n                }\\n            }\\n            k--;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<>> pq1, pq2;\\n        int n = costs.size();\\n        long long sum = 0;\\n        for (int i = 0; i < candidates && i < n; i++) {\\n            pq1.push(costs[i]);\\n        }\\n        \\n        for (int i = n - 1, j = 0; i >= candidates && j < candidates; j++, i--) {\\n            pq2.push(costs[i]);\\n        }\\n        \\n        int i = candidates, j = n - candidates - 1;\\n        while (k) {\\n            int v1 = INT_MAX, v2 = INT_MAX;\\n            if (!pq1.empty()) v1 = pq1.top(); \\n            if (!pq2.empty()) v2 = pq2.top();\\n\\n            if (v1 <= v2) {\\n                sum += v1; pq1.pop();\\n                if (i <= j) {\\n                    pq1.push(costs[i]);\\n                    i++;\\n                }\\n            } else if (v1 > v2) {\\n                sum += v2; pq2.pop();  \\n                if (i <= j) {\\n                    pq2.push(costs[j]);\\n                    j--;\\n                }\\n            }\\n            k--;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692386,
                "title": "c-solution-using-single-priority-queue",
                "content": "# Intuition\\nSince we are looking for top K elements, we can use a heap to efficiently fetch the same\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(klog(c))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int c) {\\n        var left = 0;\\n        var right = costs.Length - 1;\\n        var candidatePq = new PriorityQueue<Tuple<int, int>, Tuple<int, int>>(new TupleComparer());\\n\\n        while(left < c) {\\n            var tuple = new Tuple<int, int>(costs[left], left);\\n            candidatePq.Enqueue(tuple, tuple);\\n            left++;\\n        }\\n        while(right >= left && right >= costs.Length - c) {\\n            var tuple = new Tuple<int, int>(costs[right], right);\\n            candidatePq.Enqueue(tuple, tuple);\\n            right--;\\n        }\\n\\n        var selectedcandidate = 0;\\n        long cost = 0;\\n        while(selectedcandidate < k) {\\n            var candidate = candidatePq.Dequeue();\\n            cost += candidate.Item1;\\n\\n            var index = candidate.Item2;\\n            if(index < left && right >= left) {\\n                var tuple = new Tuple<int, int>(costs[left], left);\\n                candidatePq.Enqueue(tuple, tuple);\\n                left++;\\n            } else if (index > right && right>=left ) {\\n                var tuple = new Tuple<int, int>(costs[right], right);\\n                candidatePq.Enqueue(tuple, tuple);\\n                right--;\\n            }\\n            selectedcandidate++;\\n        }\\n        return cost;\\n    }\\n}\\n\\npublic class TupleComparer : IComparer<Tuple<int, int>>\\n{\\n    // Compares by Height, Length, and Width.\\n    public int Compare(Tuple<int, int> x, Tuple<int, int> y)\\n    {\\n        if(x.Item1.CompareTo(y.Item1) != 0) {\\n            return x.Item1.CompareTo(y.Item1);\\n        } else if(x.Item2.CompareTo(y.Item2) != 0) {\\n            return x.Item2.CompareTo(y.Item2);\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int c) {\\n        var left = 0;\\n        var right = costs.Length - 1;\\n        var candidatePq = new PriorityQueue<Tuple<int, int>, Tuple<int, int>>(new TupleComparer());\\n\\n        while(left < c) {\\n            var tuple = new Tuple<int, int>(costs[left], left);\\n            candidatePq.Enqueue(tuple, tuple);\\n            left++;\\n        }\\n        while(right >= left && right >= costs.Length - c) {\\n            var tuple = new Tuple<int, int>(costs[right], right);\\n            candidatePq.Enqueue(tuple, tuple);\\n            right--;\\n        }\\n\\n        var selectedcandidate = 0;\\n        long cost = 0;\\n        while(selectedcandidate < k) {\\n            var candidate = candidatePq.Dequeue();\\n            cost += candidate.Item1;\\n\\n            var index = candidate.Item2;\\n            if(index < left && right >= left) {\\n                var tuple = new Tuple<int, int>(costs[left], left);\\n                candidatePq.Enqueue(tuple, tuple);\\n                left++;\\n            } else if (index > right && right>=left ) {\\n                var tuple = new Tuple<int, int>(costs[right], right);\\n                candidatePq.Enqueue(tuple, tuple);\\n                right--;\\n            }\\n            selectedcandidate++;\\n        }\\n        return cost;\\n    }\\n}\\n\\npublic class TupleComparer : IComparer<Tuple<int, int>>\\n{\\n    // Compares by Height, Length, and Width.\\n    public int Compare(Tuple<int, int> x, Tuple<int, int> y)\\n    {\\n        if(x.Item1.CompareTo(y.Item1) != 0) {\\n            return x.Item1.CompareTo(y.Item1);\\n        } else if(x.Item2.CompareTo(y.Item2) != 0) {\\n            return x.Item2.CompareTo(y.Item2);\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686126,
                "title": "easy-understanding-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n)->O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        //maintain two queue for front and back\\n        priority_queue<int, vector<int>, greater<int>> f,b;\\n        int cf = 0, cb = costs.size()-1;\\n        while(candidates > 0){\\n            f.push(costs[cf]);\\n            b.push(costs[cb]);\\n            cb--;\\n            cf++;\\n            if(cf == cb || cf > cb)  break;\\n            candidates--;\\n        }\\n        long long ans = 0;\\n        while(k > 0){\\n            k--;\\n            //if front queue is empty\\n            if(f.empty()){ \\n                ans += b.top();\\n                b.pop();\\n                continue;\\n            }\\n            // if back queue is empty\\n            if(b.empty()){\\n                ans+=f.top();\\n                f.pop();\\n                continue;\\n            }\\n\\n            if(f.top() > b.top()){\\n                ans += b.top();\\n                b.pop();\\n                if(cb >= cf ){\\n                    b.push(costs[cb]);\\n                    cb--;\\n                }\\n            }\\n            else{\\n                ans+=f.top();\\n                f.pop();\\n                if(cb >= cf){\\n                    f.push(costs[cf]);\\n                    cf++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        //maintain two queue for front and back\\n        priority_queue<int, vector<int>, greater<int>> f,b;\\n        int cf = 0, cb = costs.size()-1;\\n        while(candidates > 0){\\n            f.push(costs[cf]);\\n            b.push(costs[cb]);\\n            cb--;\\n            cf++;\\n            if(cf == cb || cf > cb)  break;\\n            candidates--;\\n        }\\n        long long ans = 0;\\n        while(k > 0){\\n            k--;\\n            //if front queue is empty\\n            if(f.empty()){ \\n                ans += b.top();\\n                b.pop();\\n                continue;\\n            }\\n            // if back queue is empty\\n            if(b.empty()){\\n                ans+=f.top();\\n                f.pop();\\n                continue;\\n            }\\n\\n            if(f.top() > b.top()){\\n                ans += b.top();\\n                b.pop();\\n                if(cb >= cf ){\\n                    b.push(costs[cb]);\\n                    cb--;\\n                }\\n            }\\n            else{\\n                ans+=f.top();\\n                f.pop();\\n                if(cb >= cf){\\n                    f.push(costs[cf]);\\n                    cf++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686042,
                "title": "c-solution-using-priority-queue",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code finds the total cost by selecting \"candidates\" elements from the \"costs\" vector. It divides the elements into two parts, \"left_k\" and \"right_k,\" and maintains them as min-heaps. It alternates between selecting the minimum element from \"left_k\" and \"right_k\" until \"k\" iterations are completed. If there are remaining iterations, it selects the minimum element from either \"left_k\" or \"right_k.\" The final sum of the selected elements is returned as the total cost.\\n\\n# Explanation\\n\\n1. Initialize two pointers, \"i\" and \"j,\" to the start and end indices of the \"costs\" vector, respectively.\\n2. Create two min-heap priority queues, \"left_k\" and \"right_k,\" using the \"priority_queue\" container in C++. These priority queues store integers and are sorted in ascending order.\\n3. Iterate from index 0 to \"candidates - 1\" and push the corresponding elements from the \"costs\" vector into the \"left_k\" priority queue.\\n4. Decrease \"i\" by 1 to point to the last inserted element in \"left_k.\"\\n5. Iterate from \"j\" to \"i + 1\" (inclusive) while \"j\" is greater than \"i\" and not less than \"costs.size() - candidates.\" In each iteration, push the corresponding elements from the \"costs\" vector into the \"right_k\" priority queue and decrease \"j\" by 1.\\n6. Increase \"j\" by 1 to point to the last inserted element in \"right_k.\"\\n7. Initialize a variable \"ans\" to store the total cost, initially set to 0.\\n8. While \"i\" is less than or equal to \"j\" and \"k\" is not zero, do the following:\\na. Get the minimum element from \"left_k\" and \"right_k\" by accessing the top element using the \"top()\" function.\\nb. Compare the minimum values, \"x1\" from \"left_k\" and \"x2\" from \"right_k.\"\\nc. If \"x1\" is less than or equal to \"x2,\" add \"x1\" to \"ans,\" remove the top element from \"left_k,\" increase \"i\" by 1, and if \"i\" is less than \"j,\" push the corresponding element from the \"costs\" vector into \"left_k.\"\\nd. If \"x2\" is less than \"x1,\" add \"x2\" to \"ans,\" remove the top element from \"right_k,\" decrease \"j\" by 1, and if \"i\" is less than \"j,\" push the corresponding element from the \"costs\" vector into \"right_k.\"\\ne. Decrease \"k\" by 1.\\n9. After the above loop ends, there might be remaining iterations for \"k.\" So, while \"k\" is not zero, do the following:\\na. Get the minimum element from \"left_k\" and \"right_k\" using the same logic as before.\\nb. Compare the minimum values, \"x1\" from \"left_k\" and \"x2\" from \"right_k.\"\\nc. If \"x1\" is less than or equal to \"x2,\" add \"x1\" to \"ans\" and remove the top element from \"left_k.\"\\nd. If \"x2\" is less than \"x1,\" add \"x2\" to \"ans\" and remove the top element from \"right_k.\"\\ne. Decrease \"k\" by 1.\\n10. Return the final value of \"ans\" as the total cost.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.size()-1;\\n        priority_queue<int,vector<int>,greater<int>> left_k;\\n        priority_queue<int,vector<int>,greater<int>> right_k;\\n\\n        while(i < candidates){\\n            left_k.push(costs[i]);\\n            i++;\\n        }\\n        i--;\\n        while(j > i and j >= costs.size()-candidates){\\n            right_k.push(costs[j]);\\n            j--;\\n        }\\n        j++;\\n\\n        long long ans = 0;\\n\\n        while(i < j and k != 0){\\n            int x1 = INT_MAX;\\n            if(!left_k.empty()) x1 = left_k.top();\\n            \\n            int x2 = INT_MAX;\\n            if(!right_k.empty()) x2 = right_k.top();\\n\\n            if(x1 <= x2){\\n                ans += x1;\\n                left_k.pop();\\n                i++;\\n                if(i < j) left_k.push(costs[i]);\\n            }        \\n            else{\\n                ans += x2;\\n                right_k.pop();\\n                j--;\\n                if(i < j) right_k.push(costs[j]);\\n            }    \\n            k--;\\n        }\\n\\n        while(k != 0){\\n            int x1 = INT_MAX;\\n            if(!left_k.empty()) x1 = left_k.top();\\n            \\n            int x2 = INT_MAX;\\n            if(!right_k.empty()) x2 = right_k.top();\\n            \\n\\n            if(x1 <= x2){\\n                ans += x1;\\n                left_k.pop();\\n            }        \\n            else{\\n                ans += x2;\\n                right_k.pop();\\n            }    \\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.size()-1;\\n        priority_queue<int,vector<int>,greater<int>> left_k;\\n        priority_queue<int,vector<int>,greater<int>> right_k;\\n\\n        while(i < candidates){\\n            left_k.push(costs[i]);\\n            i++;\\n        }\\n        i--;\\n        while(j > i and j >= costs.size()-candidates){\\n            right_k.push(costs[j]);\\n            j--;\\n        }\\n        j++;\\n\\n        long long ans = 0;\\n\\n        while(i < j and k != 0){\\n            int x1 = INT_MAX;\\n            if(!left_k.empty()) x1 = left_k.top();\\n            \\n            int x2 = INT_MAX;\\n            if(!right_k.empty()) x2 = right_k.top();\\n\\n            if(x1 <= x2){\\n                ans += x1;\\n                left_k.pop();\\n                i++;\\n                if(i < j) left_k.push(costs[i]);\\n            }        \\n            else{\\n                ans += x2;\\n                right_k.pop();\\n                j--;\\n                if(i < j) right_k.push(costs[j]);\\n            }    \\n            k--;\\n        }\\n\\n        while(k != 0){\\n            int x1 = INT_MAX;\\n            if(!left_k.empty()) x1 = left_k.top();\\n            \\n            int x2 = INT_MAX;\\n            if(!right_k.empty()) x2 = right_k.top();\\n            \\n\\n            if(x1 <= x2){\\n                ans += x1;\\n                left_k.pop();\\n            }        \\n            else{\\n                ans += x2;\\n                right_k.pop();\\n            }    \\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685852,
                "title": "daily-coding-challenge-java-using-priority-queue-heap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }\\n            while (pq2.size() < candidates && i <= j) {\\n                pq2.offer(costs[j--]);\\n            }\\n\\n            int t1 = pq1.size() > 0 ? pq1.peek() : Integer.MAX_VALUE;\\n            int t2 = pq2.size() > 0 ? pq2.peek() : Integer.MAX_VALUE;\\n\\n            if (t1 <= t2) {\\n                ans += t1;\\n                pq1.poll();\\n            } else {\\n                ans += t2;\\n                pq2.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685558,
                "title": "beats-100-with-explained-approach-c-java-python",
                "content": "# Intuition\\nThe code aims to calculate the total cost of an operation by utilizing a priority queue and a map. The priority queue is used to store pairs of elements, where the first element represents the negative cost, and the second element indicates the type of the element (0 or 1). The map is used to keep track of the elements.\\n\\n# Approach\\nIt initializes the priority queue and map with the first c elements of the cost vector. Then, it iterates over the remaining elements, updating the priority queue and map accordingly. Finally, it performs k iterations, adding the negative costs from the priority queue to the total cost and adjusting the queue and map based on the element type. The time complexity is O(k log c), where k is the number of iterations and c is a parameter.\\n\\n# Complexity : O(k*logc)\\n\\n# Space complexity: O(c+k)\\n\\n# Code\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int k, int c) {\\n        priority_queue<pair<int,int>>pq;\\n        map<int,int>m;\\n        for(int i=0;i<c;i++){\\n            m[i]++;\\n            pq.push({-cost[i],1});\\n        }\\n        int i=cost.size()-1;\\n        for(int j=0;j<c;j++){\\n            if(m[i]==0){\\n                m[i]++;\\n                pq.push({-cost[i],0});\\n                i--;\\n            }\\n            else break;\\n        }\\n        int l = c;\\n        int r = cost.size()-1-c;\\n        long long ans=0;\\n        for(int j=0;j<k;j++){\\n            ans += abs(pq.top().first);\\n            int h = pq.top().second;\\n            pq.pop();\\n            if(h){\\n                if(m[l]==0 && l<cost.size()){\\n                    m[l]++;\\n                    pq.push({-cost[l],1});\\n                    l++;\\n                }\\n            } \\n            else{\\n                 if(m[r]==0 && r>=0){\\n                    m[r]++;\\n                    pq.push({-cost[r],0});\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int k, int c) {\\n        priority_queue<pair<int,int>>pq;\\n        map<int,int>m;\\n        for(int i=0;i<c;i++){\\n            m[i]++;\\n            pq.push({-cost[i],1});\\n        }\\n        int i=cost.size()-1;\\n        for(int j=0;j<c;j++){\\n            if(m[i]==0){\\n                m[i]++;\\n                pq.push({-cost[i],0});\\n                i--;\\n            }\\n            else break;\\n        }\\n        int l = c;\\n        int r = cost.size()-1-c;\\n        long long ans=0;\\n        for(int j=0;j<k;j++){\\n            ans += abs(pq.top().first);\\n            int h = pq.top().second;\\n            pq.pop();\\n            if(h){\\n                if(m[l]==0 && l<cost.size()){\\n                    m[l]++;\\n                    pq.push({-cost[l],1});\\n                    l++;\\n                }\\n            } \\n            else{\\n                 if(m[r]==0 && r>=0){\\n                    m[r]++;\\n                    pq.push({-cost[r],0});\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685124,
                "title": "java-single-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Instead of adding the cost values directly to the heap, we could just add their indices and adjust the comparator accordingly. \\n- This eliminates the need for 2 priority queues or having additional information in the priority queue.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int c) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(\\n            (a,b) -> costs[a] == costs[b] ? a - b : costs[a] - costs[b]\\n        ); \\n        long total = 0;\\n        int n = costs.length, i = 0, j = n-1;\\n\\n        // c => candidates\\n        while (i < c) {\\n            pq.add(i++);\\n        }\\n        while (j >= i && j + c >= n) {\\n            pq.add(j--);\\n        }\\n\\n        while (k-->0) {\\n            int index = pq.poll();\\n            total += costs[index];\\n            if (i > j) {\\n                continue;\\n            }\\n            if (index < i) {\\n                pq.add(i++);\\n            }\\n            else {\\n                pq.add(j--);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int c) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(\\n            (a,b) -> costs[a] == costs[b] ? a - b : costs[a] - costs[b]\\n        ); \\n        long total = 0;\\n        int n = costs.length, i = 0, j = n-1;\\n\\n        // c => candidates\\n        while (i < c) {\\n            pq.add(i++);\\n        }\\n        while (j >= i && j + c >= n) {\\n            pq.add(j--);\\n        }\\n\\n        while (k-->0) {\\n            int index = pq.poll();\\n            total += costs[index];\\n            if (i > j) {\\n                continue;\\n            }\\n            if (index < i) {\\n                pq.add(i++);\\n            }\\n            else {\\n                pq.add(j--);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685051,
                "title": "c-beginner-friendly-priority-queue-heap-beats-100-o-klogn",
                "content": "# Intuition:\\nThe code calculates the total cost of selecting candidates from both ends of the \"costs\" vector, where the number of candidates selected from each end is determined by the variable \"candidates.\" The selection process is repeated \"k\" times, and the cost is accumulated based on the minimum cost among the available candidates at each step.\\n\\n# Approach:\\n1. Initialize two priority queues, \"pq1\" and \"pq2,\" to store the candidates from the beginning and end of the \"costs\" vector, respectively. The priority queues are implemented as min heaps, ensuring that the minimum cost is always at the top.\\n2. Initialize the total cost \"cost\" to 0.\\n3. Set two pointers, \"i\" and \"j,\" to the beginning and end indices of the \"costs\" vector, respectively.\\n4. Repeat the following steps \"k\" times:\\n   - While the size of \"pq1\" is less than \"candidates\" and \"i\" is less than or equal to \"j,\" push the cost at index \"i\" into \"pq1\" and increment \"i.\"\\n   - While the size of \"pq2\" is less than \"candidates\" and \"i\" is less than or equal to \"j,\" push the cost at index \"j\" into \"pq2\" and decrement \"j.\"\\n   - Get the minimum cost from \"pq1\" and \"pq2\" by accessing the top elements of the priority queues. If either priority queue is empty, assign it the maximum integer value (INT_MAX).\\n   - Compare the minimum costs from \"pq1\" and \"pq2\" and select the smaller one.\\n   - Add the selected minimum cost to the total cost \"cost.\"\\n   - Pop the selected minimum cost from the respective priority queue.\\n5. Return the total cost \"cost.\"\\n\\n# Time Complexity:\\nThe time complexity of this code is O(k log n), where n is the size of the \"costs\" vector. The main loop runs \"k\" times, and each iteration involves pushing elements into the priority queues, which takes O(log n) time. Additionally, accessing the top elements and popping from the priority queues also take O(log n) time. Therefore, the overall time complexity is O(k log n).\\n\\n# Space Complexity:\\nThe space complexity of this code is O(candidates), as the size of the priority queues \"pq1\" and \"pq2\" is determined by the variable \"candidates.\" In the worst case, if \"candidates\" is equal to n/2, where n is the size of the \"costs\" vector, the space complexity becomes O(n/2), which simplifies to O(n) asymptotically.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        long long cost = 0;\\n        \\n        int i=0;\\n        int j = costs.size() - 1;\\n        while(k--)\\n        {\\n            while(pq1.size() < candidates && i<=j)\\n                pq1.push(costs[i++]);\\n            \\n            while(pq2.size() < candidates && i<=j)\\n                pq2.push(costs[j--]);\\n            \\n            int minLeft = pq1.size()>0 ? pq1.top() : INT_MAX;\\n            int minRight = pq2.size()>0 ? pq2.top() : INT_MAX;\\n\\n            if(minLeft <= minRight)\\n            {\\n                cost+=minLeft;\\n                pq1.pop();\\n            }\\n            else{\\n                cost+=minRight;\\n                pq2.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        long long cost = 0;\\n        \\n        int i=0;\\n        int j = costs.size() - 1;\\n        while(k--)\\n        {\\n            while(pq1.size() < candidates && i<=j)\\n                pq1.push(costs[i++]);\\n            \\n            while(pq2.size() < candidates && i<=j)\\n                pq2.push(costs[j--]);\\n            \\n            int minLeft = pq1.size()>0 ? pq1.top() : INT_MAX;\\n            int minRight = pq2.size()>0 ? pq2.top() : INT_MAX;\\n\\n            if(minLeft <= minRight)\\n            {\\n                cost+=minLeft;\\n                pq1.pop();\\n            }\\n            else{\\n                cost+=minRight;\\n                pq2.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684699,
                "title": "c-easiest-youtube-explanation-codestorywithmik",
                "content": "YouTube Video - [Total Cost to Hire K Workers](https://www.youtube.com/watch?v=ODuICq8exLo)\\nMy Github Treasure - [Total Cost to Hire K Workers](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Heap/Total%20Cost%20to%20Hire%20K%20Workers.cpp)\\n\\n```\\n//Using 2 Heaps - O(k*log(candidates)\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n        \\n        long long ans = 0;\\n        \\n        int hired = 0;\\n        int i = 0;\\n        int j = n-1;\\n        \\n        while(hired < k){\\n            \\n            while(pq1.size() < candidates && i<=j) \\n                pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) \\n                pq2.push(costs[j--]);\\n            \\n            \\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n            \\n            if(a <= b){\\n                ans += a;\\n                pq1.pop();\\n            } else {\\n                ans += b;\\n                pq2.pop();\\n            }\\n            \\n            hired++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Using 2 Heaps - O(k*log(candidates)\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n        \\n        long long ans = 0;\\n        \\n        int hired = 0;\\n        int i = 0;\\n        int j = n-1;\\n        \\n        while(hired < k){\\n            \\n            while(pq1.size() < candidates && i<=j) \\n                pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) \\n                pq2.push(costs[j--]);\\n            \\n            \\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n            \\n            if(a <= b){\\n                ans += a;\\n                pq1.pop();\\n            } else {\\n                ans += b;\\n                pq2.pop();\\n            }\\n            \\n            hired++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683879,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn this problem, we are supposed to find the minimum cost of hiring \\'k\\' employees under the given constraints. After a careful consideration of the constraints and rules, we decide to use two min-heaps (a min-heap is a priority queue on which whenever we perform a pop operation, we get the minimum element of the heap).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution is as follows:\\n1) First we create priority queues start and end to store the costs from the start and end of the costs vector, respectively.\\n\\n2) Then we initialize pointers i and j to the start and end of the costs vector.\\n\\n\\n\\n3) Next, we fill start and end priority queues with candidate costs.\\n\\n4) Then, we compare the top elements of start and end queues, select the lower cost candidate, and add the cost to res.\\n\\n5) At last, we remove the selected candidate from the respective priority queue.\\n<!-- Describe your approach to solving the problem. -->\\n6) We perform the above steps until \\'k\\' workers are hired or in simple terms, for \\'k\\' iterations. \\n\\n# Complexity\\n- Time complexity:O(KlogK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> start,end;\\n        int i=0,j=costs.size()-1,count=0;\\n        long long res=0;\\n        while(count<k){\\n            while(start.size()<candidates and i<=j) start.push(costs[i++]);\\n            while(end.size()<candidates and j>=i) end.push(costs[j--]);\\n\\n            int startCandidatesCost=start.size()>0 ? start.top() : INT_MAX;\\n            int endCandidatesCost=end.size()>0 ? end.top() : INT_MAX;\\n            if(startCandidatesCost<=endCandidatesCost){\\n                res+=startCandidatesCost;\\n                start.pop();\\n            } else {\\n                res+=endCandidatesCost;\\n                end.pop();\\n            }\\n            count++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> start,end;\\n        int i=0,j=costs.size()-1,count=0;\\n        long long res=0;\\n        while(count<k){\\n            while(start.size()<candidates and i<=j) start.push(costs[i++]);\\n            while(end.size()<candidates and j>=i) end.push(costs[j--]);\\n\\n            int startCandidatesCost=start.size()>0 ? start.top() : INT_MAX;\\n            int endCandidatesCost=end.size()>0 ? end.top() : INT_MAX;\\n            if(startCandidatesCost<=endCandidatesCost){\\n                res+=startCandidatesCost;\\n                start.pop();\\n            } else {\\n                res+=endCandidatesCost;\\n                end.pop();\\n            }\\n            count++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683628,
                "title": "c-multiset-solution-straightforward-and-explained-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& v, int k, int tc) { //tc- candidates\\n        int n=v.size();\\n        long long ans=0;\\n        int i=0, j=n-1;\\n        multiset<int> a1, b1;\\n        while(i<=j) {\\n            if(i==tc) break;   //if tc is reached then we can break\\n            a1.insert(v[i++]);\\n            if(i>j) break; //so that multiple occurence doesn\\'t occur\\n            b1.insert(v[j--]); \\n        }\\n        while(k--) {\\n            if(a1.empty()) {  //possible that all the smallest value are in a1 and it becomes empty at some point\\n                ans+=*b1.begin();  //like 1 2 3 4 5 and k=5, tc=1, so it will become empty as all the small values will get erase\\n                b1.erase(b1.begin());\\n                continue;\\n            }\\n            if(b1.empty()) {  // same logic as above\\n                ans+=*a1.begin(); \\n                a1.erase(a1.begin());\\n                continue;\\n            }\\n            if(*a1.begin()<=*b1.begin()) { //for smaller value in both (using \\'=\\' to get smallest index i.e from a1(left)\\n                ans+=(*a1.begin());\\n                a1.erase(a1.begin());\\n                if(i<=j)\\n                a1.insert(v[i++]);\\n            }\\n            else{  //this is the only option to choose from end\\n                ans+=(*b1.begin());\\n                b1.erase(b1.begin());\\n                if(i<=j)\\n                b1.insert(v[j--]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long totalCost(vector<int>& v, int k, int tc) { //tc- candidates\\n        int n=v.size();\\n        long long ans=0;\\n        int i=0, j=n-1;\\n        multiset<int> a1, b1;\\n        while(i<=j) {\\n            if(i==tc) break;   //if tc is reached then we can break\\n            a1.insert(v[i++]);\\n            if(i>j) break; //so that multiple occurence doesn\\'t occur\\n            b1.insert(v[j--]); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3683618,
                "title": "javascript-code-for-hiring-workers-with-lowest-cost-using-min-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution to the problem using a priority queue **(min-heap)** to keep track of the workers\\' costs and indices.\\n\\nThe goal is to hire exactly **k** workers according to the given rules. The solution constructs a min-heap to keep track of the workers\\' costs and indices, where the worker with the lowest cost will have the highest priority in the heap. The tie-breaking rule is also considered, as the worker with the smallest index among those with the lowest cost is selected.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a min-heap priority queue (pq) with a custom comparison function. The function compares the costs of two workers. If the costs are different, it sorts them based on the lowest cost. If the costs are the same, it breaks the tie by selecting the worker with the smallest index.\\n2. Set the left pointer (l) to 0 and the right pointer (r) to n - 1, where n is the length of the costs array.\\n3. Enqueue m workers into the priority queue. These workers are selected from the beginning and end of the costs array, considering the first m candidates.\\n4. Iterate k times to hire k workers:\\n    - Dequeue a worker from the priority queue (pq) and add its cost to the total cost (res).\\n    - Check if the dequeued worker\\'s index is less than l and if there are still available workers to the left. If true, enqueue the next worker from the left side into the priority queue.\\n    - Otherwise, if the dequeued worker\\'s index is greater than r and there are still available workers to the right, enqueue the next worker from the right side into the priority queue.\\n5. Return the total cost (res).\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O((k + m) log m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m)$$\\n# Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nconst totalCost = (costs, k, m) => {\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    let n = costs.length, l = 0, r = n - 1, res = 0;\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([costs[l], l]);\\n            l++;\\n        }\\n    }\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([costs[r], r]);\\n            r--;\\n        }\\n    }\\n    for (let i = 0; i < k; i++) {\\n        let current = pq.dequeue();\\n        res += current[0];\\n        if (current[1] < l && l <= r) {\\n            pq.enqueue([costs[l], l]);\\n            l++;\\n        } else if (current[1] > r && l <= r) {\\n            pq.enqueue([costs[r], r]);\\n            r--;\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![Untitled.jpg](https://assets.leetcode.com/users/images/4593b500-0ddf-42d5-a287-c1563b0d22db_1687758257.9905384.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nconst totalCost = (costs, k, m) => {\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    let n = costs.length, l = 0, r = n - 1, res = 0;\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([costs[l], l]);\\n            l++;\\n        }\\n    }\\n    for (let i = 0; i < m; i++) {\\n        if (l <= r) {\\n            pq.enqueue([costs[r], r]);\\n            r--;\\n        }\\n    }\\n    for (let i = 0; i < k; i++) {\\n        let current = pq.dequeue();\\n        res += current[0];\\n        if (current[1] < l && l <= r) {\\n            pq.enqueue([costs[l], l]);\\n            l++;\\n        } else if (current[1] > r && l <= r) {\\n            pq.enqueue([costs[r], r]);\\n            r--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683547,
                "title": "python-short-and-clean-heap-priority-queue-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial Solution. Approach 2](https://leetcode.com/problems/total-cost-to-hire-k-workers/editorial/) but shorter and cleaner..\\n\\n# Complexity\\n- Time complexity: $$O(m + k * log(m))$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere, `m = candidates`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        l, r = candidates, n - candidates - 1\\n\\n        l_bucket = zip(range(l), repeat(0))\\n        r_bucket = zip(range(max(l, r + 1), n), repeat(1))\\n\\n        hq = [(costs[idx], bucket) for idx, bucket in chain(l_bucket, r_bucket)]\\n        heapq.heapify(hq)\\n\\n        cost = 0\\n        for _ in range(k):\\n            c, b = heapq.heappop(hq)\\n            cost += c\\n\\n            if l > r: continue\\n\\n            idx = (l, r)[b]\\n            l, r = (l, r - 1) if b else (l + 1, r)\\n            heapq.heappush(hq, (costs[idx], b))\\n        \\n        return cost\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        l, r = candidates, n - candidates - 1\\n\\n        l_bucket = zip(range(l), repeat(0))\\n        r_bucket = zip(range(max(l, r + 1), n), repeat(1))\\n\\n        hq = [(costs[idx], bucket) for idx, bucket in chain(l_bucket, r_bucket)]\\n        heapq.heapify(hq)\\n\\n        cost = 0\\n        for _ in range(k):\\n            c, b = heapq.heappop(hq)\\n            cost += c\\n\\n            if l > r: continue\\n\\n            idx = (l, r)[b]\\n            l, r = (l, r - 1) if b else (l + 1, r)\\n            heapq.heappush(hq, (costs[idx], b))\\n        \\n        return cost\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683242,
                "title": "c-priority-queue",
                "content": "# Code\\n```\\n//writing comparation class for our priority queue\\nclass compar{\\n     public:\\n     bool operator()(pair<int,int> &a , pair<int,int> &b)\\n      {\\n              if(a.first == b.first)\\n                {\\n                     return a.second > b.second;\\n                }\\n              else \\n                     return a.first > b.first;\\n      }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n          long long int result = 0;\\n          int n = costs.size();\\n\\n        //storing element and index both so to deal with same valued element\\n          priority_queue<pair<int,int> ,vector<pair<int,int>> , compar> pq1 , pq2;\\n\\n\\n          for(int i = 0 ; i < candidates ; i++)\\n          {   \\n\\n              if(costs[i]==INT_MAX || costs[n-i-1]==INT_MAX)break;\\n              pq1.push({costs[i] , i});\\n              pq2.push({costs[n-1-i] , n - i - 1});\\n\\n            //changing cost of ith worker so that the are inserted in priority queue , to reduce time complexity\\n              costs[i] = INT_MAX;\\n              costs[n-1-i] = INT_MAX;\\n          }\\n\\n\\n          int last = n - 1 - candidates; //for further we take out from pq2 we have to insert in it from last;\\n\\n          int first = candidates; //same for pq1\\n\\n\\n          for(int i = 0 ; i < k; i++)\\n          {     \\n                pair<int,int> temp1; \\n                pair<int,int> temp2;\\n\\n                //if no element in any queue we set it to maximum\\n                if(pq1.size()){\\n                    temp1 = pq1.top();\\n                }\\n                else{\\n                    temp1 = {INT_MAX,INT_MAX};\\n                }\\n                if(pq2.size())\\n                {\\n                    temp2 = pq2.top();\\n                }\\n                else{\\n                    temp2 = {INT_MAX,INT_MAX};\\n                }\\n\\n\\n\\n                if(temp2.first < temp1.first)\\n                {\\n                    pq2.pop();\\n                    result += temp2.first;\\n                    if(last>=0 && costs[last]!=INT_MAX){\\n                        pq2.push({costs[last] , last});\\n                        costs[last] = INT_MAX;\\n                    }\\n                    last--;\\n                }\\n                else\\n                {    \\n                    //to check if we encounter same worker\\n                    if(temp1.first == temp2.first && temp1.second == temp2.second){\\n                        pq2.pop();\\n                        if(last>=0 && costs[last]!=INT_MAX){\\n                            pq2.push({costs[last] , last});\\n                            costs[last] = INT_MAX;\\n                            last--;\\n                        }\\n                    }\\n                    pq1.pop();\\n                    result += temp1.first;\\n                    if(first < n && costs[first]!=INT_MAX){\\n                        pq1.push({costs[first] , first});\\n                        costs[first] = INT_MAX;\\n                    }\\n                    first++;\\n                }\\n          }\\n\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//writing comparation class for our priority queue\\nclass compar{\\n     public:\\n     bool operator()(pair<int,int> &a , pair<int,int> &b)\\n      {\\n              if(a.first == b.first)\\n                {\\n                     return a.second > b.second;\\n                }\\n              else \\n                     return a.first > b.first;\\n      }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n          long long int result = 0;\\n          int n = costs.size();\\n\\n        //storing element and index both so to deal with same valued element\\n          priority_queue<pair<int,int> ,vector<pair<int,int>> , compar> pq1 , pq2;\\n\\n\\n          for(int i = 0 ; i < candidates ; i++)\\n          {   \\n\\n              if(costs[i]==INT_MAX || costs[n-i-1]==INT_MAX)break;\\n              pq1.push({costs[i] , i});\\n              pq2.push({costs[n-1-i] , n - i - 1});\\n\\n            //changing cost of ith worker so that the are inserted in priority queue , to reduce time complexity\\n              costs[i] = INT_MAX;\\n              costs[n-1-i] = INT_MAX;\\n          }\\n\\n\\n          int last = n - 1 - candidates; //for further we take out from pq2 we have to insert in it from last;\\n\\n          int first = candidates; //same for pq1\\n\\n\\n          for(int i = 0 ; i < k; i++)\\n          {     \\n                pair<int,int> temp1; \\n                pair<int,int> temp2;\\n\\n                //if no element in any queue we set it to maximum\\n                if(pq1.size()){\\n                    temp1 = pq1.top();\\n                }\\n                else{\\n                    temp1 = {INT_MAX,INT_MAX};\\n                }\\n                if(pq2.size())\\n                {\\n                    temp2 = pq2.top();\\n                }\\n                else{\\n                    temp2 = {INT_MAX,INT_MAX};\\n                }\\n\\n\\n\\n                if(temp2.first < temp1.first)\\n                {\\n                    pq2.pop();\\n                    result += temp2.first;\\n                    if(last>=0 && costs[last]!=INT_MAX){\\n                        pq2.push({costs[last] , last});\\n                        costs[last] = INT_MAX;\\n                    }\\n                    last--;\\n                }\\n                else\\n                {    \\n                    //to check if we encounter same worker\\n                    if(temp1.first == temp2.first && temp1.second == temp2.second){\\n                        pq2.pop();\\n                        if(last>=0 && costs[last]!=INT_MAX){\\n                            pq2.push({costs[last] , last});\\n                            costs[last] = INT_MAX;\\n                            last--;\\n                        }\\n                    }\\n                    pq1.pop();\\n                    result += temp1.first;\\n                    if(first < n && costs[first]!=INT_MAX){\\n                        pq1.push({costs[first] , first});\\n                        costs[first] = INT_MAX;\\n                    }\\n                    first++;\\n                }\\n          }\\n\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683119,
                "title": "priority-queue-custom-implementation",
                "content": "# Approach\\n***TODO***\\n\\n# Time Complexity\\n***TODO***\\n\\n# Space complexity\\n***TODO***\\n\\n# Solution\\n```swift\\nclass Solution {\\n    func totalCost(_ costs: [Int], _ k: Int, _ candidates: Int) -> Int {\\n        let n = costs.count\\n        var queue: PriorityQueue<(Int, Int)> = PriorityQueue(sort: { (a, b) -> Bool in\\n            if a.0 == b.0 { return a.1 < b.1 }\\n            else { return a.0 < b.0 }\\n        })\\n        \\n        if 2 * candidates >= n {\\n            for i in 0..<n {\\n                queue.enqueue((costs[i], 0))\\n            }\\n        } else {\\n            for i in 0..<candidates {\\n                queue.enqueue((costs[i], 0))\\n                queue.enqueue((costs[n - 1 - i], 1))\\n            }\\n        }\\n        \\n        var l = candidates\\n        var r = n - 1 - candidates\\n        var cost = 0\\n\\n        for _ in 0..<k {\\n            let a = queue.dequeue()!\\n            cost += a.0\\n            if l > r { continue }\\n\\n            if a.1 == 0 {\\n                queue.enqueue((costs[l], 0))\\n                l += 1\\n            } else {\\n                queue.enqueue((costs[r], 1))\\n                r -= 1\\n            }\\n        }\\n        return cost\\n    }\\n}\\n\\nstruct PriorityQueue<T> {\\n    private var heap: Heap<T>\\n    \\n    init(sort: @escaping (T, T) -> Bool) {\\n        heap = Heap(sort: sort)\\n    }\\n    \\n    var isEmpty: Bool {\\n        heap.isEmpty\\n    }\\n    \\n    mutating func enqueue(_ element: T) {\\n        heap.insert(element)\\n    }\\n    \\n    mutating func dequeue() -> T? {\\n        heap.remove()\\n    }\\n}\\n\\nstruct Heap<T> {  \\n    var nodes = [T]()\\n    private var orderCriteria: (T, T) -> Bool\\n  \\n    init(sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n    }\\n  \\n    init(array: [T], sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n        configureHeap(from: array)\\n    }\\n  \\n    mutating func configureHeap(from array: [T]) {\\n        nodes = array\\n        for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n            shiftDown(i)\\n        }\\n    }\\n  \\n    var isEmpty: Bool { \\n        nodes.isEmpty\\n    }\\n  \\n    var count: Int {\\n        nodes.count\\n    }\\n  \\n    @inline(__always) \\n    func parentIndex(ofIndex i: Int) -> Int {\\n        (i - 1) / 2\\n    }\\n\\n    @inline(__always) \\n    func leftChildIndex(ofIndex i: Int) -> Int {\\n        return 2 * i + 1\\n    }\\n \\n    @inline(__always) \\n    func rightChildIndex(ofIndex i: Int) -> Int {\\n        return 2 * i + 2\\n    }\\n  \\n    func peek() -> T? {\\n        return nodes.first\\n    }\\n  \\n    mutating func insert(_ value: T) {\\n        nodes.append(value)\\n        shiftUp(nodes.count - 1)\\n    }\\n  \\n    mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n        for value in sequence { insert(value) }\\n    }\\n  \\n    mutating func replace(index i: Int, value: T) {\\n        guard i < nodes.count else { return }    \\n        remove(at: i)\\n        insert(value)\\n    }\\n  \\n    @discardableResult \\n    mutating func remove() -> T? {\\n        guard !nodes.isEmpty else { return nil }      \\n        if nodes.count == 1 {\\n            return nodes.removeLast()\\n        } else {\\n            let value = nodes[0]\\n            nodes[0] = nodes.removeLast()\\n            shiftDown(0)\\n            return value\\n        }\\n    }\\n  \\n    @discardableResult \\n    mutating func remove(at index: Int) -> T? {\\n        guard index < nodes.count else { return nil }\\n        let size = nodes.count - 1\\n\\n        if index != size {\\n            nodes.swapAt(index, size)\\n            shiftDown(from: index, until: size)\\n            shiftUp(index)\\n        }\\n        return nodes.removeLast()\\n    }\\n  \\n    mutating func shiftUp(_ index: Int) {\\n        var childIndex = index\\n        let child = nodes[childIndex]\\n        var parentIndex = self.parentIndex(ofIndex: childIndex)\\n        \\n        while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n            nodes[childIndex] = nodes[parentIndex]\\n            childIndex = parentIndex\\n            parentIndex = self.parentIndex(ofIndex: childIndex)\\n        }\\n        \\n        nodes[childIndex] = child\\n    }\\n  \\n    mutating func shiftDown(from index: Int, until endIndex: Int) {\\n        let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n        let rightChildIndex = leftChildIndex + 1\\n        \\n        var first = index\\n        if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n            first = leftChildIndex\\n        }\\n        if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n            first = rightChildIndex\\n        }\\n        if first == index { return }\\n        \\n        nodes.swapAt(index, first)\\n        shiftDown(from: first, until: endIndex)\\n    }\\n  \\n    mutating func shiftDown(_ index: Int) {\\n        shiftDown(from: index, until: nodes.count)\\n    }\\n}\\n\\nextension Heap where T: Equatable {\\n    func index(of node: T) -> Int? {\\n        return nodes.index(where: { $0 == node })\\n    }\\n\\n    @discardableResult \\n    mutating func remove(node: T) -> T? {\\n        if let index = index(of: node) {\\n            return remove(at: index)\\n        }\\n        return nil\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```swift\\nclass Solution {\\n    func totalCost(_ costs: [Int], _ k: Int, _ candidates: Int) -> Int {\\n        let n = costs.count\\n        var queue: PriorityQueue<(Int, Int)> = PriorityQueue(sort: { (a, b) -> Bool in\\n            if a.0 == b.0 { return a.1 < b.1 }\\n            else { return a.0 < b.0 }\\n        })\\n        \\n        if 2 * candidates >= n {\\n            for i in 0..<n {\\n                queue.enqueue((costs[i], 0))\\n            }\\n        } else {\\n            for i in 0..<candidates {\\n                queue.enqueue((costs[i], 0))\\n                queue.enqueue((costs[n - 1 - i], 1))\\n            }\\n        }\\n        \\n        var l = candidates\\n        var r = n - 1 - candidates\\n        var cost = 0\\n\\n        for _ in 0..<k {\\n            let a = queue.dequeue()!\\n            cost += a.0\\n            if l > r { continue }\\n\\n            if a.1 == 0 {\\n                queue.enqueue((costs[l], 0))\\n                l += 1\\n            } else {\\n                queue.enqueue((costs[r], 1))\\n                r -= 1\\n            }\\n        }\\n        return cost\\n    }\\n}\\n\\nstruct PriorityQueue<T> {\\n    private var heap: Heap<T>\\n    \\n    init(sort: @escaping (T, T) -> Bool) {\\n        heap = Heap(sort: sort)\\n    }\\n    \\n    var isEmpty: Bool {\\n        heap.isEmpty\\n    }\\n    \\n    mutating func enqueue(_ element: T) {\\n        heap.insert(element)\\n    }\\n    \\n    mutating func dequeue() -> T? {\\n        heap.remove()\\n    }\\n}\\n\\nstruct Heap<T> {  \\n    var nodes = [T]()\\n    private var orderCriteria: (T, T) -> Bool\\n  \\n    init(sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n    }\\n  \\n    init(array: [T], sort: @escaping (T, T) -> Bool) {\\n        self.orderCriteria = sort\\n        configureHeap(from: array)\\n    }\\n  \\n    mutating func configureHeap(from array: [T]) {\\n        nodes = array\\n        for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n            shiftDown(i)\\n        }\\n    }\\n  \\n    var isEmpty: Bool { \\n        nodes.isEmpty\\n    }\\n  \\n    var count: Int {\\n        nodes.count\\n    }\\n  \\n    @inline(__always) \\n    func parentIndex(ofIndex i: Int) -> Int {\\n        (i - 1) / 2\\n    }\\n\\n    @inline(__always) \\n    func leftChildIndex(ofIndex i: Int) -> Int {\\n        return 2 * i + 1\\n    }\\n \\n    @inline(__always) \\n    func rightChildIndex(ofIndex i: Int) -> Int {\\n        return 2 * i + 2\\n    }\\n  \\n    func peek() -> T? {\\n        return nodes.first\\n    }\\n  \\n    mutating func insert(_ value: T) {\\n        nodes.append(value)\\n        shiftUp(nodes.count - 1)\\n    }\\n  \\n    mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n        for value in sequence { insert(value) }\\n    }\\n  \\n    mutating func replace(index i: Int, value: T) {\\n        guard i < nodes.count else { return }    \\n        remove(at: i)\\n        insert(value)\\n    }\\n  \\n    @discardableResult \\n    mutating func remove() -> T? {\\n        guard !nodes.isEmpty else { return nil }      \\n        if nodes.count == 1 {\\n            return nodes.removeLast()\\n        } else {\\n            let value = nodes[0]\\n            nodes[0] = nodes.removeLast()\\n            shiftDown(0)\\n            return value\\n        }\\n    }\\n  \\n    @discardableResult \\n    mutating func remove(at index: Int) -> T? {\\n        guard index < nodes.count else { return nil }\\n        let size = nodes.count - 1\\n\\n        if index != size {\\n            nodes.swapAt(index, size)\\n            shiftDown(from: index, until: size)\\n            shiftUp(index)\\n        }\\n        return nodes.removeLast()\\n    }\\n  \\n    mutating func shiftUp(_ index: Int) {\\n        var childIndex = index\\n        let child = nodes[childIndex]\\n        var parentIndex = self.parentIndex(ofIndex: childIndex)\\n        \\n        while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n            nodes[childIndex] = nodes[parentIndex]\\n            childIndex = parentIndex\\n            parentIndex = self.parentIndex(ofIndex: childIndex)\\n        }\\n        \\n        nodes[childIndex] = child\\n    }\\n  \\n    mutating func shiftDown(from index: Int, until endIndex: Int) {\\n        let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n        let rightChildIndex = leftChildIndex + 1\\n        \\n        var first = index\\n        if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n            first = leftChildIndex\\n        }\\n        if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n            first = rightChildIndex\\n        }\\n        if first == index { return }\\n        \\n        nodes.swapAt(index, first)\\n        shiftDown(from: first, until: endIndex)\\n    }\\n  \\n    mutating func shiftDown(_ index: Int) {\\n        shiftDown(from: index, until: nodes.count)\\n    }\\n}\\n\\nextension Heap where T: Equatable {\\n    func index(of node: T) -> Int? {\\n        return nodes.index(where: { $0 == node })\\n    }\\n\\n    @discardableResult \\n    mutating func remove(node: T) -> T? {\\n        if let index = index(of: node) {\\n            return remove(at: index)\\n        }\\n        return nil\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683075,
                "title": "daily-leetcode-challenge-26-june",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(c+c+k)= O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n=costs.size();\\n        int l=0,r=n-1;\\n        //initialize min priority_queue\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n        //insert c number of element in queue from front\\n        while(l<=r && l<(c)){\\n            pq.push({costs[l],0});\\n            cout<<costs[l]<<\" \"<<\"l\"<<\"  \";\\n            l++;\\n        }\\n\\n        //insert c number of element in queue from back\\n        while(r>=l && pq.size()<2*c){\\n            pq.push({costs[r],1});\\n            cout<<costs[r]<<\" \"<<\"r\"<<\"  \";\\n            r--;\\n        }\\n\\n        //add min element in ans\\n        long long ans=0;\\n        while(k>0 && !pq.empty()){\\n            pair<int,int>f=pq.top();\\n            pq.pop();\\n            ans+=f.first;\\n            if(f.second==0 && l<=r){\\n                pq.push({costs[l],0});\\n                l++;\\n            }\\n            else if(f.second==1 && r>=l){\\n                pq.push({costs[r],1});\\n                r--;\\n            }\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n=costs.size();\\n        int l=0,r=n-1;\\n        //initialize min priority_queue\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n        //insert c number of element in queue from front\\n        while(l<=r && l<(c)){\\n            pq.push({costs[l],0});\\n            cout<<costs[l]<<\" \"<<\"l\"<<\"  \";\\n            l++;\\n        }\\n\\n        //insert c number of element in queue from back\\n        while(r>=l && pq.size()<2*c){\\n            pq.push({costs[r],1});\\n            cout<<costs[r]<<\" \"<<\"r\"<<\"  \";\\n            r--;\\n        }\\n\\n        //add min element in ans\\n        long long ans=0;\\n        while(k>0 && !pq.empty()){\\n            pair<int,int>f=pq.top();\\n            pq.pop();\\n            ans+=f.first;\\n            if(f.second==0 && l<=r){\\n                pq.push({costs[l],0});\\n                l++;\\n            }\\n            else if(f.second==1 && r>=l){\\n                pq.push({costs[r],1});\\n                r--;\\n            }\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3533618,
                "title": "c-priority-queue-pair-o-k-logn-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we wanted the candidate number of workers from both the ends and index also matter. Therefore, we needed the priority queue with a pair of integers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNeeded to take two pointers from both the ends to marks the index till we have taken the workers and from which part either from first or the last part the number is popped this will be known from the the two pointers\\n\\n# Complexity\\n- Time complexity: O(k*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& v, int k, int candidates) {\\n        int n=v.size();\\n        priority_queue<pair<int,int>,\\n        vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int l=candidates-1,r=n;\\n        for(int i=0;i<candidates;i++){\\n            pq.push({v[i],i});\\n        }\\n\\n        for(int i=n-1;i>l && (n-1-i)<candidates;i--){\\n            pq.push({v[i],i});\\n            r=i;\\n        }\\n        // cout<<l<<\" \"<<r<<endl;\\n        ll ans=0;\\n        while(k){\\n            ans+=pq.top().first;\\n            int idx=pq.top().second;\\n            pq.pop();\\n\\n            if(l+1<r){\\n                if(idx<=l){\\n                    l++;\\n                    pq.push({v[l],l});\\n                }\\n\\n                else{\\n                    r--;\\n                    pq.push({v[r],r});\\n                }\\n            }\\n\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& v, int k, int candidates) {\\n        int n=v.size();\\n        priority_queue<pair<int,int>,\\n        vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int l=candidates-1,r=n;\\n        for(int i=0;i<candidates;i++){\\n            pq.push({v[i],i});\\n        }\\n\\n        for(int i=n-1;i>l && (n-1-i)<candidates;i--){\\n            pq.push({v[i],i});\\n            r=i;\\n        }\\n        // cout<<l<<\" \"<<r<<endl;\\n        ll ans=0;\\n        while(k){\\n            ans+=pq.top().first;\\n            int idx=pq.top().second;\\n            pq.pop();\\n\\n            if(l+1<r){\\n                if(idx<=l){\\n                    l++;\\n                    pq.push({v[l],l});\\n                }\\n\\n                else{\\n                    r--;\\n                    pq.push({v[r],r});\\n                }\\n            }\\n\\n            k--;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467550,
                "title": "python-simple-clean-solution-using-heapq-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, size: int) -> int:\\n        ans = 0\\n        n = len(costs)\\n        q = []\\n        qq = []\\n        l, r = 0, n - 1\\n\\n        for _ in range(k):\\n            while len(q) < size and l <= r: heappush(q, costs[l]); l+=1\\n            while len(qq) < size and l <= r: heappush(qq, costs[r]); r-=1\\n\\n            a = q[0] if q else maxsize\\n            b = qq[0] if qq else maxsize\\n\\n            if a <= b: ans += a; heappop(q)\\n            else: ans += b; heappop(qq)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, size: int) -> int:\\n        ans = 0\\n        n = len(costs)\\n        q = []\\n        qq = []\\n        l, r = 0, n - 1\\n\\n        for _ in range(k):\\n            while len(q) < size and l <= r: heappush(q, costs[l]); l+=1\\n            while len(qq) < size and l <= r: heappush(qq, costs[r]); r-=1\\n\\n            a = q[0] if q else maxsize\\n            b = qq[0] if qq else maxsize\\n\\n            if a <= b: ans += a; heappop(q)\\n            else: ans += b; heappop(qq)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871461,
                "title": "python-2-heaps-beats-94-50",
                "content": "# Code\\n```\\nclass Solution:\\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n    front, end = [], []\\n    l, r = 0, len(costs) - 1\\n    cost = 0\\n\\n    while l < candidates:\\n      heapq.heappush(front, costs[l])\\n      l += 1\\n    \\n    while r >= max(l, len(costs) - candidates): \\n      heapq.heappush(end, costs[r])\\n      r -= 1\\n\\n    while k > 0 and front and end:\\n      if front[0] <= end[0]:\\n        cost += heappop(front)\\n        if l <= r: heappush(front, costs[l])\\n        l += 1\\n      else:\\n        cost += heappop(end)\\n        if r >= l: heappush(end, costs[r])\\n        r -= 1\\n      k -= 1\\n    \\n    while k > 0 and front: \\n      cost += heappop(front)\\n      k -= 1\\n\\n    while k > 0 and end: \\n      cost += heappop(end)\\n      k -= 1\\n\\n    return cost\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n    front, end = [], []\\n    l, r = 0, len(costs) - 1\\n    cost = 0\\n\\n    while l < candidates:\\n      heapq.heappush(front, costs[l])\\n      l += 1\\n    \\n    while r >= max(l, len(costs) - candidates): \\n      heapq.heappush(end, costs[r])\\n      r -= 1\\n\\n    while k > 0 and front and end:\\n      if front[0] <= end[0]:\\n        cost += heappop(front)\\n        if l <= r: heappush(front, costs[l])\\n        l += 1\\n      else:\\n        cost += heappop(end)\\n        if r >= l: heappush(end, costs[r])\\n        r -= 1\\n      k -= 1\\n    \\n    while k > 0 and front: \\n      cost += heappop(front)\\n      k -= 1\\n\\n    while k > 0 and end: \\n      cost += heappop(end)\\n      k -= 1\\n\\n    return cost\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793043,
                "title": "c-clean-and-small-code-min-heap-readable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        long long cost =0;\\n        int n = costs.size();\\n        priority_queue<int, vector<int> , greater<int>> ft, lt;\\n        int i=0, j=n-1;\\n       \\n        while(k--){\\n            \\n            while(ft.size() < cand && i<= j) ft.push(costs[i++]);\\n            while(lt.size() < cand && i<= j) lt.push(costs[j--]);\\n            \\n            int a = ft.size() ? ft.top() : INT_MAX;\\n            int b = lt.size() ? lt.top() : INT_MAX;\\n            \\n            if(a<=b){\\n                cost += a;\\n                ft.pop();\\n            }else{\\n                cost += b;\\n                lt.pop();\\n            }\\n        }\\n            \\n        \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        long long cost =0;\\n        int n = costs.size();\\n        priority_queue<int, vector<int> , greater<int>> ft, lt;\\n        int i=0, j=n-1;\\n       \\n        while(k--){\\n            \\n            while(ft.size() < cand && i<= j) ft.push(costs[i++]);\\n            while(lt.size() < cand && i<= j) lt.push(costs[j--]);\\n            \\n            int a = ft.size() ? ft.top() : INT_MAX;\\n            int b = lt.size() ? lt.top() : INT_MAX;\\n            \\n            if(a<=b){\\n                cost += a;\\n                ft.pop();\\n            }else{\\n                cost += b;\\n                lt.pop();\\n            }\\n        }\\n            \\n        \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790647,
                "title": "java-2-min-heaps-very-easy",
                "content": "```\\nclass Solution {\\n    public long totalCost(int[] arr, int k, int candidates) {\\n        \\n        int n = arr.length;\\n        long ans = 0;\\n        int leftbound = candidates;\\n        int rightbound = n-candidates-1;\\n        \\n        PriorityQueue<Integer> left = new PriorityQueue<>();\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        \\n        for(int i=0;i<candidates;i++)\\n            left.add(arr[i]);\\n        \\n        \\n        \\n         for(int i=n-1; i>=Math.max(candidates,n-candidates); i--)\\n             right.add(arr[i]);\\n        \\n        \\n            \\n            while(k>0){\\n                \\n                if(left.size()!=0 && right.size()!=0){\\n                    if(left.peek()<=right.peek()){\\n                        ans+=left.peek();\\n                        left.remove();\\n                        \\n                        if(leftbound<=rightbound){\\n                            left.add(arr[leftbound]);\\n                            leftbound++;\\n                        }\\n                        \\n                    }\\n                    \\n                    else{\\n                        ans+=right.peek();\\n                        right.remove();\\n                        \\n                        if(leftbound<=rightbound){\\n                            right.add(arr[rightbound]);\\n                            rightbound--;\\n                        }\\n                    }\\n                    \\n                    \\n                }\\n                \\n                \\n                else if(left.size()!=0){\\n                    ans+=left.peek();\\n                    left.remove();\\n                }\\n                \\n                else{\\n                    ans+=right.peek();\\n                    right.remove();\\n                }\\n                \\n                k--;\\n            }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] arr, int k, int candidates) {\\n        \\n        int n = arr.length;\\n        long ans = 0;\\n        int leftbound = candidates;\\n        int rightbound = n-candidates-1;\\n        \\n        PriorityQueue<Integer> left = new PriorityQueue<>();\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        \\n        for(int i=0;i<candidates;i++)\\n            left.add(arr[i]);\\n        \\n        \\n        \\n         for(int i=n-1; i>=Math.max(candidates,n-candidates); i--)\\n             right.add(arr[i]);\\n        \\n        \\n            \\n            while(k>0){\\n                \\n                if(left.size()!=0 && right.size()!=0){\\n                    if(left.peek()<=right.peek()){\\n                        ans+=left.peek();\\n                        left.remove();\\n                        \\n                        if(leftbound<=rightbound){\\n                            left.add(arr[leftbound]);\\n                            leftbound++;\\n                        }\\n                        \\n                    }\\n                    \\n                    else{\\n                        ans+=right.peek();\\n                        right.remove();\\n                        \\n                        if(leftbound<=rightbound){\\n                            right.add(arr[rightbound]);\\n                            rightbound--;\\n                        }\\n                    }\\n                    \\n                    \\n                }\\n                \\n                \\n                else if(left.size()!=0){\\n                    ans+=left.peek();\\n                    left.remove();\\n                }\\n                \\n                else{\\n                    ans+=right.peek();\\n                    right.remove();\\n                }\\n                \\n                k--;\\n            }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785963,
                "title": "java-priority-queues-sucks",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long cost = 0;\\n\\n        PriorityQueue<Pair<Integer, Integer>> leftCandidates = new PriorityQueue<>(\\n            (a, b) -> {\\n                return a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey();\\n            }\\n        );\\n\\n        PriorityQueue<Pair<Integer, Integer>> rightCandidates = new PriorityQueue<>(\\n            (a, b) -> {\\n                return a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey();\\n            }\\n        );\\n\\n        int n = costs.length;\\n        int i = 0;\\n\\n        for (i = 0; i < candidates; i++) {\\n            leftCandidates.offer(new Pair(costs[i], i));\\n        }\\n\\n        int leftBoundary = i;\\n        int remaining = Math.min(n - i, candidates);\\n\\n        for (i = 0; i < remaining; i++) {\\n            rightCandidates.offer(new Pair(costs[n - i - 1], n - i - 1));\\n        }\\n\\n        int rightBoundary = n - 1 - remaining;\\n\\n        while (k > 0 && !leftCandidates.isEmpty() && !rightCandidates.isEmpty()) {\\n            Pair<Integer, Integer> leftPair = leftCandidates.peek();\\n            Pair<Integer, Integer> rightPair = rightCandidates.peek();\\n\\n            if (leftPair.getKey() <= rightPair.getKey()) {\\n                cost += leftPair.getKey();\\n                leftCandidates.poll();\\n\\n                if (leftBoundary <= rightBoundary) {\\n                    leftCandidates.offer(new Pair(costs[leftBoundary], leftBoundary));\\n                    leftBoundary++;\\n                }\\n            }\\n            else {\\n                cost += rightPair.getKey();\\n                rightCandidates.poll();\\n\\n                if (leftBoundary <= rightBoundary) {\\n                    rightCandidates.offer(new Pair(costs[rightBoundary], rightBoundary));\\n                    rightBoundary--;\\n                }\\n            }\\n\\n            k--;\\n        }\\n\\n        if (k > 0) {\\n            PriorityQueue<Pair<Integer, Integer>> pq = leftCandidates;\\n\\n            if (leftCandidates.isEmpty()) pq = rightCandidates;\\n\\n            while (k-- > 0) {\\n                cost += pq.poll().getKey();\\n            }\\n        }\\n\\n        return cost;\\n    }\\n}\\n\\n// TC: O(k * logn) + O(min(k, n)*logn) + O(k * logn) => O(n * logn)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long cost = 0;\\n\\n        PriorityQueue<Pair<Integer, Integer>> leftCandidates = new PriorityQueue<>(\\n            (a, b) -> {\\n                return a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey();\\n            }\\n        );\\n\\n        PriorityQueue<Pair<Integer, Integer>> rightCandidates = new PriorityQueue<>(\\n            (a, b) -> {\\n                return a.getKey() == b.getKey() ? a.getValue() - b.getValue() : a.getKey() - b.getKey();\\n            }\\n        );\\n\\n        int n = costs.length;\\n        int i = 0;\\n\\n        for (i = 0; i < candidates; i++) {\\n            leftCandidates.offer(new Pair(costs[i], i));\\n        }\\n\\n        int leftBoundary = i;\\n        int remaining = Math.min(n - i, candidates);\\n\\n        for (i = 0; i < remaining; i++) {\\n            rightCandidates.offer(new Pair(costs[n - i - 1], n - i - 1));\\n        }\\n\\n        int rightBoundary = n - 1 - remaining;\\n\\n        while (k > 0 && !leftCandidates.isEmpty() && !rightCandidates.isEmpty()) {\\n            Pair<Integer, Integer> leftPair = leftCandidates.peek();\\n            Pair<Integer, Integer> rightPair = rightCandidates.peek();\\n\\n            if (leftPair.getKey() <= rightPair.getKey()) {\\n                cost += leftPair.getKey();\\n                leftCandidates.poll();\\n\\n                if (leftBoundary <= rightBoundary) {\\n                    leftCandidates.offer(new Pair(costs[leftBoundary], leftBoundary));\\n                    leftBoundary++;\\n                }\\n            }\\n            else {\\n                cost += rightPair.getKey();\\n                rightCandidates.poll();\\n\\n                if (leftBoundary <= rightBoundary) {\\n                    rightCandidates.offer(new Pair(costs[rightBoundary], rightBoundary));\\n                    rightBoundary--;\\n                }\\n            }\\n\\n            k--;\\n        }\\n\\n        if (k > 0) {\\n            PriorityQueue<Pair<Integer, Integer>> pq = leftCandidates;\\n\\n            if (leftCandidates.isEmpty()) pq = rightCandidates;\\n\\n            while (k-- > 0) {\\n                cost += pq.poll().getKey();\\n            }\\n        }\\n\\n        return cost;\\n    }\\n}\\n\\n// TC: O(k * logn) + O(min(k, n)*logn) + O(k * logn) => O(n * logn)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783944,
                "title": "adding-workers-greedily",
                "content": "# Intuition\\nAs we always need to get the worker with mininum cost and index we can use a Priority Queue and add candidates from first and last respectively.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter Creating a Min Heap `pq`\\nWe add first `candidates` from the begin.\\nAnd if we still have space we try adding `candidates` from last.\\n\\nUsing the Min Head we pop workers and add there cost and by using the workers index we add cost from begin or end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(k * log(candidates))`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(candidates)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int n = costs.size();\\n        int l, r;\\n        \\n        for(int i = 0; i < candidates; i++)\\n            pq.push(make_pair(costs[i], i));\\n        \\n        l = candidates - 1;\\n        r = max(candidates, n - candidates);\\n        \\n        for(int i = r; i < n; i++)\\n            pq.push(make_pair(costs[i], i));\\n        \\n        int ind;\\n        while(k--) {\\n            cost += pq.top().first;\\n            ind = pq.top().second;\\n            pq.pop();\\n            \\n            if(ind <= l && (l + 1) < r) { // begin\\n                l++;\\n                pq.push(make_pair(costs[l], l));\\n            }\\n            else if(ind >= r && (r - 1) > l) { // end\\n                r--;\\n                pq.push(make_pair(costs[r], r));\\n            }\\n        }\\n        \\n        \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int n = costs.size();\\n        int l, r;\\n        \\n        for(int i = 0; i < candidates; i++)\\n            pq.push(make_pair(costs[i], i));\\n        \\n        l = candidates - 1;\\n        r = max(candidates, n - candidates);\\n        \\n        for(int i = r; i < n; i++)\\n            pq.push(make_pair(costs[i], i));\\n        \\n        int ind;\\n        while(k--) {\\n            cost += pq.top().first;\\n            ind = pq.top().second;\\n            pq.pop();\\n            \\n            if(ind <= l && (l + 1) < r) { // begin\\n                l++;\\n                pq.push(make_pair(costs[l], l));\\n            }\\n            else if(ind >= r && (r - 1) > l) { // end\\n                r--;\\n                pq.push(make_pair(costs[r], r));\\n            }\\n        }\\n        \\n        \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783799,
                "title": "c-simple-clean-solution-priority-queue-beats-87-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate 2 priority queue(pq1 and pq2). One will have `candidate` values from left and one from right. but if 2*candidate is greater than n, push `candidate` values from left(in pq1) and the remaining from right(in pq2). \\n\\n\\nTwo pointers i and j will maintain the elements from left and right respectively.\\n\\nNow, remove the min element from priority queues.\\nif any priority queue gets empty,\\n    insert the next element in another pq(if i <= j)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        int n = costs.size();\\n        long long ans = 0;\\n\\n        int i = 0, j = n-1;\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        if(2*cand >= n){\\n            for(i = 0; i < cand; i++)\\n                pq1.push(costs[i]);\\n\\n            int x = n-cand;\\n            while(x--)\\n            {\\n                pq2.push(costs[j--]);\\n            }\\n            \\n        }else{            \\n            for(i = 0; i < cand; i++)\\n                pq1.push(costs[i]);\\n            for(j = n-1; j >= n-cand; j--){\\n                pq2.push(costs[j]);\\n            }            \\n        }\\n        \\n        while(k--){\\n            if(pq1.empty()){\\n                ans += pq2.top();\\n                pq2.pop();\\n                if(i <= j){\\n                    pq2.push(costs[j--]);\\n                }\\n            }\\n            \\n            else if(pq2.empty()){\\n                ans += pq1.top();\\n                pq1.pop();\\n                if(i <= j)\\n                    pq1.push(costs[i++]);\\n            }\\n            \\n            else if(pq1.top() <= pq2.top()){\\n                ans += pq1.top();\\n                pq1.pop();\\n                if(i <= j)\\n                {\\n                    pq1.push(costs[i]);\\n                    i++;\\n                }\\n            }\\n            \\n            else if(pq2.top() < pq1.top()){\\n                ans += pq2.top();\\n                pq2.pop();\\n                if(i <= j)\\n                {\\n                    pq2.push(costs[j]);\\n                    j--;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\\n```\\nif(itHelps())\\n{\\n    upvote++\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        int n = costs.size();\\n        long long ans = 0;\\n\\n        int i = 0, j = n-1;\\n        priority_queue<int, vector<int>, greater<int>> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        if(2*cand >= n){\\n            for(i = 0; i < cand; i++)\\n                pq1.push(costs[i]);\\n\\n            int x = n-cand;\\n            while(x--)\\n            {\\n                pq2.push(costs[j--]);\\n            }\\n            \\n        }else{            \\n            for(i = 0; i < cand; i++)\\n                pq1.push(costs[i]);\\n            for(j = n-1; j >= n-cand; j--){\\n                pq2.push(costs[j]);\\n            }            \\n        }\\n        \\n        while(k--){\\n            if(pq1.empty()){\\n                ans += pq2.top();\\n                pq2.pop();\\n                if(i <= j){\\n                    pq2.push(costs[j--]);\\n                }\\n            }\\n            \\n            else if(pq2.empty()){\\n                ans += pq1.top();\\n                pq1.pop();\\n                if(i <= j)\\n                    pq1.push(costs[i++]);\\n            }\\n            \\n            else if(pq1.top() <= pq2.top()){\\n                ans += pq1.top();\\n                pq1.pop();\\n                if(i <= j)\\n                {\\n                    pq1.push(costs[i]);\\n                    i++;\\n                }\\n            }\\n            \\n            else if(pq2.top() < pq1.top()){\\n                ans += pq2.top();\\n                pq2.pop();\\n                if(i <= j)\\n                {\\n                    pq2.push(costs[j]);\\n                    j--;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\n```\\nif(itHelps())\\n{\\n    upvote++\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783604,
                "title": "c-single-multiset-crisp-to-understand-explained",
                "content": "This was fairly an interesting problem checking our knowledge on heap.\\nWe could solve this using priority-queue or multiset.\\n\\n**Explanation:**\\n* Add the first `candidate` count workers, and last `candidate` workers to multiset.\\n* Since we are using multiset, it will be sorted in ascending order of costs, idx.\\n* We maintain `l` and `r` -> which indicates the next cost index to be taken on left, right.\\n* After popping a min cost from multiset, we check if current `idx <= left`, the we know the current one was from left, so take the next `l` cost element. Otherwise `r` cost element.\\n* Accumulate the cost and return the answer.\\n\\n```cpp\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n    int n = costs.size();\\n    multiset<vector<int>> ms;\\n    int temp = candidates, l = 0, r = n - 1;\\n\\t// insert \\'candidates\\' elements from the left\\n    while (temp-- && l < n) {\\n        ms.insert({costs[l], l});\\n        l++;\\n    }\\n\\n    temp = candidates;\\n\\t// insert \\'candidates\\' elements from the right\\n    while (l < r && temp--) {\\n        ms.insert({costs[r], r});\\n        r--;\\n    }\\n\\n    long long res = 0;\\n    while (k--) {\\n\\t\\t// take the lowest costs and remove it from the multiset\\n        int curCost = (*ms.begin())[0], idx = (*ms.begin())[1];\\n        ms.erase(ms.begin());\\n        res += curCost;\\n\\n        if (l <= r) {\\n\\t\\t\\t// From where should the next element should be taken - left or right?\\n            if (idx <= l) {\\n                ms.insert({costs[l], l});\\n                l++;\\n            }\\n            else {\\n                ms.insert({costs[r], r});\\n                r--;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n**Update and let\\'s learn together!**\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n    int n = costs.size();\\n    multiset<vector<int>> ms;\\n    int temp = candidates, l = 0, r = n - 1;\\n\\t// insert \\'candidates\\' elements from the left\\n    while (temp-- && l < n) {\\n        ms.insert({costs[l], l});\\n        l++;\\n    }\\n\\n    temp = candidates;\\n\\t// insert \\'candidates\\' elements from the right\\n    while (l < r && temp--) {\\n        ms.insert({costs[r], r});\\n        r--;\\n    }\\n\\n    long long res = 0;\\n    while (k--) {\\n\\t\\t// take the lowest costs and remove it from the multiset\\n        int curCost = (*ms.begin())[0], idx = (*ms.begin())[1];\\n        ms.erase(ms.begin());\\n        res += curCost;\\n\\n        if (l <= r) {\\n\\t\\t\\t// From where should the next element should be taken - left or right?\\n            if (idx <= l) {\\n                ms.insert({costs[l], l});\\n                l++;\\n            }\\n            else {\\n                ms.insert({costs[r], r});\\n                r--;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783554,
                "title": "clean-and-concise-min-heap-solution-with-detailed-explanation",
                "content": "# Intuition\\nSince the problem asks us to find minimum in k size subarray from the beginning and the end. The best way to get that minimum will be to use min heap.\\n\\n# Approach\\nCreate two min heap for beginning and end. Lets call beginning min heap (f) and the end min heap (b). Maintain a vis array of size nums to keep track of the numbers that are already in either of the min heaps.\\n\\nYou can start with either `f` or `b`.\\nFirst fill the `f` min heap and mark all the visited indices as 1.\\nSince `f` was filled first, fill `b` with only those elements that are not filled in `f` i.e. not visited elements.\\n\\nWe are keeping track of visited for overlapping situations as show in testcase 2 in example.\\n\\nIf we omit the visited elements from the min heap than we will never use the same element twice.\\n\\nRun a loop k times and each time compare the topmost elements of minheap and add it to final answer. Make sure to remove the element and add the next element from nums in the same min heap.\\n\\nIf either of min heap is empty that means there was overlapping situation. So just add the top of non empty min heap to final answer and remove it.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &v, int k, int c)\\n    {\\n        long long ans = 0, n = v.size();\\n        priority_queue<int, vector<int>, greater<int>> f, b;\\n        vector<int> vis(v.size(), 0);\\n\\n        for(int i = 0; i < c; i++)\\n            f.push(v[i]), vis[i] = 1;\\n        for(int i = n - c; i < n; i++)\\n            if(!vis[i])\\n                b.push(v[i]), vis[i] = 1;\\n        \\n        int i = c - 1, j = n - c;\\n        while(k--)\\n        {\\n            if(f.empty() && !b.empty())\\n                ans += b.top(), b.pop();\\n            else if(b.empty() && !f.empty())\\n                ans += f.top(), f.pop();\\n            else if(f.top() <= b.top())\\n            {\\n                ans += f.top();\\n                f.pop();\\n                if(i + 1 < v.size() && !vis[i + 1])\\n                    f.push(v[++i]), vis[i] = 1;\\n            }\\n            else\\n            {\\n                ans += b.top();\\n                b.pop();\\n                if(j - 1 >= 0 && !vis[j - 1])\\n                    b.push(v[--j]), vis[j] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Note\\nIt can be done without visited array as well. Check other posts for that.",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long totalCost(vector<int> &v, int k, int c)\\n    {\\n        long long ans = 0, n = v.size();\\n        priority_queue<int, vector<int>, greater<int>> f, b;\\n        vector<int> vis(v.size(), 0);\\n\\n        for(int i = 0; i < c; i++)\\n            f.push(v[i]), vis[i] = 1;\\n        for(int i = n - c; i < n; i++)\\n            if(!vis[i])\\n                b.push(v[i]), vis[i] = 1;\\n        \\n        int i = c - 1, j = n - c;\\n        while(k--)\\n        {\\n            if(f.empty() && !b.empty())\\n                ans += b.top(), b.pop();\\n            else if(b.empty() && !f.empty())\\n                ans += f.top(), f.pop();\\n            else if(f.top() <= b.top())\\n            {\\n                ans += f.top();\\n                f.pop();\\n                if(i + 1 < v.size() && !vis[i + 1])\\n                    f.push(v[++i]), vis[i] = 1;\\n            }\\n            else\\n            {\\n                ans += b.top();\\n                b.pop();\\n                if(j - 1 >= 0 && !vis[j - 1])\\n                    b.push(v[--j]), vis[j] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783504,
                "title": "easy-understanding-java-solution-to-maintain-two-candidate-pqs",
                "content": "# Intuition\\nmaintain two pqs from left side and right side, and then add new candidate items from the middle based on leftIndex and rightIndex.\\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        if (costs == null || costs.length < k || candidates <= 0) {\\n            return 0;\\n        }\\n        \\n        long result = 0;\\n        int leftIndex = candidates - 1, rightIndex = Math.max(leftIndex + 1, costs.length - candidates);\\n        Queue<int[]> leftItems = new PriorityQueue<int[]>((x1, x2) -> {\\n            if (x1[1] == x2[1]) {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n        for (int i = 0; i <= leftIndex; i++) {\\n            leftItems.offer(new int[]{i, costs[i]});\\n        }\\n        Queue<int[]> rightItems = new PriorityQueue<int[]>((x1, x2) -> {\\n            if (x1[1] == x2[1]) {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n        for (int i = costs.length - 1; i >= rightIndex; i--) {\\n            rightItems.offer(new int[]{i, costs[i]});\\n        }\\n        \\n        while (k-- > 0) {\\n            if (leftItems.size() == 0) {\\n                int[] rightItem = rightItems.poll();\\n                result += rightItem[1];\\n                if (leftIndex + 1 < rightIndex) {\\n                    leftIndex++;\\n                    leftItems.offer(new int[]{leftIndex, costs[leftIndex]});\\n                }\\n            } else if (rightItems.size() == 0) {\\n                int[] leftItem = leftItems.poll();\\n                result += leftItem[1];\\n                if (rightIndex - 1 > leftIndex) {\\n                    rightIndex--;\\n                    rightItems.offer(new int[]{rightIndex, costs[rightIndex]});\\n                }\\n            } else {\\n                int[] leftItem = leftItems.peek();\\n                int[] rightItem = rightItems.peek();\\n                if (leftItem[1] <= rightItem[1]) {\\n                    result += leftItem[1];\\n                    leftItems.poll();\\n                    if (leftIndex + 1 < rightIndex) {\\n                        leftIndex++;\\n                        leftItems.offer(new int[]{leftIndex, costs[leftIndex]});\\n                    }\\n                } else {\\n                    result += rightItem[1];\\n                    rightItems.poll();\\n                    if (rightIndex - 1 > leftIndex) {\\n                        rightIndex--;\\n                        rightItems.offer(new int[]{rightIndex, costs[rightIndex]});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        if (costs == null || costs.length < k || candidates <= 0) {\\n            return 0;\\n        }\\n        \\n        long result = 0;\\n        int leftIndex = candidates - 1, rightIndex = Math.max(leftIndex + 1, costs.length - candidates);\\n        Queue<int[]> leftItems = new PriorityQueue<int[]>((x1, x2) -> {\\n            if (x1[1] == x2[1]) {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n        for (int i = 0; i <= leftIndex; i++) {\\n            leftItems.offer(new int[]{i, costs[i]});\\n        }\\n        Queue<int[]> rightItems = new PriorityQueue<int[]>((x1, x2) -> {\\n            if (x1[1] == x2[1]) {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n        for (int i = costs.length - 1; i >= rightIndex; i--) {\\n            rightItems.offer(new int[]{i, costs[i]});\\n        }\\n        \\n        while (k-- > 0) {\\n            if (leftItems.size() == 0) {\\n                int[] rightItem = rightItems.poll();\\n                result += rightItem[1];\\n                if (leftIndex + 1 < rightIndex) {\\n                    leftIndex++;\\n                    leftItems.offer(new int[]{leftIndex, costs[leftIndex]});\\n                }\\n            } else if (rightItems.size() == 0) {\\n                int[] leftItem = leftItems.poll();\\n                result += leftItem[1];\\n                if (rightIndex - 1 > leftIndex) {\\n                    rightIndex--;\\n                    rightItems.offer(new int[]{rightIndex, costs[rightIndex]});\\n                }\\n            } else {\\n                int[] leftItem = leftItems.peek();\\n                int[] rightItem = rightItems.peek();\\n                if (leftItem[1] <= rightItem[1]) {\\n                    result += leftItem[1];\\n                    leftItems.poll();\\n                    if (leftIndex + 1 < rightIndex) {\\n                        leftIndex++;\\n                        leftItems.offer(new int[]{leftIndex, costs[leftIndex]});\\n                    }\\n                } else {\\n                    result += rightItem[1];\\n                    rightItems.poll();\\n                    if (rightIndex - 1 > leftIndex) {\\n                        rightIndex--;\\n                        rightItems.offer(new int[]{rightIndex, costs[rightIndex]});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783377,
                "title": "javascript-min-heap",
                "content": "```\\nvar totalCost = function (costs, k, candidates) {\\n  const pq = new MaxPriorityQueue({\\n    compare: (a, b) => (a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]),\\n  });\\n  let start = 0;\\n  let end = costs.length - 1;\\n  let ans = 0;\\n  while (start < Math.min(candidates, costs.length)) {\\n    pq.enqueue([costs[start], start, true]);\\n    start++;\\n  }\\n  start--;\\n  while (end > start && end >= costs.length - candidates) {\\n    pq.enqueue([costs[end], end, false]);\\n    end--;\\n  }\\n  end++;\\n  for (let i = 0; i < Math.min(k, costs.length); i++) {\\n    const [cost, idx, fromStart] = pq.dequeue();\\n    ans += cost;\\n    if (fromStart) {\\n      if (start < end - 1) {\\n        start++;\\n        pq.enqueue([costs[start], start, true]);\\n      }\\n    } else {\\n      if (start < end - 1) {\\n        end--;\\n        pq.enqueue([costs[end], end, false]);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar totalCost = function (costs, k, candidates) {\\n  const pq = new MaxPriorityQueue({\\n    compare: (a, b) => (a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]),\\n  });\\n  let start = 0;\\n  let end = costs.length - 1;\\n  let ans = 0;\\n  while (start < Math.min(candidates, costs.length)) {\\n    pq.enqueue([costs[start], start, true]);\\n    start++;\\n  }\\n  start--;\\n  while (end > start && end >= costs.length - candidates) {\\n    pq.enqueue([costs[end], end, false]);\\n    end--;\\n  }\\n  end++;\\n  for (let i = 0; i < Math.min(k, costs.length); i++) {\\n    const [cost, idx, fromStart] = pq.dequeue();\\n    ans += cost;\\n    if (fromStart) {\\n      if (start < end - 1) {\\n        start++;\\n        pq.enqueue([costs[start], start, true]);\\n      }\\n    } else {\\n      if (start < end - 1) {\\n        end--;\\n        pq.enqueue([costs[end], end, false]);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783223,
                "title": "c-priority-queue-comparator-function",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        auto comparator = [](const pair<int,int>&a, const pair<int,int>&b) {\\n            if(a.first == b.first){\\n                return a.second > b.second;\\n            }\\n            return a.first > b.first;\\n        };\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comparator)>pq(comparator);\\n        int n = costs.size();\\n        \\n        int i = 0, j = n-1;\\n        long long cost = 0;\\n        for(;i < candidates; i++){\\n            pq.push({costs[i],i});\\n        }\\n        for(; j >= n-candidates ; j--){\\n            pq.push({costs[j],j});\\n        }\\n        // cout<<pq.top().first<<\" \"<<pq.top().second;\\n        i--;\\n        j++;\\n        while(k--){\\n            auto minVal = pq.top().first;\\n            auto minInd = pq.top().second;\\n            while(!pq.empty() && pq.top().second == minInd){\\n                pq.pop();\\n            }\\n                cost+= minVal;\\n                st.insert(minInd);\\n                if(minInd <= i && i < j){\\n                    // cout<<i<<endl;\\n                    if(i < n){\\n                        i++;\\n                        pq.push({costs[i],i});\\n                        leftMin = costs[i];\\n                    }\\n                    \\n                }else if(minInd >= j && j > i){\\n                    if(j >= 0){\\n                        j--;\\n                        pq.push({costs[j],j});\\n                        rightMin = costs[j];\\n                    }\\n                }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        auto comparator = [](const pair<int,int>&a, const pair<int,int>&b) {\\n            if(a.first == b.first){\\n                return a.second > b.second;\\n            }\\n            return a.first > b.first;\\n        };\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comparator)>pq(comparator);\\n        int n = costs.size();\\n        \\n        int i = 0, j = n-1;\\n        long long cost = 0;\\n        for(;i < candidates; i++){\\n            pq.push({costs[i],i});\\n        }\\n        for(; j >= n-candidates ; j--){\\n            pq.push({costs[j],j});\\n        }\\n        // cout<<pq.top().first<<\" \"<<pq.top().second;\\n        i--;\\n        j++;\\n        while(k--){\\n            auto minVal = pq.top().first;\\n            auto minInd = pq.top().second;\\n            while(!pq.empty() && pq.top().second == minInd){\\n                pq.pop();\\n            }\\n                cost+= minVal;\\n                st.insert(minInd);\\n                if(minInd <= i && i < j){\\n                    // cout<<i<<endl;\\n                    if(i < n){\\n                        i++;\\n                        pq.push({costs[i],i});\\n                        leftMin = costs[i];\\n                    }\\n                    \\n                }else if(minInd >= j && j > i){\\n                    if(j >= 0){\\n                        j--;\\n                        pq.push({costs[j],j});\\n                        rightMin = costs[j];\\n                    }\\n                }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783194,
                "title": "simple-priority-queue-simulation-don-t-over-thinking",
                "content": "# Important !!!\\nThis question is not ask for optimal choice sequence, we have to follow the greedy rule as said in the question !!!\\n\\n# Approach\\nThis is literally step by step simulation. Initially, we add left and right `candidate` number of worker into heap. Then as we pop, we identify where the work is from (left or right), then we push a new work from that direction into our heap. \\n\\n# Complexity\\n- Time complexity:\\n$O(n \\\\log n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\npush = heapq.heappush\\npop = heapq.heappop\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, q: int) -> int:\\n        n = len(costs)\\n        H = []\\n        for i in range(q):\\n            H.append((costs[i], i, \\'L\\'))\\n        i += 1\\n        j = n-1\\n        while j >= i and (n-j) <= q:\\n            H.append((costs[j], j, \\'R\\'))\\n            j -= 1           \\n        \\n        # print(i,j,H)\\n        heapq.heapify(H)\\n        \\n        res = 0\\n        \\n        for _ in range(k):\\n            v, ind ,d = pop(H)\\n            # print(v)\\n            res += v\\n            if i <= j:\\n                if d == \\'R\\':\\n                    push(H, (costs[j], j, \\'R\\'))\\n                    j -= 1\\n                else:\\n                    push(H, (costs[i], i, \\'L\\'))\\n                    i += 1\\n        \\n        return res\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\npush = heapq.heappush\\npop = heapq.heappop\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, q: int) -> int:\\n        n = len(costs)\\n        H = []\\n        for i in range(q):\\n            H.append((costs[i], i, \\'L\\'))\\n        i += 1\\n        j = n-1\\n        while j >= i and (n-j) <= q:\\n            H.append((costs[j], j, \\'R\\'))\\n            j -= 1           \\n        \\n        # print(i,j,H)\\n        heapq.heapify(H)\\n        \\n        res = 0\\n        \\n        for _ in range(k):\\n            v, ind ,d = pop(H)\\n            # print(v)\\n            res += v\\n            if i <= j:\\n                if d == \\'R\\':\\n                    push(H, (costs[j], j, \\'R\\'))\\n                    j -= 1\\n                else:\\n                    push(H, (costs[i], i, \\'L\\'))\\n                    i += 1\\n        \\n        return res\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783138,
                "title": "python-two-pointers-two-heaps-o-k-log-candidates",
                "content": "\\t\\tdef totalCost(self, costs: List[int], k: int, cand: int) -> int:\\n\\t\\t\\tn = len(costs)\\n\\t\\t\\tl , r = cand-1, n-cand\\n\\t\\t\\tleftHeap = costs[:min(l+1,n)] + [float(\"inf\")]\\n\\t\\t\\trightHeap = costs[max(0,r,l+1):] + [float(\"inf\")]\\n\\t\\t\\theapq.heapify(leftHeap)\\n\\t\\t\\theapq.heapify(rightHeap)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile k :\\n\\t\\t\\t\\tmin1,min2 = leftHeap[0],rightHeap[0]\\n\\t\\t\\t\\tif min1 <= min2 :   # min found on left side\\n\\t\\t\\t\\t\\tres += heapq.heappop(leftHeap)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tif l < r and l<n :   \\n\\t\\t\\t\\t\\t\\theapq.heappush(leftHeap,costs[l])\\n\\t\\t\\t\\telse:   # min found on right side\\n\\t\\t\\t\\t\\tres += heapq.heappop(rightHeap)\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\tif l < r and r>=0 :\\n\\t\\t\\t\\t\\t\\theapq.heappush(rightHeap,costs[r])\\n\\t\\t\\t\\tk -= 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "\\t\\tdef totalCost(self, costs: List[int], k: int, cand: int) -> int:\\n\\t\\t\\tn = len(costs)\\n\\t\\t\\tl , r = cand-1, n-cand\\n\\t\\t\\tleftHeap = costs[:min(l+1,n)] + [float(\"inf\")]\\n\\t\\t\\trightHeap = costs[max(0,r,l+1):] + [float(\"inf\")]\\n\\t\\t\\theapq.heapify(leftHeap)\\n\\t\\t\\theapq.heapify(rightHeap)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile k :\\n\\t\\t\\t\\tmin1,min2 = leftHeap[0],rightHeap[0]\\n\\t\\t\\t\\tif min1 <= min2 :   # min found on left side\\n\\t\\t\\t\\t\\tres += heapq.heappop(leftHeap)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tif l < r and l<n :   \\n\\t\\t\\t\\t\\t\\theapq.heappush(leftHeap,costs[l])\\n\\t\\t\\t\\telse:   # min found on right side\\n\\t\\t\\t\\t\\tres += heapq.heappop(rightHeap)\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\tif l < r and r>=0 :\\n\\t\\t\\t\\t\\t\\theapq.heappush(rightHeap,costs[r])\\n\\t\\t\\t\\tk -= 1\\n\\t\\t\\treturn res",
                "codeTag": "Python3"
            },
            {
                "id": 2783085,
                "title": "easy-explanation-basic-intuition",
                "content": "```\\n/*\\n   maintain two min priority queues in order to store first candidates elements and last candidates elements\\n    then compare the top value from those priority queues and pop from priority queue that have minimum top value \\n    add this min top value to answer\\n\\tnow check if we have any extra element available in the array that is not pushed in any priority till now,\\n    if yes push it in the priority from which pop operation has just happened\\n\\tagain repeat above steps k times\\n    */\\n    long long totalCost(vector<int>& c, int k, int can) {\\n        priority_queue<int, vector<int>, greater<int>> pq, pq2;\\n        int n = c.size();\\n        int K = -1;\\n        int l1 = -1, l2 = n;\\n        for(int i=0;i<can;i++)\\n        {\\n            pq.push(c[i]);\\n            l1++;\\n            K++;\\n        }\\n        for(int j=n-1;j>K && j>=n-can;j--)\\n        {\\n            pq2.push(c[j]);\\n            l2--;\\n        }\\n        \\n        long long ans = 0;\\n        while(k--)\\n        {\\n            if(pq.empty())\\n            {\\n                ans += pq2.top();\\n                pq2.pop();\\n                continue;\\n            }\\n            else if(pq2.empty())\\n            {\\n                ans += pq.top();\\n                pq.pop();\\n                continue;\\n            }\\n            \\n            auto it1 = pq.top();\\n            auto it2 = pq2.top();\\n            \\n            if(it1 <= it2)\\n            {\\n                pq.pop();\\n                ans += it1;\\n                \\n                if(l2-l1 > 1)\\n                    pq.push(c[++l1]);\\n            }\\n            else\\n            {\\n                pq2.pop();\\n                ans += it2;\\n                \\n                if(l2-l1 > 1)\\n                    pq2.push(c[--l2]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\n   maintain two min priority queues in order to store first candidates elements and last candidates elements\\n    then compare the top value from those priority queues and pop from priority queue that have minimum top value \\n    add this min top value to answer\\n\\tnow check if we have any extra element available in the array that is not pushed in any priority till now,\\n    if yes push it in the priority from which pop operation has just happened\\n\\tagain repeat above steps k times\\n    */\\n    long long totalCost(vector<int>& c, int k, int can) {\\n        priority_queue<int, vector<int>, greater<int>> pq, pq2;\\n        int n = c.size();\\n        int K = -1;\\n        int l1 = -1, l2 = n;\\n        for(int i=0;i<can;i++)\\n        {\\n            pq.push(c[i]);\\n            l1++;\\n            K++;\\n        }\\n        for(int j=n-1;j>K && j>=n-can;j--)\\n        {\\n            pq2.push(c[j]);\\n            l2--;\\n        }\\n        \\n        long long ans = 0;\\n        while(k--)\\n        {\\n            if(pq.empty())\\n            {\\n                ans += pq2.top();\\n                pq2.pop();\\n                continue;\\n            }\\n            else if(pq2.empty())\\n            {\\n                ans += pq.top();\\n                pq.pop();\\n                continue;\\n            }\\n            \\n            auto it1 = pq.top();\\n            auto it2 = pq2.top();\\n            \\n            if(it1 <= it2)\\n            {\\n                pq.pop();\\n                ans += it1;\\n                \\n                if(l2-l1 > 1)\\n                    pq.push(c[++l1]);\\n            }\\n            else\\n            {\\n                pq2.pop();\\n                ans += it2;\\n                \\n                if(l2-l1 > 1)\\n                    pq2.push(c[--l2]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890351,
                "title": "140ms-beats-99-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum at each point calls for MinHeap\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake tow pointers on each end of the array and intially push values with the indices in the MinHeap, but keep in consideration that only unique indices must be pushed for maintaining that (a <= b) is used in while loops.\\n\\nNow for K times pop out values from MinHeap and if popped index < a => increment a and push new element in MinHeap and similarly if popped index > b => decrement b and push new element in MinHeap, but keep in consideration that only unique indices must be pushed for maintaining that (a <= b) is used in If condition.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define pll pair<long long, long long>\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int C) {\\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n        ll ans = 0, n = costs.size(), a = 0, b = n - 1;\\n        priority_queue<pll, vector<pll>, greater<pll>> pq;\\n        while(a < C and a <= b) pq.push({costs[a], a}), a++;\\n        while(b >= n - C and a <= b) pq.push({costs[b], b}), b--;\\n        while(k--){\\n            ll cost = pq.top().first, pos = pq.top().second;\\n            pq.pop(), ans += cost;\\n            if(a <= b){\\n                if(pos < a) pq.push({costs[a], a}), a++;\\n                else pq.push({costs[b], b}), b--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\n#define ll long long\\n#define pll pair<long long, long long>\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int C) {\\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n        ll ans = 0, n = costs.size(), a = 0, b = n - 1;\\n        priority_queue<pll, vector<pll>, greater<pll>> pq;\\n        while(a < C and a <= b) pq.push({costs[a], a}), a++;\\n        while(b >= n - C and a <= b) pq.push({costs[b], b}), b--;\\n        while(k--){\\n            ll cost = pq.top().first, pos = pq.top().second;\\n            pq.pop(), ans += cost;\\n            if(a <= b){\\n                if(pos < a) pq.push({costs[a], a}), a++;\\n                else pq.push({costs[b], b}), b--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3700975,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long sum = 0L;\\n\\n        if (candidates * 2 >= costs.length) {\\n            Arrays.sort(costs);\\n            for (int i = 0; i < k; i++) {\\n                sum += costs[i];\\n            }\\n            return sum;\\n        }\\n\\n        Queue<int[]> queue = new PriorityQueue<>((o1, o2) -> {\\n            int compare = Integer.compare(o1[0], o2[0]);\\n            if (compare == 0) {\\n                return Integer.compare(o1[1], o2[1]); // Break the tie by the smallest index.\\n            } else {\\n                return compare;\\n            }\\n        });\\n        \\n        int left = 0;\\n        int right = costs.length - 1;\\n        for (int i = 0; i < candidates; i++) {\\n            queue.offer(new int[]{costs[left++], -1}); // -1 = left side\\n            queue.offer(new int[]{costs[right--], 1}); // 1 = right side\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] poll = queue.poll();\\n            sum += poll[0];\\n            if (left <= right) {\\n                if (poll[1] == -1) {\\n                    queue.offer(new int[]{costs[left++], -1});\\n                } else {\\n                    queue.offer(new int[]{costs[right--], 1});\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long sum = 0L;\\n\\n        if (candidates * 2 >= costs.length) {\\n            Arrays.sort(costs);\\n            for (int i = 0; i < k; i++) {\\n                sum += costs[i];\\n            }\\n            return sum;\\n        }\\n\\n        Queue<int[]> queue = new PriorityQueue<>((o1, o2) -> {\\n            int compare = Integer.compare(o1[0], o2[0]);\\n            if (compare == 0) {\\n                return Integer.compare(o1[1], o2[1]); // Break the tie by the smallest index.\\n            } else {\\n                return compare;\\n            }\\n        });\\n        \\n        int left = 0;\\n        int right = costs.length - 1;\\n        for (int i = 0; i < candidates; i++) {\\n            queue.offer(new int[]{costs[left++], -1}); // -1 = left side\\n            queue.offer(new int[]{costs[right--], 1}); // 1 = right side\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            int[] poll = queue.poll();\\n            sum += poll[0];\\n            if (left <= right) {\\n                if (poll[1] == -1) {\\n                    queue.offer(new int[]{costs[left++], -1});\\n                } else {\\n                    queue.offer(new int[]{costs[right--], 1});\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700306,
                "title": "simple-heap-solution-using-two-heap",
                "content": "# Intuition\\nmaintains two priority queues (pq1 and pq2) that store the candidates smallest costs from the beginning and end of the list.\\n\\n# Approach\\n\\nTwo priority queues (pql and pqr) are created to store the lowest candidates costs from the beginning (pql) and the end (pqr) of the costs array.\\n\\nTwo separate loops are used to add workers\\' costs to the priority queues. In each loop iteration, the cost is added to the respective priority queue, and the p or q index is incremented or decremented accordingly. The loop condition ensures that the number of iterations is limited to candidates and that p does not exceed q.\\n\\nAfter initializing the priority queues, a variable total is initialized to keep track of the total cost.\\n\\nThe code then enters a while loop, which iterates k times, representing the hiring sessions. In each session, it checks which priority queue has the lowest cost worker (pql or pqr), or if either of the queues is empty.\\n\\nIf pqr is empty or pql.peek() (the lowest cost worker in pql) is less than or equal to pqr.peek() (the lowest cost worker in pqr), the worker from pql is selected. Its cost is added to the total, and the worker is removed from the queue using pql.poll().\\n\\nIf pql is empty or pql.peek() is greater than pqr.peek(), the worker from pqr is selected. Its cost is added to the total, and the worker is removed from the queue using pqr.poll().\\n\\nAfter each selection, if there are more workers available in the costs array (p <= q), a new worker is added to the respective priority queue.\\n\\nFinally, the total cost is returned as the result.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n public static long totalCost1(int[] costs, int k, int candidates) {\\n        Queue<Integer> pql = new PriorityQueue<>(), pqr = new PriorityQueue<>();\\n        int p = 0, q = costs.length - 1;\\n        for (int i = 0; i < candidates && p <= q; i++)\\n                pql.add(costs[p++]);\\n\\n        for (int i = 0; i < candidates && p <= q; i++)\\n            pqr.add(costs[q--]);\\n\\n        long total = 0;\\n        while (k-- > 0) {\\n            if (pqr.isEmpty()  ||( !pql.isEmpty() && pql.peek() <= pqr.peek()) ){\\n                total += pql.poll();\\n                if (p <= q) pql.add(costs[p++]);\\n            } else {\\n                total += pqr.poll();\\n                if (p <= q) pqr.add(costs[q--]);\\n            }\\n        }\\n        return total;\\n    }\\n\\n    public long totalCost2(int[] costs, int k, int candidates) {\\n          Queue<Integer> pql = new PriorityQueue<>(), pqr = new PriorityQueue<>();\\n        int p = 0, q = costs.length - 1;\\n        long total = 0;\\n        while (k-- > 0) {\\n            while (pql.size() < candidates && p <= q )\\n                pql.add(costs[p++]);\\n            while (pqr.size() < candidates && p <= q )\\n                pqr.add(costs[q--]);\\n            int t1 = pql.size() > 0 ? pql.peek() : Integer.MAX_VALUE;\\n            int t2 = pqr.size() > 0 ? pqr.peek() : Integer.MAX_VALUE;\\n            if (t1 <= t2) {\\n                total += t1;\\n                pql.poll();\\n            } else {\\n                total += t2;\\n                pqr.poll();\\n            }\\n        }\\n        return total;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n public static long totalCost1(int[] costs, int k, int candidates) {\\n        Queue<Integer> pql = new PriorityQueue<>(), pqr = new PriorityQueue<>();\\n        int p = 0, q = costs.length - 1;\\n        for (int i = 0; i < candidates && p <= q; i++)\\n                pql.add(costs[p++]);\\n\\n        for (int i = 0; i < candidates && p <= q; i++)\\n            pqr.add(costs[q--]);\\n\\n        long total = 0;\\n        while (k-- > 0) {\\n            if (pqr.isEmpty()  ||( !pql.isEmpty() && pql.peek() <= pqr.peek()) ){\\n                total += pql.poll();\\n                if (p <= q) pql.add(costs[p++]);\\n            } else {\\n                total += pqr.poll();\\n                if (p <= q) pqr.add(costs[q--]);\\n            }\\n        }\\n        return total;\\n    }\\n\\n    public long totalCost2(int[] costs, int k, int candidates) {\\n          Queue<Integer> pql = new PriorityQueue<>(), pqr = new PriorityQueue<>();\\n        int p = 0, q = costs.length - 1;\\n        long total = 0;\\n        while (k-- > 0) {\\n            while (pql.size() < candidates && p <= q )\\n                pql.add(costs[p++]);\\n            while (pqr.size() < candidates && p <= q )\\n                pqr.add(costs[q--]);\\n            int t1 = pql.size() > 0 ? pql.peek() : Integer.MAX_VALUE;\\n            int t2 = pqr.size() > 0 ? pqr.peek() : Integer.MAX_VALUE;\\n            if (t1 <= t2) {\\n                total += t1;\\n                pql.poll();\\n            } else {\\n                total += t2;\\n                pqr.poll();\\n            }\\n        }\\n        return total;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688188,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll totalCost(vector<int>& costs, int k, int candidates) {\\n        ll ans = 0;\\n        priority_queue<int,vector<int>, greater<int>> pq1, pq2;\\n        int count = 0, i = 0, j = costs.size()-1;\\n        while(count < k){\\n            while(pq1.size() < candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size() < candidates && j>=i) pq2.push(costs[j--]);\\n            int x = (pq1.size()) ? pq1.top():INT_MAX;\\n            int y = (pq2.size()) ? pq2.top():INT_MAX;\\n            if(x <= y){\\n                ans += x;\\n                pq1.pop();\\n            }else{\\n                ans += y;\\n                pq2.pop();\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll totalCost(vector<int>& costs, int k, int candidates) {\\n        ll ans = 0;\\n        priority_queue<int,vector<int>, greater<int>> pq1, pq2;\\n        int count = 0, i = 0, j = costs.size()-1;\\n        while(count < k){\\n            while(pq1.size() < candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size() < candidates && j>=i) pq2.push(costs[j--]);\\n            int x = (pq1.size()) ? pq1.top():INT_MAX;\\n            int y = (pq2.size()) ? pq2.top():INT_MAX;\\n            if(x <= y){\\n                ans += x;\\n                pq1.pop();\\n            }else{\\n                ans += y;\\n                pq2.pop();\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686661,
                "title": "python-solution-using-heap",
                "content": "# Intuition\\npriority queue (heap)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nlet candidate = p\\n- Time complexity: k log p + p log p\\n\\n \\n\\n- Space complexity: O(p)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n\\n\\n\\n        h1 = []\\n        h2 = []\\n\\n        n = len(costs)\\n        for i in range(candidates):\\n            heapq.heappush(h1, costs[i])\\n\\n        for i in range(n-1, max(candidates-1, n-candidates-1), -1):\\n            heapq.heappush(h2, costs[i])\\n        res = 0\\n\\n        startP = candidates\\n        endP = n-candidates-1\\n\\n        while k  > 0:\\n\\n            if len(h1) > 0 and len(h2) > 0:\\n                t1 = h1[0]\\n                t2 = h2[0]\\n\\n                if t1 <= t2:\\n                    res += t1\\n                    heapq.heappop(h1)\\n                    if startP <= endP:\\n                        \\n                        heapq.heappush(h1, costs[startP])\\n                        startP += 1\\n                else:\\n                    res += t2\\n                    heapq.heappop(h2)\\n                    if endP >= startP:\\n                        heapq.heappush(h2, costs[endP])\\n                        endP -= 1\\n            elif len(h2) == 0:\\n                res += h1[0]\\n                heapq.heappop(h1)\\n            elif len(h1) == 0:\\n                res += h2[0]\\n                heapq.heappop(h2)\\n\\n            k -= 1\\n     \\n\\n        return res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n\\n\\n\\n        h1 = []\\n        h2 = []\\n\\n        n = len(costs)\\n        for i in range(candidates):\\n            heapq.heappush(h1, costs[i])\\n\\n        for i in range(n-1, max(candidates-1, n-candidates-1), -1):\\n            heapq.heappush(h2, costs[i])\\n        res = 0\\n\\n        startP = candidates\\n        endP = n-candidates-1\\n\\n        while k  > 0:\\n\\n            if len(h1) > 0 and len(h2) > 0:\\n                t1 = h1[0]\\n                t2 = h2[0]\\n\\n                if t1 <= t2:\\n                    res += t1\\n                    heapq.heappop(h1)\\n                    if startP <= endP:\\n                        \\n                        heapq.heappush(h1, costs[startP])\\n                        startP += 1\\n                else:\\n                    res += t2\\n                    heapq.heappop(h2)\\n                    if endP >= startP:\\n                        heapq.heappush(h2, costs[endP])\\n                        endP -= 1\\n            elif len(h2) == 0:\\n                res += h1[0]\\n                heapq.heappop(h1)\\n            elif len(h1) == 0:\\n                res += h2[0]\\n                heapq.heappop(h2)\\n\\n            k -= 1\\n     \\n\\n        return res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686350,
                "title": "c-easy-code-beats-88-in-memory-and-beats-60-in-runtime",
                "content": "# Intuition\\n dry run this code for better understanding and think about corner cases when k is greater than two times of candidates. \\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        long long ans = 0;\\n        priority_queue<int,vector<int>,greater<int> >pq1,pq2;\\n\\n        for(int i=0;i<candidates;i++){\\n            pq1.push(costs[i]);\\n        }\\n        for(int i=n-1;i>=max(n-candidates,candidates);i--){\\n            pq2.push(costs[i]);\\n        }\\n        int end = candidates , start = n-candidates-1;\\n\\n        while(k--){\\n            int a=INT_MAX,b=INT_MAX;\\n            if(!pq1.empty())\\n             a = pq1.top();\\n            if(!pq2.empty())\\n             b = pq2.top();\\n\\n            if(a<=b or b==INT_MAX){\\n                ans += (long long)a;\\n                pq1.pop();\\n                if(end<=start)\\n                pq1.push(costs[end]),end++;\\n            }else {\\n                  ans += (long long)b;\\n                pq2.pop();\\n                if(end<=start)\\n                pq2.push(costs[start]),start--;\\n\\n            }\\n        }\\n         return ans;       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        long long ans = 0;\\n        priority_queue<int,vector<int>,greater<int> >pq1,pq2;\\n\\n        for(int i=0;i<candidates;i++){\\n            pq1.push(costs[i]);\\n        }\\n        for(int i=n-1;i>=max(n-candidates,candidates);i--){\\n            pq2.push(costs[i]);\\n        }\\n        int end = candidates , start = n-candidates-1;\\n\\n        while(k--){\\n            int a=INT_MAX,b=INT_MAX;\\n            if(!pq1.empty())\\n             a = pq1.top();\\n            if(!pq2.empty())\\n             b = pq2.top();\\n\\n            if(a<=b or b==INT_MAX){\\n                ans += (long long)a;\\n                pq1.pop();\\n                if(end<=start)\\n                pq1.push(costs[end]),end++;\\n            }else {\\n                  ans += (long long)b;\\n                pq2.pop();\\n                if(end<=start)\\n                pq2.push(costs[start]),start--;\\n\\n            }\\n        }\\n         return ans;       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686156,
                "title": "simple-solution-by-priority-queue-deque-data-structure",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\npriority_queue<int, vector<int>, greater<int>>ft;\\npriority_queue<int, vector<int>, greater<int>>rt;\\ndeque<int>rem;\\nlong long res;\\nvoid delete_right(int right)\\n{\\n\\tres += right;\\n\\trt.pop();\\n\\n\\tif (rem.size()) {\\n\\t\\trt.push(rem.back());\\n\\t\\trem.pop_back();\\n\\t}\\n}\\nvoid delete_left(int left)\\n{\\n\\tres += left;\\n\\t\\t\\tft.pop();\\n\\n\\t\\t\\tif (rem.size()) {\\n\\t\\t\\t\\tft.push(rem.front());\\n\\t\\t\\t\\trem.pop_front();\\n\\t\\t\\t}\\n}\\n    long long totalCost(vector<int>& v, int k, int c)\\n     {\\n    \\n    int n = v.size();\\n\\tvector<bool>vis(n, 0);\\n\\tfor (int i = 0; i < c; i++)\\n\\t{\\n\\t\\tft.push(v[i]);\\n\\t\\tvis[i] = 1;\\n\\t}\\n\\tfor (int i = n-1; i >= n-c; i--)\\n\\t{\\n\\t\\tif (vis[i] == 0)\\n\\t\\t\\trt.push(v[i]);\\n\\t}\\n\\tfor (int i = c; i < n - c; i++)\\n\\t{\\n\\t\\trem.push_back(v[i]);\\n\\t}\\n\\n\\twhile (k)\\n\\t{\\n\\t\\tint left, right;\\n\\t\\tleft = right = 0;\\n\\n\\t\\tif (ft.size())\\n\\t\\t{\\n\\t\\t\\tleft = ft.top();\\n\\t\\t}\\n\\t\\tif (rt.size())\\n\\t\\t{\\n\\t\\t\\tright = rt.top();\\n\\t\\t}\\n\\t\\tcout << \"ft== \" << left << \" , right== \" << right << endl;\\n\\t\\t//-------\\n\\t\\tif (left == 0)\\n\\t\\t{\\n\\t\\t\\tdelete_right(right);\\n\\t\\t}\\n\\t\\telse if (right == 0)\\n\\t\\t{\\n\\t\\t\\tdelete_left(left);\\n\\t\\t}\\n\\t\\telse if (left <= right)\\n\\t\\t{\\n\\t\\t\\tdelete_left(left);\\n\\t\\t}\\n\\t\\telse if (left > right)\\n\\t\\t{\\n\\t\\t\\tdelete_right(right);\\n\\t\\t}\\n\\t\\tk--;\\n\\t}\\n\\n\\tcout << res << endl;\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npriority_queue<int, vector<int>, greater<int>>ft;\\npriority_queue<int, vector<int>, greater<int>>rt;\\ndeque<int>rem;\\nlong long res;\\nvoid delete_right(int right)\\n{\\n\\tres += right;\\n\\trt.pop();\\n\\n\\tif (rem.size()) {\\n\\t\\trt.push(rem.back());\\n\\t\\trem.pop_back();\\n\\t}\\n}\\nvoid delete_left(int left)\\n{\\n\\tres += left;\\n\\t\\t\\tft.pop();\\n\\n\\t\\t\\tif (rem.size()) {\\n\\t\\t\\t\\tft.push(rem.front());\\n\\t\\t\\t\\trem.pop_front();\\n\\t\\t\\t}\\n}\\n    long long totalCost(vector<int>& v, int k, int c)\\n     {\\n    \\n    int n = v.size();\\n\\tvector<bool>vis(n, 0);\\n\\tfor (int i = 0; i < c; i++)\\n\\t{\\n\\t\\tft.push(v[i]);\\n\\t\\tvis[i] = 1;\\n\\t}\\n\\tfor (int i = n-1; i >= n-c; i--)\\n\\t{\\n\\t\\tif (vis[i] == 0)\\n\\t\\t\\trt.push(v[i]);\\n\\t}\\n\\tfor (int i = c; i < n - c; i++)\\n\\t{\\n\\t\\trem.push_back(v[i]);\\n\\t}\\n\\n\\twhile (k)\\n\\t{\\n\\t\\tint left, right;\\n\\t\\tleft = right = 0;\\n\\n\\t\\tif (ft.size())\\n\\t\\t{\\n\\t\\t\\tleft = ft.top();\\n\\t\\t}\\n\\t\\tif (rt.size())\\n\\t\\t{\\n\\t\\t\\tright = rt.top();\\n\\t\\t}\\n\\t\\tcout << \"ft== \" << left << \" , right== \" << right << endl;\\n\\t\\t//-------\\n\\t\\tif (left == 0)\\n\\t\\t{\\n\\t\\t\\tdelete_right(right);\\n\\t\\t}\\n\\t\\telse if (right == 0)\\n\\t\\t{\\n\\t\\t\\tdelete_left(left);\\n\\t\\t}\\n\\t\\telse if (left <= right)\\n\\t\\t{\\n\\t\\t\\tdelete_left(left);\\n\\t\\t}\\n\\t\\telse if (left > right)\\n\\t\\t{\\n\\t\\t\\tdelete_right(right);\\n\\t\\t}\\n\\t\\tk--;\\n\\t}\\n\\n\\tcout << res << endl;\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3686000,
                "title": "clear-explanation-1-queue-and-2-priority-queues",
                "content": "# Intuition\\nThe conditions are clearly stated.\\nImplement the conditions stated.\\n\\n\\n# Approach\\n- Use 2 priority-queues to store and obtain the smallest costs for the first and last candidates respectively.\\n\\n- Store the middle elements(elements that are not currently in any of the priority-queues) in a Queue.\\n- Compare the smallest values of the two priorty queues.\\n- Pop the smallest and add the cost to the total cost to hire workers.\\n- If there is any element in the middle Queue add the first or the last element(first element if the smallest was in the first priority queue) to the priority-queue that contained the smallest cost.\\n- Repeat till k workers are selected.\\n\\n# Complexity\\n- Time complexity:\\nO(NLog(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import deque\\nfrom heapq import *\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n\\n        middle = deque()\\n        left = [float(\"inf\")]\\n        right = [float(\"inf\")]\\n        \\n        for i, cost in enumerate(costs):\\n            if i < candidates: \\n                heappush(left, cost)\\n            elif i >= len(costs) - candidates:\\n                heappush(right, cost)\\n            else:\\n                middle.append(cost)\\n\\n\\n        total_cost = 0\\n        for _ in range(k):\\n            if left[0] <= right[0]:\\n                total_cost += heappop(left)\\n                middle and heappush(left, middle.popleft())\\n            else:\\n                total_cost += heappop(right)\\n                middle and heappush(right, middle.pop())\\n\\n        return total_cost\\n\\n            \\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom heapq import *\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n\\n        middle = deque()\\n        left = [float(\"inf\")]\\n        right = [float(\"inf\")]\\n        \\n        for i, cost in enumerate(costs):\\n            if i < candidates: \\n                heappush(left, cost)\\n            elif i >= len(costs) - candidates:\\n                heappush(right, cost)\\n            else:\\n                middle.append(cost)\\n\\n\\n        total_cost = 0\\n        for _ in range(k):\\n            if left[0] <= right[0]:\\n                total_cost += heappop(left)\\n                middle and heappush(left, middle.popleft())\\n            else:\\n                total_cost += heappop(right)\\n                middle and heappush(right, middle.pop())\\n\\n        return total_cost\\n\\n            \\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685981,
                "title": "easy-explanation-priority-queue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo just give you an overview of how this solution is working - I will make a priority queue that stores all the eligible people to be hired\\nThen we keep on extracting elements from this priority queue, keep hiring people and consequentially adding up to the final Hiring Cost.\\nPlease Upvote\\uD83D\\uDE4F\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\'minElement\\' is a priority queue of pairs where first element is the cost of hiring a worker and second element is the index of that cost. This priority queue is defined in such a way that the top element is minimum of all the contained elements with smallest index possible, I ensured this via the custom comparator class. Here is how it works :\\na is the element that stays on top of b\\nif a does not satisfy the given conditions then a and b will be swapped so that b comes on top of a\\nNow continuing with the explanation - first we engulf first and last candidates number of elements into the priority queue, after that we will run k operations to hire k number of workers. And as we remove a worker from the queue we check from which part of the array was this worker taken and then consequentially add a new worker to the queue (if any more eligible workers are left to be considered) from the first part if the previously hired person was from the first part and vica verca. Please upvote\\uD83D\\uDE4F\\n\\n# Complexity\\n- Time complexity: $$O(candidates)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(( k + candidates ) * log(candidates))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Compare {\\npublic:\\n    bool operator()(pair<int, int> b, pair<int, int> a) {\\n        return a.first < b.first or (a.first == b.first and a.second < b.second);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minElement;\\n        int n = costs.size();\\n        \\n        int i = 0, j = n - 1;\\n        while(i <= j and i < candidates) {\\n            minElement.push( {costs[i], i} );\\n            i++ ;\\n            if(i > j) {\\n                break;\\n            }\\n\\n            minElement.push( {costs[j], j} );\\n            j-- ;\\n        }\\n        long long hiringCost = 0;\\n        int hiredWorkers = 0;\\n        while(hiredWorkers < k) {\\n            pair<int, int> currentHire = minElement.top();\\n            minElement.pop();\\n            \\n            hiringCost += currentHire.first;\\n            hiredWorkers++ ;\\n\\n            if( i <= j ) {\\n                if(currentHire.second < i) {\\n                    minElement.push({costs[i], i});\\n                    i++ ;\\n                }\\n                else {\\n                    minElement.push({costs[j], j});\\n                    j-- ;\\n                }\\n            }\\n        }\\n        return hiringCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Compare {\\npublic:\\n    bool operator()(pair<int, int> b, pair<int, int> a) {\\n        return a.first < b.first or (a.first == b.first and a.second < b.second);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minElement;\\n        int n = costs.size();\\n        \\n        int i = 0, j = n - 1;\\n        while(i <= j and i < candidates) {\\n            minElement.push( {costs[i], i} );\\n            i++ ;\\n            if(i > j) {\\n                break;\\n            }\\n\\n            minElement.push( {costs[j], j} );\\n            j-- ;\\n        }\\n        long long hiringCost = 0;\\n        int hiredWorkers = 0;\\n        while(hiredWorkers < k) {\\n            pair<int, int> currentHire = minElement.top();\\n            minElement.pop();\\n            \\n            hiringCost += currentHire.first;\\n            hiredWorkers++ ;\\n\\n            if( i <= j ) {\\n                if(currentHire.second < i) {\\n                    minElement.push({costs[i], i});\\n                    i++ ;\\n                }\\n                else {\\n                    minElement.push({costs[j], j});\\n                    j-- ;\\n                }\\n            }\\n        }\\n        return hiringCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685934,
                "title": "priority-queue-greedy",
                "content": "```\\nclass Solution {\\n    \\n\\npublic:\\n    long long totalCost(vector<int>& a, int k, int c) {\\n        int n = a.size();\\n\\n        priority_queue<pair<int ,int>,vector<pair<int,int>>,greater<pair<int ,int>>> fr;\\n        priority_queue<pair<int ,int>,vector<pair<int,int>>,greater<pair<int ,int>>> bk;\\n        \\n        long long int s = 0;\\n        int e = n-1;\\n        \\n        long long int res = 0;\\n        \\n        long long int fcnt,bcnt;\\n        fcnt=bcnt=c;\\n        while(k--)\\n        {\\n            \\n            \\n            \\n            while(s<=e && fcnt>0)\\n            {\\n                fr.push({a[s],s});\\n                s++;\\n                fcnt--;\\n            }\\n            \\n            \\n            while(e>=s && bcnt>0)\\n            {\\n                bk.push({a[e],e});\\n                e--;\\n                bcnt--;\\n            }\\n            \\n            long long int v1,v2,i1,i2;\\n            v1 = v2 = LONG_MAX;\\n            i1=i2=-1;            \\n            if(!fr.empty())\\n            {\\n                v1 = fr.top().first;\\n                i1 = fr.top().second;\\n            }\\n            \\n            if(!bk.empty())\\n            {\\n                v2 = bk.top().first;\\n                i2 = bk.top().second;\\n            }\\n            \\n            if(i1 == i2){\\n                v2 = INT_MAX;\\n                bk.pop();\\n            }\\n            \\n            if(v1<=v2)\\n            {\\n                res+=v1;\\n                fr.pop();\\n                fcnt++;\\n            }\\n            else\\n            {\\n                res+=v2;\\n                bk.pop();\\n                bcnt++;\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\npublic:\\n    long long totalCost(vector<int>& a, int k, int c) {\\n        int n = a.size();\\n\\n        priority_queue<pair<int ,int>,vector<pair<int,int>>,greater<pair<int ,int>>> fr;\\n        priority_queue<pair<int ,int>,vector<pair<int,int>>,greater<pair<int ,int>>> bk;\\n        \\n        long long int s = 0;\\n        int e = n-1;\\n        \\n        long long int res = 0;\\n        \\n        long long int fcnt,bcnt;\\n        fcnt=bcnt=c;\\n        while(k--)\\n        {\\n            \\n            \\n            \\n            while(s<=e && fcnt>0)\\n            {\\n                fr.push({a[s],s});\\n                s++;\\n                fcnt--;\\n            }\\n            \\n            \\n            while(e>=s && bcnt>0)\\n            {\\n                bk.push({a[e],e});\\n                e--;\\n                bcnt--;\\n            }\\n            \\n            long long int v1,v2,i1,i2;\\n            v1 = v2 = LONG_MAX;\\n            i1=i2=-1;            \\n            if(!fr.empty())\\n            {\\n                v1 = fr.top().first;\\n                i1 = fr.top().second;\\n            }\\n            \\n            if(!bk.empty())\\n            {\\n                v2 = bk.top().first;\\n                i2 = bk.top().second;\\n            }\\n            \\n            if(i1 == i2){\\n                v2 = INT_MAX;\\n                bk.pop();\\n            }\\n            \\n            if(v1<=v2)\\n            {\\n                res+=v1;\\n                fr.pop();\\n                fcnt++;\\n            }\\n            else\\n            {\\n                res+=v2;\\n                bk.pop();\\n                bcnt++;\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685907,
                "title": "c-super-easy-clean-code-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        int n = costs.size();\\n        int s = 0;\\n        int e = n-1;\\n        priority_queue<int,vector<int>,greater<int>> left,right; \\n        long long cost = 0;\\n        while(k--){\\n            while(left.size() < candidates && s <= e){\\n                left.push(costs[s]);\\n                s++;\\n            }\\n            while(right.size() < candidates && s <= e){\\n                right.push(costs[e]);\\n                e--;\\n            }\\n\\n            int x = left.size() > 0 ? left.top() : 1e9;\\n            int y = right.size() > 0 ? right.top() : 1e9;\\n\\n            if(y < x){\\n                cost += y;\\n                right.pop();\\n            }\\n            else{\\n                cost += x;\\n                left.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        int n = costs.size();\\n        int s = 0;\\n        int e = n-1;\\n        priority_queue<int,vector<int>,greater<int>> left,right; \\n        long long cost = 0;\\n        while(k--){\\n            while(left.size() < candidates && s <= e){\\n                left.push(costs[s]);\\n                s++;\\n            }\\n            while(right.size() < candidates && s <= e){\\n                right.push(costs[e]);\\n                e--;\\n            }\\n\\n            int x = left.size() > 0 ? left.top() : 1e9;\\n            int y = right.size() > 0 ? right.top() : 1e9;\\n\\n            if(y < x){\\n                cost += y;\\n                right.pop();\\n            }\\n            else{\\n                cost += x;\\n                left.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685477,
                "title": "c-easy-priorityqueue-twopointer-with-algo",
                "content": "# Intuition\\nread the question\\nhere candidate refers to the number of elements we have to check from left and right part of array\\n\\n# Approach\\nAlgo :-\\n1.We have to find the minimum element from the left and right part for that we maintain two pointers and two min priority queue\\n2. The number of highered wokers is given is k so we iterate over k possible answers and keep a check with count variable.\\n3. push first k candidates from left and right pointer .\\n4. We have to define a search space from left and right according to number of candidates and the given consition if the array is not able to accomadate the number of candidates which is fulfilled by (pq.size()<candidates  && i<=j)\\n5. According to  the given condition if the same value occurs in both left and right part we have to take value from left therfore we first check the condition a<=b and update answer \\n6. repeat till our count reaches k\\n\\n\\n# Complexity\\n- Time complexity:\\nO(2*candidates*k + log(candidates)) ~= O(nlogn)\\n\\n- Space complexity:\\nO(N);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0 ; \\n        int n = costs.size();\\n        int j = n-1;\\n        long long ans = 0;\\n        int count = 0;\\n        priority_queue<int ,vector<int>,greater<int> > pq1 ,pq2;\\n        while(count < k){\\n            while(pq1.size()<candidates  && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX; //to avoid tle and check if a exists if not than update it to a very large value\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }\\n            else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int i = 0 ; \\n        int n = costs.size();\\n        int j = n-1;\\n        long long ans = 0;\\n        int count = 0;\\n        priority_queue<int ,vector<int>,greater<int> > pq1 ,pq2;\\n        while(count < k){\\n            while(pq1.size()<candidates  && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX; //to avoid tle and check if a exists if not than update it to a very large value\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }\\n            else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685383,
                "title": "c-min-heap-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        int n = costs.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i=0; i<candidates && i<(n+1)/2; i++){\\n\\n            pq.push({costs[i],i});\\n            \\n            if(i<n-i-1){\\n                pq.push({costs[n-i-1],n-i-1});\\n            }\\n        }\\n        long long ans = 0;\\n        int first = candidates, second = n-candidates-1;\\n\\n        while(k--){\\n            pair<int,int> temp = pq.top();\\n            pq.pop();\\n\\n            ans += temp.first;\\n            if(first<=second){\\n                if(temp.second<first){\\n                    pq.push({costs[first],first++});\\n                }else{\\n                    pq.push({costs[second],second--});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        int n = costs.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i=0; i<candidates && i<(n+1)/2; i++){\\n\\n            pq.push({costs[i],i});\\n            \\n            if(i<n-i-1){\\n                pq.push({costs[n-i-1],n-i-1});\\n            }\\n        }\\n        long long ans = 0;\\n        int first = candidates, second = n-candidates-1;\\n\\n        while(k--){\\n            pair<int,int> temp = pq.top();\\n            pq.pop();\\n\\n            ans += temp.first;\\n            if(first<=second){\\n                if(temp.second<first){\\n                    pq.push({costs[first],first++});\\n                }else{\\n                    pq.push({costs[second],second--});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685362,
                "title": "easy-python-solution-heapsort",
                "content": "\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n=len(costs)\\n        if 2*candidates>=n:\\n            costs.sort()\\n            return sum(costs[:k])\\n        df=n-(2*candidates)\\n        df2=df\\n        sm=0\\n        s1=costs[:candidates]\\n        s2=costs[n-candidates:]\\n        heapq.heapify(s1)\\n        heapq.heapify(s2)\\n        i=candidates\\n        j=n-candidates-1\\n        # print(costs[i],costs[j])\\n        ct=k\\n        while df>0 and k>0:\\n            x=heapq.heappop(s1)\\n            y=heapq.heappop(s2)\\n            if x<=y:\\n                sm+=x\\n                heapq.heappush(s1,costs[i])\\n                heapq.heappush(s2,y)\\n                i+=1\\n            else:\\n                sm+=y\\n                heapq.heappush(s1,x)\\n                heapq.heappush(s2,costs[j])\\n                j-=1\\n            df-=1\\n            k-=1\\n        lst1=heapq.nsmallest(min(k,len(s1)),s1)\\n        lst2=heapq.nsmallest(min(k,len(s2)),s2)\\n        lst=[]\\n        lst+=lst1[:]\\n        lst+=lst2[:]\\n        lst.sort()\\n        return sm+sum(lst[:k])\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n=len(costs)\\n        if 2*candidates>=n:\\n            costs.sort()\\n            return sum(costs[:k])\\n        df=n-(2*candidates)\\n        df2=df\\n        sm=0\\n        s1=costs[:candidates]\\n        s2=costs[n-candidates:]\\n        heapq.heapify(s1)\\n        heapq.heapify(s2)\\n        i=candidates\\n        j=n-candidates-1\\n        # print(costs[i],costs[j])\\n        ct=k\\n        while df>0 and k>0:\\n            x=heapq.heappop(s1)\\n            y=heapq.heappop(s2)\\n            if x<=y:\\n                sm+=x\\n                heapq.heappush(s1,costs[i])\\n                heapq.heappush(s2,y)\\n                i+=1\\n            else:\\n                sm+=y\\n                heapq.heappush(s1,x)\\n                heapq.heappush(s2,costs[j])\\n                j-=1\\n            df-=1\\n            k-=1\\n        lst1=heapq.nsmallest(min(k,len(s1)),s1)\\n        lst2=heapq.nsmallest(min(k,len(s2)),s2)\\n        lst=[]\\n        lst+=lst1[:]\\n        lst+=lst2[:]\\n        lst.sort()\\n        return sm+sum(lst[:k])\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685270,
                "title": "priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int> &costs, int k, int candidates)\\n{\\n    int n = costs.size();\\n    long long ans = 0;\\n\\n    if (((2 * candidates) + k - 1) >= n)\\n    {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            pq.push(costs[i]);\\n        }\\n\\n        while (k--)\\n        {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n    }\\n    else\\n    {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        for (int i = 0; i < candidates; i++)\\n        {\\n            pq.push({costs[i], i});\\n        }\\n\\n        int fr = candidates;\\n\\n        for (int i = n - 1; i >= n - candidates; i--)\\n        {\\n            pq.push({costs[i], i});\\n        }\\n\\n        int sec = n - candidates - 1;\\n\\n        while (k--)\\n        {\\n            int x = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n\\n            ans += x;\\n            if (index < fr)\\n            {\\n                pq.push({costs[fr], fr});\\n                fr++;\\n            }\\n            else\\n            {\\n                pq.push({costs[sec], sec});\\n                sec--;\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int> &costs, int k, int candidates)\\n{\\n    int n = costs.size();\\n    long long ans = 0;\\n\\n    if (((2 * candidates) + k - 1) >= n)\\n    {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            pq.push(costs[i]);\\n        }\\n\\n        while (k--)\\n        {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n    }\\n    else\\n    {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        for (int i = 0; i < candidates; i++)\\n        {\\n            pq.push({costs[i], i});\\n        }\\n\\n        int fr = candidates;\\n\\n        for (int i = n - 1; i >= n - candidates; i--)\\n        {\\n            pq.push({costs[i], i});\\n        }\\n\\n        int sec = n - candidates - 1;\\n\\n        while (k--)\\n        {\\n            int x = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n\\n            ans += x;\\n            if (index < fr)\\n            {\\n                pq.push({costs[fr], fr});\\n                fr++;\\n            }\\n            else\\n            {\\n                pq.push({costs[sec], sec});\\n                sec--;\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684852,
                "title": "min-heap-clean-code-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        // min heap \\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        int cnt = 0, i=0, j=costs.size()-1;\\n        long long ans=0;\\n        while(cnt<k){\\n            while(pq1.size() < candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size() <\\xA0candidates & j>=i) pq2.push(costs[j--]);\\n\\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n            // we will try to take lowest index element\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        // min heap \\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        int cnt = 0, i=0, j=costs.size()-1;\\n        long long ans=0;\\n        while(cnt<k){\\n            while(pq1.size() < candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size() <\\xA0candidates & j>=i) pq2.push(costs[j--]);\\n\\n            int a = pq1.size() > 0 ? pq1.top() : INT_MAX;\\n            int b = pq2.size() > 0 ? pq2.top() : INT_MAX;\\n\\n            // we will try to take lowest index element\\n            if(a<=b){\\n                ans+=a;\\n                pq1.pop();\\n            }else{\\n                ans+=b;\\n                pq2.pop();\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684473,
                "title": "2462-total-cost-to-hire-k-workers-heap-c-easy-to-understand-priority-queue",
                "content": "# 2462. Total Cost to Hire K Workers | Heap | C++ | Easy to Understand | Priority Queue\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates)\\n    {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n\\n        long long cost = 0;   \\n \\n        int count = 0;\\n        int low = 0;\\n        int high = costs.size()-1;\\n\\n        while(count < k)\\n        {\\n            while( (pq1.size() < candidates) && (low <= high) )\\n            {\\n                pq1.push(costs[low]);\\n                low += 1;\\n            }\\n\\n            while( (pq2.size() < candidates) && (high >= low) )\\n            {\\n                pq2.push(costs[high]);\\n                high -= 1;\\n            }\\n\\n            int cost1 = (pq1.size() > 0) ? pq1.top() : INT_MAX;\\n            int cost2 = (pq2.size() > 0) ? pq2.top() : INT_MAX;\\n\\n            if(cost1 <= cost2)\\n            {\\n                cost += cost1;\\n                pq1.pop();\\n            }\\n            else\\n            {\\n                cost += cost2;\\n                pq2.pop();\\n            }\\n\\n            count += 1;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates)\\n    {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n\\n        long long cost = 0;   \\n \\n        int count = 0;\\n        int low = 0;\\n        int high = costs.size()-1;\\n\\n        while(count < k)\\n        {\\n            while( (pq1.size() < candidates) && (low <= high) )\\n            {\\n                pq1.push(costs[low]);\\n                low += 1;\\n            }\\n\\n            while( (pq2.size() < candidates) && (high >= low) )\\n            {\\n                pq2.push(costs[high]);\\n                high -= 1;\\n            }\\n\\n            int cost1 = (pq1.size() > 0) ? pq1.top() : INT_MAX;\\n            int cost2 = (pq2.size() > 0) ? pq2.top() : INT_MAX;\\n\\n            if(cost1 <= cost2)\\n            {\\n                cost += cost1;\\n                pq1.pop();\\n            }\\n            else\\n            {\\n                cost += cost2;\\n                pq2.pop();\\n            }\\n\\n            count += 1;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684298,
                "title": "typescript-solution-with-built-in-min-queue",
                "content": "# Complexity\\n- Time complexity:\\nO((k + m) * log m), m - candidates\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nfunction totalCost(costs: number[], k: number, candidates: number): number {\\n    const minPq = new MinPriorityQueue({ \\n        compare: (a, b) => a.cost === b.cost ? a.index - b.index : a.cost - b.cost\\n    });\\n\\n    let totalCost: number = 0;\\n    let nextHead: number = candidates;\\n    let nextTail: number = costs.length - candidates - 1;\\n\\n    for (let i = 0; i < candidates; i++) {\\n      minPq.enqueue({cost: costs[i], index: i});\\n    }\\n    for (let i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\\n      minPq.enqueue({cost: costs[i], index: i});\\n    }\\n\\n    while (k-- > 0) {\\n      const element = minPq.dequeue();\\n      totalCost += element.cost;\\n      if (nextHead > nextTail) continue;\\n\\n      minPq.enqueue(element.index < nextHead ? \\n        {index: nextHead, cost: costs[nextHead++]}:\\n        {index: nextTail, cost: costs[nextTail--]}\\n      );\\n    }\\n\\n    return totalCost;\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction totalCost(costs: number[], k: number, candidates: number): number {\\n    const minPq = new MinPriorityQueue({ \\n        compare: (a, b) => a.cost === b.cost ? a.index - b.index : a.cost - b.cost\\n    });\\n\\n    let totalCost: number = 0;\\n    let nextHead: number = candidates;\\n    let nextTail: number = costs.length - candidates - 1;\\n\\n    for (let i = 0; i < candidates; i++) {\\n      minPq.enqueue({cost: costs[i], index: i});\\n    }\\n    for (let i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\\n      minPq.enqueue({cost: costs[i], index: i});\\n    }\\n\\n    while (k-- > 0) {\\n      const element = minPq.dequeue();\\n      totalCost += element.cost;\\n      if (nextHead > nextTail) continue;\\n\\n      minPq.enqueue(element.index < nextHead ? \\n        {index: nextHead, cost: costs[nextHead++]}:\\n        {index: nextTail, cost: costs[nextTail--]}\\n      );\\n    }\\n\\n    return totalCost;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684209,
                "title": "python-3-clean-code-solution",
                "content": "_NEVER write such unwieldy code on a real interview unless you are asked to._\\n_This code is written for studying purposes only._\\n<br>\\n\\n# Code\\n```\\nimport heapq\\nfrom dataclasses import dataclass\\n\\n@dataclass\\nclass Candidate:\\n    ind: int\\n    cost: int\\n\\n    def __lt__(self, other):\\n        return (self.cost, self.ind) < (other.cost, other.ind)\\n\\n\\nclass CandidatesPool:\\n    def __init__(self, costs: List[int], size: int):\\n        self.costs = costs\\n        self.heap = []\\n        self.next_left_candidate_ind = 0\\n        self.next_right_candidate_ind = len(costs) - 1\\n        \\n        cur_size = 0\\n        while True:\\n            if cur_size == size:\\n                break\\n            self.try_add_left_candidate()\\n            cur_size += 1\\n\\n            if cur_size == size:\\n                break\\n            self.try_add_right_candidate()\\n            cur_size += 1\\n    \\n    def extract_best_candidate(self):\\n        candidate = heapq.heappop(self.heap)\\n        self._replace_candidate(candidate)\\n        return candidate\\n\\n    def try_add_left_candidate(self):\\n        if self.has_new_candidates:\\n            heapq.heappush(self.heap, self.next_left_candidate)\\n            self.next_left_candidate_ind += 1\\n    \\n    def try_add_right_candidate(self):\\n        if self.has_new_candidates:\\n            heapq.heappush(self.heap, self.next_right_candidate)\\n            self.next_right_candidate_ind -= 1\\n\\n    @property\\n    def next_left_candidate(self):\\n        return Candidate(self.next_left_candidate_ind, self.costs[self.next_left_candidate_ind])\\n\\n    @property\\n    def next_right_candidate(self):\\n        return Candidate(self.next_right_candidate_ind, self.costs[self.next_right_candidate_ind])\\n    \\n    @property\\n    def has_new_candidates(self):\\n        return self.next_left_candidate_ind <= self.next_right_candidate_ind\\n    \\n    def _replace_candidate(self, candidate: Candidate):\\n        if candidate.ind < self.next_left_candidate_ind:\\n            self.try_add_left_candidate()\\n        else:\\n            self.try_add_right_candidate()\\n\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        pool = CandidatesPool(costs, size=2*candidates)\\n        total_cost = 0\\n        for _ in range(k):\\n            candidate = pool.extract_best_candidate()\\n            total_cost += candidate.cost\\n        return total_cost\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom dataclasses import dataclass\\n\\n@dataclass\\nclass Candidate:\\n    ind: int\\n    cost: int\\n\\n    def __lt__(self, other):\\n        return (self.cost, self.ind) < (other.cost, other.ind)\\n\\n\\nclass CandidatesPool:\\n    def __init__(self, costs: List[int], size: int):\\n        self.costs = costs\\n        self.heap = []\\n        self.next_left_candidate_ind = 0\\n        self.next_right_candidate_ind = len(costs) - 1\\n        \\n        cur_size = 0\\n        while True:\\n            if cur_size == size:\\n                break\\n            self.try_add_left_candidate()\\n            cur_size += 1\\n\\n            if cur_size == size:\\n                break\\n            self.try_add_right_candidate()\\n            cur_size += 1\\n    \\n    def extract_best_candidate(self):\\n        candidate = heapq.heappop(self.heap)\\n        self._replace_candidate(candidate)\\n        return candidate\\n\\n    def try_add_left_candidate(self):\\n        if self.has_new_candidates:\\n            heapq.heappush(self.heap, self.next_left_candidate)\\n            self.next_left_candidate_ind += 1\\n    \\n    def try_add_right_candidate(self):\\n        if self.has_new_candidates:\\n            heapq.heappush(self.heap, self.next_right_candidate)\\n            self.next_right_candidate_ind -= 1\\n\\n    @property\\n    def next_left_candidate(self):\\n        return Candidate(self.next_left_candidate_ind, self.costs[self.next_left_candidate_ind])\\n\\n    @property\\n    def next_right_candidate(self):\\n        return Candidate(self.next_right_candidate_ind, self.costs[self.next_right_candidate_ind])\\n    \\n    @property\\n    def has_new_candidates(self):\\n        return self.next_left_candidate_ind <= self.next_right_candidate_ind\\n    \\n    def _replace_candidate(self, candidate: Candidate):\\n        if candidate.ind < self.next_left_candidate_ind:\\n            self.try_add_left_candidate()\\n        else:\\n            self.try_add_right_candidate()\\n\\n\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        pool = CandidatesPool(costs, size=2*candidates)\\n        total_cost = 0\\n        for _ in range(k):\\n            candidate = pool.extract_best_candidate()\\n            total_cost += candidate.cost\\n        return total_cost\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684075,
                "title": "2462-total-cost-to-hire-k-workers-c",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans=0;\\n        int cnt=0;\\n        int l=0,r=costs.size()-1;\\n        priority_queue <int, vector<int>, greater<int>> one;\\n        priority_queue <int, vector<int>, greater<int>> two;\\n\\n        while(cnt<k)\\n        {\\n            while(one.size()<candidates && l<=r)\\n            {\\n                one.push(costs[l]);\\n                l++;\\n            }\\n\\n            while(two.size()<candidates &&l<=r)\\n            {\\n                two.push(costs[r]);\\n                r--;\\n            }\\n        \\n\\n        int top1=INT_MAX;\\n        int top2=INT_MAX;\\n\\n        if(one.size()>0)\\n        {\\n            top1=one.top();\\n        }\\n\\n        if(two.size()>0)\\n        {\\n            top2=two.top();\\n        }\\n\\n        if(top1<=top2)\\n        {\\n            ans+=top1;\\n            one.pop();\\n        }\\n\\n        else\\n        {\\n            ans+=top2;\\n            two.pop();\\n        }\\n\\n        cnt++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans=0;\\n        int cnt=0;\\n        int l=0,r=costs.size()-1;\\n        priority_queue <int, vector<int>, greater<int>> one;\\n        priority_queue <int, vector<int>, greater<int>> two;\\n\\n        while(cnt<k)\\n        {\\n            while(one.size()<candidates && l<=r)\\n            {\\n                one.push(costs[l]);\\n                l++;\\n            }\\n\\n            while(two.size()<candidates &&l<=r)\\n            {\\n                two.push(costs[r]);\\n                r--;\\n            }\\n        \\n\\n        int top1=INT_MAX;\\n        int top2=INT_MAX;\\n\\n        if(one.size()>0)\\n        {\\n            top1=one.top();\\n        }\\n\\n        if(two.size()>0)\\n        {\\n            top2=two.top();\\n        }\\n\\n        if(top1<=top2)\\n        {\\n            ans+=top1;\\n            one.pop();\\n        }\\n\\n        else\\n        {\\n            ans+=top2;\\n            two.pop();\\n        }\\n\\n        cnt++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683869,
                "title": "c-85-fast-easy-and-clean-code-heaps",
                "content": "# Intuition\\nMake 2 min Heap, 1 for starting elements and other for ending elements. Then keep comparing their top and keep adding upcoming elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> left, right;\\n\\n        int i=0, j=costs.size()-1;\\n        while(i < candidates){\\n            left.push(costs[i]);\\n            costs[i] = INT_MAX;\\n            i++;\\n        }\\n        while(costs.size()-1-j < candidates){\\n            right.push(costs[j]);\\n            costs[j] = INT_MAX;\\n            j--;\\n        }\\n\\n        long long ans = 0;\\n        while(k--){\\n            if(!right.size() || (left.size() && left.top() <= right.top())){\\n                int num = left.top();\\n                left.pop();\\n\\n                ans += num;\\n\\n                if(i < costs.size()){\\n                    left.push(costs[i]);\\n                    costs[i] = INT_MAX;\\n                    i++;\\n                }\\n            }\\n            else{\\n                int num = right.top();\\n                right.pop();\\n\\n                ans += num;\\n                \\n                if(j >= 0){\\n                    right.push(costs[j]);\\n                    costs[j] = INT_MAX;\\n                    j--;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> left, right;\\n\\n        int i=0, j=costs.size()-1;\\n        while(i < candidates){\\n            left.push(costs[i]);\\n            costs[i] = INT_MAX;\\n            i++;\\n        }\\n        while(costs.size()-1-j < candidates){\\n            right.push(costs[j]);\\n            costs[j] = INT_MAX;\\n            j--;\\n        }\\n\\n        long long ans = 0;\\n        while(k--){\\n            if(!right.size() || (left.size() && left.top() <= right.top())){\\n                int num = left.top();\\n                left.pop();\\n\\n                ans += num;\\n\\n                if(i < costs.size()){\\n                    left.push(costs[i]);\\n                    costs[i] = INT_MAX;\\n                    i++;\\n                }\\n            }\\n            else{\\n                int num = right.top();\\n                right.pop();\\n\\n                ans += num;\\n                \\n                if(j >= 0){\\n                    right.push(costs[j]);\\n                    costs[j] = INT_MAX;\\n                    j--;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683808,
                "title": "min-heap-priority-queue-aryan-mittal-two-pointer-c",
                "content": "[Help: ](http:/https://www.youtube.com/watch?v=9voS0KO1HuY/)\\n\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        \\n        priority_queue<int, vector<int>, greater<int>>pleft, pright;\\n        long long sum = 0;\\n        int i = 0, j = costs.size() - 1, c = 0;\\n        \\n        while(c < k)\\n        {\\n\\t\\t//inserting the left candidates number of elements \\n            while(i <=j && pleft.size() < candidates)\\n            {\\n                pleft.push(costs[i++]);\\n            }\\n            \\n\\t\\t\\t//inserting the right candidates number of elements \\n            while(j >= i && pright.size() < candidates)\\n            {\\n                pright.push(costs[j--]);\\n            }\\n            \\n\\t\\t\\t//Calculating the minimum among these elements and adding it to our answer, removing it from the respective queue as well\\n            int a = pleft.size() > 0 ? pleft.top(): 1e9;\\n            int b = pright.size() > 0 ? pright.top() : 1e9;\\n            \\n            if(a <= b)\\n            {\\n                sum += a;\\n                pleft.pop();\\n            }\\n            else\\n            {\\n                sum += b;\\n                pright.pop();\\n            }\\n            \\n            c++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        \\n        priority_queue<int, vector<int>, greater<int>>pleft, pright;\\n        long long sum = 0;\\n        int i = 0, j = costs.size() - 1, c = 0;\\n        \\n        while(c < k)\\n        {\\n\\t\\t//inserting the left candidates number of elements \\n            while(i <=j && pleft.size() < candidates)\\n            {\\n                pleft.push(costs[i++]);\\n            }\\n            \\n\\t\\t\\t//inserting the right candidates number of elements \\n            while(j >= i && pright.size() < candidates)\\n            {\\n                pright.push(costs[j--]);\\n            }\\n            \\n\\t\\t\\t//Calculating the minimum among these elements and adding it to our answer, removing it from the respective queue as well\\n            int a = pleft.size() > 0 ? pleft.top(): 1e9;\\n            int b = pright.size() > 0 ? pright.top() : 1e9;\\n            \\n            if(a <= b)\\n            {\\n                sum += a;\\n                pleft.pop();\\n            }\\n            else\\n            {\\n                sum += b;\\n                pright.pop();\\n            }\\n            \\n            c++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683725,
                "title": "best-c-solution-priority-queue-fully-optimised-possible-solution",
                "content": "Define a variable ans to keep track of the total cost of hiring k workers.\\n\\nDefine two priority queues pq1 and pq2 with the greater comparator to store the lowest candidates costs seen so far from the beginning and the end of the costs vector, respectively.\\n\\n\\nlong long ans=0;\\npriority_queue<int,vector<int>,greater<int>> pq1,pq2;\\nInitialize the variables cnt, i, and j to 0, 0, and costs.size()-1, respectively. These variables will be used to keep track of the number of workers hired so far, the index of the first worker being considered, and the index of the last worker being considered, respectively.\\n\\nint cnt = 0;\\nint i=0;\\nint j=costs.size()-1;\\nEnter a loop that continues until cnt is equal to k, which is the number of workers to be hired.\\n\\nwhile(cnt<k){\\nWithin the loop, enter another loop that adds the lowest candidates costs from the beginning of the costs vector to pq1 and from the end of the costs vector to pq2.\\nstylus\\n\\nwhile(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\nwhile(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\nGet the lowest cost from pq1 and pq2 and add it to the total cost ans. If the lowest cost is from pq1, pop the top element from pq1. If the lowest cost is from pq2, pop the top element from pq2.\\napache\\n\\nint cost1 = pq1.size()>0?pq1.top():INT_MAX;\\nint cost2 = pq2.size()>0?pq2.top():INT_MAX;\\n\\nif(cost1<=cost2){\\n\\n   ans += cost1;\\n   pq1.pop();\\n}\\nelse{\\n\\n  ans += cost2;\\n  pq2.pop();\\n}\\nIncrement cnt to indicate that another worker has been hired.\\n\\ncnt++;\\nReturn the total cost ans.\\n\\nreturn ans;\\n# Code\\n```\\n\\n// TC - O((Candidates + k)Log(Candidates+k))\\n// SC - O(Candidates)\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        long long ans=0;\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n\\n        int cnt = 0;\\n        int i=0;\\n        int j=costs.size()-1;\\n\\n        while(cnt<k){\\n\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int cost1 = pq1.size()>0?pq1.top():INT_MAX;\\n            int cost2 = pq2.size()>0?pq2.top():INT_MAX;\\n\\n            if(cost1<=cost2){\\n\\n               ans += cost1;\\n               pq1.pop();\\n            }\\n            else{\\n\\n              ans += cost2;\\n              pq2.pop();\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// TC - O((Candidates + k)Log(Candidates+k))\\n// SC - O(Candidates)\\n\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n\\n        long long ans=0;\\n        priority_queue<int,vector<int>,greater<int>> pq1,pq2;\\n\\n        int cnt = 0;\\n        int i=0;\\n        int j=costs.size()-1;\\n\\n        while(cnt<k){\\n\\n            while(pq1.size()<candidates && i<=j) pq1.push(costs[i++]);\\n            while(pq2.size()<candidates && j>=i) pq2.push(costs[j--]);\\n\\n            int cost1 = pq1.size()>0?pq1.top():INT_MAX;\\n            int cost2 = pq2.size()>0?pq2.top():INT_MAX;\\n\\n            if(cost1<=cost2){\\n\\n               ans += cost1;\\n               pq1.pop();\\n            }\\n            else{\\n\\n              ans += cost2;\\n              pq2.pop();\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683721,
                "title": "priority-queue-c",
                "content": "# if it helps you, Upvote me Please...! \\u2764\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Problems Looks Easy but how do you handle Overlaps conditions.**\\n\\nhere i used two priority queues one for **left side** and one for **right side** and i maintain a size equal to candidates.\\n\\nto Handel **overlap condition** i store the **index values** also, because after selecting a minimum value from any index, change the **value to 0 for that index**.\\n\\n**Overlap Condition:-** a single element appears in both priority Queues. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n = costs.size();\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        long long ans = 0;\\n        int i  = 0,j = n-1,count = 0;\\n\\n        while(count<k)\\n        {\\n            while(i<n && pq1.size()<c)\\n            {\\n              pq1.push({-1*costs[i],i});  \\n              i++;\\n            }\\n            while(j>=0 && pq2.size()<c)\\n            {\\n              pq2.push({-1*costs[j],j});\\n              j--;  \\n            }\\n\\n            while(pq1.size()>0 && costs[pq1.top().second]==0)\\n            pq1.pop();\\n\\n            while(pq2.size()>0 && costs[pq2.top().second]==0)\\n            pq2.pop();\\n\\n\\n            if(pq1.size()>0 && pq2.size()>0)\\n            {\\n               if(abs(pq1.top().first) <= abs(pq2.top().first))\\n               {\\n                   ans+=abs(pq1.top().first);\\n                   costs[pq1.top().second] = 0;\\n                   pq1.pop();\\n                   count++;\\n               }\\n               else\\n               {\\n                   ans+=abs(pq2.top().first);\\n                   costs[pq2.top().second] = 0;\\n                   pq2.pop(); \\n                   count++;\\n               }\\n            }\\n            else if(pq1.size()>0)\\n            {\\n                   ans+=abs(pq1.top().first);\\n                   costs[pq1.top().second] = 0;\\n                   pq1.pop(); \\n                   count++;\\n            }\\n            else if(pq2.size()>0)\\n            {\\n                   ans+=abs(pq2.top().first);\\n                   costs[pq2.top().second] = 0;\\n                   pq2.pop();  \\n                   count++;\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4662b633-2294-41e6-ad65-396770e1a892_1687760174.4611058.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) {\\n        int n = costs.size();\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        long long ans = 0;\\n        int i  = 0,j = n-1,count = 0;\\n\\n        while(count<k)\\n        {\\n            while(i<n && pq1.size()<c)\\n            {\\n              pq1.push({-1*costs[i],i});  \\n              i++;\\n            }\\n            while(j>=0 && pq2.size()<c)\\n            {\\n              pq2.push({-1*costs[j],j});\\n              j--;  \\n            }\\n\\n            while(pq1.size()>0 && costs[pq1.top().second]==0)\\n            pq1.pop();\\n\\n            while(pq2.size()>0 && costs[pq2.top().second]==0)\\n            pq2.pop();\\n\\n\\n            if(pq1.size()>0 && pq2.size()>0)\\n            {\\n               if(abs(pq1.top().first) <= abs(pq2.top().first))\\n               {\\n                   ans+=abs(pq1.top().first);\\n                   costs[pq1.top().second] = 0;\\n                   pq1.pop();\\n                   count++;\\n               }\\n               else\\n               {\\n                   ans+=abs(pq2.top().first);\\n                   costs[pq2.top().second] = 0;\\n                   pq2.pop(); \\n                   count++;\\n               }\\n            }\\n            else if(pq1.size()>0)\\n            {\\n                   ans+=abs(pq1.top().first);\\n                   costs[pq1.top().second] = 0;\\n                   pq1.pop(); \\n                   count++;\\n            }\\n            else if(pq2.size()>0)\\n            {\\n                   ans+=abs(pq2.top().first);\\n                   costs[pq2.top().second] = 0;\\n                   pq2.pop();  \\n                   count++;\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683691,
                "title": "easy-priority-queue-with-class-solution-clean-simple-code",
                "content": "Time Complexity :- O(n*logn)\\nSpace Complexity :- O(n)\\n```\\nclass Drive{\\n    public :\\n    int cost;\\n    int flag;\\n    Drive(int cost,bool flag)\\n    {\\n        this->cost = cost;\\n        this->flag = flag;\\n    }\\n    \\n};\\n\\nclass myComparator{\\npublic:\\n    int operator() (const Drive* p1, const Drive* p2)\\n    {\\n        if( p1->cost > p2->cost)\\n            return true;\\n        if(p1->cost == p2->cost)\\n        {\\n            if(p1->flag > p2->flag)\\n                return true;\\n            else if(p1->flag < p2->flag)\\n                return false; \\n        }\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        \\n        priority_queue<Drive* ,vector<Drive*>, myComparator>pq;\\n        int candi = candidates;\\n        int i = 0;\\n        for(i=0;i<candi;i++)\\n        {\\n            Drive *dnode = new Drive(costs[i],0);\\n            pq.push(dnode);\\n        }\\n        int start = i-1;\\n        i = n-1;\\n        while(candi-- != 0)\\n        {\\n            if(i == start)\\n                break;\\n            Drive *dnode = new Drive(costs[i],1);\\n            pq.push(dnode);\\n            i--;\\n        }\\n        int end = i+1;\\n        long long ans = 0;\\n        while(k-- != 0 )\\n        {\\n            Drive *dnode = pq.top();\\n            pq.pop();\\n            ans += (long long)dnode->cost;\\n            \\n            bool flag = dnode->flag;\\n            \\n            if(flag == 1)\\n            {\\n                end--;\\n                if(end <=  start)\\n                    continue;\\n                Drive *dnode1 = new Drive(costs[end],1);\\n                pq.push(dnode1);\\n            }\\n            else\\n            {\\n                start++;\\n                if(start >= end)\\n                    continue;\\n                Drive *dnode1 = new Drive(costs[start],0);\\n                pq.push(dnode1);\\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Drive{\\n    public :\\n    int cost;\\n    int flag;\\n    Drive(int cost,bool flag)\\n    {\\n        this->cost = cost;\\n        this->flag = flag;\\n    }\\n    \\n};\\n\\nclass myComparator{\\npublic:\\n    int operator() (const Drive* p1, const Drive* p2)\\n    {\\n        if( p1->cost > p2->cost)\\n            return true;\\n        if(p1->cost == p2->cost)\\n        {\\n            if(p1->flag > p2->flag)\\n                return true;\\n            else if(p1->flag < p2->flag)\\n                return false; \\n        }\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n = costs.size();\\n        \\n        priority_queue<Drive* ,vector<Drive*>, myComparator>pq;\\n        int candi = candidates;\\n        int i = 0;\\n        for(i=0;i<candi;i++)\\n        {\\n            Drive *dnode = new Drive(costs[i],0);\\n            pq.push(dnode);\\n        }\\n        int start = i-1;\\n        i = n-1;\\n        while(candi-- != 0)\\n        {\\n            if(i == start)\\n                break;\\n            Drive *dnode = new Drive(costs[i],1);\\n            pq.push(dnode);\\n            i--;\\n        }\\n        int end = i+1;\\n        long long ans = 0;\\n        while(k-- != 0 )\\n        {\\n            Drive *dnode = pq.top();\\n            pq.pop();\\n            ans += (long long)dnode->cost;\\n            \\n            bool flag = dnode->flag;\\n            \\n            if(flag == 1)\\n            {\\n                end--;\\n                if(end <=  start)\\n                    continue;\\n                Drive *dnode1 = new Drive(costs[end],1);\\n                pq.push(dnode1);\\n            }\\n            else\\n            {\\n                start++;\\n                if(start >= end)\\n                    continue;\\n                Drive *dnode1 = new Drive(costs[start],0);\\n                pq.push(dnode1);\\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683681,
                "title": "priority-queue-easy-to-understand",
                "content": "# Intuition\\nThis problem can be solved by using priority queue and some mathematics.\\nLets suppose there are m candidates\\nInitialise i=0,j=n-1;\\nFirstly we push cost of first m candidates from begin and from last along with their indces in priority queue by incrementing i and decrementing j ( such that no element is pushed twice, we check for condition i<candidates).\\nSo, while k (workers count > 0 ) we increase cost by top element of priority queue.(minimum cost among first m candidates and last m candidates) and check for what index of element is poped. If that index is greater that j implies that poped candidates is from end so push one candidate from end(i.e,jth  as after this already pushed ) and decrement j.\\nelse poped candidates is from begin so push one candidate from begin(ith) and increment i.\\nrepeat until k>0.\\nreturn cost.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n// TC - O((k)Log(2*Candidates)) + O(Candidates)\\n\\n\\n- Space complexity:\\n// SC - O(2*Candidates)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   # define ll long long\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n      \\n        int n=costs.size();\\n        if(n==1) return costs[0];\\n        int i=0,j=n-1;\\n        long long cost=0;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        while(i<j && i<candidates ){\\n              pq.push({costs[i],i});\\n              pq.push({costs[j],j});\\n              i++;j--;\\n        }\\n        \\n        while(k>0){\\n           int ind=pq.top().second;\\n           cost+=(ll)pq.top().first;\\n           pq.pop(); //cout<<ind<<\" \"<<i<<\" \"<<j<<endl;\\n           if(i<=j){ \\n               if(ind>j){\\n                   pq.push({costs[j],j});\\n                   j--;\\n               }\\n               else{\\n                   pq.push({costs[i],i});\\n                   i++;\\n               }\\n           } //cout<<cost<<endl;\\n           k--;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   # define ll long long\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n      \\n        int n=costs.size();\\n        if(n==1) return costs[0];\\n        int i=0,j=n-1;\\n        long long cost=0;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        while(i<j && i<candidates ){\\n              pq.push({costs[i],i});\\n              pq.push({costs[j],j});\\n              i++;j--;\\n        }\\n        \\n        while(k>0){\\n           int ind=pq.top().second;\\n           cost+=(ll)pq.top().first;\\n           pq.pop(); //cout<<ind<<\" \"<<i<<\" \"<<j<<endl;\\n           if(i<=j){ \\n               if(ind>j){\\n                   pq.push({costs[j],j});\\n                   j--;\\n               }\\n               else{\\n                   pq.push({costs[i],i});\\n                   i++;\\n               }\\n           } //cout<<cost<<endl;\\n           k--;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3683662,
                "title": "c-min-heap-two-pointers-tc-o-max-k-cand-log-cand-sc-o-cand",
                "content": "INTUITION : We have to select minimum element always from group of elements, and most important we have to remove that element also from the group and also we need to add more elements(eligible candidates). Hence, it\\'s simple to use MIN HEAP(Priority Queue).\\nTC & SC mentioned in the title !!\\nNow it\\'s easy, we only have to focus on the implementation part. Using concept of Two pointers also.\\n\\nAdded the comments in the code!! You can upvote if you liked it!!\\n```\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;\\n        \\n\\t\\t//min heap declaration - {( cost ), ( element is from left or right ) },  as I will pop out element from min heap,\\n\\t\\t// I will be checking element is from left or right, and according to which adding the new candidate from that side\\n\\t\\tpriority_queue<pair<int, char>, vector<pair<int, char>>, greater<pair<int, char>>> pq;\\n        int n = costs.size();\\n        \\n\\t\\t//adding all eligible candidates from left for 1st session\\n        int i;\\n        for(i = 0; i < n && i < candidates; i++)\\n        {\\n            pq.push({costs[i], \\'L\\'});\\n        }\\n        \\n\\t\\t//adding all eligible candidates from right\\n        int j;\\n        for(j = n - 1; j >= i && (n - j) <= candidates; j--)\\n        {\\n            pq.push({costs[j], \\'R\\'});\\n        }\\n        \\n        while(k--)\\n        {\\n            int mini = pq.top().first;\\n            char side = pq.top().second;\\n            pq.pop();\\n            ans += 1LL*mini;\\n            \\n\\t\\t\\t//if popped element is from left side, then add one more candidate in min Heap and shift our left pointer \\n            if(side == \\'L\\' && i <= j)\\n            {\\n                pq.push({costs[i], \\'L\\'});\\n                i++;\\n            }\\n\\t\\t\\t//similarly for right also\\n            if(side == \\'R\\' && j >= i)\\n            {\\n                pq.push({costs[j], \\'R\\'});\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlong long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long ans = 0;\\n        \\n\\t\\t//min heap declaration - {( cost ), ( element is from left or right ) },  as I will pop out element from min heap,\\n\\t\\t// I will be checking element is from left or right, and according to which adding the new candidate from that side\\n\\t\\tpriority_queue<pair<int, char>, vector<pair<int, char>>, greater<pair<int, char>>> pq;\\n        int n = costs.size();\\n        \\n\\t\\t//adding all eligible candidates from left for 1st session\\n        int i;\\n        for(i = 0; i < n && i < candidates; i++)\\n        {\\n            pq.push({costs[i], \\'L\\'});\\n        }\\n        \\n\\t\\t//adding all eligible candidates from right\\n        int j;\\n        for(j = n - 1; j >= i && (n - j) <= candidates; j--)\\n        {\\n            pq.push({costs[j], \\'R\\'});\\n        }\\n        \\n        while(k--)\\n        {\\n            int mini = pq.top().first;\\n            char side = pq.top().second;\\n            pq.pop();\\n            ans += 1LL*mini;\\n            \\n\\t\\t\\t//if popped element is from left side, then add one more candidate in min Heap and shift our left pointer \\n            if(side == \\'L\\' && i <= j)\\n            {\\n                pq.push({costs[i], \\'L\\'});\\n                i++;\\n            }\\n\\t\\t\\t//similarly for right also\\n            if(side == \\'R\\' && j >= i)\\n            {\\n                pq.push({costs[j], \\'R\\'});\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683531,
                "title": "kotlin-two-pointer-priority-queue",
                "content": "![image.png](https://assets.leetcode.com/users/images/f654304d-c58d-436f-a2f7-e995d6a1a832_1687756508.645389.png)\\n\\n#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/257\\n#### Problem TLDR\\nThe sum of the smallest cost from suffix and prefix of a `costs` size of `candidates` in `k` iterations\\n#### Intuition\\nDescription of the problem is rather ambiguous: we actually need to consider `candidates` count of items from the head and from the tail of the `costs` array. Then we can use `PriorityQueue` to choose the minimum and adjust two pointers `lo` and `hi`. \\n\\n#### Approach\\n* use separate condition, when `2 * candidates >= costs.size`\\n* careful with indexes, check yourself by doing dry run\\n* we can use separate variable `takenL` and `takenR` or just use queue\\'s sizes to minify the code\\n#### Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n- Space complexity:\\n$$O(n)$$\\n#### Code\\n```\\n\\n    fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {\\n        val pqL = PriorityQueue<Int>()\\n        val pqR = PriorityQueue<Int>()\\n        var lo = 0\\n        var hi = costs.lastIndex\\n        var sum = 0L\\n        var count = 0\\n        if (2 * candidates >= costs.size) while (lo <= hi) pqL.add(costs[lo++])\\n        while (pqL.size < candidates && lo <= hi) pqL.add(costs[lo++])\\n        while (pqR.size < candidates && lo < hi) pqR.add(costs[hi--])\\n        while (lo <= hi && count++ < k) {\\n            if (pqR.peek() < pqL.peek()) {\\n                sum += pqR.poll()\\n                pqR.add(costs[hi--])\\n            } else {\\n                sum += pqL.poll()\\n                pqL.add(costs[lo++])\\n            }\\n        }\\n        while (pqR.isNotEmpty()) pqL.add(pqR.poll())\\n        while (count++ < k && pqL.isNotEmpty()) sum += pqL.poll()\\n        return sum\\n    }\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n    fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {\\n        val pqL = PriorityQueue<Int>()\\n        val pqR = PriorityQueue<Int>()\\n        var lo = 0\\n        var hi = costs.lastIndex\\n        var sum = 0L\\n        var count = 0\\n        if (2 * candidates >= costs.size) while (lo <= hi) pqL.add(costs[lo++])\\n        while (pqL.size < candidates && lo <= hi) pqL.add(costs[lo++])\\n        while (pqR.size < candidates && lo < hi) pqR.add(costs[hi--])\\n        while (lo <= hi && count++ < k) {\\n            if (pqR.peek() < pqL.peek()) {\\n                sum += pqR.poll()\\n                pqR.add(costs[hi--])\\n            } else {\\n                sum += pqL.poll()\\n                pqL.add(costs[lo++])\\n            }\\n        }\\n        while (pqR.isNotEmpty()) pqL.add(pqR.poll())\\n        while (count++ < k && pqL.isNotEmpty()) sum += pqL.poll()\\n        return sum\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683378,
                "title": "swift-2-heaps-k-smallest-solution",
                "content": "# Approach\\n\\n*Observation:* If sum of candidate ranges lengths on both sides plus (k-1) their advances is equal or bigger than total workers count, that means that total pick range during the hiring process wil cover all workers. And for that case, the ones to be hired are $k$ workers with smallest costs among all.\\n\\nSo, we split the problem in two, based on the condition `if candidatesRange * 2 + k > n`. If left-side value exceeds $n$, the problem is reduced to well-known task of selecting $k$ smallest values from array. If not, we\\'ll employ the default 2 heaps approach for this problem.\\n\\n## Two Heaps(Priority Queues) branch\\n\\nUse one min-heap for the `candidatesRange` workers on the left side and one for the  `candidatesRange` workers on the right side of `costs` array. Pick the smallest cost worker from them one-by-one and advance corresponding heap\\'s range to the opposite side, absorbing new potential workers to replace the hired one.\\nPretty much the same as amply explained in [Editorial](https://leetcode.com/problems/total-cost-to-hire-k-workers/editorial). The one difference is that in our solution, the condition `candidatesRange * 2 + k <= n` holds for 2 heaps branch. And that conveniently guarantees that the heaps will not run out of elements and their ranges won\\'t intersect, so there won\\'t be any double counting possible. Saves from a lot of checking.\\n\\n## k smallest branch\\n\\nThere are several ways to solve a [\"selection of k-smallest\"](https://en.wikipedia.org/wiki/Selection_algorithm) problem. We\\'ll implement some of them and try to choose the most suitable one based on values of **n**, **k** and **candidatesRange**. (Inspired by a similar choice in [Introselect](https://en.wikipedia.org/wiki/Introselect), though, of course, we will have a much more primitive version).\\n\\n- **[Heapselect](https://en.wikipedia.org/?title=Heapselect)**\\nInitialize max-heap of $k$ size with the first $k$ elements. For each next item in the array, check whether it\\'s smaller than the max in the heap. If it is, remove the max and put that item into heap instead. If it\\'s bigger, just go further. **At the end, heap will hold k smallest elements** from array.\\nTime complexity: $O(n\\\\cdot\\\\log k)$, space complexity: $O(k)$\\n- **[Quickselect](https://en.wikipedia.org/wiki/Quickselect)**\\nQuickselect uses the same overall approach as quicksort: choose one random element as a pivot and partition the array based on the pivot value, so the items less than it be on left and greater be on right. Unlike quicksort, quickselect then only continues to repeat this work with one side \\u2013 the side which holds the *k*th index from end. Repeat until the partition dividing index will not be that *k*th from end index, which means that the value in it is the searched one, *k*th biggest or smallest in array. Quickselect is generally implemented as an in-place algorithm, and beyond selecting the *k*th element, it also partially sorts the data, which is *just* what we need - after it finishes, **on one side there will be *k* smallest items** in array, and on other - *n-k* largest.\\nThe average time complexity is $O(n)$, with a worst case of $O(n^{2})$. Space complexity is $O(n)$, as we need to copy an array for modifying.\\n- Built-in sort. The main advantage is being built-in and highly optimized. Swift uses [Timsort](https://en.wikipedia.org/wiki/Timsort), which has an average time $O(n\\\\cdot\\\\log n)$ and worst-case space complexity of $O(n)$.\\n\\n\\n## Complexity\\n\\n###### $n$ is workers count, $k$ is amount to hire, $m$ is candidates ranges length\\n\\n- Time complexity: $O(n\\\\cdot\\\\log n)$\\n$O(m + k\\\\cdot\\\\log m)$ for the heaps route, $O(n\\\\cdot\\\\log n)$ for the case of k smallest route. As $m, k \\\\le n$, it can be brought to more rough $O(n\\\\cdot\\\\log n)$ for both cases.\\n- Space complexity: $O(n)$\\n$O(m)$ for the 2 heaps route, $O(n)$ for k smallest route.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    func totalCost(_ costs: [Int], _ k: Int, _ candidatesRange: Int) -> Int\\n    {\\n        let n = costs.count\\n        if k == n { return costs.reduce(0, +) } // edge case shortcut\\n\\n        if candidatesRange * 2 + k > n // k smallest route\\n        {\\n            if k == 1 { return costs.min()! } // edge case shortcut\\n\\n            if k < 32 // heapselect\\n            {\\n                let maxHeap = Heap(of: costs[..<k], sort: >)\\n                for cost in costs[k...] where cost < maxHeap.peek() {\\n                    maxHeap.popThenPush(cost)\\n                }\\n                return maxHeap.items.reduce(0, +)\\n            }\\n            else if n > 100 // quickselect\\n            {\\n                var costs = costs\\n                costs.quickselect(n-k)\\n                return costs[..<k].reduce(0, +)\\n            }\\n            else // built-in sort\\n            {             \\n                return costs.sorted()[..<k].reduce(0, +)\\n            }\\n        }\\n        else // 2 heaps route\\n        {\\n            var leftRangeBound = candidatesRange\\n            var rightRangeBound = n - 1 - candidatesRange\\n\\n            let firstWorkers = Heap(of: costs[..<leftRangeBound])\\n            let lastWorkers = Heap(of: costs[(rightRangeBound+1)...])\\n            \\n            var totalCost = 0\\n            for _ in 1...k\\n            {\\n                if firstWorkers.peek() <= lastWorkers.peek() {\\n                    totalCost += firstWorkers.popThenPush(costs[leftRangeBound])\\n                    leftRangeBound += 1\\n                }\\n                else {\\n                    totalCost += lastWorkers.popThenPush(costs[rightRangeBound])\\n                    rightRangeBound -= 1\\n                }\\n            }\\n            return totalCost\\n        }\\n    }\\n}\\n\\nclass Heap<T>\\n{\\n    typealias Comparator = (T, T) -> Bool\\n    private(set) var items: [T]    \\n    var isEmpty: Bool { return items.isEmpty }    \\n    var count: Int { return items.count }\\n    func peek() -> T! { return items.first }\\n\\n    // pass operator \\'>\\' for a max-heap, \\'<\\' for a min-heap, or custom comparing function\\n    // use \"withoutOrdering\" if array is already in proper form for binary tree, e.g. sorted\\n    init(_ array: [T], sort: @escaping Comparator, withoutOrdering: Bool = false)\\n    {\\n        self.items = array\\n        self.orderCriterion = sort\\n        if withoutOrdering { return }                         \\n        for i in stride(from: (items.count/2 - 1), through: 0, by: -1) {\\n            siftUp(i)   // inspired by Pyton\\'s\\' heapify, O(n) time complexity for the whole array\\n        }\\n    }\\n    convenience init(sort: @escaping Comparator) {\\n        self.init([], sort: sort)\\n    }\\n    convenience init<S: Sequence>(of s: S, sort: @escaping Comparator) where S.Element == T {\\n        self.init(Array(s), sort: sort)\\n    }\\n    \\n    func push(_ value: T) {\\n        items.append(value)\\n        siftDown(items.count - 1)\\n    }    \\n    func push<S: Sequence>(_ s: S) where S.Element == T {\\n        for value in s { push(value) }\\n    }\\n\\n    // takes the root node from heap (max value for a max-heap, min value for a min-heap)    \\n    @discardableResult func pop() -> T!\\n    {\\n        if items.isEmpty { return nil }        \\n        if items.count == 1 { return items.removeLast() }\\n        defer { items[0] = items.removeLast(); siftUp() }     \\n        return items[0]\\n    }\\n\\n    // push + pop in one action, more efficient than simply calling push then pop\\n    @discardableResult func pushThenPop(_ value: T) -> T      // aka \\'heappushpop\\'\\n    {\\n        if items.isEmpty || orderCriterion(value, items[0]) { return value }\\n        defer { items[0] = value; siftUp() }        \\n        return items[0]\\n    }\\n    // pop + push in one action, more efficient than simply calling pop then push\\n    @discardableResult func popThenPush(_ value: T) -> T!     // aka \\'heapreplace\\'\\n    {\\n        if items.isEmpty || items.count == 1 {\\n            defer { items = [value] }; return items.first\\n        }\\n        defer { items[0] = value; siftUp() }\\n        return items[0]\\n    }\\n    \\n    func clear() { items = [] }\\n\\n    private var orderCriterion: Comparator\\n    @inline(__always) private func parent(of index: Int) -> Int { (index - 1) / 2 }\\n    @inline(__always) private func leftChild(of index: Int) -> Int { 2 * index + 1 }\\n    @inline(__always) private func rightChild(of index: Int) -> Int { 2 * index + 2 }\\n\\n    // moves the value from given index up to its respective position in binary tree\\n    private func siftDown(_ index: Int)\\n    {\\n        let value = items[index]\\n        var childInd = index, parentInd = parent(of: childInd)        \\n        while childInd > 0 && orderCriterion(value, items[parentInd]) {\\n            items[childInd] = items[parentInd]\\n            (childInd, parentInd) = (parentInd, parent(of: parentInd))\\n        }        \\n        items[childInd] = value\\n    }\\n    \\n    // restores the items heap order by moving the item from given index towards the end of array\\n    private func siftUp(_ index: Int = 0)\\n    {\\n        let end = items.count\\n        var parentInd = index, leftChildInd, rightChildInd: Int\\n        var firstInFamily = parentInd //min of these three for min-heap, max of them for max-heap\\n        while true\\n        {\\n            leftChildInd = leftChild(of: parentInd)\\n            rightChildInd = leftChildInd + 1\\n\\n            if leftChildInd < end && orderCriterion(items[leftChildInd], items[firstInFamily]) {\\n                firstInFamily = leftChildInd\\n            }\\n            if rightChildInd < end && orderCriterion(items[rightChildInd], items[firstInFamily]) {\\n                firstInFamily = rightChildInd\\n            }\\n            if firstInFamily == parentInd { break }\\n\\n            items.swapAt(firstInFamily, parentInd)\\n            parentInd = firstInFamily\\n        }\\n    }\\n}\\n\\nextension Heap where T: Comparable {\\n    convenience init(_ array: [T], withoutOrdering: Bool = false) { // defaults for min-heap\\n        self.init(array, sort: <, withoutOrdering: withoutOrdering)\\n    } \\n    convenience init() { self.init([]) }\\n    convenience init<S: Sequence>(of s: S) where S.Element == T { self.init(Array(s)) }\\n}\\n\\nextension Array where Element: Comparable\\n{\\n    // partly sorts the array in a way that k biggest values will be at the end,\\n    // and the kth largest element will be exactly at its index k away from end\\n    @discardableResult mutating func quickselect(_ k: Int) -> Element\\n    {\\n        var range = startIndex..<endIndex\\n        let targetIndex = self.count - k\\n        var pivotValue: Element, valueRange: Range<Index>\\n        while true\\n        {\\n            if range.isEmpty { return self[targetIndex] }\\n            pivotValue = self[Int.random(in: range)]\\n            valueRange = threeWayPartition(pivotValue)\\n            if valueRange.contains(targetIndex) {\\n                return self[targetIndex]\\n            }\\n            else if targetIndex < valueRange.lowerBound { // go left\\n                range = (range.lowerBound)..<(valueRange.lowerBound)\\n            }\\n            else { // go right             \\n                range = (valueRange.upperBound)..<(range.upperBound)\\n            }\\n        }\\n        // returns range of values equal to pivotValue\\n        func threeWayPartition(_ pivotValue: Element) -> Range<Index>\\n        {\\n            var i = range.lowerBound, j = i\\n            var top = range.upperBound - 1\\n            while j <= top\\n            {\\n                if self[j] < pivotValue { self.swapAt(i, j); i += 1; j += 1 }\\n                else if self[j] > pivotValue { self.swapAt(j, top); top -= 1 }\\n                else { j += 1 }\\n            }\\n            return (i..<j)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    func totalCost(_ costs: [Int], _ k: Int, _ candidatesRange: Int) -> Int\\n    {\\n        let n = costs.count\\n        if k == n { return costs.reduce(0, +) } // edge case shortcut\\n\\n        if candidatesRange * 2 + k > n // k smallest route\\n        {\\n            if k == 1 { return costs.min()! } // edge case shortcut\\n\\n            if k < 32 // heapselect\\n            {\\n                let maxHeap = Heap(of: costs[..<k], sort: >)\\n                for cost in costs[k...] where cost < maxHeap.peek() {\\n                    maxHeap.popThenPush(cost)\\n                }\\n                return maxHeap.items.reduce(0, +)\\n            }\\n            else if n > 100 // quickselect\\n            {\\n                var costs = costs\\n                costs.quickselect(n-k)\\n                return costs[..<k].reduce(0, +)\\n            }\\n            else // built-in sort\\n            {             \\n                return costs.sorted()[..<k].reduce(0, +)\\n            }\\n        }\\n        else // 2 heaps route\\n        {\\n            var leftRangeBound = candidatesRange\\n            var rightRangeBound = n - 1 - candidatesRange\\n\\n            let firstWorkers = Heap(of: costs[..<leftRangeBound])\\n            let lastWorkers = Heap(of: costs[(rightRangeBound+1)...])\\n            \\n            var totalCost = 0\\n            for _ in 1...k\\n            {\\n                if firstWorkers.peek() <= lastWorkers.peek() {\\n                    totalCost += firstWorkers.popThenPush(costs[leftRangeBound])\\n                    leftRangeBound += 1\\n                }\\n                else {\\n                    totalCost += lastWorkers.popThenPush(costs[rightRangeBound])\\n                    rightRangeBound -= 1\\n                }\\n            }\\n            return totalCost\\n        }\\n    }\\n}\\n\\nclass Heap<T>\\n{\\n    typealias Comparator = (T, T) -> Bool\\n    private(set) var items: [T]    \\n    var isEmpty: Bool { return items.isEmpty }    \\n    var count: Int { return items.count }\\n    func peek() -> T! { return items.first }\\n\\n    // pass operator \\'>\\' for a max-heap, \\'<\\' for a min-heap, or custom comparing function\\n    // use \"withoutOrdering\" if array is already in proper form for binary tree, e.g. sorted\\n    init(_ array: [T], sort: @escaping Comparator, withoutOrdering: Bool = false)\\n    {\\n        self.items = array\\n        self.orderCriterion = sort\\n        if withoutOrdering { return }                         \\n        for i in stride(from: (items.count/2 - 1), through: 0, by: -1) {\\n            siftUp(i)   // inspired by Pyton\\'s\\' heapify, O(n) time complexity for the whole array\\n        }\\n    }\\n    convenience init(sort: @escaping Comparator) {\\n        self.init([], sort: sort)\\n    }\\n    convenience init<S: Sequence>(of s: S, sort: @escaping Comparator) where S.Element == T {\\n        self.init(Array(s), sort: sort)\\n    }\\n    \\n    func push(_ value: T) {\\n        items.append(value)\\n        siftDown(items.count - 1)\\n    }    \\n    func push<S: Sequence>(_ s: S) where S.Element == T {\\n        for value in s { push(value) }\\n    }\\n\\n    // takes the root node from heap (max value for a max-heap, min value for a min-heap)    \\n    @discardableResult func pop() -> T!\\n    {\\n        if items.isEmpty { return nil }        \\n        if items.count == 1 { return items.removeLast() }\\n        defer { items[0] = items.removeLast(); siftUp() }     \\n        return items[0]\\n    }\\n\\n    // push + pop in one action, more efficient than simply calling push then pop\\n    @discardableResult func pushThenPop(_ value: T) -> T      // aka \\'heappushpop\\'\\n    {\\n        if items.isEmpty || orderCriterion(value, items[0]) { return value }\\n        defer { items[0] = value; siftUp() }        \\n        return items[0]\\n    }\\n    // pop + push in one action, more efficient than simply calling pop then push\\n    @discardableResult func popThenPush(_ value: T) -> T!     // aka \\'heapreplace\\'\\n    {\\n        if items.isEmpty || items.count == 1 {\\n            defer { items = [value] }; return items.first\\n        }\\n        defer { items[0] = value; siftUp() }\\n        return items[0]\\n    }\\n    \\n    func clear() { items = [] }\\n\\n    private var orderCriterion: Comparator\\n    @inline(__always) private func parent(of index: Int) -> Int { (index - 1) / 2 }\\n    @inline(__always) private func leftChild(of index: Int) -> Int { 2 * index + 1 }\\n    @inline(__always) private func rightChild(of index: Int) -> Int { 2 * index + 2 }\\n\\n    // moves the value from given index up to its respective position in binary tree\\n    private func siftDown(_ index: Int)\\n    {\\n        let value = items[index]\\n        var childInd = index, parentInd = parent(of: childInd)        \\n        while childInd > 0 && orderCriterion(value, items[parentInd]) {\\n            items[childInd] = items[parentInd]\\n            (childInd, parentInd) = (parentInd, parent(of: parentInd))\\n        }        \\n        items[childInd] = value\\n    }\\n    \\n    // restores the items heap order by moving the item from given index towards the end of array\\n    private func siftUp(_ index: Int = 0)\\n    {\\n        let end = items.count\\n        var parentInd = index, leftChildInd, rightChildInd: Int\\n        var firstInFamily = parentInd //min of these three for min-heap, max of them for max-heap\\n        while true\\n        {\\n            leftChildInd = leftChild(of: parentInd)\\n            rightChildInd = leftChildInd + 1\\n\\n            if leftChildInd < end && orderCriterion(items[leftChildInd], items[firstInFamily]) {\\n                firstInFamily = leftChildInd\\n            }\\n            if rightChildInd < end && orderCriterion(items[rightChildInd], items[firstInFamily]) {\\n                firstInFamily = rightChildInd\\n            }\\n            if firstInFamily == parentInd { break }\\n\\n            items.swapAt(firstInFamily, parentInd)\\n            parentInd = firstInFamily\\n        }\\n    }\\n}\\n\\nextension Heap where T: Comparable {\\n    convenience init(_ array: [T], withoutOrdering: Bool = false) { // defaults for min-heap\\n        self.init(array, sort: <, withoutOrdering: withoutOrdering)\\n    } \\n    convenience init() { self.init([]) }\\n    convenience init<S: Sequence>(of s: S) where S.Element == T { self.init(Array(s)) }\\n}\\n\\nextension Array where Element: Comparable\\n{\\n    // partly sorts the array in a way that k biggest values will be at the end,\\n    // and the kth largest element will be exactly at its index k away from end\\n    @discardableResult mutating func quickselect(_ k: Int) -> Element\\n    {\\n        var range = startIndex..<endIndex\\n        let targetIndex = self.count - k\\n        var pivotValue: Element, valueRange: Range<Index>\\n        while true\\n        {\\n            if range.isEmpty { return self[targetIndex] }\\n            pivotValue = self[Int.random(in: range)]\\n            valueRange = threeWayPartition(pivotValue)\\n            if valueRange.contains(targetIndex) {\\n                return self[targetIndex]\\n            }\\n            else if targetIndex < valueRange.lowerBound { // go left\\n                range = (range.lowerBound)..<(valueRange.lowerBound)\\n            }\\n            else { // go right             \\n                range = (valueRange.upperBound)..<(range.upperBound)\\n            }\\n        }\\n        // returns range of values equal to pivotValue\\n        func threeWayPartition(_ pivotValue: Element) -> Range<Index>\\n        {\\n            var i = range.lowerBound, j = i\\n            var top = range.upperBound - 1\\n            while j <= top\\n            {\\n                if self[j] < pivotValue { self.swapAt(i, j); i += 1; j += 1 }\\n                else if self[j] > pivotValue { self.swapAt(j, top); top -= 1 }\\n                else { j += 1 }\\n            }\\n            return (i..<j)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683213,
                "title": "only-one-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        long long ans=0;\\n        if(costs.size()<=2*cand)\\n        {\\n            sort(costs.begin(),costs.end());\\n            for(int i=0;i<k;i++) ans+=costs[i];\\n        }\\n        else\\n        {\\n            priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n            int i=0,n=costs.size(),j=costs.size()-cand;\\n            for(i=0;i<cand;i++)\\n            {\\n                pq.push({costs[i],i});\\n                pq.push({costs[n-i-1],n-i-1});\\n            }\\n            i--;\\n            while(k && i<j)\\n            {\\n                auto v=pq.top(); pq.pop();\\n                long long res=v[0];\\n                int ind=v[1];\\n                ans+=res;\\n                k--;\\n                if(ind<=i) \\n                {\\n                    i++;\\n                    if(i<j)\\n                    pq.push({costs[i],i});\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i<j)\\n                    pq.push({costs[j],j});\\n                }\\n            }\\n            while(k)\\n            {\\n                ans+=pq.top()[0];\\n                pq.pop();\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//please upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int cand) {\\n        long long ans=0;\\n        if(costs.size()<=2*cand)\\n        {\\n            sort(costs.begin(),costs.end());\\n            for(int i=0;i<k;i++) ans+=costs[i];\\n        }\\n        else\\n        {\\n            priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n            int i=0,n=costs.size(),j=costs.size()-cand;\\n            for(i=0;i<cand;i++)\\n            {\\n                pq.push({costs[i],i});\\n                pq.push({costs[n-i-1],n-i-1});\\n            }\\n            i--;\\n            while(k && i<j)\\n            {\\n                auto v=pq.top(); pq.pop();\\n                long long res=v[0];\\n                int ind=v[1];\\n                ans+=res;\\n                k--;\\n                if(ind<=i) \\n                {\\n                    i++;\\n                    if(i<j)\\n                    pq.push({costs[i],i});\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i<j)\\n                    pq.push({costs[j],j});\\n                }\\n            }\\n            while(k)\\n            {\\n                ans+=pq.top()[0];\\n                pq.pop();\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//please upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683156,
                "title": "simple-c-solution-priority-queue-min-heap",
                "content": "# Intuition\\nTo have two windows of size equal to candidate and to get minimum of both windows of overall cost.\\n\\n# Approach\\n1. This question can be solved using min heap.\\n2. We have to hire in k sessions. \\n3. Lets consider two indices ```l=0``` and ```r=n-1``` where n=costs.size();\\n4. Also take two min heaps to create the window.\\n5. We have to add elements in each k sessions in either or both min heaps.\\n6. We will add element at index ```l``` in first min heap and ```r```in second one.\\n7. We will take care about the size of each min heap should be less than candidates.\\n8. After this, we will get the minimum in both min heap.\\n9. If the minimum belongs to first one then we will pop from first min heap otherwise same from second one.\\n10. This minimum value will be used in making of overall cost.\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlog(n))$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n=costs.size();\\n        int l=0,r=n-1;\\n        priority_queue<int,vector<int>,greater<int>>pq1,pq2;\\n        long long cost=0;\\n        for(int i=0;i<k;i++){\\n            while(pq1.size()<candidates&&(l<=r)){\\n                pq1.push(costs[l]);\\n                l++;\\n            }\\n            while(pq2.size()<candidates&&(l<=r)){\\n                pq2.push(costs[r]);\\n                r--;\\n            }\\n            long long top1=INT_MAX,top2=INT_MAX;\\n            if(pq1.size()>0){\\n                top1=pq1.top();\\n            }\\n            if(pq2.size()>0){\\n                top2=pq2.top();\\n            }\\n            if(top1<=top2){\\n                cost+=top1;\\n                pq1.pop();\\n            }\\n            else{\\n                cost+=top2;\\n                pq2.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n            //<!-- Please upvote if you liked -->\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```l=0```\n```r=n-1```\n```l```\n```r```\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        int n=costs.size();\\n        int l=0,r=n-1;\\n        priority_queue<int,vector<int>,greater<int>>pq1,pq2;\\n        long long cost=0;\\n        for(int i=0;i<k;i++){\\n            while(pq1.size()<candidates&&(l<=r)){\\n                pq1.push(costs[l]);\\n                l++;\\n            }\\n            while(pq2.size()<candidates&&(l<=r)){\\n                pq2.push(costs[r]);\\n                r--;\\n            }\\n            long long top1=INT_MAX,top2=INT_MAX;\\n            if(pq1.size()>0){\\n                top1=pq1.top();\\n            }\\n            if(pq2.size()>0){\\n                top2=pq2.top();\\n            }\\n            if(top1<=top2){\\n                cost+=top1;\\n                pq1.pop();\\n            }\\n            else{\\n                cost+=top2;\\n                pq2.pop();\\n            }\\n        }\\n        return cost;\\n    }\\n            //<!-- Please upvote if you liked -->\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683146,
                "title": "beats-98-8-c-beginner-friendly-solution-using-2-priority-queue",
                "content": "# Intuition\\nTo get min element effectively from a sample space of array we can use min heap (priority queue)\\n\\n\\n# Approach\\n1) Taking 2 variables i and j to check whether the size of array provided is large enough to avoid duplicate entries \\nIndex i tells where to end for pq1 insertions (itterate from 0 to i (for pq1))\\nIndex j tells where to start for pq2 insertions (itterate from j to n (for pq2))\\n2) Then setting the i and j accordingly\\n\\n        if(2*candidates<=n) //sufficient size to avoid duplicacy\\n        {\\n            j=n-candidates;\\n        }\\n        else // less space (i and j surpass) to avoid duplicacy include full array\\n        {\\n            i=n-1;\\n        }\\n3) Index i tell the end index so we itterate from (0 to i)\\n   Index j tells the start index so we itterate from (j to n)\\n\\n         for(int x=0;x<=i;x++)\\n        {\\n            pq1.push(costs[x]);\\n        }\\n         //taking elements out 1 by 1\\n        for(int x=j;x<n;x++)\\n        {\\n            pq2.push(costs[x]);\\n        }\\n4) Untill k!=0 take out entry from pq1 and pq2 compare and take the smaller value and add it to the answer\\n\\n        while(k--)\\n        {\\n            int top1=INT_MAX,top2=INT_MAX;\\n            if(!pq1.empty())\\n            {\\n                top1=pq1.top();\\n            }\\n            if(!pq2.empty())\\n            {\\n                top2=pq2.top();\\n            }\\n            if(top1<=top2)\\n            {\\n                ans+=top1;\\n                pq1.pop();\\n                if(i+1<j)\\n                {\\n                    i++;\\n                    pq1.push(costs[i]);\\n                }\\n            }\\n            else if(top2<top1)\\n            {\\n                ans+=top2;\\n                pq2.pop();\\n                if(j-1>i)\\n                {\\n                    j--;\\n                    pq2.push(costs[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n# Complexity\\n- Time complexity:\\n- O(nLogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/6e8b81b5-914c-4eda-9ea0-518fd151c39f_1687747233.9272149.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long  ans=0;\\n        long long  n=costs.size();\\n        long long  i=0,j=costs.size();\\n        priority_queue<long long ,vector<long long >,greater<long long >> pq1;\\n        priority_queue<long long ,vector<long long >,greater<long long >> pq2;\\n\\n        //checking if there are sufficient candidates for both i and j and double candidates are pushes initially \\n        if(2*candidates<=n)\\n        {\\n            //i tells us where to end (itterate fromfrom 0 to i)\\n            i=candidates-1;\\n            //j tells us where to start from (itterate from j to n)\\n            j=n-candidates;\\n        }\\n        //i and j do not have sufficient candidates (i and j surpass each other) so we take full array itself\\n        else\\n        {\\n            // i runs from 0 to n-1 (full array)\\n            i=n-1;\\n        }\\n\\n        //taking elements out 1 by 1\\n        for(int x=0;x<=i;x++)\\n        {\\n            pq1.push(costs[x]);\\n        }\\n         //taking elements out 1 by 1\\n        for(int x=j;x<n;x++)\\n        {\\n            pq2.push(costs[x]);\\n        }\\n        //comparing and adding to ans\\n        while(k--)\\n        {\\n            int top1=INT_MAX,top2=INT_MAX;\\n            if(!pq1.empty())\\n            {\\n                top1=pq1.top();\\n            }\\n            if(!pq2.empty())\\n            {\\n                top2=pq2.top();\\n            }\\n            if(top1<=top2)\\n            {\\n                ans+=top1;\\n                pq1.pop();\\n                if(i+1<j)\\n                {\\n                    i++;\\n                    pq1.push(costs[i]);\\n                }\\n            }\\n            else if(top2<top1)\\n            {\\n                ans+=top2;\\n                pq2.pop();\\n                if(j-1>i)\\n                {\\n                    j--;\\n                    pq2.push(costs[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long  ans=0;\\n        long long  n=costs.size();\\n        long long  i=0,j=costs.size();\\n        priority_queue<long long ,vector<long long >,greater<long long >> pq1;\\n        priority_queue<long long ,vector<long long >,greater<long long >> pq2;\\n\\n        //checking if there are sufficient candidates for both i and j and double candidates are pushes initially \\n        if(2*candidates<=n)\\n        {\\n            //i tells us where to end (itterate fromfrom 0 to i)\\n            i=candidates-1;\\n            //j tells us where to start from (itterate from j to n)\\n            j=n-candidates;\\n        }\\n        //i and j do not have sufficient candidates (i and j surpass each other) so we take full array itself\\n        else\\n        {\\n            // i runs from 0 to n-1 (full array)\\n            i=n-1;\\n        }\\n\\n        //taking elements out 1 by 1\\n        for(int x=0;x<=i;x++)\\n        {\\n            pq1.push(costs[x]);\\n        }\\n         //taking elements out 1 by 1\\n        for(int x=j;x<n;x++)\\n        {\\n            pq2.push(costs[x]);\\n        }\\n        //comparing and adding to ans\\n        while(k--)\\n        {\\n            int top1=INT_MAX,top2=INT_MAX;\\n            if(!pq1.empty())\\n            {\\n                top1=pq1.top();\\n            }\\n            if(!pq2.empty())\\n            {\\n                top2=pq2.top();\\n            }\\n            if(top1<=top2)\\n            {\\n                ans+=top1;\\n                pq1.pop();\\n                if(i+1<j)\\n                {\\n                    i++;\\n                    pq1.push(costs[i]);\\n                }\\n            }\\n            else if(top2<top1)\\n            {\\n                ans+=top2;\\n                pq2.pop();\\n                if(j-1>i)\\n                {\\n                    j--;\\n                    pq2.push(costs[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683066,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut i = 0;\\n        let mut j = costs.len() - 1;\\n        for _ in 0..candidates {\\n            if i >= costs.len() {\\n                break;\\n            }\\n            heap.push((Reverse(costs[i]), Reverse(i), 0));\\n            i += 1;\\n        }\\n        for _ in 0..candidates {\\n            if j <= i {\\n                break;\\n            }\\n            heap.push((Reverse(costs[j]), Reverse(j), 1));\\n            j -= 1;\\n        }\\n\\n        let mut ret = 0;\\n        for _ in 0..k {\\n            if let Some((Reverse(n), _, dir)) = heap.pop() {\\n                ret += n as i64;\\n                if i <= j {\\n                    if dir == 0 {\\n                        heap.push((Reverse(costs[i]), Reverse(i), 0));\\n                        i += 1;\\n                    } else {\\n                        heap.push((Reverse(costs[j]), Reverse(j), 1));\\n                        j -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut i = 0;\\n        let mut j = costs.len() - 1;\\n        for _ in 0..candidates {\\n            if i >= costs.len() {\\n                break;\\n            }\\n            heap.push((Reverse(costs[i]), Reverse(i), 0));\\n            i += 1;\\n        }\\n        for _ in 0..candidates {\\n            if j <= i {\\n                break;\\n            }\\n            heap.push((Reverse(costs[j]), Reverse(j), 1));\\n            j -= 1;\\n        }\\n\\n        let mut ret = 0;\\n        for _ in 0..k {\\n            if let Some((Reverse(n), _, dir)) = heap.pop() {\\n                ret += n as i64;\\n                if i <= j {\\n                    if dir == 0 {\\n                        heap.push((Reverse(costs[i]), Reverse(i), 0));\\n                        i += 1;\\n                    } else {\\n                        heap.push((Reverse(costs[j]), Reverse(j), 1));\\n                        j -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683028,
                "title": "javascript-very-easy-solution-best-the-best-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      // take left\\n      result += lf[0];\\n      left.dequeue();\\n      if (l <= r) {\\n        left.enqueue([costs[l], l]);\\n        ++l;\\n      }\\n    } else {\\n      // take right\\n      result += rf[0];\\n      right.dequeue();\\n      if (l <= r) {\\n        right.enqueue([costs[r], r]);\\n        --r;\\n      }\\n    }\\n\\n    --k;\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      // take left\\n      result += lf[0];\\n      left.dequeue();\\n      if (l <= r) {\\n        left.enqueue([costs[l], l]);\\n        ++l;\\n      }\\n    } else {\\n      // take right\\n      result += rf[0];\\n      right.dequeue();\\n      if (l <= r) {\\n        right.enqueue([costs[r], r]);\\n        --r;\\n      }\\n    }\\n\\n    --k;\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3682982,
                "title": "short-c-code-using-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> left;\\n        priority_queue<int,vector<int>,greater<int>> right;\\n        int l=0,r=costs.size()-1;\\n        long long out=0;\\n        while(k--){\\n            while(left.size()<candidates && l<=r) left.push(costs[l++]);\\n            while(right.size()<candidates && l<=r) right.push(costs[r--]);\\n            int a=(left.empty())?INT_MAX:left.top();\\n            int b=(right.empty())?INT_MAX:right.top();\\n            if(a<b){\\n                out+=a;\\n                left.pop();\\n            }\\n            else if(b<a){\\n                out+=b;\\n                right.pop();\\n            }\\n            else{\\n                out+=a;\\n                left.pop();\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> left;\\n        priority_queue<int,vector<int>,greater<int>> right;\\n        int l=0,r=costs.size()-1;\\n        long long out=0;\\n        while(k--){\\n            while(left.size()<candidates && l<=r) left.push(costs[l++]);\\n            while(right.size()<candidates && l<=r) right.push(costs[r--]);\\n            int a=(left.empty())?INT_MAX:left.top();\\n            int b=(right.empty())?INT_MAX:right.top();\\n            if(a<b){\\n                out+=a;\\n                left.pop();\\n            }\\n            else if(b<a){\\n                out+=b;\\n                right.pop();\\n            }\\n            else{\\n                out+=a;\\n                left.pop();\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682945,
                "title": "daily-leetcoding-challenge-june-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/total-cost-to-hire-k-workers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** 2 Priority Queues\n\n  \n**Approach 2:** 1 Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/total-cost-to-hire-k-workers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3632796,
                "title": "priority-queue-approach-ac-in-1-try-easy-to-unserstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + k)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        int left = 0;\\n        int n = costs.size();\\n        int right = n - 1;\\n        for(int i=0;i<candidates;i++){\\n            pq.push({costs[i], i});\\n            left++;\\n        }\\n        for(int i=n-1, j=0;i>=0 && j<candidates;i--, j++){\\n            if(left<=right){\\n                pq.push({costs[i], i});\\n                right--;\\n            }\\n        }\\n        \\n        long long tot = 0;\\n        while(k--){\\n            int cst = pq.top().first;\\n            int idx = pq.top().second;\\n            tot += cst;\\n            pq.pop();\\n            if(left<=right){\\n                if(idx<left){\\n                    pq.push({costs[left], left});\\n                    left++;\\n                }\\n                else{\\n                    pq.push({costs[right], right});\\n                    right--;\\n                }\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        int left = 0;\\n        int n = costs.size();\\n        int right = n - 1;\\n        for(int i=0;i<candidates;i++){\\n            pq.push({costs[i], i});\\n            left++;\\n        }\\n        for(int i=n-1, j=0;i>=0 && j<candidates;i--, j++){\\n            if(left<=right){\\n                pq.push({costs[i], i});\\n                right--;\\n            }\\n        }\\n        \\n        long long tot = 0;\\n        while(k--){\\n            int cst = pq.top().first;\\n            int idx = pq.top().second;\\n            tot += cst;\\n            pq.pop();\\n            if(left<=right){\\n                if(idx<left){\\n                    pq.push({costs[left], left});\\n                    left++;\\n                }\\n                else{\\n                    pq.push({costs[right], right});\\n                    right--;\\n                }\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558872,
                "title": "python-heap-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe totalCost function takes the costs array, the number of workers to hire (k), and the number of candidates (candidates) as inputs. It returns the total cost to hire exactly k workers according to the given rules.\\n\\nNote: The code assumes that the input constraints are satisfied (1 <= costs.length <= 10^5, 1 <= costs[i] <= 10^5, 1 <= k, candidates <= costs.length).\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def totalCost(self, costs, k, candidates):\\n        heap1 = []\\n        heap2 = []\\n        ans = 0\\n        cnt = 0\\n        i = 0\\n        j = len(costs) - 1\\n        \\n        while cnt < k:\\n            while len(heap1) < candidates and i <= j:\\n                heapq.heappush(heap1, costs[i])\\n                i += 1\\n                \\n            while len(heap2) < candidates and j >= i:\\n                heapq.heappush(heap2, costs[j])\\n                j -= 1\\n                \\n            a = heap1[0] if heap1 else float(\\'inf\\')\\n            b = heap2[0] if heap2 else float(\\'inf\\')\\n            \\n            if a <= b:\\n                ans += a\\n                heapq.heappop(heap1)\\n            else:\\n                ans += b\\n                heapq.heappop(heap2)\\n            \\n            cnt += 1\\n        \\n        return ans\\n\\n```\\n![th.jpg](https://assets.leetcode.com/users/images/39e9cc3b-289b-4ac9-b0b1-8481596ce6f9_1684933710.0556946.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def totalCost(self, costs, k, candidates):\\n        heap1 = []\\n        heap2 = []\\n        ans = 0\\n        cnt = 0\\n        i = 0\\n        j = len(costs) - 1\\n        \\n        while cnt < k:\\n            while len(heap1) < candidates and i <= j:\\n                heapq.heappush(heap1, costs[i])\\n                i += 1\\n                \\n            while len(heap2) < candidates and j >= i:\\n                heapq.heappush(heap2, costs[j])\\n                j -= 1\\n                \\n            a = heap1[0] if heap1 else float(\\'inf\\')\\n            b = heap2[0] if heap2 else float(\\'inf\\')\\n            \\n            if a <= b:\\n                ans += a\\n                heapq.heappop(heap1)\\n            else:\\n                ans += b\\n                heapq.heappop(heap2)\\n            \\n            cnt += 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490804,
                "title": "c-one-priorityqueue-with-tuples",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse priority queue with (cost, index) tuple as priority and dequeue next worker on each session. Add its cost to total cost. Whenever a worker is dequeued see if it\\'s from first or last candidates and add another worker from either first or last candidates if any left.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a priority queue with (cost, isFirstCandidate) as element and (cost, index) as priority. Having a tuple as priority will first sort by cost and if those are equal then by index.\\n2. Initialzie `first` and `last` variables as first and last element of costs array\\n3. Start with `firstCandidates` and `lastCandidates` equal to `candidates`\\n4. Run a loop `k` times. On each iteration (session):\\n    - Add first candidates to priority queue if any left\\n    - Add last candidates to priority queue if any elft\\n    - If there are any workers, dequeue the next worker, add its cost to total cost\\n    - Determine if the worker is first or last candidate and increase the `firstCandidates` or `lastCandidates` accordingly.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int candidates) \\n    {\\n        var workers = new PriorityQueue<(int cost, bool isFirstCandidate), (int cost, int index)>();\\n\\n        var first = 0;\\n        var last = costs.Length - 1;\\n        long totalHireCost = 0;\\n\\n        var firstCandidates = candidates;\\n        var lastCandidates = candidates;\\n\\n        for (var session = 0; session < k; session++)\\n        {\\n            var possibleHires = candidates;\\n\\n            while (first <= last && firstCandidates > 0)\\n            {\\n                workers.Enqueue((costs[first], true), (costs[first], first));\\n\\n                first++;\\n                firstCandidates--;\\n            }\\n\\n            while (first <= last && lastCandidates > 0)\\n            {\\n                workers.Enqueue((costs[last], false), (costs[last], last));\\n\\n                last--;\\n                lastCandidates--;\\n            }\\n\\n            if (workers.Count > 0)\\n            {\\n                var lowestCostWorker = workers.Dequeue();\\n                totalHireCost += lowestCostWorker.cost;\\n\\n                if (lowestCostWorker.isFirstCandidate)\\n                    firstCandidates++;\\n                else\\n                    lastCandidates++;\\n            }\\n        }\\n\\n        return totalHireCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long TotalCost(int[] costs, int k, int candidates) \\n    {\\n        var workers = new PriorityQueue<(int cost, bool isFirstCandidate), (int cost, int index)>();\\n\\n        var first = 0;\\n        var last = costs.Length - 1;\\n        long totalHireCost = 0;\\n\\n        var firstCandidates = candidates;\\n        var lastCandidates = candidates;\\n\\n        for (var session = 0; session < k; session++)\\n        {\\n            var possibleHires = candidates;\\n\\n            while (first <= last && firstCandidates > 0)\\n            {\\n                workers.Enqueue((costs[first], true), (costs[first], first));\\n\\n                first++;\\n                firstCandidates--;\\n            }\\n\\n            while (first <= last && lastCandidates > 0)\\n            {\\n                workers.Enqueue((costs[last], false), (costs[last], last));\\n\\n                last--;\\n                lastCandidates--;\\n            }\\n\\n            if (workers.Count > 0)\\n            {\\n                var lowestCostWorker = workers.Dequeue();\\n                totalHireCost += lowestCostWorker.cost;\\n\\n                if (lowestCostWorker.isFirstCandidate)\\n                    firstCandidates++;\\n                else\\n                    lastCandidates++;\\n            }\\n        }\\n\\n        return totalHireCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104355,
                "title": "c",
                "content": "```\\ntypedef struct _node{\\n    int val ;\\n    int idx ;\\n}node ;\\n\\nint cmp(const void* a, const void* b){\\n    node *A = *(node**)a ;\\n    node *B = *(node**)b ;\\n    return A->val - B->val ;\\n}\\nvoid swap(node** a, node** b){\\n    node* tmp = *a ;\\n    *a = *b ;\\n    *b = tmp ;\\n}\\nvoid modifyHeap(node** heap, int n){\\n    int f =  0 ;\\n    while(1){\\n        int son1 = 2*f + 1 ;\\n        int son2 = 2*f + 2 ;\\n        if(son2 < n){\\n            if(heap[son1]->val <= heap[son2]->val){\\n                if(heap[son1]->val < heap[f]->val){\\n                    swap( &heap[f], &heap[son1] ) ;\\n                    f = son1 ;\\n                }\\n                else\\n                    break ;\\n            }\\n            else{\\n                if(heap[son2]->val < heap[f]->val){\\n                    swap( &heap[f], &heap[son2] ) ;\\n                    f = son2 ;\\n                }\\n                else\\n                    break ;\\n            }\\n        }\\n        else if(son1 < n){\\n            if(heap[son1]->val < heap[f]->val){\\n                swap( &heap[f], &heap[son1] ) ;\\n                f = son1 ;\\n            }\\n            else\\n                break ;\\n        }\\n        else\\n            break ;\\n    }\\n}\\nint heapPop(node** heap, int* n){\\n    int ans = heap[0]->val ;\\n    *n = *n - 1 ;\\n    heap[0] = heap[*n] ;\\n    \\n    int f = 0 ;\\n    int N = *n ;\\n    while(1){\\n        int son1 = 2*f + 1 ;\\n        int son2 = 2*f + 2 ;\\n            if(son2 < N){\\n                if(heap[son1]->val <= heap[son2]->val){\\n                    if(heap[f]->val > heap[son1]->val){\\n                        swap( &heap[f], &heap[son1] ) ;\\n                        f = son1 ;\\n                        continue ;\\n                    }\\n                    else\\n                        break ;\\n                }\\n                else{\\n                    if(heap[f]->val > heap[son2]->val){\\n                        swap( &heap[f], &heap[son2] ) ;\\n                        f = son2 ;\\n                        continue ;\\n                    }\\n                    else\\n                        break ;                    \\n                }\\n            }\\n            else if(son1 < N){\\n                if(heap[f]->val > heap[son1]->val){\\n                    swap( &heap[f], &heap[son1] ) ;\\n                    f = son1 ;\\n                    continue ;\\n                }\\n                else\\n                    break ;                \\n            }\\n            else\\n                break ;\\n        \\n    }\\n    return ans ;\\n}\\nlong long totalCost(int* costs, int costsSize, int k, int candidates){    \\n    int n = costsSize ;\\n    int left_cn = candidates ;\\n    int right_cn = candidates ;    \\n    \\n    if((left_cn + right_cn) > n){\\n        left_cn = n/2 ;\\n        right_cn = n - n/2 ;\\n    }\\n    \\n    long long ans =  0 ;\\n    if(k == costsSize){\\n        for(int i = 0; i < costsSize; i++){\\n            ans = ans + costs[i] ;\\n        }\\n        return ans ;\\n    }\\n    \\n    bool* used = calloc( n, sizeof(bool) ) ;\\n    node** left = malloc(left_cn * sizeof(node*) ) ;\\n    node** right = malloc(right_cn * sizeof(node*) ) ;\\n    for(int i = 0; i < left_cn; i++){\\n        left[i] = malloc(sizeof(node) ) ;\\n        left[i]->val = costs[i] ;\\n        left[i]->idx = i ;\\n        used[i] = true ;\\n    }\\n    for(int i = 0; i < right_cn; i++){\\n        right[i] = malloc(sizeof(node) ) ;\\n        right[i]->val = costs[n-1-i] ;\\n        right[i]->idx = n-1-i ;\\n        used[n-1-i] = true ;\\n    }\\n    qsort(left, left_cn, sizeof(node*), cmp) ;\\n    qsort(right, right_cn, sizeof(node*), cmp) ;\\n    int l_idx = left_cn ;\\n    int r_idx = n-1-right_cn ;\\n\\n    int item = 0 ;\\n    while(item < k){\\n        if(left_cn == 0){\\n            ans += heapPop(right, &right_cn) ;\\n            item++ ;\\n            continue ;\\n        }\\n        if(right_cn == 0){\\n            ans += heapPop(left, &left_cn) ;\\n            item++ ;\\n            continue ;\\n        }\\n        if(left[0]->val == right[0]->val && left[0]->idx == right[0]->idx){\\n            ans += left[0]->val ;\\n            heapPop(left, &left_cn) ;\\n            heapPop(right, &right_cn) ;\\n        }\\n        else if(left[0]->val <= right[0]->val){\\n            ans += left[0]->val ;\\n            if( used[l_idx] )\\n                heapPop(left, &left_cn) ;\\n            else{\\n                left[0]->val = costs[l_idx] ;\\n                left[0]->idx = l_idx ;\\n                used[l_idx] = true ;\\n                l_idx++ ;\\n                modifyHeap(left, left_cn) ;\\n            }\\n        }\\n        else{\\n            ans += right[0]->val ;\\n            if( used[r_idx] ){\\n                heapPop(right, &right_cn) ;\\n            }\\n            else{\\n                right[0]->val = costs[r_idx] ;\\n                right[0]->idx = r_idx ;\\n                used[r_idx] = true ;\\n                r_idx-- ;\\n                modifyHeap(right, right_cn) ;\\n            }\\n        }\\n        item++ ;\\n    }\\n    //free memory\\n    free(used) ;\\n    for(int i = 0; i < right_cn; i++)\\n        free(right[i]) ;\\n    for(int i = 0; i < left_cn; i++)\\n        free(left[i]) ;\\n    free(left) ;\\n    free(right) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct _node{\\n    int val ;\\n    int idx ;\\n}node ;\\n\\nint cmp(const void* a, const void* b){\\n    node *A = *(node**)a ;\\n    node *B = *(node**)b ;\\n    return A->val - B->val ;\\n}\\nvoid swap(node** a, node** b){\\n    node* tmp = *a ;\\n    *a = *b ;\\n    *b = tmp ;\\n}\\nvoid modifyHeap(node** heap, int n){\\n    int f =  0 ;\\n    while(1){\\n        int son1 = 2*f + 1 ;\\n        int son2 = 2*f + 2 ;\\n        if(son2 < n){\\n            if(heap[son1]->val <= heap[son2]->val){\\n                if(heap[son1]->val < heap[f]->val){\\n                    swap( &heap[f], &heap[son1] ) ;\\n                    f = son1 ;\\n                }\\n                else\\n                    break ;\\n            }\\n            else{\\n                if(heap[son2]->val < heap[f]->val){\\n                    swap( &heap[f], &heap[son2] ) ;\\n                    f = son2 ;\\n                }\\n                else\\n                    break ;\\n            }\\n        }\\n        else if(son1 < n){\\n            if(heap[son1]->val < heap[f]->val){\\n                swap( &heap[f], &heap[son1] ) ;\\n                f = son1 ;\\n            }\\n            else\\n                break ;\\n        }\\n        else\\n            break ;\\n    }\\n}\\nint heapPop(node** heap, int* n){\\n    int ans = heap[0]->val ;\\n    *n = *n - 1 ;\\n    heap[0] = heap[*n] ;\\n    \\n    int f = 0 ;\\n    int N = *n ;\\n    while(1){\\n        int son1 = 2*f + 1 ;\\n        int son2 = 2*f + 2 ;\\n            if(son2 < N){\\n                if(heap[son1]->val <= heap[son2]->val){\\n                    if(heap[f]->val > heap[son1]->val){\\n                        swap( &heap[f], &heap[son1] ) ;\\n                        f = son1 ;\\n                        continue ;\\n                    }\\n                    else\\n                        break ;\\n                }\\n                else{\\n                    if(heap[f]->val > heap[son2]->val){\\n                        swap( &heap[f], &heap[son2] ) ;\\n                        f = son2 ;\\n                        continue ;\\n                    }\\n                    else\\n                        break ;                    \\n                }\\n            }\\n            else if(son1 < N){\\n                if(heap[f]->val > heap[son1]->val){\\n                    swap( &heap[f], &heap[son1] ) ;\\n                    f = son1 ;\\n                    continue ;\\n                }\\n                else\\n                    break ;                \\n            }\\n            else\\n                break ;\\n        \\n    }\\n    return ans ;\\n}\\nlong long totalCost(int* costs, int costsSize, int k, int candidates){    \\n    int n = costsSize ;\\n    int left_cn = candidates ;\\n    int right_cn = candidates ;    \\n    \\n    if((left_cn + right_cn) > n){\\n        left_cn = n/2 ;\\n        right_cn = n - n/2 ;\\n    }\\n    \\n    long long ans =  0 ;\\n    if(k == costsSize){\\n        for(int i = 0; i < costsSize; i++){\\n            ans = ans + costs[i] ;\\n        }\\n        return ans ;\\n    }\\n    \\n    bool* used = calloc( n, sizeof(bool) ) ;\\n    node** left = malloc(left_cn * sizeof(node*) ) ;\\n    node** right = malloc(right_cn * sizeof(node*) ) ;\\n    for(int i = 0; i < left_cn; i++){\\n        left[i] = malloc(sizeof(node) ) ;\\n        left[i]->val = costs[i] ;\\n        left[i]->idx = i ;\\n        used[i] = true ;\\n    }\\n    for(int i = 0; i < right_cn; i++){\\n        right[i] = malloc(sizeof(node) ) ;\\n        right[i]->val = costs[n-1-i] ;\\n        right[i]->idx = n-1-i ;\\n        used[n-1-i] = true ;\\n    }\\n    qsort(left, left_cn, sizeof(node*), cmp) ;\\n    qsort(right, right_cn, sizeof(node*), cmp) ;\\n    int l_idx = left_cn ;\\n    int r_idx = n-1-right_cn ;\\n\\n    int item = 0 ;\\n    while(item < k){\\n        if(left_cn == 0){\\n            ans += heapPop(right, &right_cn) ;\\n            item++ ;\\n            continue ;\\n        }\\n        if(right_cn == 0){\\n            ans += heapPop(left, &left_cn) ;\\n            item++ ;\\n            continue ;\\n        }\\n        if(left[0]->val == right[0]->val && left[0]->idx == right[0]->idx){\\n            ans += left[0]->val ;\\n            heapPop(left, &left_cn) ;\\n            heapPop(right, &right_cn) ;\\n        }\\n        else if(left[0]->val <= right[0]->val){\\n            ans += left[0]->val ;\\n            if( used[l_idx] )\\n                heapPop(left, &left_cn) ;\\n            else{\\n                left[0]->val = costs[l_idx] ;\\n                left[0]->idx = l_idx ;\\n                used[l_idx] = true ;\\n                l_idx++ ;\\n                modifyHeap(left, left_cn) ;\\n            }\\n        }\\n        else{\\n            ans += right[0]->val ;\\n            if( used[r_idx] ){\\n                heapPop(right, &right_cn) ;\\n            }\\n            else{\\n                right[0]->val = costs[r_idx] ;\\n                right[0]->idx = r_idx ;\\n                used[r_idx] = true ;\\n                r_idx-- ;\\n                modifyHeap(right, right_cn) ;\\n            }\\n        }\\n        item++ ;\\n    }\\n    //free memory\\n    free(used) ;\\n    for(int i = 0; i < right_cn; i++)\\n        free(right[i]) ;\\n    for(int i = 0; i < left_cn; i++)\\n        free(left[i]) ;\\n    free(left) ;\\n    free(right) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3088757,
                "title": "intuitive-approach-self-explanatory-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pqleft, pqright;\\n        int left=0, right=costs.size()-1;\\n        long long ans=0;\\n        while(k--){\\n            while(pqleft.size()!=candidates && left<=right){\\n                pqleft.push({costs[left],left++});\\n            }\\n            while(pqright.size()!=candidates && left<=right){\\n                pqright.push({costs[right],right--});\\n            }\\n            pair<int,int> left={INT_MAX, INT_MAX};\\n            pair<int,int> right={INT_MAX, INT_MAX};\\n\\n            if(pqleft.size())   left=pqleft.top();\\n            if(pqright.size())  right=pqright.top();\\n            \\n            if(left.first>right.first){\\n                ans+=right.first;\\n                pqright.pop();\\n            }else{\\n                ans+=left.first;\\n                pqleft.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pqleft, pqright;\\n        int left=0, right=costs.size()-1;\\n        long long ans=0;\\n        while(k--){\\n            while(pqleft.size()!=candidates && left<=right){\\n                pqleft.push({costs[left],left++});\\n            }\\n            while(pqright.size()!=candidates && left<=right){\\n                pqright.push({costs[right],right--});\\n            }\\n            pair<int,int> left={INT_MAX, INT_MAX};\\n            pair<int,int> right={INT_MAX, INT_MAX};\\n\\n            if(pqleft.size())   left=pqleft.top();\\n            if(pqright.size())  right=pqright.top();\\n            \\n            if(left.first>right.first){\\n                ans+=right.first;\\n                pqright.pop();\\n            }else{\\n                ans+=left.first;\\n                pqleft.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046397,
                "title": "java-solution-using-one-priorityqueue-and-two-pointers",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(k * log(candidates))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(candidates)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int cost;\\n    int index;\\n    Pair(int cost, int index){\\n        this.cost = cost;\\n        this.index = index;\\n    }\\n}\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->{   \\n                                                                if(a.cost == b.cost) return a.index-b.index;\\n                                                                return a.cost - b.cost;\\n                                                            }\\n                                                    );\\n        long total = 0; \\n        int start = 0; \\n        int n = costs.length;\\n        int end = n-1;\\n        while(start<Math.min(n,candidates)){\\n            pq.add(new Pair(costs[start],start));\\n            start++;\\n        }\\n       \\n        while(end>=Math.max(start,n-candidates)){\\n            pq.add(new Pair(costs[end],end));\\n            end--;\\n        }\\n        while(k-->0){\\n            Pair p = pq.poll();\\n            total += p.cost;\\n            int index = p.index;\\n            if(index>end && index<=n-1 && end>=start){\\n                pq.add(new Pair(costs[end],end));\\n                end --;\\n            }\\n            else if(index>=0 && index<start && start<=end){\\n                pq.add(new Pair(costs[start],start));\\n                start++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int cost;\\n    int index;\\n    Pair(int cost, int index){\\n        this.cost = cost;\\n        this.index = index;\\n    }\\n}\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->{   \\n                                                                if(a.cost == b.cost) return a.index-b.index;\\n                                                                return a.cost - b.cost;\\n                                                            }\\n                                                    );\\n        long total = 0; \\n        int start = 0; \\n        int n = costs.length;\\n        int end = n-1;\\n        while(start<Math.min(n,candidates)){\\n            pq.add(new Pair(costs[start],start));\\n            start++;\\n        }\\n       \\n        while(end>=Math.max(start,n-candidates)){\\n            pq.add(new Pair(costs[end],end));\\n            end--;\\n        }\\n        while(k-->0){\\n            Pair p = pq.poll();\\n            total += p.cost;\\n            int index = p.index;\\n            if(index>end && index<=n-1 && end>=start){\\n                pq.add(new Pair(costs[end],end));\\n                end --;\\n            }\\n            else if(index>=0 && index<start && start<=end){\\n                pq.add(new Pair(costs[start],start));\\n                start++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952898,
                "title": "c-minheap-beats-98-sol-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\npriority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n       \\n        int i;\\n        for(i=0 ;i<candidates ;i++)\\n        pq.push({costs[i],i});\\n\\n        int j=costs.size()-1 , count = candidates;\\n\\n        while(count>0 && i<=j)\\n        {\\n            pq.push({costs[j],j});\\n            j--;\\n            count--;\\n        }\\n        long long ans = 0;\\n        \\n        while(k>0)\\n        {\\n            ans += pq.top().first;\\n            if(i<=j)\\n            {\\n                int ind = pq.top().second;\\n                pq.pop();\\n                if(ind>j){\\n                    pq.push({costs[j],j});\\n                    j--;\\n                }\\n                else {\\n                    pq.push({costs[i],i});\\n                    i++;\\n                }\\n            }\\n            else\\n            pq.pop();\\n            k--;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\npriority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n       \\n        int i;\\n        for(i=0 ;i<candidates ;i++)\\n        pq.push({costs[i],i});\\n\\n        int j=costs.size()-1 , count = candidates;\\n\\n        while(count>0 && i<=j)\\n        {\\n            pq.push({costs[j],j});\\n            j--;\\n            count--;\\n        }\\n        long long ans = 0;\\n        \\n        while(k>0)\\n        {\\n            ans += pq.top().first;\\n            if(i<=j)\\n            {\\n                int ind = pq.top().second;\\n                pq.pop();\\n                if(ind>j){\\n                    pq.push({costs[j],j});\\n                    j--;\\n                }\\n                else {\\n                    pq.push({costs[i],i});\\n                    i++;\\n                }\\n            }\\n            else\\n            pq.pop();\\n            k--;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838256,
                "title": "c-two-min-heap-solution",
                "content": "# Approach\\nTake two min heaps and store candidates(c) number of elements from starting and ending in each of them respectively, if 2*candidates <= n(size of costs), else put all elements in one min heap and pop the top one by one.\\n\\n# Complexity\\n- Time complexity: $$O(n logc)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        int n = costs.size(), i=0,j=n;\\n        long long ans=0;\\n        if(2*candidates <= n){\\n            i=candidates-1;\\n            j=n-candidates;\\n        }\\n        else{\\n            i=n-1;\\n        }\\n        for(int x=0;x<=i;x++){\\n            pq1.push(costs[x]);\\n        }\\n        for(int x=j;x<n;x++){\\n            pq2.push(costs[x]);\\n        }\\n        while(k--){\\n            int top1 = INT_MAX, top2 = INT_MAX;\\n            if(!pq1.empty()){\\n                top1 = pq1.top();\\n            }\\n            if(!pq2.empty()){\\n                top2 = pq2.top();\\n            }\\n            if(top1 <= top2){\\n                ans += top1;\\n                pq1.pop();\\n                if(i+1<j){\\n                    i++;\\n                    pq1.push(costs[i]);\\n                }\\n            }\\n            else if(top1 > top2){\\n                ans += top2;\\n                pq2.pop();\\n                if(j-1>i){\\n                    j--;\\n                    pq2.push(costs[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        int n = costs.size(), i=0,j=n;\\n        long long ans=0;\\n        if(2*candidates <= n){\\n            i=candidates-1;\\n            j=n-candidates;\\n        }\\n        else{\\n            i=n-1;\\n        }\\n        for(int x=0;x<=i;x++){\\n            pq1.push(costs[x]);\\n        }\\n        for(int x=j;x<n;x++){\\n            pq2.push(costs[x]);\\n        }\\n        while(k--){\\n            int top1 = INT_MAX, top2 = INT_MAX;\\n            if(!pq1.empty()){\\n                top1 = pq1.top();\\n            }\\n            if(!pq2.empty()){\\n                top2 = pq2.top();\\n            }\\n            if(top1 <= top2){\\n                ans += top1;\\n                pq1.pop();\\n                if(i+1<j){\\n                    i++;\\n                    pq1.push(costs[i]);\\n                }\\n            }\\n            else if(top1 > top2){\\n                ans += top2;\\n                pq2.pop();\\n                if(j-1>i){\\n                    j--;\\n                    pq2.push(costs[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796663,
                "title": "golang-heap-solution",
                "content": "```go\\nfunc totalCost(costs []int, k int, candidates int) int64 {\\n\\tlBound, rBound := candidates-1, len(costs)-candidates\\n\\th := &Heap{}\\n\\tcost := 0\\n\\tfor i := 0; i <= lBound; i++ {\\n\\t\\theap.Push(h, []int{costs[i], i})\\n\\t}\\n\\tfor i := len(costs) - 1; i >= rBound && i > lBound; i-- {\\n\\t\\theap.Push(h, []int{costs[i], i})\\n\\t}\\n\\t// lBound, rBound already pushed\\n\\tfor k > 0 && h.Len() > 0 {\\n\\t\\tk--\\n\\t\\tv := heap.Pop(h).([]int)\\n\\t\\tcost += v[0]\\n\\t\\tif rBound - lBound > 1 {\\n\\t\\t\\tif v[1] <= lBound {\\n\\t\\t\\t\\tlBound++\\n\\t\\t\\t\\theap.Push(h, []int{costs[lBound], lBound})\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trBound--\\n\\t\\t\\t\\theap.Push(h, []int{costs[rBound], rBound})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\ntype Heap [][]int\\n\\nfunc (p Heap) Len() int { return len(p) }\\nfunc (p Heap) Less(i, j int) bool {\\n\\tif p[i][0] == p[j][0] {\\n\\t\\treturn p[i][1] < p[j][1]\\n\\t}\\n\\treturn p[i][0] < p[j][0]\\n}\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\nfunc totalCost(costs []int, k int, candidates int) int64 {\\n\\tlBound, rBound := candidates-1, len(costs)-candidates\\n\\th := &Heap{}\\n\\tcost := 0\\n\\tfor i := 0; i <= lBound; i++ {\\n\\t\\theap.Push(h, []int{costs[i], i})\\n\\t}\\n\\tfor i := len(costs) - 1; i >= rBound && i > lBound; i-- {\\n\\t\\theap.Push(h, []int{costs[i], i})\\n\\t}\\n\\t// lBound, rBound already pushed\\n\\tfor k > 0 && h.Len() > 0 {\\n\\t\\tk--\\n\\t\\tv := heap.Pop(h).([]int)\\n\\t\\tcost += v[0]\\n\\t\\tif rBound - lBound > 1 {\\n\\t\\t\\tif v[1] <= lBound {\\n\\t\\t\\t\\tlBound++\\n\\t\\t\\t\\theap.Push(h, []int{costs[lBound], lBound})\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trBound--\\n\\t\\t\\t\\theap.Push(h, []int{costs[rBound], rBound})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\ntype Heap [][]int\\n\\nfunc (p Heap) Len() int { return len(p) }\\nfunc (p Heap) Less(i, j int) bool {\\n\\tif p[i][0] == p[j][0] {\\n\\t\\treturn p[i][1] < p[j][1]\\n\\t}\\n\\treturn p[i][0] < p[j][0]\\n}\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792724,
                "title": "java-solution-using-priorityqueue",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse PriorityQueue to store the accessible candidates with their respective index, than pop the min cost in each round. After each pop, add another candidate based on the which sides of the candidate were popped.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int r, int candidates) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{\\n            if(a[0]==b[0]) return a[1]-b[1];\\n            return a[0]-b[0];\\n        });\\n        long res = 0;\\n        int j=0, k=costs.length-1;\\n        if(r>=costs.length){\\n            for(int i=0; i<costs.length; ++i){\\n                res += costs[i];\\n            }\\n            return res;\\n        }\\n        while(j<k && j<candidates){\\n            pq.offer(new int[]{costs[j], j});\\n            pq.offer(new int[]{costs[k], k});\\n            j++;\\n            k--;\\n        }\\n        for(int i=0; i<r && pq.size()>0; ++i){\\n            int[] c = pq.poll();\\n            res += c[0];\\n            int ind = c[1];\\n            if(ind<j && j<=k){\\n                pq.offer(new int[]{costs[j], j});\\n                j++;\\n            }else if(ind>k && j<=k){\\n                pq.offer(new int[]{costs[k], k});\\n                k--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nPlease leave a like if you find this helpful\\nFeel free to ask question down below\\nHappy coding~ ^^",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int r, int candidates) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{\\n            if(a[0]==b[0]) return a[1]-b[1];\\n            return a[0]-b[0];\\n        });\\n        long res = 0;\\n        int j=0, k=costs.length-1;\\n        if(r>=costs.length){\\n            for(int i=0; i<costs.length; ++i){\\n                res += costs[i];\\n            }\\n            return res;\\n        }\\n        while(j<k && j<candidates){\\n            pq.offer(new int[]{costs[j], j});\\n            pq.offer(new int[]{costs[k], k});\\n            j++;\\n            k--;\\n        }\\n        for(int i=0; i<r && pq.size()>0; ++i){\\n            int[] c = pq.poll();\\n            res += c[0];\\n            int ind = c[1];\\n            if(ind<j && j<=k){\\n                pq.offer(new int[]{costs[j], j});\\n                j++;\\n            }else if(ind>k && j<=k){\\n                pq.offer(new int[]{costs[k], k});\\n                k--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792485,
                "title": "c-comparator-85ms-fast-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    class Comp {\\n    public:\\n        bool operator() (pair<int,pair<int,int>> a, pair<int,pair<int,int>> b) {\\n        \\n            if(a.first<b.first){\\n                \\n                return false;\\n            }\\n            if(a.first ==  b.first){\\n                \\n                return a.second.first>b.second.first?true:false;\\n            }\\n            \\n            return true;\\n        }\\n    };\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,Comp> pq;//We use priority_Queue for taking minimum value and using pair of pair of ints in first pair first value is the value and second is pair of ints where 1st value is index and 2nd value denotes 1 as right 0 as left\\n        \\n        int  i=0 , j=costs.size()-1;\\n        \\n        long long  ans=0 ;\\n        \\n        for(i = 0 ,  j = costs.size()-1; i < costs.size()  && i < candidates && i<=j ; i++ , j -- ){//adding k elements from left and right if k is greater than size of costs above conditions prevent from out of bound\\n            \\n            \\n            pq.push(make_pair(costs[i],make_pair(i,0)));\\n            if(i!=j)// when overlapping occurs we need to add only one element soo j is ignored because we have to take lower index value\\n            pq.push(make_pair(costs[j],make_pair(j,1)));\\n            \\n        }\\n      //  cout<<costs.size();\\n        while(!pq.empty() && k-->0){\\n            \\n            auto t = pq.top();\\n            \\n           // cout<<t.first<<\"  \"<<t.second.first<<\" \"<<t.second.second<<endl;\\n            pq.pop();\\n            \\n            ans+=t.first;\\n            \\n            //cout<<j-1<<\" \"<< i<<endl;\\n            \\n            if(i>j)continue;//if overlapping is occured it prevent adding visited elements again in priority_queue\\n            \\n            if(t.second.second==1){//if right element is popped then we need to add next right element.\\n                \\n                    pq.push(make_pair(costs[j],make_pair(j--,1)));\\n                \\n            }\\n            else{//if left element is popped then we need to add next left element.\\n               \\n                    pq.push(make_pair(costs[i],make_pair(i++,0)));\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Comp {\\n    public:\\n        bool operator() (pair<int,pair<int,int>> a, pair<int,pair<int,int>> b) {\\n        \\n            if(a.first<b.first){\\n                \\n                return false;\\n            }\\n            if(a.first ==  b.first){\\n                \\n                return a.second.first>b.second.first?true:false;\\n            }\\n            \\n            return true;\\n        }\\n    };\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,Comp> pq;//We use priority_Queue for taking minimum value and using pair of pair of ints in first pair first value is the value and second is pair of ints where 1st value is index and 2nd value denotes 1 as right 0 as left\\n        \\n        int  i=0 , j=costs.size()-1;\\n        \\n        long long  ans=0 ;\\n        \\n        for(i = 0 ,  j = costs.size()-1; i < costs.size()  && i < candidates && i<=j ; i++ , j -- ){//adding k elements from left and right if k is greater than size of costs above conditions prevent from out of bound\\n            \\n            \\n            pq.push(make_pair(costs[i],make_pair(i,0)));\\n            if(i!=j)// when overlapping occurs we need to add only one element soo j is ignored because we have to take lower index value\\n            pq.push(make_pair(costs[j],make_pair(j,1)));\\n            \\n        }\\n      //  cout<<costs.size();\\n        while(!pq.empty() && k-->0){\\n            \\n            auto t = pq.top();\\n            \\n           // cout<<t.first<<\"  \"<<t.second.first<<\" \"<<t.second.second<<endl;\\n            pq.pop();\\n            \\n            ans+=t.first;\\n            \\n            //cout<<j-1<<\" \"<< i<<endl;\\n            \\n            if(i>j)continue;//if overlapping is occured it prevent adding visited elements again in priority_queue\\n            \\n            if(t.second.second==1){//if right element is popped then we need to add next right element.\\n                \\n                    pq.push(make_pair(costs[j],make_pair(j--,1)));\\n                \\n            }\\n            else{//if left element is popped then we need to add next left element.\\n               \\n                    pq.push(make_pair(costs[i],make_pair(i++,0)));\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2789445,
                "title": "ruby-two-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe store first and last candidates as Heap, then we can find the min cost inside the candidates efficiently.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSincy Ruby doesn\\'t build in Heap, we need to implement it by our self.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} costs\\n# @param {Integer} k\\n# @param {Integer} candidates\\n# @return {Integer}\\nclass Heap\\n    attr_accessor :size, :heap\\n\\n    def initialize()\\n        @heap = []\\n        @size = 0\\n    end\\n    \\n    def add input\\n        @heap[@size] = input\\n        balance_up size\\n        @size += 1\\n    end\\n\\n    def pop\\n        @size -= 1\\n        @heap[0] = @heap[@size]\\n        @heap.delete_at(@size+1)\\n        balance_down 0 \\n    end\\n\\n    def peak\\n        if @size == 0\\n            100001\\n        else\\n            @heap[0]\\n        end\\n    end\\n\\n    def size\\n        @size\\n    end\\n\\n     def heap\\n        @heap\\n    end\\n    \\n\\n    private\\n    def balance_down index\\n\\n        # check right\\n        if is_node?(right_index(index))  \\n            if ((@heap[index].to_i > @heap[right_index(index)]) and (not is_node?(left_index(index)) or @heap[right_index(index)] < @heap[left_index(index)].to_i ))\\n                \\n                swap index,right_index(index)\\n                balance_down right_index(index)\\n            end\\n        end\\n        # check left\\n        if is_node?(left_index(index))  \\n            if @heap[index].to_i > @heap[left_index(index)]\\n                swap index,left_index(index)\\n                balance_down left_index(index)\\n            end\\n        end\\n    end\\n\\n    private\\n    def balance_up index\\n        if index ==0\\n            balance_down index    \\n        end\\n        parrent_node_index = parrent_index index\\n        if is_node? parrent_node_index\\n            if  @heap[parrent_node_index] > @heap[index]\\n                swap parrent_node_index,index\\n                balance_up parrent_node_index\\n            else\\n                return\\n            end\\n        end\\n    end\\n\\n    private\\n    def is_node? index\\n        return (index <= @size and index >=0)\\n    end\\n\\n    private\\n    def right_index index\\n        return 2*index+2\\n    end\\n\\n    private\\n    def left_index index\\n        return 2*index+1\\n    end\\n\\n    private\\n    def parrent_index index\\n        ((index - 1) / 2).floor\\n    end\\n\\n    private\\n    def swap parrent_node_index,index\\n        temp = @heap[parrent_node_index]\\n        @heap[parrent_node_index] = @heap[index]\\n        @heap[index] = temp\\n    end\\n\\nend\\n\\ndef total_cost(costs, k, candidates)\\n    left_heap = Heap.new()\\n    right_heap = Heap.new()\\n\\n    l, r = 0, costs.size()-1\\n\\n    step = 0\\n    res = 0\\n    while step < k\\n        step += 1\\n        while left_heap.size < candidates && l <= r\\n            left_heap.add(costs[l])\\n            l += 1\\n        end\\n\\n        while right_heap.size < candidates && r >= l\\n            right_heap.add(costs[r])\\n            r -= 1\\n        end\\n        \\n        left_peak = left_heap.size > 0 ? left_heap.peak : 100001\\n        right_peak = right_heap.size > 0 ? right_heap.peak : 100001\\n\\n        if left_peak <= right_peak\\n            res += left_peak\\n            left_heap.pop\\n        else\\n            res += right_peak\\n            right_heap.pop\\n        end\\n    end\\n    res\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# @param {Integer[]} costs\\n# @param {Integer} k\\n# @param {Integer} candidates\\n# @return {Integer}\\nclass Heap\\n    attr_accessor :size, :heap\\n\\n    def initialize()\\n        @heap = []\\n        @size = 0\\n    end\\n    \\n    def add input\\n        @heap[@size] = input\\n        balance_up size\\n        @size += 1\\n    end\\n\\n    def pop\\n        @size -= 1\\n        @heap[0] = @heap[@size]\\n        @heap.delete_at(@size+1)\\n        balance_down 0 \\n    end\\n\\n    def peak\\n        if @size == 0\\n            100001\\n        else\\n            @heap[0]\\n        end\\n    end\\n\\n    def size\\n        @size\\n    end\\n\\n     def heap\\n        @heap\\n    end\\n    \\n\\n    private\\n    def balance_down index\\n\\n        # check right\\n        if is_node?(right_index(index))  \\n            if ((@heap[index].to_i > @heap[right_index(index)]) and (not is_node?(left_index(index)) or @heap[right_index(index)] < @heap[left_index(index)].to_i ))\\n                \\n                swap index,right_index(index)\\n                balance_down right_index(index)\\n            end\\n        end\\n        # check left\\n        if is_node?(left_index(index))  \\n            if @heap[index].to_i > @heap[left_index(index)]\\n                swap index,left_index(index)\\n                balance_down left_index(index)\\n            end\\n        end\\n    end\\n\\n    private\\n    def balance_up index\\n        if index ==0\\n            balance_down index    \\n        end\\n        parrent_node_index = parrent_index index\\n        if is_node? parrent_node_index\\n            if  @heap[parrent_node_index] > @heap[index]\\n                swap parrent_node_index,index\\n                balance_up parrent_node_index\\n            else\\n                return\\n            end\\n        end\\n    end\\n\\n    private\\n    def is_node? index\\n        return (index <= @size and index >=0)\\n    end\\n\\n    private\\n    def right_index index\\n        return 2*index+2\\n    end\\n\\n    private\\n    def left_index index\\n        return 2*index+1\\n    end\\n\\n    private\\n    def parrent_index index\\n        ((index - 1) / 2).floor\\n    end\\n\\n    private\\n    def swap parrent_node_index,index\\n        temp = @heap[parrent_node_index]\\n        @heap[parrent_node_index] = @heap[index]\\n        @heap[index] = temp\\n    end\\n\\nend\\n\\ndef total_cost(costs, k, candidates)\\n    left_heap = Heap.new()\\n    right_heap = Heap.new()\\n\\n    l, r = 0, costs.size()-1\\n\\n    step = 0\\n    res = 0\\n    while step < k\\n        step += 1\\n        while left_heap.size < candidates && l <= r\\n            left_heap.add(costs[l])\\n            l += 1\\n        end\\n\\n        while right_heap.size < candidates && r >= l\\n            right_heap.add(costs[r])\\n            r -= 1\\n        end\\n        \\n        left_peak = left_heap.size > 0 ? left_heap.peak : 100001\\n        right_peak = right_heap.size > 0 ? right_heap.peak : 100001\\n\\n        if left_peak <= right_peak\\n            res += left_peak\\n            left_heap.pop\\n        else\\n            res += right_peak\\n            right_heap.pop\\n        end\\n    end\\n    res\\n    \\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789204,
                "title": "faster-than-100-java-solution",
                "content": "***To be honest initially this question was quite confusing*** .\\nI took almost 2 hours to this question and still was not accepted because of some test cases \\nbut finally it got accepted \\n\\nI have written quite lengthy solution , I have also used deque here . **Seems like this question would never appear in interview**\\n```\\n   public long totalCost(int[] costs, int k, int candidates) {\\n        long minCost = 0 ;\\n        if(2*candidates>=costs.length || k>=costs.length){\\n            Arrays.sort(costs);\\n          for(int i = 0 ; i < k ; i++) minCost+=costs[i];\\n            return minCost;\\n        } \\n        int min = Integer.MIN_VALUE;\\n        PriorityQueue<Integer> priorityQueue1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> priorityQueue2 = new PriorityQueue<>();\\n        Deque<Integer> deque = new LinkedList<>();\\n        for(int i = 0 ; i < costs.length ; i++){\\n            if(i<candidates) priorityQueue1.add(costs[i]);\\n        else if (i>=(costs.length-candidates))     priorityQueue2.add(costs[i]);\\n            else deque.addLast(costs[i]);\\n         }\\n        while(!deque.isEmpty() && k > 0){\\n            if(priorityQueue1.peek()<=priorityQueue2.peek()){\\n                minCost+=priorityQueue1.poll();\\n                priorityQueue1.add(deque.getFirst());\\n                deque.removeFirst();\\n            }\\n            else{\\n                minCost+=priorityQueue2.poll();\\n                priorityQueue2.add(deque.getLast());\\n                deque.removeLast();\\n            }\\n            k--;\\n        }\\n    while(k>0){\\n             if(!priorityQueue1.isEmpty() && priorityQueue1.peek()<=priorityQueue2.peek()){ minCost+=priorityQueue1.poll();                                                  }\\n            else {\\n                minCost+=priorityQueue2.poll();\\n            }\\n            k--;\\n        }\\n        return minCost;  \\n    }\\n```",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n   public long totalCost(int[] costs, int k, int candidates) {\\n        long minCost = 0 ;\\n        if(2*candidates>=costs.length || k>=costs.length){\\n            Arrays.sort(costs);\\n          for(int i = 0 ; i < k ; i++) minCost+=costs[i];\\n            return minCost;\\n        } \\n        int min = Integer.MIN_VALUE;\\n        PriorityQueue<Integer> priorityQueue1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> priorityQueue2 = new PriorityQueue<>();\\n        Deque<Integer> deque = new LinkedList<>();\\n        for(int i = 0 ; i < costs.length ; i++){\\n            if(i<candidates) priorityQueue1.add(costs[i]);\\n        else if (i>=(costs.length-candidates))     priorityQueue2.add(costs[i]);\\n            else deque.addLast(costs[i]);\\n         }\\n        while(!deque.isEmpty() && k > 0){\\n            if(priorityQueue1.peek()<=priorityQueue2.peek()){\\n                minCost+=priorityQueue1.poll();\\n                priorityQueue1.add(deque.getFirst());\\n                deque.removeFirst();\\n            }\\n            else{\\n                minCost+=priorityQueue2.poll();\\n                priorityQueue2.add(deque.getLast());\\n                deque.removeLast();\\n            }\\n            k--;\\n        }\\n    while(k>0){\\n             if(!priorityQueue1.isEmpty() && priorityQueue1.peek()<=priorityQueue2.peek()){ minCost+=priorityQueue1.poll();                                                  }\\n            else {\\n                minCost+=priorityQueue2.poll();\\n            }\\n            k--;\\n        }\\n        return minCost;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2787319,
                "title": "c-priority-queue-without-priority-queue-approach",
                "content": "**Intution**\\nAs we can take an element either from left or right side, we have to use sepearate data structures of same kind for both sides.\\nInitially we will store *n number of elements from costs[], n = candidates*  from starting in the 1st data structure and similary  *n* elements from end in the 2nd data structure.\\nAs we take an element from any of the data structure we will insert the new element from costs.\\nWe can use *i and j variables* as pointers from *left and right direction,* to the most recent elements which have been inserted from their respective sides to their respective data structures.\\nNow the question is what data structure to use **?**\\n**Approach 1**\\nUse vectors -> If we use vectors then we have to insert the element optimally in order.\\n```\\n#define pb               push_back\\n#define all(v)           v.begin(), v.end()\\n#define rall(v)          v.rbegin(), v.rend()\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        int n = costs.size();\\n\\t\\t// In this case, the window from which we can take elements is the whole costs[]\\n        if(n <= can * 2) {\\n            ll ans = 0;\\n            sort(all(costs));\\n            for(int i = 0; i < k; i++)\\n                ans += costs[i];\\n            return ans;\\n        }\\n        vector<int> f, b;\\n        int i, j;\\n        for(i = 0; i < can; i++) {\\n            f.pb(costs[i]);\\n        }\\n        sort(rall(f));\\n        for(j = n - 1; j >= n - can; j--) {\\n            b.pb(costs[j]);\\n        }\\n        sort(rall(b));\\n        ll ans = 0;\\n        int kc = k;\\n        while(kc--) {\\n\\t\\t\\t// If the minimum costs[x] is present in left window or if there is no element left in right window \\n            if((f.size() && b.size() && f[f.size() - 1] <= b[b.size() - 1]) || !b.size()) {\\n                ans += f[f.size() - 1];\\n                f.pop_back();\\n\\t\\t\\t\\t// We can only insert an element while i <= j else overlapping will happen\\n                if(i <= j) {\\n                    f.pb(costs[i++]);\\n                    int idx = can - 1;\\n\\t\\t\\t\\t\\t// Positioning the inserted element in order\\n                    while(idx - 1 >= 0 && f[idx] > f[idx - 1]) {\\n                        swap(f[idx], f[idx - 1]);\\n                        idx--;\\n                    }\\n                }\\n            } else { \\n                ans += b[b.size() - 1];\\n                b.pop_back();\\n                if(i <= j) {\\n                    b.pb(costs[j--]);\\n                    int idx = can - 1;\\n                    while(idx - 1 >= 0 && b[idx] > b[idx - 1]) {\\n                        swap(b[idx], b[idx - 1]);\\n                        idx--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2**\\nUse priority queue (min heap) -> This will automatically store the elements in the ascending order.\\n```\\n#define all(v) v.begin(), v.end()\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        int n = costs.size();\\n        if(n <= 2 * can) {\\n            ll ans = 0;\\n            sort(all(costs));\\n            for(int i = 0; i < k; i++)\\n                ans += costs[i];\\n            return ans;\\n        }\\n        priority_queue<int, vector<int>, greater<int>> q1, q2;\\n        int i, j;\\n        for(i = 0; i < can; i++) q1.push(costs[i]);\\n        for(j = n - 1; j >= n - can; j--) q2.push(costs[j]);\\n        ll ans = 0;\\n        while(k--) {\\n            if((!q1.empty() && !q2.empty() && q1.top() <= q2.top()) || q2.empty()) {\\n                ans += q1.top(); q1.pop();\\n                if(i <= j) q1.push(costs[i++]);\\n            } else {\\n                ans += q2.top(); q2.pop();\\n                if(i <= j) q2.push(costs[j--]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#define pb               push_back\\n#define all(v)           v.begin(), v.end()\\n#define rall(v)          v.rbegin(), v.rend()\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        int n = costs.size();\\n\\t\\t// In this case, the window from which we can take elements is the whole costs[]\\n        if(n <= can * 2) {\\n            ll ans = 0;\\n            sort(all(costs));\\n            for(int i = 0; i < k; i++)\\n                ans += costs[i];\\n            return ans;\\n        }\\n        vector<int> f, b;\\n        int i, j;\\n        for(i = 0; i < can; i++) {\\n            f.pb(costs[i]);\\n        }\\n        sort(rall(f));\\n        for(j = n - 1; j >= n - can; j--) {\\n            b.pb(costs[j]);\\n        }\\n        sort(rall(b));\\n        ll ans = 0;\\n        int kc = k;\\n        while(kc--) {\\n\\t\\t\\t// If the minimum costs[x] is present in left window or if there is no element left in right window \\n            if((f.size() && b.size() && f[f.size() - 1] <= b[b.size() - 1]) || !b.size()) {\\n                ans += f[f.size() - 1];\\n                f.pop_back();\\n\\t\\t\\t\\t// We can only insert an element while i <= j else overlapping will happen\\n                if(i <= j) {\\n                    f.pb(costs[i++]);\\n                    int idx = can - 1;\\n\\t\\t\\t\\t\\t// Positioning the inserted element in order\\n                    while(idx - 1 >= 0 && f[idx] > f[idx - 1]) {\\n                        swap(f[idx], f[idx - 1]);\\n                        idx--;\\n                    }\\n                }\\n            } else { \\n                ans += b[b.size() - 1];\\n                b.pop_back();\\n                if(i <= j) {\\n                    b.pb(costs[j--]);\\n                    int idx = can - 1;\\n                    while(idx - 1 >= 0 && b[idx] > b[idx - 1]) {\\n                        swap(b[idx], b[idx - 1]);\\n                        idx--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#define all(v) v.begin(), v.end()\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long totalCost(vector<int>& costs, int k, int can) {\\n        int n = costs.size();\\n        if(n <= 2 * can) {\\n            ll ans = 0;\\n            sort(all(costs));\\n            for(int i = 0; i < k; i++)\\n                ans += costs[i];\\n            return ans;\\n        }\\n        priority_queue<int, vector<int>, greater<int>> q1, q2;\\n        int i, j;\\n        for(i = 0; i < can; i++) q1.push(costs[i]);\\n        for(j = n - 1; j >= n - can; j--) q2.push(costs[j]);\\n        ll ans = 0;\\n        while(k--) {\\n            if((!q1.empty() && !q2.empty() && q1.top() <= q2.top()) || q2.empty()) {\\n                ans += q1.top(); q1.pop();\\n                if(i <= j) q1.push(costs[i++]);\\n            } else {\\n                ans += q2.top(); q2.pop();\\n                if(i <= j) q2.push(costs[j--]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786517,
                "title": "one-minpriorityqueue-javascript-solution",
                "content": "take variable is not required to be ~half, we just need to check that we are not taking too much, but I am using it similar to description explanation\\n\\n# Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n    let leftIndex = 0;\\n    let rightIndex = costs.length - 1;\\n    const minPriorityQueue = new MinPriorityQueue({ \\n        compare: (a, b) => a.value === b.value ? a.index - b.index : a.value - b.value\\n    });\\n    let sum = 0, element;\\n    const take = Math.min(Math.ceil(costs.length / 2), candidates);\\n\\n    for (let i = 0; i < take; ++i) {\\n        minPriorityQueue.enqueue({ index: i, value: costs[i] });\\n        ++leftIndex;\\n    }\\n\\n    for (let i = 0; i < candidates && leftIndex < rightIndex; ++i) {\\n        minPriorityQueue.enqueue({ index: rightIndex, value: costs[rightIndex--] });\\n    }\\n\\n    for (let i = 0; i < k; ++i) {\\n        element = minPriorityQueue.dequeue();\\n        sum += element.value;\\n        if (leftIndex <= rightIndex) {\\n            if (element.index < leftIndex) minPriorityQueue.enqueue({ index: leftIndex, value: costs[leftIndex++] });\\n            else minPriorityQueue.enqueue({ index: rightIndex, value: costs[rightIndex--] });\\n        }\\n    }\\n\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n    let leftIndex = 0;\\n    let rightIndex = costs.length - 1;\\n    const minPriorityQueue = new MinPriorityQueue({ \\n        compare: (a, b) => a.value === b.value ? a.index - b.index : a.value - b.value\\n    });\\n    let sum = 0, element;\\n    const take = Math.min(Math.ceil(costs.length / 2), candidates);\\n\\n    for (let i = 0; i < take; ++i) {\\n        minPriorityQueue.enqueue({ index: i, value: costs[i] });\\n        ++leftIndex;\\n    }\\n\\n    for (let i = 0; i < candidates && leftIndex < rightIndex; ++i) {\\n        minPriorityQueue.enqueue({ index: rightIndex, value: costs[rightIndex--] });\\n    }\\n\\n    for (let i = 0; i < k; ++i) {\\n        element = minPriorityQueue.dequeue();\\n        sum += element.value;\\n        if (leftIndex <= rightIndex) {\\n            if (element.index < leftIndex) minPriorityQueue.enqueue({ index: leftIndex, value: costs[leftIndex++] });\\n            else minPriorityQueue.enqueue({ index: rightIndex, value: costs[rightIndex--] });\\n        }\\n    }\\n\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785361,
                "title": "java-two-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nOnLogn<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nOn<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    int l = 0, r = costs.length - 1;\\n    \\n    PriorityQueue<int[]> L = new PriorityQueue<>(r+1, (int[] o1, int[] o2) ->{\\n        if(o2[0] != o1[0]) return o1[0] - o2[0];\\n        return                    o1[1] - o2[1]; });\\n    PriorityQueue<int[]> R = new PriorityQueue<>(r+1, (int[] o1, int[] o2) ->{\\n        if(o2[0] != o1[0]) return o1[0] - o2[0];\\n        return                    o1[1] - o2[1]; });\\n    \\n    long ans = 0;\\n\\n    while(k-- != 0){\\n      while(l <= r && L.size() < candidates) {L.add( new  int[]{costs[l], l}); l++;}\\n      while(l <= r && R.size() < candidates) {R.add( new  int[]{costs[r], r}); r--;}\\n\\n      if     (L.isEmpty())                ans += R.poll()[0];\\n      else if(R.isEmpty())                ans += L.poll()[0];\\n      else if(L.peek()[0] <= R.peek()[0]) ans += L.poll()[0];\\n      else                                ans += R.poll()[0];  \\n    }\\n\\n    return ans;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    int l = 0, r = costs.length - 1;\\n    \\n    PriorityQueue<int[]> L = new PriorityQueue<>(r+1, (int[] o1, int[] o2) ->{\\n        if(o2[0] != o1[0]) return o1[0] - o2[0];\\n        return                    o1[1] - o2[1]; });\\n    PriorityQueue<int[]> R = new PriorityQueue<>(r+1, (int[] o1, int[] o2) ->{\\n        if(o2[0] != o1[0]) return o1[0] - o2[0];\\n        return                    o1[1] - o2[1]; });\\n    \\n    long ans = 0;\\n\\n    while(k-- != 0){\\n      while(l <= r && L.size() < candidates) {L.add( new  int[]{costs[l], l}); l++;}\\n      while(l <= r && R.size() < candidates) {R.add( new  int[]{costs[r], r}); r--;}\\n\\n      if     (L.isEmpty())                ans += R.poll()[0];\\n      else if(R.isEmpty())                ans += L.poll()[0];\\n      else if(L.peek()[0] <= R.peek()[0]) ans += L.poll()[0];\\n      else                                ans += R.poll()[0];  \\n    }\\n\\n    return ans;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785328,
                "title": "java-two-minheaps-vs-one-minheap",
                "content": "Two MinHeaps:\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int len = costs.length, i = 0, j = len-1;\\n        long ans = 0;\\n        PriorityQueue<Integer> l = new PriorityQueue<>();\\n        PriorityQueue<Integer> r = new PriorityQueue<>();\\n        \\n        while(i<candidates) l.add(costs[i++]);\\n        \\n        while(j>=len-candidates && j>=i) r.add(costs[j--]);\\n        \\n        while(k-- > 0){\\n            ans += (!r.isEmpty() && !l.isEmpty()) ? (l.peek() <= r.peek()) ? l.poll() : r.poll() : (r.isEmpty() ? l.poll() : r.poll());\\n            if(l.size() < candidates && i<=j){\\n                l.add(costs[i++]);\\n            }\\n            else if(r.size() < candidates && j>=i){\\n                r.add(costs[j--]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nOne Heap:\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int len = costs.length, i = 0, j = len-1;\\n        long ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> costs[a] == costs[b] ? a-b : costs[a] - costs[b]);\\n        \\n        while(i<candidates) pq.add(i++);\\n      \\n        while(j>=len-candidates && j>=i) pq.add(j--);\\n        \\n        while(k-- > 0){\\n            int idx = pq.poll();\\n            ans += costs[idx];\\n            if(idx < i && i<=j){\\n                pq.add(i++);\\n            }\\n            else if(idx > j && j>=i){\\n                pq.add(j--);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int len = costs.length, i = 0, j = len-1;\\n        long ans = 0;\\n        PriorityQueue<Integer> l = new PriorityQueue<>();\\n        PriorityQueue<Integer> r = new PriorityQueue<>();\\n        \\n        while(i<candidates) l.add(costs[i++]);\\n        \\n        while(j>=len-candidates && j>=i) r.add(costs[j--]);\\n        \\n        while(k-- > 0){\\n            ans += (!r.isEmpty() && !l.isEmpty()) ? (l.peek() <= r.peek()) ? l.poll() : r.poll() : (r.isEmpty() ? l.poll() : r.poll());\\n            if(l.size() < candidates && i<=j){\\n                l.add(costs[i++]);\\n            }\\n            else if(r.size() < candidates && j>=i){\\n                r.add(costs[j--]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int len = costs.length, i = 0, j = len-1;\\n        long ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> costs[a] == costs[b] ? a-b : costs[a] - costs[b]);\\n        \\n        while(i<candidates) pq.add(i++);\\n      \\n        while(j>=len-candidates && j>=i) pq.add(j--);\\n        \\n        while(k-- > 0){\\n            int idx = pq.poll();\\n            ans += costs[idx];\\n            if(idx < i && i<=j){\\n                pq.add(i++);\\n            }\\n            else if(idx > j && j>=i){\\n                pq.add(j--);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785209,
                "title": "simple-python-solution-using-priority-queue",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n=len(costs)\\n        if candidates>n-candidates:\\n            costs.sort()\\n            return sum(costs[:k])\\n        st=[]\\n        end=[]        \\n        heapq.heapify(st)\\n        heapq.heapify(end)\\n        for i in range(candidates):\\n            heapq.heappush(st,costs[i])\\n            heapq.heappush(end,costs[n-i-1])\\n        sm=0\\n        lt=candidates-1\\n        rt=n-candidates\\n        while k>0:\\n            x,y=float(\"infinity\"),float(\"infinity\")\\n            if st:\\n                x=heapq.heappop(st)\\n            if y:\\n                y=heapq.heappop(end)\\n            if x<=y:\\n                sm+=x\\n                lt+=1\\n                if lt<rt:\\n                    heapq.heappush(st,costs[lt])\\n                heapq.heappush(end,y)\\n            else:\\n                sm+=y\\n                rt-=1\\n                if lt<rt:\\n                    heapq.heappush(end,costs[rt])\\n                heapq.heappush(st,x)\\n            k-=1\\n        return sm\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        n=len(costs)\\n        if candidates>n-candidates:\\n            costs.sort()\\n            return sum(costs[:k])\\n        st=[]\\n        end=[]        \\n        heapq.heapify(st)\\n        heapq.heapify(end)\\n        for i in range(candidates):\\n            heapq.heappush(st,costs[i])\\n            heapq.heappush(end,costs[n-i-1])\\n        sm=0\\n        lt=candidates-1\\n        rt=n-candidates\\n        while k>0:\\n            x,y=float(\"infinity\"),float(\"infinity\")\\n            if st:\\n                x=heapq.heappop(st)\\n            if y:\\n                y=heapq.heappop(end)\\n            if x<=y:\\n                sm+=x\\n                lt+=1\\n                if lt<rt:\\n                    heapq.heappush(st,costs[lt])\\n                heapq.heappush(end,y)\\n            else:\\n                sm+=y\\n                rt-=1\\n                if lt<rt:\\n                    heapq.heappush(end,costs[rt])\\n                heapq.heappush(st,x)\\n            k-=1\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785105,
                "title": "using-two-minheaps-and-two-pointers-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int need, int candidates) {\\n        long ans = 0;\\n        int n = cost.size();\\n        \\n        int left = 0, right = n - 1;\\n        priority_queue<int, vector<int>, greater<int>> lq, rq;\\n        \\n        // pushing the starting candidates elements in the left queue\\n        for (int i = 0; i < candidates; i++) \\n            lq.push(cost[left++]); \\n        \\n        // pushing the last candidates elements in the right queue and also making sure that we don\\'t cross the left pointer\\n        for (int i = 0; i < min(candidates, n - candidates); i++) \\n            rq.push(cost[right--]);\\n        \\n        \\n        for (int i = 0; i < need; i++) {\\n            int lTop = lq.empty() ? INT_MAX : lq.top();\\n            int rTop = rq.empty() ? INT_MAX : rq.top();\\n            \\n            if (lTop <= rTop) {\\n                ans += lTop;\\n                lq.pop();\\n                \\n                if (left <= right) \\n                    lq.push(cost[left++]);\\n            }\\n            else {\\n                ans += rTop;\\n                rq.pop();\\n                \\n                if (left <= right) \\n                    rq.push(cost[right--]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& cost, int need, int candidates) {\\n        long ans = 0;\\n        int n = cost.size();\\n        \\n        int left = 0, right = n - 1;\\n        priority_queue<int, vector<int>, greater<int>> lq, rq;\\n        \\n        // pushing the starting candidates elements in the left queue\\n        for (int i = 0; i < candidates; i++) \\n            lq.push(cost[left++]); \\n        \\n        // pushing the last candidates elements in the right queue and also making sure that we don\\'t cross the left pointer\\n        for (int i = 0; i < min(candidates, n - candidates); i++) \\n            rq.push(cost[right--]);\\n        \\n        \\n        for (int i = 0; i < need; i++) {\\n            int lTop = lq.empty() ? INT_MAX : lq.top();\\n            int rTop = rq.empty() ? INT_MAX : rq.top();\\n            \\n            if (lTop <= rTop) {\\n                ans += lTop;\\n                lq.pop();\\n                \\n                if (left <= right) \\n                    lq.push(cost[left++]);\\n            }\\n            else {\\n                ans += rTop;\\n                rq.pop();\\n                \\n                if (left <= right) \\n                    rq.push(cost[right--]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784914,
                "title": "c-easiest-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& A, int k, int c) {\\n        int n = A.size();\\n        long long res = 0;\\n        auto cmp = [](vector<int>& a, vector<int>& b){\\n            if(a[0] != b[0])\\n                return a[0] > b[0];\\n            return a[1] > b[1];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        int li = 0, ri = n - 1;\\n        while(li < c)\\n            pq.push({A[li], li++, 1});\\n        for(int i = 0; i < c && ri > li; i++)\\n            pq.push({A[ri], ri--, 0});\\n        \\n        while(k--){\\n            int cost = pq.top()[0], idx = pq.top()[1], isLeft = pq.top()[2]; pq.pop();\\n            res += cost;\\n            if(ri >= li)\\n                if(isLeft)\\n                    pq.push({A[li], li++, 1});\\n                else\\n                    pq.push({A[ri], ri--, 0});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& A, int k, int c) {\\n        int n = A.size();\\n        long long res = 0;\\n        auto cmp = [](vector<int>& a, vector<int>& b){\\n            if(a[0] != b[0])\\n                return a[0] > b[0];\\n            return a[1] > b[1];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        int li = 0, ri = n - 1;\\n        while(li < c)\\n            pq.push({A[li], li++, 1});\\n        for(int i = 0; i < c && ri > li; i++)\\n            pq.push({A[ri], ri--, 0});\\n        \\n        while(k--){\\n            int cost = pq.top()[0], idx = pq.top()[1], isLeft = pq.top()[2]; pq.pop();\\n            res += cost;\\n            if(ri >= li)\\n                if(isLeft)\\n                    pq.push({A[li], li++, 1});\\n                else\\n                    pq.push({A[ri], ri--, 0});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784478,
                "title": "two-min-heap",
                "content": "```cpp\\nint n = costs.size();\\nlong long ret = 0;\\nint l = 0;\\nint r = n - 1;\\n\\n// two min-heap, \\n// one for the first `candidates\\'\\n// the other for the last `candidates\\'\\npriority_queue<int, vector<int>, greater<>> pq1, pq2;\\n\\n// the first `candidates\\'\\nfor (int i = 0; i < candidates && l <= r; ++i)\\n\\tpq1.push(costs[l ++]);\\n\\n// the last `candidates\\', there might be overlap, so we add another constrain.\\nfor (int i = 0; i < candidates && l <= r; ++i)\\n\\tpq2.push(costs[r --]);\\n\\n// k sessions\\nwhile (k --)\\n{\\n\\t// under the following circumstances, \\n\\t// we pick the one with lowest cost from the second min-heap.\\n\\tif (pq1.empty() || \\n\\t   (pq1.size() && pq2.size() && pq2.top() < pq1.top()))\\n\\t{\\n\\t\\tret += pq2.top();\\n\\t\\tpq2.pop();\\n\\t\\t\\n\\t\\t// add one more worker to the heap, if there are any.\\n\\t\\tif (l <= r)\\n\\t\\t\\tpq2.push(costs[r --]);\\n\\t}\\n\\t// similarly\\n\\telse \\n\\t{\\n\\t\\tret += pq1.top();\\n\\t\\tpq1.pop();\\n\\t\\t\\n\\t\\tif (l <= r)\\n\\t\\t\\tpq1.push(costs[l ++]);\\n\\t}\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nint n = costs.size();\\nlong long ret = 0;\\nint l = 0;\\nint r = n - 1;\\n\\n// two min-heap, \\n// one for the first `candidates\\'\\n// the other for the last `candidates\\'\\npriority_queue<int, vector<int>, greater<>> pq1, pq2;\\n\\n// the first `candidates\\'\\nfor (int i = 0; i < candidates && l <= r; ++i)\\n\\tpq1.push(costs[l ++]);\\n\\n// the last `candidates\\', there might be overlap, so we add another constrain.\\nfor (int i = 0; i < candidates && l <= r; ++i)\\n\\tpq2.push(costs[r --]);\\n\\n// k sessions\\nwhile (k --)\\n{\\n\\t// under the following circumstances, \\n\\t// we pick the one with lowest cost from the second min-heap.\\n\\tif (pq1.empty() || \\n\\t   (pq1.size() && pq2.size() && pq2.top() < pq1.top()))\\n\\t{\\n\\t\\tret += pq2.top();\\n\\t\\tpq2.pop();\\n\\t\\t\\n\\t\\t// add one more worker to the heap, if there are any.\\n\\t\\tif (l <= r)\\n\\t\\t\\tpq2.push(costs[r --]);\\n\\t}\\n\\t// similarly\\n\\telse \\n\\t{\\n\\t\\tret += pq1.top();\\n\\t\\tpq1.pop();\\n\\t\\t\\n\\t\\tif (l <= r)\\n\\t\\t\\tpq1.push(costs[l ++]);\\n\\t}\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784283,
                "title": "min-heap-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        \\n        int i = 0, j = costs.size() - 1;\\n\\t\\twhile(i < candidates){\\n            pq1.push(costs[i]);\\n            i++;\\n        }\\n        while(j >= i && pq2.size() < candidates){\\n            pq2.push(costs[j]);\\n            j--;\\n        }\\n        \\n        long long total = 0;\\n        while(k){\\n            if(pq2.empty() || (!pq1.empty() && pq1.top() <= pq2.top())){\\n                total += pq1.top();pq1.pop();\\n                if(i <= j)pq1.push(costs[i++]);\\n            }\\n            else if(pq1.empty() || (!pq2.empty() && pq2.top() < pq1.top())){\\n                total += pq2.top();pq2.pop();\\n                if(i <= j)pq2.push(costs[j--]);\\n            }\\n            k--;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        priority_queue<int, vector<int>, greater<int>> pq1, pq2;\\n        \\n        int i = 0, j = costs.size() - 1;\\n\\t\\twhile(i < candidates){\\n            pq1.push(costs[i]);\\n            i++;\\n        }\\n        while(j >= i && pq2.size() < candidates){\\n            pq2.push(costs[j]);\\n            j--;\\n        }\\n        \\n        long long total = 0;\\n        while(k){\\n            if(pq2.empty() || (!pq1.empty() && pq1.top() <= pq2.top())){\\n                total += pq1.top();pq1.pop();\\n                if(i <= j)pq1.push(costs[i++]);\\n            }\\n            else if(pq1.empty() || (!pq2.empty() && pq2.top() < pq1.top())){\\n                total += pq2.top();pq2.pop();\\n                if(i <= j)pq2.push(costs[j--]);\\n            }\\n            k--;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784176,
                "title": "c-2-min-priority-queue-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) \\n    {\\n        priority_queue<int,vector<int> ,greater<int>>left,right;\\n        for(int i=0;i<c;i++)\\n        {\\n            left.push(costs[i]);\\n        }\\n        int z=c;\\n        int bk=costs.size()-1;\\n        while(z--)\\n        {\\n            right.push(costs[bk--]);\\n        }\\n         // while(right.size()>0)\\n         //    {\\n         //        cout<<right.top()<<\" \"; \\n         //        right.pop();\\n         //    }\\n        // cout<<endl;\\n        int i=c;\\n        long long sum=0;\\n        int j=costs.size()-c-1;\\n        if(j<i)                     // if intial overlapping \\n        {\\n            priority_queue<int,vector<int> ,greater<int>>common;\\n            for(auto e:costs)\\n            {\\n                common.push(e);\\n            }\\n            while(k--)\\n            {\\n                sum+=common.top();\\n                common.pop();\\n            }\\n            return sum;\\n        }\\n        // cout<<j<<\" \"<<i;\\n        while(k>0 && j>=i)\\n        {\\n            if(left.top()<=right.top())\\n            {\\n                // cout<<left.top()<<\" L\"<<endl;\\n                sum+=left.top();\\n                left.pop();\\n                left.push(costs[i++]);\\n            }\\n            else\\n            {\\n                // cout<<right.top()<<\" R\"<<endl;\\n                sum+=right.top();\\n                right.pop();\\n                right.push(costs[j--]);\\n            }\\n            k--;\\n        }\\n        // cout<<i<<\" \"<<j<<endl;\\n        // cout<<k<<endl;\\n        if(j<=i && k>0)                 // for remainning k, all can be used again overlapping case\\n        {\\n            priority_queue<int,vector<int> ,greater<int>>common;\\n            while(left.size()>0)\\n            {\\n                common.push(left.top());\\n                left.pop();\\n            }\\n            while(right.size()>0)\\n            {\\n                common.push(right.top());\\n                right.pop();\\n            }\\n            while(k--)\\n            {\\n                sum+=common.top();\\n                common.pop();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int c) \\n    {\\n        priority_queue<int,vector<int> ,greater<int>>left,right;\\n        for(int i=0;i<c;i++)\\n        {\\n            left.push(costs[i]);\\n        }\\n        int z=c;\\n        int bk=costs.size()-1;\\n        while(z--)\\n        {\\n            right.push(costs[bk--]);\\n        }\\n         // while(right.size()>0)\\n         //    {\\n         //        cout<<right.top()<<\" \"; \\n         //        right.pop();\\n         //    }\\n        // cout<<endl;\\n        int i=c;\\n        long long sum=0;\\n        int j=costs.size()-c-1;\\n        if(j<i)                     // if intial overlapping \\n        {\\n            priority_queue<int,vector<int> ,greater<int>>common;\\n            for(auto e:costs)\\n            {\\n                common.push(e);\\n            }\\n            while(k--)\\n            {\\n                sum+=common.top();\\n                common.pop();\\n            }\\n            return sum;\\n        }\\n        // cout<<j<<\" \"<<i;\\n        while(k>0 && j>=i)\\n        {\\n            if(left.top()<=right.top())\\n            {\\n                // cout<<left.top()<<\" L\"<<endl;\\n                sum+=left.top();\\n                left.pop();\\n                left.push(costs[i++]);\\n            }\\n            else\\n            {\\n                // cout<<right.top()<<\" R\"<<endl;\\n                sum+=right.top();\\n                right.pop();\\n                right.push(costs[j--]);\\n            }\\n            k--;\\n        }\\n        // cout<<i<<\" \"<<j<<endl;\\n        // cout<<k<<endl;\\n        if(j<=i && k>0)                 // for remainning k, all can be used again overlapping case\\n        {\\n            priority_queue<int,vector<int> ,greater<int>>common;\\n            while(left.size()>0)\\n            {\\n                common.push(left.top());\\n                left.pop();\\n            }\\n            while(right.size()>0)\\n            {\\n                common.push(right.top());\\n                right.pop();\\n            }\\n            while(k--)\\n            {\\n                sum+=common.top();\\n                common.pop();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783821,
                "title": "priorityqueue-java",
                "content": "# Intuition\\nUsing prioryqueue to store least costly candidate at top of queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(candidates) \\n\\n# Code\\n```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        PriorityQueue<int[]> pql = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> pqr = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        int l = 0;\\n        int r = costs.length -1 ;\\n        int n = costs.length;\\n        \\n        if(2* candidates >= n){\\n            \\n            int res = 0;\\n            PriorityQueue<int[]> rem = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n            for(int i = 0; i < n ; i++){\\n                rem.add(new int[]{ costs[i], i});\\n            }\\n            \\n            for(int j =0; j < k; j++){\\n                res += rem.poll()[0];\\n            }\\n            return res;\\n        }\\n\\n        for(int i = 0; i < candidates && i < n ; i++){\\n            pql.add(new int[]{ costs[l], l});\\n            l++;\\n            pqr.add(new int[]{ costs[r], r});\\n            r--;\\n        }\\n        long res = 0;\\n        int i= 0;\\n        for(; i < k && l <= r; i++){\\n            \\n            if(pql.peek()[0] < pqr.peek()[0]){\\n                res += pql.poll()[0];\\n                pql.add(new int[]{ costs[l], l});\\n                l++;\\n            }else if(pql.peek()[0] > pqr.peek()[0]){\\n                res += pqr.poll()[0];\\n                pqr.add(new int[]{ costs[r], r});\\n                r--;\\n            }else{\\n                if(pql.peek()[1] < pqr.peek()[1]){\\n                    res += pql.poll()[0];\\n                    pql.add(new int[]{ costs[l], l});\\n                    l++;\\n                }else{\\n                    res += pqr.poll()[0];\\n                    pqr.add(new int[]{ costs[r], r});\\n                    r--;\\n                }\\n            }\\n        }\\n        \\n        PriorityQueue<int[]> rem = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        rem.addAll(pql);\\n        rem.addAll(pqr);\\n        for(; i < k; i++){\\n            res += rem.poll()[0];\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        PriorityQueue<int[]> pql = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> pqr = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        int l = 0;\\n        int r = costs.length -1 ;\\n        int n = costs.length;\\n        \\n        if(2* candidates >= n){\\n            \\n            int res = 0;\\n            PriorityQueue<int[]> rem = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n            for(int i = 0; i < n ; i++){\\n                rem.add(new int[]{ costs[i], i});\\n            }\\n            \\n            for(int j =0; j < k; j++){\\n                res += rem.poll()[0];\\n            }\\n            return res;\\n        }\\n\\n        for(int i = 0; i < candidates && i < n ; i++){\\n            pql.add(new int[]{ costs[l], l});\\n            l++;\\n            pqr.add(new int[]{ costs[r], r});\\n            r--;\\n        }\\n        long res = 0;\\n        int i= 0;\\n        for(; i < k && l <= r; i++){\\n            \\n            if(pql.peek()[0] < pqr.peek()[0]){\\n                res += pql.poll()[0];\\n                pql.add(new int[]{ costs[l], l});\\n                l++;\\n            }else if(pql.peek()[0] > pqr.peek()[0]){\\n                res += pqr.poll()[0];\\n                pqr.add(new int[]{ costs[r], r});\\n                r--;\\n            }else{\\n                if(pql.peek()[1] < pqr.peek()[1]){\\n                    res += pql.poll()[0];\\n                    pql.add(new int[]{ costs[l], l});\\n                    l++;\\n                }else{\\n                    res += pqr.poll()[0];\\n                    pqr.add(new int[]{ costs[r], r});\\n                    r--;\\n                }\\n            }\\n        }\\n        \\n        PriorityQueue<int[]> rem = new PriorityQueue<>((a,b)->a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0]);\\n        rem.addAll(pql);\\n        rem.addAll(pqr);\\n        for(; i < k; i++){\\n            res += rem.poll()[0];\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783785,
                "title": "javascript-100-everywhere",
                "content": "After getting TLE for brute-force, I came up with approach with two PQ\\'s, did not have time to debug it during contest. \\n\\nOn the bright side, now that I got AC, I can enjoy getting 100% speed and 100% memory among JS submissions. It feels great!\\n\\n![image](https://assets.leetcode.com/users/images/c269ee04-85b9-4d86-ae81-e1ebc1bfa201_1667714028.0658934.png)\\n\\n\\n```javascript\\nvar totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      // take left\\n      result += lf[0];\\n      left.dequeue();\\n      if (l <= r) {\\n        left.enqueue([costs[l], l]);\\n        ++l;\\n      }\\n    } else {\\n      // take right\\n      result += rf[0];\\n      right.dequeue();\\n      if (l <= r) {\\n        right.enqueue([costs[r], r]);\\n        --r;\\n      }\\n    }\\n\\n    --k;\\n  }\\n\\n  return result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      // take left\\n      result += lf[0];\\n      left.dequeue();\\n      if (l <= r) {\\n        left.enqueue([costs[l], l]);\\n        ++l;\\n      }\\n    } else {\\n      // take right\\n      result += rf[0];\\n      right.dequeue();\\n      if (l <= r) {\\n        right.enqueue([costs[r], r]);\\n        --r;\\n      }\\n    }\\n\\n    --k;\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783734,
                "title": "java-easy-to-understand-with-useful-testcases-minheap-two-pointers",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/heap/TotalCostHireWorkers.java",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2783596,
                "title": "javascript-binary-search",
                "content": "# Code\\n```\\nconst binSearch = (arr, target) => {\\n    let l = 0;\\n    let r = arr.length - 1;\\n\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n\\n        if (arr[mid] > target) {\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return l;\\n};\\n\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n    if(costs.length <= candidates * 2) return costs.sort((a,b)=>a-b).slice(0, k).reduce((a,c)=>a+c,0);\\n\\n    const left = costs.slice(0, candidates);\\n    const middle = costs.slice(candidates, costs.length - candidates);\\n    const right = costs.slice(costs.length - candidates, costs.length);\\n    left.sort((a,b)=>a-b);\\n    right.sort((a,b)=>a-b);\\n\\n    const selected = [];\\n\\n    while(selected.length < k) {\\n        if(left[0] <= right[0]) {\\n            selected.push(left.shift());\\n            const n = middle.shift();\\n            left.splice(binSearch(left, n), 0, n);\\n        }\\n        else {\\n            selected.push(right.shift());\\n            const n = middle.pop();\\n            right.splice(binSearch(right, n), 0, n);\\n        }\\n    }\\n    \\n    return selected.reduce((a,c)=>a+c,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst binSearch = (arr, target) => {\\n    let l = 0;\\n    let r = arr.length - 1;\\n\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n\\n        if (arr[mid] > target) {\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return l;\\n};\\n\\n/**\\n * @param {number[]} costs\\n * @param {number} k\\n * @param {number} candidates\\n * @return {number}\\n */\\nvar totalCost = function(costs, k, candidates) {\\n    if(costs.length <= candidates * 2) return costs.sort((a,b)=>a-b).slice(0, k).reduce((a,c)=>a+c,0);\\n\\n    const left = costs.slice(0, candidates);\\n    const middle = costs.slice(candidates, costs.length - candidates);\\n    const right = costs.slice(costs.length - candidates, costs.length);\\n    left.sort((a,b)=>a-b);\\n    right.sort((a,b)=>a-b);\\n\\n    const selected = [];\\n\\n    while(selected.length < k) {\\n        if(left[0] <= right[0]) {\\n            selected.push(left.shift());\\n            const n = middle.shift();\\n            left.splice(binSearch(left, n), 0, n);\\n        }\\n        else {\\n            selected.push(right.shift());\\n            const n = middle.pop();\\n            right.splice(binSearch(right, n), 0, n);\\n        }\\n    }\\n    \\n    return selected.reduce((a,c)=>a+c,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783581,
                "title": "java-track-the-chosen-candidates-heap-to-get-the-candidate-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long ans = 0;\\n        boolean[] chosen = new boolean[costs.length];\\n        \\n        PriorityQueue<int[]> front = new PriorityQueue<>((a, b) -> {\\n            if(a[0] < b[0]){\\n                return -1;\\n            }\\n            else if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            }\\n            else{\\n                return 1;\\n            }\\n        });\\n        \\n        PriorityQueue<int[]> back = new PriorityQueue<>((a, b) -> {\\n            if(a[0] < b[0]){\\n                return -1;\\n            }\\n            else if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            }\\n            else{\\n                return 1;\\n            }\\n        });\\n        \\n        Deque<int[]> remain = new ArrayDeque<>();\\n        \\n        for(int i=0;i<candidates;i++){\\n            front.offer(new int[]{costs[i], i});\\n        }\\n        \\n        for(int i=costs.length-candidates;i<costs.length;i++){\\n            back.offer(new int[]{costs[i], i});\\n        }\\n        \\n        for(int i=candidates;i<costs.length-candidates;i++){\\n            remain.offerLast(new int[]{costs[i], i});\\n        }\\n        \\n        while(k-- > 0){\\n            \\n            while(!front.isEmpty() && chosen[front.peek()[1]])\\n                front.poll();\\n            \\n            while(!back.isEmpty() && chosen[back.peek()[1]])\\n                back.poll();\\n            \\n            while(front.size() < candidates && remain.size() > 0){\\n                front.offer(remain.pollFirst());\\n            }\\n            \\n            while(back.size() < candidates && remain.size() > 0){\\n                back.offer(remain.pollLast());\\n            }\\n            \\n            if(front.size() + back.size() >= candidates){\\n               if(front.size() > 0 && back.size() > 0){\\n                    if(front.peek()[0] < back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                    }\\n                    else if(front.peek()[0] == back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                        \\n                    }\\n                    else{\\n                        chosen[back.peek()[1]] = true;\\n                        ans += back.poll()[0];\\n                    }\\n                }\\n                else if(front.size() > 0){\\n                    chosen[front.peek()[1]] = true;\\n                    ans += front.poll()[0];\\n                }\\n                else if(back.size() > 0){\\n                    chosen[back.peek()[1]] = true;\\n                    ans += back.poll()[0];\\n                }\\n            }\\n            else{\\n                if(front.size() > 0 && back.size() > 0){\\n                    if(front.peek()[0] < back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                    }\\n                    else if(front.peek()[0] == back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                        \\n                    }\\n                    else{\\n                        chosen[back.peek()[1]] = true;\\n                        ans += back.poll()[0];\\n                    }\\n                }\\n                else if(front.size() > 0){\\n                    chosen[front.peek()[1]] = true;\\n                    ans += front.poll()[0];\\n                }\\n                else if(back.size() > 0){\\n                    chosen[back.peek()[1]] = true;\\n                    ans += back.poll()[0];\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        long ans = 0;\\n        boolean[] chosen = new boolean[costs.length];\\n        \\n        PriorityQueue<int[]> front = new PriorityQueue<>((a, b) -> {\\n            if(a[0] < b[0]){\\n                return -1;\\n            }\\n            else if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            }\\n            else{\\n                return 1;\\n            }\\n        });\\n        \\n        PriorityQueue<int[]> back = new PriorityQueue<>((a, b) -> {\\n            if(a[0] < b[0]){\\n                return -1;\\n            }\\n            else if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            }\\n            else{\\n                return 1;\\n            }\\n        });\\n        \\n        Deque<int[]> remain = new ArrayDeque<>();\\n        \\n        for(int i=0;i<candidates;i++){\\n            front.offer(new int[]{costs[i], i});\\n        }\\n        \\n        for(int i=costs.length-candidates;i<costs.length;i++){\\n            back.offer(new int[]{costs[i], i});\\n        }\\n        \\n        for(int i=candidates;i<costs.length-candidates;i++){\\n            remain.offerLast(new int[]{costs[i], i});\\n        }\\n        \\n        while(k-- > 0){\\n            \\n            while(!front.isEmpty() && chosen[front.peek()[1]])\\n                front.poll();\\n            \\n            while(!back.isEmpty() && chosen[back.peek()[1]])\\n                back.poll();\\n            \\n            while(front.size() < candidates && remain.size() > 0){\\n                front.offer(remain.pollFirst());\\n            }\\n            \\n            while(back.size() < candidates && remain.size() > 0){\\n                back.offer(remain.pollLast());\\n            }\\n            \\n            if(front.size() + back.size() >= candidates){\\n               if(front.size() > 0 && back.size() > 0){\\n                    if(front.peek()[0] < back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                    }\\n                    else if(front.peek()[0] == back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                        \\n                    }\\n                    else{\\n                        chosen[back.peek()[1]] = true;\\n                        ans += back.poll()[0];\\n                    }\\n                }\\n                else if(front.size() > 0){\\n                    chosen[front.peek()[1]] = true;\\n                    ans += front.poll()[0];\\n                }\\n                else if(back.size() > 0){\\n                    chosen[back.peek()[1]] = true;\\n                    ans += back.poll()[0];\\n                }\\n            }\\n            else{\\n                if(front.size() > 0 && back.size() > 0){\\n                    if(front.peek()[0] < back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                    }\\n                    else if(front.peek()[0] == back.peek()[0]){\\n                        if(front.peek()[1] <= back.peek()[1]){\\n                            chosen[front.peek()[1]] = true;\\n                            ans += front.poll()[0];\\n                        }\\n                        else{\\n                            chosen[back.peek()[1]] = true;\\n                            ans += back.poll()[0];\\n                        }\\n                        \\n                    }\\n                    else{\\n                        chosen[back.peek()[1]] = true;\\n                        ans += back.poll()[0];\\n                    }\\n                }\\n                else if(front.size() > 0){\\n                    chosen[front.peek()[1]] = true;\\n                    ans += front.poll()[0];\\n                }\\n                else if(back.size() > 0){\\n                    chosen[back.peek()[1]] = true;\\n                    ans += back.poll()[0];\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783525,
                "title": "javascript-two-heaps",
                "content": "**Solution: Two Heaps**\\n\\nTwo min heaps, `left` and `right`.\\nKeep up to `candidates` number of candidates in each heap.\\nFor each hire, pick the smallest candidate out of both heaps.\\n*   Remove the candidate from its heap.\\n*   Add the next worker into the heap.\\n\\n`k = number of workers to hire`, `m = candidates`\\nTime Complexity: `O(m log(m) + k log(m))` 1048ms\\nSpace Complexity: `O(m)` 97.7MB\\n```\\nvar totalCost = function(costs, k, candidates) {\\n  let n = costs.length;\\n  let left = new PriorityQueue((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); // [index, cost]  \\n  let right = new PriorityQueue((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); // [index, cost]\\n  let l, r;\\n  for (l = 0; l < Math.min(n, candidates); l++) {\\n    left.add([l, costs[l]]);\\n  }\\n  for (r = n - 1; r >= Math.max(0, n - candidates) && r > l; r--) {\\n    right.add([r, costs[r]]);\\n  }\\n  \\n  let totalCost = 0;\\n  for (let i = 0; i < k; i++) {\\n    let [leftIndex, leftCost] = left.size > 0 ? left.top() : [Infinity, Infinity];\\n    let [rightIndex, rightCost] = right.size > 0 ? right.top() : [Infinity, Infinity];\\n    let pickFromLeft = leftCost === rightCost ? leftIndex < rightIndex : leftCost < rightCost;\\n    if (pickFromLeft) { // pick from left heap\\n      left.remove();\\n      if (l <= r) left.add([l, costs[l]]), l++;\\n      totalCost += leftCost;\\n    } else { // pick from right heap\\n      right.remove();\\n      if (r >= l) right.add([r, costs[r]]), r--;\\n      totalCost += rightCost;\\n    } \\n  }\\n  return totalCost;\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar totalCost = function(costs, k, candidates) {\\n  let n = costs.length;\\n  let left = new PriorityQueue((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); // [index, cost]  \\n  let right = new PriorityQueue((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); // [index, cost]\\n  let l, r;\\n  for (l = 0; l < Math.min(n, candidates); l++) {\\n    left.add([l, costs[l]]);\\n  }\\n  for (r = n - 1; r >= Math.max(0, n - candidates) && r > l; r--) {\\n    right.add([r, costs[r]]);\\n  }\\n  \\n  let totalCost = 0;\\n  for (let i = 0; i < k; i++) {\\n    let [leftIndex, leftCost] = left.size > 0 ? left.top() : [Infinity, Infinity];\\n    let [rightIndex, rightCost] = right.size > 0 ? right.top() : [Infinity, Infinity];\\n    let pickFromLeft = leftCost === rightCost ? leftIndex < rightIndex : leftCost < rightCost;\\n    if (pickFromLeft) { // pick from left heap\\n      left.remove();\\n      if (l <= r) left.add([l, costs[l]]), l++;\\n      totalCost += leftCost;\\n    } else { // pick from right heap\\n      right.remove();\\n      if (r >= l) right.add([r, costs[r]]), r--;\\n      totalCost += rightCost;\\n    } \\n  }\\n  return totalCost;\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783499,
                "title": "segment-tree-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<pair<int,int>> tree;\\n    vector<int> arr;\\n    pair<int,int> calc(pair<int,int> left,pair<int,int> right){\\n        if(left.first <= right.first) return left;\\n    \\treturn right;\\n    }\\n\\n    void build(int node,int st,int en){\\n        if(st == en){\\n            tree[node] = {arr[st],st};\\n        }else{\\n            int mid = st + (en - st)/2;\\n            build(node*2,st,mid);\\n            build(node*2+1,mid+1,en);\\n            tree[node] = calc(tree[node*2], tree[node*2+1]);\\n        }\\n    }\\n\\n    void update(int node,int st,int en,int pos,int val){\\n        if(st > pos or en < pos) return;\\n\\n        if(st == en){\\n            tree[node].first = val;\\n        }else{\\n            int mid = st + (en - st)/2;\\n            update(node*2,st,mid,pos,val);\\n            update(node*2+1,mid+1,en,pos,val);\\n            tree[node] = calc(tree[node*2], tree[node*2+1]);\\n        }\\n    }\\n\\n    pair<int,int> query(int node,int st,int en,int l,int r){\\n        if(en < l or st > r) return {1e9,-1};\\n\\n        if(st >= l and en <= r){\\n            return tree[node];\\n        }\\n\\n        int mid = st + (en-st)/2;\\n\\n        auto left = query(node*2,st,mid,l,r);\\n        auto right = query(node*2+1,mid+1,en,l,r);\\n\\n        return calc(left, right);\\n    }\\n    \\npublic:\\n    long long totalCost(vector<int>& c, int k, int cn) {\\n        int n = c.size();\\n        arr = c;\\n        tree.resize(4*n);\\n        build(1,0,n-1);\\n        int left = 0, right = 0;\\n        long long ans = 0;\\n        while(k--){\\n            auto op1 = query(1,0,n-1,0,min(n-1,cn-1+left));\\n            auto op2 = query(1,0,n-1,max(0,n-cn-right),n-1);\\n            if(op1.first <= op2.first){\\n                ans += op1.first; left++; update(1,0,n-1,op1.second,1e9);\\n            }else{\\n                ans += op2.first; right++; update(1,0,n-1,op2.second,1e9);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<pair<int,int>> tree;\\n    vector<int> arr;\\n    pair<int,int> calc(pair<int,int> left,pair<int,int> right){\\n        if(left.first <= right.first) return left;\\n    \\treturn right;\\n    }\\n\\n    void build(int node,int st,int en){\\n        if(st == en){\\n            tree[node] = {arr[st],st};\\n        }else{\\n            int mid = st + (en - st)/2;\\n            build(node*2,st,mid);\\n            build(node*2+1,mid+1,en);\\n            tree[node] = calc(tree[node*2], tree[node*2+1]);\\n        }\\n    }\\n\\n    void update(int node,int st,int en,int pos,int val){\\n        if(st > pos or en < pos) return;\\n\\n        if(st == en){\\n            tree[node].first = val;\\n        }else{\\n            int mid = st + (en - st)/2;\\n            update(node*2,st,mid,pos,val);\\n            update(node*2+1,mid+1,en,pos,val);\\n            tree[node] = calc(tree[node*2], tree[node*2+1]);\\n        }\\n    }\\n\\n    pair<int,int> query(int node,int st,int en,int l,int r){\\n        if(en < l or st > r) return {1e9,-1};\\n\\n        if(st >= l and en <= r){\\n            return tree[node];\\n        }\\n\\n        int mid = st + (en-st)/2;\\n\\n        auto left = query(node*2,st,mid,l,r);\\n        auto right = query(node*2+1,mid+1,en,l,r);\\n\\n        return calc(left, right);\\n    }\\n    \\npublic:\\n    long long totalCost(vector<int>& c, int k, int cn) {\\n        int n = c.size();\\n        arr = c;\\n        tree.resize(4*n);\\n        build(1,0,n-1);\\n        int left = 0, right = 0;\\n        long long ans = 0;\\n        while(k--){\\n            auto op1 = query(1,0,n-1,0,min(n-1,cn-1+left));\\n            auto op2 = query(1,0,n-1,max(0,n-cn-right),n-1);\\n            if(op1.first <= op2.first){\\n                ans += op1.first; left++; update(1,0,n-1,op1.second,1e9);\\n            }else{\\n                ans += op2.first; right++; update(1,0,n-1,op2.second,1e9);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783494,
                "title": "java-priority-queue-solution-with-comments",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tpublic long totalCost(int[] costs, int k, int candidates) {\\n\\t\\t\\t// the first element is the value and second is the index of that value in the original costs array\\n\\t\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[0]-o2[0]==0?o1[1]-o2[1]:o1[0]-o2[0]);\\n\\t\\t\\t// use a flag to detect whether we need to add more element to pq \\n\\t\\t\\tboolean flag = false;\\n\\t\\t\\tint left =0;\\n\\t\\t\\tint right =costs.length-1;\\n\\t\\t\\t// insert candidates*2 elements or entire array if candidates*2 >= costs.length\\n\\t\\t\\twhile(left < candidates){\\n\\t\\t\\t\\tpq.offer(new int[]{costs[left], left});\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tif(left > right){\\n\\t\\t\\t\\t\\tflag =true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpq.offer(new int[]{costs[right], right});\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t\\tif(left > right){\\n\\t\\t\\t\\t\\tflag =true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlong totalCost = 0;\\n\\t\\t\\t// Use preIndex to record we delete the left or right element in the previous round\\n\\t\\t\\tint prevIndex =-1;\\n\\t\\t\\t// poll k times\\n\\t\\t\\tfor(int i=0; i < k; i++){\\n\\t\\t\\t\\tint[]curMin = pq.poll();\\n\\t\\t\\t\\tprevIndex = curMin[1];\\n\\t\\t\\t\\ttotalCost+=curMin[0];\\n\\t\\t\\t\\tif(!flag && prevIndex <=left ){\\n\\t\\t\\t\\t pq.offer(new int[]{costs[left], left});\\n\\t\\t\\t\\t left++;\\n\\t\\t\\t\\t if(left > right){\\n\\t\\t\\t\\t\\t flag = true;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(!flag && prevIndex > left){\\n\\t\\t\\t\\t pq.offer(new int[]{costs[right], right});\\n\\t\\t\\t\\t right--;\\n\\t\\t\\t\\t if(left > right){\\n\\t\\t\\t\\t   flag = true;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t}\\n\\t\\t\\t } \\n\\t\\t\\treturn totalCost;\\n\\n\\t\\t}\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic long totalCost(int[] costs, int k, int candidates) {\\n\\t\\t\\t// the first element is the value and second is the index of that value in the original costs array\\n\\t\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[0]-o2[0]==0?o1[1]-o2[1]:o1[0]-o2[0]);\\n\\t\\t\\t// use a flag to detect whether we need to add more element to pq \\n\\t\\t\\tboolean flag = false;\\n\\t\\t\\tint left =0;\\n\\t\\t\\tint right =costs.length-1;\\n\\t\\t\\t// insert candidates*2 elements or entire array if candidates*2 >= costs.length\\n\\t\\t\\twhile(left < candidates){\\n\\t\\t\\t\\tpq.offer(new int[]{costs[left], left}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1913638,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944649,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944715,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1673758,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944856,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1674199,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944704,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944652,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1673507,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1912172,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1913638,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944649,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944715,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1673758,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944856,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1674199,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944704,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944652,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1673507,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1912172,
                "content": [
                    {
                        "username": "mattreex",
                        "content": "This is the worst described problem I\\'ve ever seen on LeetCode. There is no way it was written by someone fluent in English."
                    },
                    {
                        "username": "z3eg",
                        "content": "nah dawg with descriptions like this i\\'m never seeing my T-shirt"
                    },
                    {
                        "username": "jswang00037",
                        "content": "Solving the problem is medium. \nUnderstandnig the description is HARD. "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "the word candidate is really confusing. i wasted 25 mins in contest thinking its something else."
                    },
                    {
                        "username": "Rohan__N",
                        "content": "same here bro "
                    },
                    {
                        "username": "parasmn4",
                        "content": "Use/ Meaning of Candidates here\n\ncandidates refers to 2 set of  people - one from start and other from last of costs array.\n\nAnd from these two sets we have to choose our lowest cost worker. \n\nEg:-\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n\ncandidates - 1st : - 17, 12, 10, 2\n                   - last - 2, 11, 20, 8\n\n\n\nChoose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly (using one pointer for each set).\n\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\n\nHere -> Choose 2 with index 3\n\nNext:-> \n- Here First candidates set will be updated.\nCandidates - 1st: 17, 12, 10, 7\n                   - Last: 2, 11, 20, 8 "
                    },
                    {
                        "username": "parasmn4",
                        "content": "[@Tigarana](/Tigarana) Choose only one worker in each session among these two sets (use min heap) of candidates and after choosing update the candidates sets accordingly using two pointers for each set "
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "[@Jana](/Tigarana) If you mean that candidates is a multiple of 2 then that will not be the case. All you have to do is to compare the cost from first n elements(candidates in this case) and last n elements(named as candidates) of the costs array"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@PinkiePieYay2707](/PinkiePieYay2707) So, in each hiring round, you can chose between the number of 2*candidates"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "Worst description I\\'ve seen yet, thank you for clarifying."
                    },
                    {
                        "username": "meanup",
                        "content": "Upvoted and make sense. Thanks."
                    },
                    {
                        "username": "yjianghong",
                        "content": "The `canddiate` should really be renamed as `n`"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@be_upriser](/be_upriser) yeah, `candidatesRange` sounds more clear"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Nope , candidate is something like range from beginning and end of the costs array , from where you can choose workers to hire"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed, I thought it was another array"
                    },
                    {
                        "username": "zB0y",
                        "content": "thank you so much! ``candidates`` made no sense..."
                    },
                    {
                        "username": "Wiblz",
                        "content": " `If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them.`\\nIs that english?"
                    },
                    {
                        "username": "Wiblz",
                        "content": "[@Ebad1001](/Ebad1001) `candidates` should be properly escaped in this case. Didn\\'t even realize they were referring to a variable. "
                    },
                    {
                        "username": "shyambhawsar",
                        "content": "[@Ebad1001](/Ebad1001) Replacing candidates with n really helped, thanks\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "replace the word `candidates` with `n` and it will make sense.\\n\"If there are fewer than `n` workers remaining, choose the worker with the lowest cost among them.\""
                    },
                    {
                        "username": "vmcniket",
                        "content": "English is a funny language 😵‍💫\n\nP.S: while reading the question, just replace candidates with n. It'll make the question very clear."
                    },
                    {
                        "username": "meanup",
                        "content": "Haha.. you are amazing. Now it make sense. Upvoted."
                    },
                    {
                        "username": "ksaxena149",
                        "content": "That really helped, can\\'t understand how changing one variable can make question hard to understand \\uD83D\\uDE02"
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I am unable to understand this question don\\'t know why?"
                    },
                    {
                        "username": "nvaslav48",
                        "content": "[@MaverickEyedea](/MaverickEyedea) That\\'s the beautiful explanation"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "[@MaverickEyedea](/MaverickEyedea) Thanks a lot for this explanation. Really appreciate this."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "congo for the 1 year insane streak !!!"
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "I hope they replace that description with this "
                    },
                    {
                        "username": "code_er7",
                        "content": "[@MaverickEyedea](/MaverickEyedea)  god , is that you ?"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "You\\'re supposed to traverse first \\'candidate\\' number of the array(elements from the beginning) and last \\'candidate\\' number of elements from the ending of the array. Find the minimum element in it and then remove that element from the list. This minimum element you found is the cost of one worker. Now, repeat this process k times since we wanna hire k workers exactly.\\n\\nEx: [3, ,5,1 2, 4, 1, 8, 2] and candidate = 2\\n-> Two elements from the beginning = 3, 5\\n-> Two elements at the end = 8, 2\\nMinimum element among 3, 5, 8, 2 is 2. That\\'s the cost of one worker. Now that you have hired one worker, remove 2 from the array. Now, array will look like\\n[3, 5, 1, 2, 4, 1, 8]\\nRepeat the process K times.\\n\\nif ever you find two elements with the same value, you need to remove the element with the smallest index in the array. (In the above examples, there are two 1\\'s in the array. When you encounter them, choose the one with the smallest index)\\n\\nHope you got it. "
                    },
                    {
                        "username": "Mirn",
                        "content": "Why such a difficult and dreary selection? why candidates and not N? why is it not said that it is necessary to choose 2N in total? why is it so complex?\\nHas anyone done this in practice? (not as abstract task, but as real business code)\\nvery weak examples, sarcasm: yes, let\\'s generally example an empty set and a trivial 1-2-3 and n=3 into examples /sarcasm\\neverything in description is very very VERY bad, too complex, too non reason.\\nYes I solved it.\\nI wish that no one in a real technical interview will come across such a task."
                    },
                    {
                        "username": "Husoski",
                        "content": "If N is \"candidates\" in the problem, it is not necessary to choose 2N of them.  You choose k of them, no matter what N is.  N helps determine which worker to hire at each step, but not how many workers are chosen."
                    },
                    {
                        "username": "am14",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Agreed."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess it trains us to comprehend the customer-formulated demands (which can be much more rambling than this)."
                    }
                ]
            },
            {
                "id": 1944889,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1945153,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1945065,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1944776,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1945230,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1944729,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1944688,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1967027,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1944662,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1945286,
                "content": [
                    {
                        "username": "darshitdobariya9719",
                        "content": "costs = [50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58], k=7, candidates=12\\nwhy the expected result is 95 rather than 86?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@muthuhari009](/muthuhari009) but the problem state we choose the worker with the following rule \n```In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.```\nso we can't just keep hiring from right array to get the second 16"
                    },
                    {
                        "username": "muthuhari009",
                        "content": "[@EricRaw](/EricRaw) we have 16 twice in the list to ideally it has to come on k = 5 as well know"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since we can only select the left and right of the cost array here's the 12 candidates\nleft = [50,80,34,9,86,20,67,94,65,82,40,79]\nright = [89,55,67,84,3,79,38,16,44,2,54,58]\n\nleftover cost = [74,92,84,37,19,16,85,20,79,25]\n\n- k = 1\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (2 3 16 38 44 54 55 58 67 79 84 89)\ncost = 0 + 2 (right Array) = 2\nright add 25\n\n- k = 2\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (3 16 25 38 44 54 55 58 67 79 84 89)\ncost = 2 + 3 (right Array) = 5\nright add 79\n\n- k = 3\nleft Array (9 20 34 40 50 65 67 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 5 + 9 (left Array) = 14\nleft add 74\n\n- k = 4\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (16 25 38 44 54 55 58 67 79 79 84 89)\ncost = 14 + 16 (right Array) = 30\nright add 20\n\n- k = 5\nleft Array (20 34 40 50 65 67 74 79 80 82 86 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 30 + 20 (left Array break tie smallest index) = 50\nleft add 92\n\n- k = 6\nleft Array (34 40 50 65 67 74 79 80 82 86 92 94)\nright Array (20 25 38 44 54 55 58 67 79 79 84 89)\ncost = 50+ 20 (right Array) = 70\nright add 85\n\n- k = 7\nleft Array (34 40 50 65 67 74 74 79 80 82 86 94)\nright Array (25 38 44 54 55 58 67 79 79 84 85 89)\ncost = 70+ 25 (right Array) = 95\nright add 16\n\nthe answer is 95"
                    },
                    {
                        "username": "asyukesh",
                        "content": "Yeah I am stuck in the same test case"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Poorly Written Question, let me explain\nYou have to select `k` workers from `costs` array with minimum cost.\nIn each round you can select 1 worker out of `candidates` worker from beginning or `candidates` workers from end. \n\ni.e k=2 , candidates = 3 , cost = [ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\nRound 1 :\nAs candidates=3 , you can either select from 3 people from the front or 3 people from the back\n\n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n^-----^_______ ^-----^\nSelection area\n`We take 1`\nnow we remove 1 from the begining and include the next \ni.e \n[ 1, 2, 3, 4, 5, 6 ,7 ,8, 9 ]\n _x ^-----^____^-----^\n\nRound 2 :\nselect 2\nans = 1+ 2"
                    },
                    {
                        "username": "RaduTuodr",
                        "content": "why did the 3 people from the back moved to the left? I\\'m trying to understand why did 9 get excluded and 6 included in the right candidates\\' list."
                    },
                    {
                        "username": "yuvalbalak",
                        "content": "thx"
                    },
                    {
                        "username": "eugencius",
                        "content": "That helped me A LOT! I\\'m eternally grateful"
                    },
                    {
                        "username": "Sakshi_646",
                        "content": "costs =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\ncan anyone here explain why this test case is not passing and giving 86 as output instead of 95.\\n16 is not deleting at once it is getting deleted in second time."
                    },
                    {
                        "username": "pranitsehgal",
                        "content": "The deletion code you are using is removing the first instance of the smallest number from costs[]. I had the same issue but fixed i now"
                    },
                    {
                        "username": "ajv97",
                        "content": "I got a stroke reading this description."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Problem text suits for improving mindfulness**"
                    },
                    {
                        "username": "maningning",
                        "content": "costs = [17,12,10,2,7,20,11,20,8], k=3, candidates=2\\nwhy the expected result is 31 rather than 24?\\n\\nthe first session chooses 12, ([17,12,10,2,7,20,11,20,8], choose index 1)\\nand the second session chooses 10, ([17,10,2,7,20,11,20,8], choose index 1)\\nand final session chooses 2, ([17,2,7,20,11,20,8], choose index 1)\\n\\n I think the answer should be 24"
                    },
                    {
                        "username": "GrandWizard",
                        "content": "FIrst session will choose 8. not 12. you dont have to minimize total cost. Pick candidate with minimum cost or each iteration\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Thanks, you\\'ve really helped"
                    },
                    {
                        "username": "maningning",
                        "content": "[@Krish-Gupta](/Krish-Gupta) Got, thanks"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "u have to choose the smallest number in the reange itself... like for the first time u choose the smallest from {17, 12, 20, 8} and hence the smallest is 8 so add it in you answer ... similarly 11 then 12."
                    },
                    {
                        "username": "letrung",
                        "content": "This is problem description is quite confusing, I have to read the discussion first in order to understand it. \\uD83D\\uDE05"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "what is candidate denotes here ? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done one month ago!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Managed to figure out what to do (a priority queue for each end of the costs array) without looking at the hint or editorial.\\nBut man, the edge cases made this a long problem to solve."
                    }
                ]
            },
            {
                "id": 1945283,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1945191,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1944991,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1944975,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1944677,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1944632,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 1945005,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 2052422,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 2036650,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 2020546,
                "content": [
                    {
                        "username": "FlickNBA",
                        "content": "Don\\'t know if I\\'m trippin but why is there candidates arg?"
                    },
                    {
                        "username": "andrewseva",
                        "content": "each time costs is divided into 2 groups. the size of each group is determined by candidates variable.\\nfirst group [0, candidates)\\nsecond group [size(costs) - candidates , size(costs))\\n\\n2 cases as example:\\noverlapping:\\nn = 2\\n[1, 2, 3]\\n[1,2] [3]\\n\\nnon overlapping:\\n[1,2,3,4,5]\\nn = 2\\n[1,2][4,5]\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Looking forward to seeing some advices for better english expression here..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what is the role of candidates here? Can someone explain me plz?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the role of candidates is like a limit on where you can choose the worker.\n\n- [17,12,10,2,7,2,11,20,8] candidates = 4\nleft = [17, 12, 10, 2] = limit 4\nright = [2, 11, 20 ,8] = limit 4\n\n- [17,12,10,2,7,2,11,20,8] candidates = 2\nleft = [17, 12] = limit 2\nright = [20, 8] = limit 2\n\nso you cannot choose other cost outside of the limit"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "really confusing description"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i solved this problem before the daily, and i can say with absolute certainty ... this is on my top 5 hated questions "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nNo need to use 2 priority_queue use pair.\\n\\n# Approach\\n\\n1. Create a priority queue `pq` to store pairs of integers in ascending order. Each pair represents the cost and index of an element.\\n2. Get the size of the input vector `costs` and initialize variables `low`, `high`, and `cal` to  `candidates - 1`, `0`, and `0`, respectively.\\n3. Iterate `i` from 0 to `candidates - 1` and insert pairs `{costs[i], i}` into the priority queue `pq`.\\n4. Iterate `i` from `n - 1` (the last index of `costs`) to `low` (inclusive) and as long as the number of remaining elements to consider `(n - 1 - i)` is less than `candidates`.\\n    a. Insert pairs `{costs[i], i}` into the priority queue `pq`.\\n    b. Update the value of `high` to `i`.\\n5. Initialize the variable `ans` to 0. This variable will store the total cost.\\n6. Iterate `i` from 0 to `k - 1` to select the top `k` elements from the priority queue `pq`.\\n    a. Get the value and index of the top element from the priority queue `pq`.\\n    b. Remove the top element from the priority queue `pq`.\\n    c. Add the value to `ans`.\\n    d. If the index is less than or equal to `low` and there are more elements between `low` and `high`, increment `low` and insert the corresponding element into the priority queue `pq`.\\n    e. If the index is greater than or equal to `high` and there are more elements between `low` and `high`, decrement `high` and insert the corresponding element into the priority queue `pq`.\\n7. Return the final value of `ans`, which represents the total cost.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=max(k*logK + 2*candidate) : k*logK=> k time loop run in iteration element push or pop take logK time.\\n\\n- Space complexity:\\nS.C=min(2*candidate,n), n=length of costs array.\\n\\n----------------------------\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683791/c-priority-queue-using-pair-simple-solution/"
                    },
                    {
                        "username": "ixeridium",
                        "content": "It might be interesting to compare the two approaches. In Python the solutions that use two heaps are generally a bit faster (maybe 10-20%) than the solutions that use pairs and just one heap. Using pairs also slightly increases the memory consumption. However if one is interested in simply getting things done, then the one heap approach looks simpler (at least to me) and is certainly good enough."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A badly-formulated problem with a handful of pesky corner cases."
                    },
                    {
                        "username": "ingato",
                        "content": "descriptions like this make me want to cancel my premium account."
                    },
                    {
                        "username": "udit_jha",
                        "content": "is it cheating if i see the related tags before attempting a question?\\n"
                    }
                ]
            },
            {
                "id": 2010901,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1996501,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1994350,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1994096,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1981724,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1969762,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1963422,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1955238,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1950882,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1946585,
                "content": [
                    {
                        "username": "iwilldothis",
                        "content": "i am getting struck in 94th testcase an anyone explain it??\\n"
                    },
                    {
                        "username": "obbl",
                        "content": "it would be nice of you to provide the testcase"
                    },
                    {
                        "username": "panksea06",
                        "content": "\"candidates\" is the worst name for this variable and totally misleads the question, and is poorly explained in walkthrough. \\n\\nRename it to something like \\'consideration_size\\' "
                    },
                    {
                        "username": "obbl",
                        "content": "Got zero Ideas how to solve TLE(skill issue) of my solution. Is there any way it can be faster then O(n^2)?"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "take a look at my Linked In profile just below"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documetation-activity-7091677872783802368-hKp5?utm_source=share&utm_medium=member_desktop\n\nplease upvote if you found the post to your liking"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This is the most poorly described algo question I\\'ve ever come across anywhere. If a part of the aim is to judge the interviewee\\'s ability to seek clarification in the face of dubious requirements then the editorial solution should clearly mention this.\\n\\nIt\\'s not realistic to pose a question that can only be understood by looking at the solution."
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "took me around 30mins to understand the question and 15mins to code it. :)"
                    },
                    {
                        "username": "EvilSerje",
                        "content": "Took me hours to find out there is FINEPRINT: if values're the same, 1st take from left one! Not the right!\nSo before you doing crazy algorithm that looks ahead, see that comment and no need to thank me."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "Can anyone help to explain the answer with following test cast? \\ncosts = [2,2,9,9,1,1,2,2]\\nk = 4\\ncandidates = 1\\nThe answer should be 6, but the system\\'s answer is 8.\\n Thank you."
                    },
                    {
                        "username": "UniqueAndy",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you. I missed the sentences \"Break the tie by the smallest index.\" "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`candidates == 1` means that in each round you can either choose the first or the last element of `costs`.  \nYou have to choose the smaller of the two, if they are equal you have to choose the first element.  \n\nIn the 1st round the candidates are `costs[0] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 2nd round the candidates are `costs[1] = 2` and `costs[7] = 2`. They are equal, you have to choose the first one.  \nIn the 3rd round the candidates are `costs[2] = 9` and `costs[7] = 2`. The last one is smaller, you have to choose it.  \nIn the 4th round the candidates are `costs[2] = 9` and `costs[6] = 2`. The last one is smaller, you have to choose it.  \nTherefore the correct answer is `2+2+2+2 == 8`.  \n\nIf you were allowed to make \"clever\" choices you could choose the last four elements an end up with a total cost of `6`.  \nBut that's not how this exercise works.  "
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "hey what is the  value of k is greater than the value of arr size in such case what we have to return ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the \"Constraints\" section: `1 <= k, candidates <= costs.length`"
                    },
                    {
                        "username": "abid29",
                        "content": "I go through the description several times and cant figure out the problem here. wtf is this."
                    }
                ]
            },
            {
                "id": 1945980,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945976,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945975,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945943,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945916,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945839,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945815,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945728,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945701,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945700,
                "content": [
                    {
                        "username": "AnotherFakeSub",
                        "content": "Took me 1 hour instead of 15 minutes because I missed the \"Break the tie by the smallest index\" condition. Stupid me."
                    },
                    {
                        "username": "pesterev",
                        "content": "By the way, it can be solved so elegantly in Rust using iterators and `BinaryHeap`, and implementing ordering traits. Magic."
                    },
                    {
                        "username": "pesterev",
                        "content": "The edge cases are poorly described."
                    },
                    {
                        "username": "user2049D",
                        "content": "I'm french and the statement was not so difficult to understand. Maybe a sign !"
                    },
                    {
                        "username": "shashwat_1999",
                        "content": "Can any one help me where i am doing wrong?\\n\\nHere is code \\n`class Solution:\\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\\n        cr = 0\\n        for i in range(k):\\n            if 2*candidates < len(costs):\\n                min1 = min(costs[:candidates])\\n                min2 = min(costs[-candidates:])\\n                print(min1,min2)\\n                mi = min(min1,min2)\\n                cr+=mi\\n                costs.remove(mi)\\n            else:\\n                mi= min(costs)\\n                cr+=mi\\n                costs.remove(mi)\\n            print(mi,costs)\\n        return cr\\n`\\nTest Case Passed(108/165)\\nFailed one\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nMy answer 86\\nExpected 95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`list.remove()` finds the *first* matching element, so the `costs.remove(mi)` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker.\\n\\nBTW: Please format your code correctly, that makes it easier to read and more likely that somebody will take the time to do so."
                    },
                    {
                        "username": "Belyua",
                        "content": "HR\\'s, can you solve this?"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I really hate this problem, but also thanks to whoever set this problem... Your contribution was meaningful and has helped someone learn."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "I personally like how the description is written in assembly language"
                    },
                    {
                        "username": "Amar___",
                        "content": "YA Leetcode you call it medium by giving alien statement :)\n"
                    },
                    {
                        "username": "crocodilehy",
                        "content": "I have to say the describetion is the worst"
                    },
                    {
                        "username": "psionl0",
                        "content": "describetion?"
                    }
                ]
            },
            {
                "id": 1945686,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945667,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945637,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945601,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945577,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945569,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945478,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945385,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945349,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945197,
                "content": [
                    {
                        "username": "belepod",
                        "content": "typical monday nightmare"
                    },
                    {
                        "username": "taparia11",
                        "content": "if they want to confuse us then confuse it properly. i still not get the use of candidate. sometimes they consider sometimes not."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "Why is my code lagging...   \\n`class Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.begin(),costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n    }\\n};`\\ncosts =\\n[50,80,34,9,86,20,67,94,65,82,40,79,74,92,84,37,19,16,85,20,79,25,89,55,67,84,3,79,38,16,44,2,54,58]\\nk =\\n7\\ncandidates =\\n12\\n\\nOutput\\n86\\nExpected\\n95"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@choksi_harsh_18](/choksi_harsh_18) For each of the `k` workers this solution creates the two priority queues. That\\'s a lot of effort. Instead you could create them once, before the loop, and whenever you `.pop()` an element replace it with a new one. You will have to keep track of the current end points within `costs` and that the two queues don\\'t overlap."
                    },
                    {
                        "username": "choksi_harsh_18",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks!! I have corrected it and it has passed that particular testcase but now getting time limit exceeded error. Can you give me a hint to reduce it.\\nclass Solution {\\npublic:\\n    long long totalCost(vector<int>& costs, int k, int candidates) {\\n        long long cost = 0;\\n        for(int i=0;i<k;i++){\\n            if(costs.size()<candidates){\\n                candidates--;\\n            }\\n            priority_queue<int, vector<int>, greater<int> > p1(costs.begin(), costs.begin() + candidates);\\n            priority_queue<int, vector<int>, greater<int> > p2(costs.end() - candidates, costs.end());\\n            long long min1 = p1.top();\\n            long long min2 = p2.top();\\n            if(min1<=min2){\\n                cost+=min1;\\n                p1.pop();\\n                costs.erase(find(costs.begin(), costs.begin() + candidates,min1));\\n            }\\n            else{\\n                cost+=min2;\\n                p2.pop();\\n                costs.erase(find(costs.end() - candidates, costs.end(),min2));\\n            }\\n        }\\n        return cost;\\n}\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find()` finds the *first* matching element, so the `costs.erase(find(costs.begin(),costs.end(),min2));` does not necessarily remove the correct element from `costs`.  \\nIn the example above the `16` at index `29` gets chosen as the 4th worker (so far so good) but then the `16` at index `17` gets removed and in the next iteration the `16` at index `29` gets chosen a second time as the 5th worker."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "input = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 , candidates = 2\\n\\nMy Output : 414\\nExpected : 423\\n\\nCan anyone help me what i am doing wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "That\\'s almost impossible to tell without seeing your code."
                    },
                    {
                        "username": "yc209633",
                        "content": "Same issue "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I solved the problem in `O(c*k)` time complexity. But it is showing *Time Limit Exceeded*. can anyone tell me the expected time complexity to solve the problem."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(`k` log `candidates`) "
                    },
                    {
                        "username": "atharva598",
                        "content": "O(nlogn) where n is size of costs array."
                    },
                    {
                        "username": "bhruti1",
                        "content": "I think i need to learn english again!!!"
                    },
                    {
                        "username": "sadriddin17",
                        "content": "TEST case is missing!! My code successfully has been successfully submitted but failing with this test.\\n[8,1,9]\\n1\\n2\\n\\n\\n\\n\\n `        if(costs.length == 1) return costs[0];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        Queue<Integer> q2 = new PriorityQueue<>();\\n        long sum = 0;\\n        int l = 0;\\n        int r = costs.length - 1;\\n\\n        while(l < candidates && l < r) {\\n            q.add(costs[l++]);\\n            q2.add(costs[r--]);\\n        }\\n\\n        while(k > 0) {\\n            if(q.isEmpty()) {\\n                sum += q2.poll();\\n                k--;\\n                continue;\\n            }\\n            if(q2.isEmpty()) {\\n                sum += q.poll();\\n                k--;\\n                continue;\\n            }\\n\\n            int left = q.poll();\\n            int right = q2.poll();\\n\\n            if(left <= right) {\\n                q2.add(right);\\n                if(l <= r)\\n                q.add(costs[l++]);\\n                sum += left;\\n            } else {\\n                if(l <= r)\\n                q2.add(costs[r--]);\\n                q.add(left);\\n                sum += right;\\n            }\\n            k--;\\n        }\\n\\n        return sum;`"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Are there downsides of using indices to compare values in priority queue instead of adding the values directly? I tried it that way but it is slow (Beats only 19%). [My solution](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3685124/java-single-priority-queue/)"
                    },
                    {
                        "username": "loloksEth",
                        "content": "my eyes are bleeding"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Fun question but the description was really painful to read ngl"
                    }
                ]
            },
            {
                "id": 1945164,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945139,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945133,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945132,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945118,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945112,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945098,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945072,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945053,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945012,
                "content": [
                    {
                        "username": "serkora",
                        "content": "Abysmal description, as always.\\n\\nShoudl\\'ve provided an example such as [3,2,1,2,3] with k=1, candidates=2 to explain that worker with cost=1 cannot be hired to clearly show what that \\'candidates\\' parameter is."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "This problem is boring..."
                    },
                    {
                        "username": "trpaslik",
                        "content": "LOL I was about to solve this yesterday as a pick-random and here it goes again!"
                    },
                    {
                        "username": "Isha307",
                        "content": "Problem was good but description was worst "
                    },
                    {
                        "username": "ops2991",
                        "content": "I got 160 / 160 testcases passed but my solution is not accepted. Instead, I got Time Limit Exceeded and the Last Executed Input is empty. Who can tell me why please.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the overall performance took too long to execute so it give you Time limit exceeded. So you should improve the time complexity of your code"
                    },
                    {
                        "username": "PalmerMa",
                        "content": "candidates\\nBad description"
                    },
                    {
                        "username": "tjshranjan",
                        "content": "[10,11,1,10]\\n[10,1,11,10]\\n\\nwhy above have different answers...\\n"
                    },
                    {
                        "username": "kantarcise",
                        "content": "You are not only battling with an algorithm here. You are also trying to interpret someone\\u2019s non ideal English."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Most FUCKED up description I\\'ve ever seen. The question was ok not very hard. But the description confused the shif out of me. And I got irriteted trying to solve this problem. The edge cases are such a bitch!!"
                    },
                    {
                        "username": "codernakul",
                        "content": "The hell bro who wrote this"
                    }
                ]
            },
            {
                "id": 1945011,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944968,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944963,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944914,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944873,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944872,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944866,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944858,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944847,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944846,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "The description was so bad even after reading it repeatedly i had  no idea what to do. Thanks to the test cases and explanation that got some idea about the question."
                    },
                    {
                        "username": "velimir1995",
                        "content": "Did Joe Biden explained this?"
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "why sorting the cost and taking k costs not working solution is not working  for all the test cases ,125 test case passed..  this one giving worng ans [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\n11\\n2  can\\'t able to figure about,, help plz."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@EricRaw](/EricRaw)  thanks a lot . Now i got it."
                    },
                    {
                        "username": "Ranjanj17",
                        "content": "[@hicugi](/hicugi)  thanks for the potinting out  ."
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "EricRaw",
                        "content": "since you are selecting cost based on candidates left and right of the cost array, you should refrain from modifying the cost array in any manner"
                    },
                    {
                        "username": "debapriya_sen",
                        "content": "The part which was hard for me to understand is: \\n\\nIt says, in each session you can select from the first `n` workers or the last `n` workers, not the entire array. `n` here is the `candidates`. \\nMeaning: If you have: `costs = [3,2,7,1,7,2]` and `candidates = 2`, then in the first hiring session, we can not select \\'1\\'. Since it is not within first 2 or last 2 elements. we have to select \\'2\\'.\\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "The description. Oh gawd!!"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Very well explained problem statement😒, good job problem setter sahab😏"
                    },
                    {
                        "username": "demoai",
                        "content": "why can\\'t I use sort and add the least k numbers \\ncan sessions be conduscted only at begining / ending ?\\n"
                    },
                    {
                        "username": "be_upriser",
                        "content": "Yes , here candidate is like a range in beginning and ending of the costs array from which you can choose workers\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "you basicly answered you question yourself, you cant do it exactly for that reason"
                    },
                    {
                        "username": "arunbharath",
                        "content": "costs = [31,25,72,79,74,65,84,91,18,59,27,9,81,33,17,58]\\nk = 11 and Candidates = 9\\noutput = 423\\nI didn\\'t understand this part. How come 423 is for hiring 2 candidate? Am I missing something from description? "
                    },
                    {
                        "username": "hicugi",
                        "content": "2 candidates from start OR end side of the costs. You probably considering only one side at every step"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are hiring k workers, in each of the k seassion you choose from at most 2*candidates (candidates at the beginning and candidates at the end of the costs array)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Heavy use of sets"
                    },
                    {
                        "username": "Aadil42",
                        "content": "What are we suppose to do with candidates input?"
                    },
                    {
                        "username": "premkumar9030",
                        "content": "For me the same doubt Loll , but later I got the error at 15th testcase. Over all program works on candidates."
                    },
                    {
                        "username": "parasmn4",
                        "content": "candidates refers to 2 set of  people - one from start and other from last of costs array.\\n\\nAnd from these two sets you have to choose your lowest cost worker. \\n\\nEg:-\\n[17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\\n\\ncandidates - 1st : - 17, 12, 10, 2\\n                   - last - 2, 11, 20, 8\\n\\nAmong these 2 sets choose lowest cost. If equal then choose the one with smallest index.\\n\\nHere -> Choose 2 with index 3\\n\\nNext:->\\nCandidates - 1st: 17, 12, 10, 7\\n                   - Last: 2, 11, 20, 8\\n "
                    },
                    {
                        "username": "vmcniket",
                        "content": "While reading the question..read \\'candidates\\' as \\'n\\'.. You\\'ll understand the question clearly"
                    }
                ]
            },
            {
                "id": 1944830,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944798,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944748,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944686,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944664,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944651,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1944645,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1820882,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1673580,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            },
            {
                "id": 1673567,
                "content": [
                    {
                        "username": "samarth_717",
                        "content": "Anyone did the ques with 2 multisets? "
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Is priority queue the only option, any other way to do that?\\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "you can use set.."
                    },
                    {
                        "username": "marco_seven",
                        "content": "Is this right Leetcode?\n\n`History Tells Us That`\n`Powerful Questions Come From Powerful Places.`\n`History Was Wrong,`\n`Powerful Question Make Places Powerful`"
                    },
                    {
                        "username": "Anupkrpal",
                        "content": "why can\\'t we just sort it and just take those k elements in the array it will be smallest only right?"
                    },
                    {
                        "username": "acohen31",
                        "content": "Sorting the two initial subarrays would take O(klogk) whereas heapify is O(k) so there is already quite a large difference.  Now every time you want to insert a new element into your sorted array it would  take O(k) where inserting a new element into a heap is O(logk).  If you need to hire k candidates then the difference between the two methods becomes quite obvious.  O(k^2) vs O(klogk)."
                    },
                    {
                        "username": "Karilli",
                        "content": "you can choose only from a subset of workers at each session (the subset is defined by \\'candidates\\'). element in the middle of cost might not even get a chance to get hired."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "MathWorks prob hires like this which drives hiring during the freeze"
                    },
                    {
                        "username": "vnk01",
                        "content": "wtf description not make any sense!"
                    },
                    {
                        "username": "HuntZou",
                        "content": "stop complain\\uFF0Ccan same one explain the question? what\\'s the candidates mean for? transform it to plain question, not the work cost balabala."
                    },
                    {
                        "username": "Karilli",
                        "content": "At each step u can select new worker only from a subset of workers. the subset is first \\'candidates\\' workers (at the beginning of the array) and last \\'candidates\\' workers (at the end of the array). \\n\\nAs others suggested, replace \\'candidates\\' with \\'n\\', it will make more sense."
                    },
                    {
                        "username": "Mohit1234567",
                        "content": "What is the use of candidates here if the calculations are made only on k and costs."
                    },
                    {
                        "username": "amansingh0997",
                        "content": "\nCan someone tell what is wrong with this solution?\n\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        long long n=costs.size();\n        long long sum=0;\n        priority_queue<long long,vector<long long>,greater<long long>>pq1;\n        priority_queue<long long,vector<long long>,greater<long long>>pq2;\n        long long i=0,j=n-1;\n        while(i<=j && k>0){\n            while(pq1.size()<candidates || pq2.size()<candidates){\n                if(pq1.size()<candidates){\n                    pq1.push(costs[i]);\n                    i++;\n                }\n                if(pq2.size()<candidates){\n                    pq2.push(costs[j]);\n                    j--;\n                }\n            }\n            int x=min(pq1.top() , pq2.top());\n            \n            if(x==pq1.top()) pq1.pop();\n            else pq2.pop();\n            \n            sum+=x;\n            k--;\n        }\n        while(k!=0){\n            while(pq1.size() && pq2.size()){\n                if(k>0){\n                    int x=min(pq1.top(),pq2.top());\n                    if(x==pq1.top()) pq1.pop();\n                    else pq2.pop();\n                    sum+=x;\n                    k--;\n                }\n                else break;\n            }\n        }\n    return sum;\n    }\n};"
                    },
                    {
                        "username": "Shekhar0050M",
                        "content": "`  \\nclass Solution {\\n\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\t\\tint len = costs.length, tmp = 0;\\n\\t\\tlong res = 0;\\n\\t\\tTreeMap<Integer,Integer> firstST = new TreeMap<>();\\n\\t\\tTreeMap<Integer,Integer> LastST = new TreeMap<>();\\n\\t\\tfor (int i = 0; i < candidates; i++) {\\n            if(firstST.containsKey(costs[i])){\\n                firstST.put(costs[i],firstST.get(costs[i])+1);\\n            }\\n            else{\\n\\t\\t\\t    firstST.put(costs[i],1);                \\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int i = len - candidates; i < len; i++) {\\n            if(LastST.containsKey(costs[i])){\\n\\t\\t\\t    LastST.put(costs[i],LastST.get(costs[i])+1);\\n            }\\n            else{\\n                LastST.put(costs[i],1);\\n            }\\n\\t\\t\\tcosts[i] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tint idx1 = candidates, idx2 = len - candidates-1;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\ttmp = Integer.MAX_VALUE;\\n\\t\\t\\tif (!firstST.isEmpty()) {\\n\\t\\t\\t\\ttmp = firstST.firstKey();\\n\\t\\t\\t}\\n\\t\\t\\tif (!LastST.isEmpty()) {\\n\\t\\t\\t\\ttmp = Math.min(LastST.firstKey(), tmp);\\n\\t\\t\\t}\\n\\t\\t\\tres += tmp;\\n\\t\\t\\tif (firstST.firstKey() <= LastST.firstKey()) {\\n\\t\\t\\t\\tfirstST.put(firstST.firstKey(),firstST.get(firstST.firstKey())-1);\\n                if(firstST.get(firstST.firstKey())==0){\\n                    firstST.remove(firstST.firstKey());\\n                }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tLastST.put(LastST.firstKey(),LastST.get(LastST.firstKey())-1);\\n                if(LastST.get(LastST.firstKey())==0){\\n                    LastST.remove(LastST.firstKey());\\n                }\\n\\t\\t\\t}\\n\\t\\t\\tif (firstST.size() < candidates && idx1 < costs.length) {\\n                if(firstST.containsKey(costs[idx1])){\\n                    firstST.put(costs[idx1],firstST.get(costs[idx1])+1);\\n                }\\n                else{\\n                    firstST.put(costs[idx1],1);\\n                }\\n\\t\\t\\t\\tcosts[idx1] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t} else if (LastST.size() < candidates && idx2 >= 0) {\\n\\t\\t\\t\\tif(LastST.containsKey(costs[idx2])){\\n                    LastST.put(costs[idx2],LastST.get(costs[idx2])+1);\\n                }\\n                else{\\n                    LastST.put(costs[idx2],1);\\n                }\\n\\t\\t\\t\\tcosts[idx2] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tidx2--;\\n\\t\\t\\t}\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n} \\n\\'\\nWhere am I wrong?"
                    }
                ]
            }
        ]
    }
]