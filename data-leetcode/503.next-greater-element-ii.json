[
    {
        "title": "Next Greater Element II",
        "question_content": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\nThe next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs to search circularly, which is also 2.\n\nExample 2:\n\nInput: nums = [1,2,3,4,3]\nOutput: [2,3,4,-1,4]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-109 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 98270,
                "title": "java-c-python-loop-twice",
                "content": "## **Explanation**\\nLoop once, we can get the Next Greater Number of a normal array.\\nLoop twice, we can get the Next Greater Number of a circular array\\n<br>\\n\\n## **Complexity**\\nTime `O(N)` for one pass\\nSpce `O(N)` in worst case\\n<br>\\n\\n**Java**\\n```java\\n    public int[] nextGreaterElements(int[] A) {\\n        int n = A.length, res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n * 2; i++) {\\n            while (!stack.isEmpty() && A[stack.peek()] < A[i % n])\\n                res[stack.pop()] = A[i % n];\\n            stack.push(i % n);\\n        }\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<int> nextGreaterElements(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> stack, res(n, -1);\\n        for (int i = 0; i < n * 2; ++i) {\\n            while (stack.size() && A[stack.back()] < A[i % n]) {\\n                res[stack.back()] = A[i % n];\\n                stack.pop_back();\\n            }\\n            stack.push_back(i % n);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def nextGreaterElements(self, A):\\n        stack, res = [], [-1] * len(A)\\n        for i in range(len(A)) * 2:\\n            while stack and (A[stack[-1]] < A[i]):\\n                res[stack.pop()] = A[i]\\n            stack.append(i)\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n[901. Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n[856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n[503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n496. Next Greater Element I\\n84. Largest Rectangle in Histogram\\n42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] nextGreaterElements(int[] A) {\\n        int n = A.length, res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n * 2; i++) {\\n            while (!stack.isEmpty() && A[stack.peek()] < A[i % n])\\n                res[stack.pop()] = A[i % n];\\n            stack.push(i % n);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> nextGreaterElements(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> stack, res(n, -1);\\n        for (int i = 0; i < n * 2; ++i) {\\n            while (stack.size() && A[stack.back()] < A[i % n]) {\\n                res[stack.back()] = A[i % n];\\n                stack.pop_back();\\n            }\\n            stack.push_back(i % n);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def nextGreaterElements(self, A):\\n        stack, res = [], [-1] * len(A)\\n        for i in range(len(A)) * 2:\\n            while stack and (A[stack[-1]] < A[i]):\\n                res[stack.pop()] = A[i]\\n            stack.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 98273,
                "title": "java-10-lines-and-c-12-lines-linear-time-complexity-o-n-with-explanation",
                "content": "The approach is same as *Next Greater Element I*\\nSee explanation in [my solution to the previous problem](https://discuss.leetcode.com/topic/77916/java-10-lines-linear-time-complexity-o-n-with-explanation)\\nThe only difference here is that we use ```stack``` to keep the **indexes** of the **decreasing** subsequence\\n\\n**Java**\\n```\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length, next[] = new int[n];\\n        Arrays.fill(next, -1);\\n        Stack<Integer> stack = new Stack<>(); // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!stack.isEmpty() && nums[stack.peek()] < num)\\n                next[stack.pop()] = num;\\n            if (i < n) stack.push(i);\\n        }   \\n        return next;\\n    }\\n```\\n**C++**\\n```\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> next(n, -1);\\n        stack<int> s; // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!s.empty() && nums[s.top()] < num) {\\n                next[s.top()] = num;\\n                s.pop();\\n            }\\n            if (i < n) s.push(i);\\n        }   \\n        return next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```stack```\n```\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length, next[] = new int[n];\\n        Arrays.fill(next, -1);\\n        Stack<Integer> stack = new Stack<>(); // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!stack.isEmpty() && nums[stack.peek()] < num)\\n                next[stack.pop()] = num;\\n            if (i < n) stack.push(i);\\n        }   \\n        return next;\\n    }\\n```\n```\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> next(n, -1);\\n        stack<int> s; // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!s.empty() && nums[s.top()] < num) {\\n                next[s.top()] = num;\\n                s.pop();\\n            }\\n            if (i < n) s.push(i);\\n        }   \\n        return next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98262,
                "title": "typical-ways-to-solve-circular-array-problems-java-solution",
                "content": "The first typical way to solve circular array problems is to extend the original array to twice length, 2nd half has the same element as first half. Then everything become simple.\\nNaive by simple solution, just look for the next greater element directly. Time complexity: O(n^2).\\n```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        \\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int[] temp = new int[n * 2];\\n        \\n        for (int i = 0; i < n * 2; i++) {\\n            temp[i] = nums[i % n];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            result[i] = -1;\\n            if (nums[i] == max) continue;\\n            \\n            for (int j = i + 1; j < n * 2; j++) {\\n                if (temp[j] > nums[i]) {\\n                    result[i] = temp[j];\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nThe second way is to use a ```stack``` to facilitate the look up. First we put all indexes into the stack, ```smaller``` index on the ```top```. Then we start from ```end``` of the array look for the first element (index) in the stack which is greater than the current one. That one is guaranteed to be the ```Next Greater Element```. Then put the current element (index) into the stack.\\nTime complexity: O(n).\\n```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            stack.push(i);\\n        }\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            result[i] = -1;\\n            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()){\\n                result[i] = nums[stack.peek()];\\n            }\\n            stack.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        \\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int[] temp = new int[n * 2];\\n        \\n        for (int i = 0; i < n * 2; i++) {\\n            temp[i] = nums[i % n];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            result[i] = -1;\\n            if (nums[i] == max) continue;\\n            \\n            for (int j = i + 1; j < n * 2; j++) {\\n                if (temp[j] > nums[i]) {\\n                    result[i] = temp[j];\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```stack```\n```smaller```\n```top```\n```end```\n```Next Greater Element```\n```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            stack.push(i);\\n        }\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            result[i] = -1;\\n            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()){\\n                result[i] = nums[stack.peek()];\\n            }\\n            stack.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390699,
                "title": "optimized-solution-easy-c-stack-implementation-st",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach \\n### Simple implementation of stacks and because of circular array we take 2*n elements instead of n elements\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& a) {\\n        int n = a.size();\\n        vector<int>v(n,-1);\\n\\n        stack<int>st;\\n        for(int i = 2*n - 1; i >= 0; i--)\\n        {\\n            // we pop out all elements smaller than current element\\n            while(!st.empty() && (a[i%n] >= st.top()))\\n            {\\n                st.pop();\\n            }\\n\\n            // if stack is empty means no greater element is there\\n            // if not empty we make answer at that index equal to top element\\n            if(!st.empty() && (i < n))\\n            {\\n                v[i] = st.top();\\n            }\\n\\n            st.push(a[i%n]);\\n        }\\n\\n        return v;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/b1321a46-fa48-4dbb-aace-41f5c1cad2c6_1680879272.3589258.png)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& a) {\\n        int n = a.size();\\n        vector<int>v(n,-1);\\n\\n        stack<int>st;\\n        for(int i = 2*n - 1; i >= 0; i--)\\n        {\\n            // we pop out all elements smaller than current element\\n            while(!st.empty() && (a[i%n] >= st.top()))\\n            {\\n                st.pop();\\n            }\\n\\n            // if stack is empty means no greater element is there\\n            // if not empty we make answer at that index equal to top element\\n            if(!st.empty() && (i < n))\\n            {\\n                v[i] = st.top();\\n            }\\n\\n            st.push(a[i%n]);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671531,
                "title": "c-stack-explained-o-2-n",
                "content": "* Imagine the input array as a concatenation of the same array, *twice*. ```[1,2,1] -> [1,2,1,1,2,1]```\\n* Similar to *Next Greater Element*, store the ***index*** in the stack instead of the actual value.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        nums.resize(2*n);\\n        \\n        for(int i=n; i<2*n; i++) //concatenate the same array\\n        {\\n            nums[i] = nums[i-n];\\n        }\\n        \\n        vector<int> res(n, -1); //to be returned, initialize it with -1\\n        stack<int> st;\\n        \\n        for(int i=0; i<2*n; i++)\\n        {\\n            int ele = nums[i];\\n            \\n            while(!st.empty() && ele > nums[st.top()])\\n            {\\n\\t\\t\\t\\t//ele acts as NGE to the value at st.top()\\n\\t\\t\\t\\t\\n                if(st.top() >= n) //index should not exceed n\\n                {\\n                    st.top() = st.top() - n;\\n                }\\n                \\n                res[st.top()] = ele;\\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```[1,2,1] -> [1,2,1,1,2,1]```\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        nums.resize(2*n);\\n        \\n        for(int i=n; i<2*n; i++) //concatenate the same array\\n        {\\n            nums[i] = nums[i-n];\\n        }\\n        \\n        vector<int> res(n, -1); //to be returned, initialize it with -1\\n        stack<int> st;\\n        \\n        for(int i=0; i<2*n; i++)\\n        {\\n            int ele = nums[i];\\n            \\n            while(!st.empty() && ele > nums[st.top()])\\n            {\\n\\t\\t\\t\\t//ele acts as NGE to the value at st.top()\\n\\t\\t\\t\\t\\n                if(st.top() >= n) //index should not exceed n\\n                {\\n                    st.top() = st.top() - n;\\n                }\\n                \\n                res[st.top()] = ele;\\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215705,
                "title": "javascript-o-n-think-how-your-brain-thinks-solution-with-comments",
                "content": "I looked at other solutions where they had a for loop going over double the size of the input array and doing \\'%\\' (modulo) and stuff like that. While that is a smart way to do it, I think the following approach helped me think in a better/cleaner way.\\n\\nNOTE: We push the indexes of the elements in the stack and not the elements themselves. Just read the solution and try to go over this case (nums = [1,4,2,1,2]), you will get what it\\'s doing.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    const ret = [];\\n    const stack = [];\\n\\n\\t//paranoid base case.\\n    if (!nums || nums.length < 1) return ret;\\n\\t\\n\\t//normal case: while iterating over the array if we find an element which is  bigger\\n\\t//than one in the stack, set ret[`smaller element from stack`] to the current\\n\\t//larger element found.\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[i]) {\\n            const smallerEleIndexFromStack = stack.pop();\\n            ret[smallerEleIndexFromStack] = nums[i];\\n        }\\n        stack.push(i);\\n    }\\n\\n\\t//Now, we again begin from the start of nums and deal with elements\\n\\t//for which we couldn\\'t find a \\'next bigger element\\' in the previous for loop\\n\\t//Example: nums = [1,4,2,1,2]. After the first loop, the stack would still hold the\\n\\t//indexes 1, 2 and 4 since we couldn\\'t find next elements bigger than nums[1],\\n\\t//nums[2] and nums[4].\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[i]) {\\n            const smallerEleIndexFromStack = stack.pop();\\n            ret[smallerEleIndexFromStack] = nums[i];\\n        }\\n    }\\n\\n\\t//Finally, still there would be some elements for which there was no \\'next greater element\\'\\n\\t//In the case of nums = [1,4,2,1,2], 4 would be such an element. So we just go over the\\n\\t//remaining elements in the stack and assign -1 to them in ret array.\\n    const remaining = stack.length;\\n    for (let i = 0; i < remaining; i++) {\\n        ret[stack.pop()] = -1;\\n    }\\n\\n    return ret;\\n};\\n```\\n\\nPlease let me know if any part of the solution is unclear/confusing.",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    const ret = [];\\n    const stack = [];\\n\\n\\t//paranoid base case.\\n    if (!nums || nums.length < 1) return ret;\\n\\t\\n\\t//normal case: while iterating over the array if we find an element which is  bigger\\n\\t//than one in the stack, set ret[`smaller element from stack`] to the current\\n\\t//larger element found.\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[i]) {\\n            const smallerEleIndexFromStack = stack.pop();\\n            ret[smallerEleIndexFromStack] = nums[i];\\n        }\\n        stack.push(i);\\n    }\\n\\n\\t//Now, we again begin from the start of nums and deal with elements\\n\\t//for which we couldn\\'t find a \\'next bigger element\\' in the previous for loop\\n\\t//Example: nums = [1,4,2,1,2]. After the first loop, the stack would still hold the\\n\\t//indexes 1, 2 and 4 since we couldn\\'t find next elements bigger than nums[1],\\n\\t//nums[2] and nums[4].\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[i]) {\\n            const smallerEleIndexFromStack = stack.pop();\\n            ret[smallerEleIndexFromStack] = nums[i];\\n        }\\n    }\\n\\n\\t//Finally, still there would be some elements for which there was no \\'next greater element\\'\\n\\t//In the case of nums = [1,4,2,1,2], 4 would be such an element. So we just go over the\\n\\t//remaining elements in the stack and assign -1 to them in ret array.\\n    const remaining = stack.length;\\n    for (let i = 0; i < remaining; i++) {\\n        ret[stack.pop()] = -1;\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449789,
                "title": "java-damn-easy-to-understand",
                "content": "**Time Complexity : O(n)**\\n**Space Complexity : O(n)**\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            stack.push(nums[i]);\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            int number=nums[i];\\n                while(!stack.isEmpty() && stack.peek()<=nums[i]){\\n                    stack.pop();\\n                }\\n           \\n            nums[i]=stack.empty()?-1:stack.peek();\\n            stack.push(number);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\\n\\n**Time Complexity : O(n)**\\n**Space Complexity : O(n)**\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            stack.push(nums[i]);\\n        }\\n        \\n        int greater[]=new int[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            while(!stack.isEmpty() && stack.peek()<=nums[i]){\\n                    stack.pop();\\n                }\\n            greater[i]=stack.empty()?-1:stack.peek();\\n            stack.push(nums[i]);\\n        }\\n        \\n        return greater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            stack.push(nums[i]);\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            int number=nums[i];\\n                while(!stack.isEmpty() && stack.peek()<=nums[i]){\\n                    stack.pop();\\n                }\\n           \\n            nums[i]=stack.empty()?-1:stack.peek();\\n            stack.push(number);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            stack.push(nums[i]);\\n        }\\n        \\n        int greater[]=new int[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            while(!stack.isEmpty() && stack.peek()<=nums[i]){\\n                    stack.pop();\\n                }\\n            greater[i]=stack.empty()?-1:stack.peek();\\n            stack.push(nums[i]);\\n        }\\n        \\n        return greater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590592,
                "title": "c-concise-o-n-time-solution-using-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=nums.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=nums.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile(!st.empty() && nums[i]>=st.top())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(st.top());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treverse(ans.begin(),ans.end());\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=nums.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 145374,
                "title": "python-beats-100",
                "content": "Use the stack to record the reversed array **nums**. Loop the array from last integer to the first one. If the last integer in stack is bigger than the current interger in array, we have found the answer. Otherwise, we need to keep pop up the integer in stack. Besides, we need to push the current integer to the stack in each step.\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack and stack[-1] <= nums[i]:\\n                stack.pop()\\n            if stack:\\n                ret[i] = stack[-1]\\n            stack.append(nums[i])\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack and stack[-1] <= nums[i]:\\n                stack.pop()\\n            if stack:\\n                ret[i] = stack[-1]\\n            stack.append(nums[i])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311398,
                "title": "c-solution-o-n-time-complexity-with-proper-explaination",
                "content": "**Time complexity - O(N)**\\n**Space complexity - O(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    //circular integer array -> when we consider first element as the next of the last element hence it\\'s circular \\n        \\n        vector<int> ans(nums.size(), -1); // to store the next greater element of every element and initialize it with -1 why ? because if there is no element in stack which is greater to the element we will return -1\\n        \\n        stack<int> s; //make a stack \\n        \\n        for(int i = 0; i < 2*nums.size()-1; i++) { //why ? 2*nums.size()-1 beacuse we assuming a joint imaginary array same as nums\\n            \\n            while(!s.empty() && nums[s.top()] < nums[i%nums.size()]) {\\n                //check  if the stack is not empty  and the check the top element of the stack if there is an element present which is smaller than i% nums.size\\n                ans[s.top()] = nums[i%nums.size()];\\n                s.pop();// pop the elements which are smaller \\n            }\\n            s.push(i%nums.size()); \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote and comment if have doubt**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    //circular integer array -> when we consider first element as the next of the last element hence it\\'s circular \\n        \\n        vector<int> ans(nums.size(), -1); // to store the next greater element of every element and initialize it with -1 why ? because if there is no element in stack which is greater to the element we will return -1\\n        \\n        stack<int> s; //make a stack \\n        \\n        for(int i = 0; i < 2*nums.size()-1; i++) { //why ? 2*nums.size()-1 beacuse we assuming a joint imaginary array same as nums\\n            \\n            while(!s.empty() && nums[s.top()] < nums[i%nums.size()]) {\\n                //check  if the stack is not empty  and the check the top element of the stack if there is an element present which is smaller than i% nums.size\\n                ans[s.top()] = nums[i%nums.size()];\\n                s.pop();// pop the elements which are smaller \\n            }\\n            s.push(i%nums.size()); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387062,
                "title": "c-python-java-javascript-using-stack-with-small-modification-in-next-greater-element-1",
                "content": "\\n# Intuition:\\nThe problem requires finding the next greater element for each element in the array, considering the array as a circular array. So, we need to compare the elements in the array in a circular manner, and for each element, we need to find the next greater element. One way to do this is to use a stack.\\n\\n# Approach:\\nWe start by initializing a stack and a vector to store the answer. We loop through the array from the end, twice the size of the array, to simulate a circular array. For each element, we compare it with the top element in the stack. If the top element in the stack is smaller than the current element, we pop it from the stack until the top element is greater than the current element or the stack becomes empty. If the stack is not empty, we store the top element as the next greater element for the current element, otherwise, we store -1. Finally, we push the current element into the stack.\\n\\n# Complexity:\\n- Time complexity: The time complexity of the solution is O(n) because we are traversing the array twice, and for each element, we are performing a constant number of operations, which is popping elements from the stack and comparing them with the current element.\\n\\n- Space complexity: The space complexity of the solution is O(n) because we are using a stack and a vector, each of size n, to store the intermediate results.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n);\\n        for(int i=n*2-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()){\\n                    ans[i]=st.top();\\n                }\\n                else{\\n                    ans[i]=-1;\\n                }\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack<>();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n        for(int i = n * 2 - 1; i >= 0; i--) {\\n            while(!st.isEmpty() && st.peek() <= nums[i % n]) {\\n                st.pop();\\n            }\\n            if(i < n) {\\n                ans[i] = st.isEmpty() ? -1 : st.peek();\\n            }\\n            st.push(nums[i % n]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        st = []\\n        ans = [-1] * n\\n        for i in xrange(n * 2 - 1, -1, -1):\\n            while st and st[-1] <= nums[i % n]:\\n                st.pop()\\n            if i < n:\\n                ans[i] = st[-1] if st else -1\\n            st.append(nums[i % n])\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction nextGreaterElements(nums) {\\n    const n = nums.length;\\n    const st = [];\\n    const ans = new Array(n).fill(-1);\\n    for(let i = n * 2 - 1; i >= 0; i--) {\\n        while(st.length && st[st.length - 1] <= nums[i % n]) {\\n            st.pop();\\n        }\\n        if(i < n) {\\n            ans[i] = st.length ? st[st.length - 1] : -1;\\n        }\\n        st.push(nums[i % n]);\\n    }\\n    return ans;   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n);\\n        for(int i=n*2-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()){\\n                    ans[i]=st.top();\\n                }\\n                else{\\n                    ans[i]=-1;\\n                }\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack<>();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n        for(int i = n * 2 - 1; i >= 0; i--) {\\n            while(!st.isEmpty() && st.peek() <= nums[i % n]) {\\n                st.pop();\\n            }\\n            if(i < n) {\\n                ans[i] = st.isEmpty() ? -1 : st.peek();\\n            }\\n            st.push(nums[i % n]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        st = []\\n        ans = [-1] * n\\n        for i in xrange(n * 2 - 1, -1, -1):\\n            while st and st[-1] <= nums[i % n]:\\n                st.pop()\\n            if i < n:\\n                ans[i] = st[-1] if st else -1\\n            st.append(nums[i % n])\\n        return ans\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction nextGreaterElements(nums) {\\n    const n = nums.length;\\n    const st = [];\\n    const ans = new Array(n).fill(-1);\\n    for(let i = n * 2 - 1; i >= 0; i--) {\\n        while(st.length && st[st.length - 1] <= nums[i % n]) {\\n            st.pop();\\n        }\\n        if(i < n) {\\n            ans[i] = st.length ? st[st.length - 1] : -1;\\n        }\\n        st.push(nums[i % n]);\\n    }\\n    return ans;   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98328,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/78268/python-solution-with-detailed-explanation\\n\\n**Next Greater Element II** https://leetcode.com/problems/next-greater-element-ii/\\n\\n**Algorithm**\\n* **Stack for next greater element**: Suppose we have a decreasing sequence followed by a greater number. For example [5, 4, 3, 2, 1, 6] then the greater number 6 is the next greater element for all previous numbers in the sequence.\\n*  **Handling duplicates in input**: Push the index and value tuple on the stack instead of just the value. This makes sure duplicated elements are correctly handled. Example:[100,1,11,1,120,111,123,1,-1,-100] - we need to have the right answer for both 1s.\\n*  **Handling circular array**: Process it twice. Example: [5,4,3,2,1]. By processing it twice, you are essentially doing: [5,4,3,2,1]+[5,4,3,2,1]. Typical pattern to solve circular array problems is to extend the original array to twice length, 2nd half has the same element as first half. Then everything become simple.\\nhttps://discuss.leetcode.com/topic/77881/typical-way-to-solve-circular-array-problems-java-solution\\n\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cache, st = {}, []\\n        for idx,x in enumerate(nums):\\n            while st and st[-1][1] < x:\\n                a,b = st.pop()\\n                cache[a] = x\\n            st.append((idx,x))\\n        for idx,x in enumerate(nums):\\n            while st and st[-1][1] < x:\\n                a,b = st.pop()\\n                cache[a] = x\\n            st.append((idx,x))\\n        result = [-1]*len(nums)\\n        for idx,x in enumerate(nums):\\n            if idx in cache:\\n                result[idx] = cache[idx]\\n        return result        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cache, st = {}, []\\n        for idx,x in enumerate(nums):\\n            while st and st[-1][1] < x:\\n                a,b = st.pop()\\n                cache[a] = x\\n            st.append((idx,x))\\n        for idx,x in enumerate(nums):\\n            while st and st[-1][1] < x:\\n                a,b = st.pop()\\n                cache[a] = x\\n            st.append((idx,x))\\n        result = [-1]*len(nums)\\n        for idx,x in enumerate(nums):\\n            if idx in cache:\\n                result[idx] = cache[idx]\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 822807,
                "title": "simple-cpp-stack-solution-95-similar-to-next-greater-element-i",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>s;\\n        vector<int>ans;\\n        for(int i=nums.size()-1;i>=0;i--)\\n\\t\\t    s.push(nums[i]);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.size()==0)\\n                ans.push_back(-1);\\n            else if(s.size()>0&&s.top()>nums[i])\\n                ans.push_back(s.top());\\n            else if(s.size()>0&&s.top()<=nums[i])\\n            {\\n                while(s.size()>0&&s.top()<=nums[i])\\n                    s.pop();\\n                if(s.size()==0)\\n                    ans.push_back(-1);\\n                else\\n                    ans.push_back(s.top());\\n            }\\n            s.push(nums[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>s;\\n        vector<int>ans;\\n        for(int i=nums.size()-1;i>=0;i--)\\n\\t\\t    s.push(nums[i]);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.size()==0)\\n                ans.push_back(-1);\\n            else if(s.size()>0&&s.top()>nums[i])\\n                ans.push_back(s.top());\\n            else if(s.size()>0&&s.top()<=nums[i])\\n            {\\n                while(s.size()>0&&s.top()<=nums[i])\\n                    s.pop();\\n                if(s.size()==0)\\n                    ans.push_back(-1);\\n                else\\n                    ans.push_back(s.top());\\n            }\\n            s.push(nums[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540152,
                "title": "python-monotonic-stack-one-pass-clean-concise",
                "content": "**Idea**\\n- Exactly the same idea with **[496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/discuss/1533016)**.\\n- Here, we iterate from `[2n-1...0]` instead of from `[n-1..0]`, and to access value if `nums[i]` we access `nums[i % n]`.\\n```python\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        st = []\\n        n = len(nums)\\n        ans = [-1] * n\\n        for i in range(2*n-1, -1, -1):\\n            while st and st[-1] <= nums[i%n]:\\n                st.pop()\\n            if st and i < n:\\n                ans[i] = st[-1]\\n            st.append(nums[i%n])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        st = []\\n        n = len(nums)\\n        ans = [-1] * n\\n        for i in range(2*n-1, -1, -1):\\n            while st and st[-1] <= nums[i%n]:\\n                st.pop()\\n            if st and i < n:\\n                ans[i] = st[-1]\\n            st.append(nums[i%n])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501587,
                "title": "python-solution-explained",
                "content": "```\\n\\'\\'\\'\\nThe idea here is to store the indexes of the elements that we haven\\'t seen a greater than value for them yet\\nwe do this because if you stored the values you wouldn\\'t be able to easily know where a value is at so you\\ncan set it accordingly. This comes in handy in the second loop.\\n\\nThe values in the stack when we enter the second loop will always be decending, this is an important part of knowing that \\nwe are setting the indexes to their correct value. Since we always will set the index\\'s left in the stack to the smallest\\nnumber when reiterating over the stack, ensuring a correct answer. \\n\\'\\'\\'\\n\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        stack = []\\n        result = [-1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] < nums[i]:\\n                result[stack.pop()] = nums[i]\\n            stack.append(i)\\n\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] < nums[i]:\\n                result[stack.pop()] = nums[i]\\n                \\n        return result\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nThe idea here is to store the indexes of the elements that we haven\\'t seen a greater than value for them yet\\nwe do this because if you stored the values you wouldn\\'t be able to easily know where a value is at so you\\ncan set it accordingly. This comes in handy in the second loop.\\n\\nThe values in the stack when we enter the second loop will always be decending, this is an important part of knowing that \\nwe are setting the indexes to their correct value. Since we always will set the index\\'s left in the stack to the smallest\\nnumber when reiterating over the stack, ensuring a correct answer. \\n\\'\\'\\'\\n\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        stack = []\\n        result = [-1] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] < nums[i]:\\n                result[stack.pop()] = nums[i]\\n            stack.append(i)\\n\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] < nums[i]:\\n                result[stack.pop()] = nums[i]\\n                \\n        return result\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98264,
                "title": "no-stack-o-n-time-complexity-and-o-1-space-complexity-using-dp",
                "content": "The idea is to use the array to be returned to store information rather than an extra Stack. We use the array called result to store index of next larger element and replace with actual values before returning it. In first iteration, we move from right to left and find next greater element assuming array to be non-cyclical. Then we do another iteration from right to left. This time, we assume array is cyclical and find next larger element for the elements that do not have next larger element if array is not cyclical. \\n```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n\\n        //Case when array is empty\\n        if(nums.length == 0) return nums;\\n      \\n        int[] result = new int[nums.length];\\n\\n        //Assuming array to be non-cyclical, last element does not have next larger element\\n        result[nums.length - 1] = -1;\\n\\n        //Case when only one element is there in array     \\n        if(result.length == 1) return result;\\n\\n        for (int i = nums.length - 2; i >= 0; i--){   \\n            //Starting from next element\\n            int k = i + 1;\\n\\n            //Keep tracking next larger element until you find it or you find element with no next larger element\\n            while(nums[i] >= nums[k] && result[k] != -1){\\n                k = result[k];\\n            }\\n            \\n            //If next larger element is found, store index      \\n            if(nums[k] > nums[i]) result[i] = k;\\n            //If not found, it doesn't have next larger element\\n            else result[i] = -1;\\n        }\\n        \\n        //Second iteration assuming cyclical array, last element can also have next larger element\\n        for (int i = nums.length - 1; i >= 0; i--){   \\n\\n            //If next larger element assuming non-cyclical array already exists, continue\\n            if(result[i] != -1) continue;\\n      \\n            //Case when i + 1 is greater than length of array: when on last element\\n            int k = (i + 1) % nums.length;\\n\\n            //Keep tracking next larger element until you find it or you find element with no next larger element\\n            while(nums[i] >= nums[k] && result[k] != -1){\\n                k = result[k];\\n            }\\n\\n            //If next larger element is found, store it's index\\n            if(nums[k] > nums[i]) result[i] = k;\\n            //If not found, it doesn't have next larger element\\n            else result[i] = -1;\\n        }\\n\\n        //Replace indices with actual values\\n        for(int i = 0; i < nums.length; i++){\\n            if(result[i] != -1) result[i] = nums[result[i]];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n\\n        //Case when array is empty\\n        if(nums.length == 0) return nums;\\n      \\n        int[] result = new int[nums.length];\\n\\n        //Assuming array to be non-cyclical, last element does not have next larger element\\n        result[nums.length - 1] = -1;\\n\\n        //Case when only one element is there in array     \\n        if(result.length == 1) return result;\\n\\n        for (int i = nums.length - 2; i >= 0; i--){   \\n            //Starting from next element\\n            int k = i + 1;\\n\\n            //Keep tracking next larger element until you find it or you find element with no next larger element\\n            while(nums[i] >= nums[k] && result[k] != -1){\\n                k = result[k];\\n            }\\n            \\n            //If next larger element is found, store index      \\n            if(nums[k] > nums[i]) result[i] = k;\\n            //If not found, it doesn't have next larger element\\n            else result[i] = -1;\\n        }\\n        \\n        //Second iteration assuming cyclical array, last element can also have next larger element\\n        for (int i = nums.length - 1; i >= 0; i--){   \\n\\n            //If next larger element assuming non-cyclical array already exists, continue\\n            if(result[i] != -1) continue;\\n      \\n            //Case when i + 1 is greater than length of array: when on last element\\n            int k = (i + 1) % nums.length;\\n\\n            //Keep tracking next larger element until you find it or you find element with no next larger element\\n            while(nums[i] >= nums[k] && result[k] != -1){\\n                k = result[k];\\n            }\\n\\n            //If next larger element is found, store it's index\\n            if(nums[k] > nums[i]) result[i] = k;\\n            //If not found, it doesn't have next larger element\\n            else result[i] = -1;\\n        }\\n\\n        //Replace indices with actual values\\n        for(int i = 0; i < nums.length; i++){\\n            if(result[i] != -1) result[i] = nums[result[i]];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703473,
                "title": "python-simple-2-pass-solution-using-stack-99-faster",
                "content": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## Similar to leetcode 739. Daily Temperatures ##\\n        \\n        ## LOGIC ##\\n        ## 1. Monotone decreasing stack to find NGE (next greater element)\\n        ## 2. In the first loop, we fill NGE all possible.\\n        ## 3. In the second loop, there might be some elements left in the stack, so we iterate again (without appending to stack) and get NGE\\n        ## 4. The elements that are left in the stack even after second loop are max(nums).\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        stack, res = [], [-1] * len(nums)\\n        for i, num in enumerate(nums):              # 2\\n            while stack and nums[stack[-1]] < num:\\n                res[stack.pop()] = num\\n            stack.append(i)\\n        for i, num in enumerate(nums):              # 3\\n            while stack and nums[stack[-1]] < num:\\n                res[stack.pop()] = num\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## Similar to leetcode 739. Daily Temperatures ##\\n        \\n        ## LOGIC ##\\n        ## 1. Monotone decreasing stack to find NGE (next greater element)\\n        ## 2. In the first loop, we fill NGE all possible.\\n        ## 3. In the second loop, there might be some elements left in the stack, so we iterate again (without appending to stack) and get NGE\\n        ## 4. The elements that are left in the stack even after second loop are max(nums).\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        stack, res = [], [-1] * len(nums)\\n        for i, num in enumerate(nums):              # 2\\n            while stack and nums[stack[-1]] < num:\\n                res[stack.pop()] = num\\n            stack.append(i)\\n        for i, num in enumerate(nums):              # 3\\n            while stack and nums[stack[-1]] < num:\\n                res[stack.pop()] = num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804418,
                "title": "javascript-solution-beats-84-78-tc-o-n-sc-o-n",
                "content": "// -------------------------------- APPROACH -------------------------------- \\\\\\\\\\n    \\n Iterate from the last element :\\n1.     Check if there is any element lesser than current element in the satck \\n             a. If No lesser element found & the stack is empty, fill that index with -1.\\n\\t\\t\\t     Then Insert the curr element into the stack.\\n             b. If No lesser element found & the stack has greater element than current, fill that index with the stack\\'s top element. \\n\\t\\t\\t     push the curr element into the stack.\\n             c. If there is less element keep removing from the top of the stack until you find the next greater element.\\n\\t\\t\\t     Fill that index with stack\\'s top element and insert the current element into the stack \\n\\n            \\n2.     For traversing in circular fashion, Do i % n\\n    \\n  */\\n    \\n    TIME COMPLEXITY = O(2N) + O(2N) ~~ O(N)\\n    SPACE COMPLEXITY = O(N)\\n    \\n    \\n    // -------------------------------- STACK SOLUTION -------------------------------- \\\\\\\\\\n    \\n    var nextGreaterElements = function(nums) {\\n      let stack = [];\\n      let output = [];\\n    \\n     for(let i=2*(nums.length-1); i>=0; i--) {\\n        \\n        let Index = i % nums.length;\\n        while(stack.length > 0 && nums[Index] >= nums[stack[stack.length-1]]) {\\n           \\n            stack.pop();\\n        }\\n        \\n        if(stack.length === 0){\\n            output[Index] = -1;\\n        }else{\\n            output[Index] = nums[stack[stack.length-1]]\\n        }\\n        \\n        stack.push(Index);\\n     }\\n    \\n     return output;\\n\\t}",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "// -------------------------------- APPROACH -------------------------------- \\\\\\\\\\n    \\n Iterate from the last element :\\n1.     Check if there is any element lesser than current element in the satck \\n             a. If No lesser element found & the stack is empty, fill that index with -1.\\n\\t\\t\\t     Then Insert the curr element into the stack.\\n             b. If No lesser element found & the stack has greater element than current, fill that index with the stack\\'s top element. \\n\\t\\t\\t     push the curr element into the stack.\\n             c. If there is less element keep removing from the top of the stack until you find the next greater element.\\n\\t\\t\\t     Fill that index with stack\\'s top element and insert the current element into the stack \\n\\n            \\n2.     For traversing in circular fashion, Do i % n\\n    \\n  */\\n    \\n    TIME COMPLEXITY = O(2N) + O(2N) ~~ O(N)\\n    SPACE COMPLEXITY = O(N)\\n    \\n    \\n    // -------------------------------- STACK SOLUTION -------------------------------- \\\\\\\\\\n    \\n    var nextGreaterElements = function(nums) {\\n      let stack = [];\\n      let output = [];\\n    \\n     for(let i=2*(nums.length-1); i>=0; i--) {\\n        \\n        let Index = i % nums.length;\\n        while(stack.length > 0 && nums[Index] >= nums[stack[stack.length-1]]) {\\n           \\n            stack.pop();\\n        }\\n        \\n        if(stack.length === 0){\\n            output[Index] = -1;\\n        }else{\\n            output[Index] = nums[stack[stack.length-1]]\\n        }\\n        \\n        stack.push(Index);\\n     }\\n    \\n     return output;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1092257,
                "title": "c-most-easiest-solution-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        stack<int>s;\\n        for(int i=n-1;i>=0;i--) {\\n            s.push(nums[i]);\\n        }\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            while(!s.empty() && nums[i]>=s.top()) s.pop();\\n            if(s.empty()) ans[i]=-1;\\n            else ans[i]=s.top();\\n            s.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        stack<int>s;\\n        for(int i=n-1;i>=0;i--) {\\n            s.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2520585,
                "title": "python-stack-98-78-faster-simplest-solution-with-explanation-beg-to-adv-monotonic-stack",
                "content": "**Basic Idea:**\\n\\n1. We`ll loop once, in that way we get the Next Greater Number of a normal array.\\n2. We`ll Loop second time, then we will get the Next Greater Number of a circular array.\\n\\n**Optimised solution :**\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, res = [], [-1] * len(nums) # taking an empty stack for storing index, a list with the lenght same as of nums so that we wont add unnecessary elements.\\n        # [-1] * len(nums) = this will produce a list with len of nums and all elems will be -1.\\n        for i in list(range(len(nums))) * 2: # see explanation below.\\n            while stack and (nums[stack[-1]] < nums[i]): # stack is not empty and nums previous elem is less then current, i.e 1<2. \\n                res[stack.pop()] = nums[i] # then we`ll pop the index in stack and in the res on the same index will add the current num. \\n            stack.append(i) # if stack is empty then we`ll add the index of num in it for comparision to the next element in the provided list. \\n        return res # returing the next greater number for every element in nums.\\n```\\n\\n >**for i in list(range(len(nums))) * 2:**\\n > As we know the given array is circular integer array, so we have to run the for loop twice so that we could compare last elments of the list to the first elements. \\n > In python 3, just `for i in range(len(nums)) * 2` will thrown exception `TypeError: unsupported operand type(s) for *: \\'range\\' and \\'int\\'`, however if we put range inside it`ll work fine. Using list() is a little hack to make it work. \\n\\n**Expantion of the above solution :**\\n```python\\nstack, r = [], [-1] * len(nums)\\n        for i in range(len(nums)):\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                r[stack.pop()] = nums[i]\\n            stack.append(i)\\n        for i in range(len(nums)):\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                r[stack.pop()] = nums[i]\\n            if stack == []:\\n                break\\n        return r\\n```\\n\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, res = [], [-1] * len(nums) # taking an empty stack for storing index, a list with the lenght same as of nums so that we wont add unnecessary elements.\\n        # [-1] * len(nums) = this will produce a list with len of nums and all elems will be -1.\\n        for i in list(range(len(nums))) * 2: # see explanation below.\\n            while stack and (nums[stack[-1]] < nums[i]): # stack is not empty and nums previous elem is less then current, i.e 1<2. \\n                res[stack.pop()] = nums[i] # then we`ll pop the index in stack and in the res on the same index will add the current num. \\n            stack.append(i) # if stack is empty then we`ll add the index of num in it for comparision to the next element in the provided list. \\n        return res # returing the next greater number for every element in nums.\\n```\n```python\\nstack, r = [], [-1] * len(nums)\\n        for i in range(len(nums)):\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                r[stack.pop()] = nums[i]\\n            stack.append(i)\\n        for i in range(len(nums)):\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                r[stack.pop()] = nums[i]\\n            if stack == []:\\n                break\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138585,
                "title": "java-code-6ms-two-iterations-ngetr",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] arr) {\\n        int ngetr[] = new int[arr.length];\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n        //1st iteration\\n        for(int i = 1 ; i < arr.length ; i++){\\n            while(st.size() > 0 && arr[st.peek()] < arr[i])\\n            {  //this is the logic for NGETR\\n                ngetr[st.peek()] = arr[i];\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        //second iteration as array is cyclic\\n        for(int i = 0 ; i < arr.length ; i++){\\n            while(arr[st.peek()] < arr[i])\\n            {\\n                ngetr[st.peek()] = arr[i];\\n                st.pop();\\n            }\\n        }\\n        while(st.size() > 0){\\n            ngetr[st.peek()] = -1;\\n            st.pop();\\n        }\\n        return ngetr;\\n    }\\n\\t//NGETR => Next Greater Element to Right\\n}\\n```\\n***Plz Upvote If you like the solution***",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] arr) {\\n        int ngetr[] = new int[arr.length];\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n        //1st iteration\\n        for(int i = 1 ; i < arr.length ; i++){\\n            while(st.size() > 0 && arr[st.peek()] < arr[i])\\n            {  //this is the logic for NGETR\\n                ngetr[st.peek()] = arr[i];\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        //second iteration as array is cyclic\\n        for(int i = 0 ; i < arr.length ; i++){\\n            while(arr[st.peek()] < arr[i])\\n            {\\n                ngetr[st.peek()] = arr[i];\\n                st.pop();\\n            }\\n        }\\n        while(st.size() > 0){\\n            ngetr[st.peek()] = -1;\\n            st.pop();\\n        }\\n        return ngetr;\\n    }\\n\\t//NGETR => Next Greater Element to Right\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804636,
                "title": "c-solution-with-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<int> temp2(2*nums.size());\\n        for(int i=0; i<nums.size(); i++){\\n            temp.push_back(nums[i]);\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            temp.push_back(nums[i]);\\n        }\\n        stack<int> st;\\n        for(int i=temp.size()-1; i>=0; i--){\\n            int k=temp[i];\\n            while(!st.empty() && st.top()<=k){\\n                st.pop();\\n            }\\n            int nge;\\n            if(st.empty()){\\n                nge=-1;\\n            }\\n            else{\\n                nge=st.top();\\n            }\\n            temp2[i]=nge;\\n            st.push(k);\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            ans.push_back(temp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<int> temp2(2*nums.size());\\n        for(int i=0; i<nums.size(); i++){\\n            temp.push_back(nums[i]);\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            temp.push_back(nums[i]);\\n        }\\n        stack<int> st;\\n        for(int i=temp.size()-1; i>=0; i--){\\n            int k=temp[i];\\n            while(!st.empty() && st.top()<=k){\\n                st.pop();\\n            }\\n            int nge;\\n            if(st.empty()){\\n                nge=-1;\\n            }\\n            else{\\n                nge=st.top();\\n            }\\n            temp2[i]=nge;\\n            st.push(k);\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            ans.push_back(temp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736929,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int[] nextGreaterElements(int[] nums) {\\n     \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        int[] result = new int[nums.length];\\n        \\n        process(nums, result, stack, true);\\n                \\n        process(nums, result, stack, false);  \\n        \\n        while (!stack.isEmpty()) {\\n            \\n            result[stack.pop()] = -1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void process(int[] nums, int[] result, Stack<Integer> stack, boolean push) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n           while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {\\n                    \\n                result[stack.pop()] = nums[i];\\n            }\\n                \\n            if (push)\\n            stack.push(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] nextGreaterElements(int[] nums) {\\n     \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        int[] result = new int[nums.length];\\n        \\n        process(nums, result, stack, true);\\n                \\n        process(nums, result, stack, false);  \\n        \\n        while (!stack.isEmpty()) {\\n            \\n            result[stack.pop()] = -1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void process(int[] nums, int[] result, Stack<Integer> stack, boolean push) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n           while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {\\n                    \\n                result[stack.pop()] = nums[i];\\n            }\\n                \\n            if (push)\\n            stack.push(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097703,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n, -1);\\n        stack<int> st;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            while(!st.empty() && nums[i%n]>nums[st.top()%n])\\n            {\\n                ans[st.top()%n]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n, -1);\\n        stack<int> st;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            while(!st.empty() && nums[i%n]>nums[st.top()%n])\\n            {\\n                ans[st.top()%n]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095758,
                "title": "javascript-easy-stack-solution",
                "content": "```\\nvar nextGreaterElements = function(nums) {\\n    let n = nums.length;\\n    let stack =[];\\n    let result = new Array(n).fill(-1)\\n    for(let i=0; i<2*n;i++){\\n        while(stack.length && nums[i%n]>nums[stack[stack.length-1]]){\\n            result[stack.pop()]= nums[i%n]\\n        }\\n        stack.push(i%n)\\n    }\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar nextGreaterElements = function(nums) {\\n    let n = nums.length;\\n    let stack =[];\\n    let result = new Array(n).fill(-1)\\n    for(let i=0; i<2*n;i++){\\n        while(stack.length && nums[i%n]>nums[stack[stack.length-1]]){\\n            result[stack.pop()]= nums[i%n]\\n        }\\n        stack.push(i%n)\\n    }\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 472010,
                "title": "java-use-a-stack",
                "content": "More concise version:\\n```\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for (int cnt = 0; cnt < 2; cnt++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                while (!st.isEmpty() && nums[i] > nums[st.peek()]) res[st.pop()] = nums[i];\\n                if (cnt == 0) st.push(i);\\n            }\\n        }\\n        while (!st.isEmpty()) res[st.pop()] = -1;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for (int cnt = 0; cnt < 2; cnt++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                while (!st.isEmpty() && nums[i] > nums[st.peek()]) res[st.pop()] = nums[i];\\n                if (cnt == 0) st.push(i);\\n            }\\n        }\\n        while (!st.isEmpty()) res[st.pop()] = -1;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387267,
                "title": "simply-simple-python-solution-two-pass-o-n-stack",
                "content": "\\tdef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ln = len(nums)\\n        if ln == 0:\\n            return []\\n        stack = []\\n        res = [-1] * ln\\n        # Run it twice. After first iteration\\n        # the stack has the increasing order of elements from starting\\n        # so in second iteration you will get the next greater from stack\\n        # which was on the left side of that node\\n        for _ in range(2):\\n            for i in range(ln - 1, -1, -1):\\n                while len(stack) > 0 and stack[-1] <= nums[i]:\\n                    stack.pop()\\n                if len(stack) > 0:\\n                    res[i] = stack[-1]\\n                    \\n                stack.append(nums[i])\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ln = len(nums)\\n        if ln == 0:\\n            return []\\n        stack = []\\n        res = [-1] * ln\\n        # Run it twice. After first iteration\\n        # the stack has the increasing order of elements from starting\\n        # so in second iteration you will get the next greater from stack\\n        # which was on the left side of that node\\n        for _ in range(2):\\n            for i in range(ln - 1, -1, -1):\\n                while len(stack) > 0 and stack[-1] <= nums[i]:\\n                    stack.pop()\\n                if len(stack) > 0:\\n                    res[i] = stack[-1]\\n                    \\n                stack.append(nums[i])\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 280741,
                "title": "most-general-code-using-stack-without-trick-and-4-th-variant-i-met-on-my-oa",
                "content": "**Algorithm**:\\n**Mono Stack** as you know\\n\\n---\\nFinal code:\\n\\n```java\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        // corner case\\n        if(nums == null) return null;\\n        \\n        int n = nums.length;\\n        int[] res = new int[n];\\n                \\n        Deque<Integer> stack = new ArrayDeque<>(); // to store idx\\n        for(int i = 0; i < 2 * n; i++){       \\n            int num = nums[i % n];\\n            while(!stack.isEmpty() && num > nums[stack.peekFirst()]){\\n                int idx = stack.pollFirst();\\n                res[idx] = num;\\n            }\\n            \\n            if(i < n) stack.offerFirst(i);\\n        }\\n        \\n        // set the max\\'s greater element to be -1\\n        while(!stack.isEmpty()){\\n            int idx = stack.pollFirst();\\n            res[idx] = -1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n---\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)` \\n- If the array is sorted in descending order like `[5, 4, 3, 2, 1]` or \\n- All the elements in the array are the same like `[5, 5, 5, 5, 5]`\\n\\n---\\n**What\\'s the trick of other OP?**\\n\\n```java\\n public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length, next[] = new int[n];\\n        Arrays.fill(next, -1); // difference!!!\\n        Stack<Integer> stack = new Stack<>(); // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!stack.isEmpty() && nums[stack.peek()] < num)\\n                next[stack.pop()] = num;\\n            if (i < n) stack.push(i);\\n        }   \\n\\t\\t\\n\\t\\t// no polling all nodes in stack and set max\\'s greater element to be -1\\n\\t\\t// because of the difference!!!\\n\\t\\t\\n        return next;\\n    }\\n```\\n**One trick hidden** if you notice: `Arrays.fill(res, -1);`, have you wondered why we initalize the `res` to `-1` here ?\\n**Guess**: according to the definition? \\nNope, `-1` means there is no greater number exists, i.e. currrent number is the max number, but initially we just don\\'t know if there is a greater number, doesn\\'t mean that there is no one.\\n**Reason** is that it can help us **save extra operations** to set the greater element of the max number to be `-1`!  As we know, at last there **are** only indices of the max number in the stack. For example: `[1, 5, 3, 5, 4]`, at last the stack will be: `[2, 3]` which is the indices of number `5`. If we initialize them to be `-1`, nothing we need to take care of. \\n**Question**: can we do without it?\\nYes, we just need to pop all the elements in stack, and set corresponding greater value in `res[]` to be `-1`. It leads to the code below:\\n**Compare**: which is better?\\nHonestly, I like my own. Since I now have a clear picture of what the whole process is like especially at the end.\\n\\n---\\n**How to deal with circular array? 3 variations to deal with circular array**:\\n1. we can scan the array twice using 2 for loop, but will cause redundancy code\\n2. we can expand the original array, but can be simplified by method 3\\n3. we can simulate expanding the original array like the author\\'s code\\n\\n---\\nNote: we push elements to stack in the 1st round, but only pop elements in the 2nd round!!!\\n\\n---\\n**Variant**\\n**Closest greater element**\\nlike the name, find the the greater element which is most cloest to it, if have 2 elements having same distance to an element, choose the greater element with the smallest index. For example: `[4, 2 ,1, 3]`, return `[-1, 4, 2, 4]`.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        // corner case\\n        if(nums == null) return null;\\n        \\n        int n = nums.length;\\n        int[] res = new int[n];\\n                \\n        Deque<Integer> stack = new ArrayDeque<>(); // to store idx\\n        for(int i = 0; i < 2 * n; i++){       \\n            int num = nums[i % n];\\n            while(!stack.isEmpty() && num > nums[stack.peekFirst()]){\\n                int idx = stack.pollFirst();\\n                res[idx] = num;\\n            }\\n            \\n            if(i < n) stack.offerFirst(i);\\n        }\\n        \\n        // set the max\\'s greater element to be -1\\n        while(!stack.isEmpty()){\\n            int idx = stack.pollFirst();\\n            res[idx] = -1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```java\\n public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length, next[] = new int[n];\\n        Arrays.fill(next, -1); // difference!!!\\n        Stack<Integer> stack = new Stack<>(); // index stack\\n        for (int i = 0; i < n * 2; i++) {\\n            int num = nums[i % n]; \\n            while (!stack.isEmpty() && nums[stack.peek()] < num)\\n                next[stack.pop()] = num;\\n            if (i < n) stack.push(i);\\n        }   \\n\\t\\t\\n\\t\\t// no polling all nodes in stack and set max\\'s greater element to be -1\\n\\t\\t// because of the difference!!!\\n\\t\\t\\n        return next;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160320,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        for (int i = 0; i < n; i++) {\\n            int NGE = -1;\\n            for (int j = 1; j < n; j++) {\\n                int k = (i + j) % n;\\n                if (nums[k] > nums[i]) {\\n                    NGE = nums[k];\\n                    break;\\n                }\\n            }\\n            ans.push_back(NGE);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing Stack\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        stack <int> s;\\n        for (int i = 2 * n - 1; i >= 0; i--) {\\n            while (s.empty() == false && s.top() <= nums[i % n])\\n                s.pop();\\n            if (i < n) {\\n                int NGE = s.empty() ? -1 : s.top();\\n                ans.push_back(NGE);\\n            }    \\n            s.push(nums[i % n]);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        for (int i = 0; i < n; i++) {\\n            int NGE = -1;\\n            for (int j = 1; j < n; j++) {\\n                int k = (i + j) % n;\\n                if (nums[k] > nums[i]) {\\n                    NGE = nums[k];\\n                    break;\\n                }\\n            }\\n            ans.push_back(NGE);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        stack <int> s;\\n        for (int i = 2 * n - 1; i >= 0; i--) {\\n            while (s.empty() == false && s.top() <= nums[i % n])\\n                s.pop();\\n            if (i < n) {\\n                int NGE = s.empty() ? -1 : s.top();\\n                ans.push_back(NGE);\\n            }    \\n            s.push(nums[i % n]);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749896,
                "title": "explanation-of-the-high-rated-solution",
                "content": "Try to explain [Ya Chen Chang](https://leetcode.com/problems/next-greater-element-ii/discuss/145374/Python-beats-100http://)\\'s solution. It\\'s concise and elegant but I could get the main idea at the first glance. I hope this could help to make it clear that how it works.\\n\\nThe code:\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack and stack[-1] <= nums[i]:\\n                stack.pop()\\n            if stack:\\n                ret[i] = stack[-1]\\n            stack.append(nums[i])\\n        return ret\\n```\\n\\nFirst ignore that it\\'s a circular array. Then the code is almost the same except that stack should be initisalized as an emplty stack:\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack1 = []\\n        # stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack1 and stack1[-1] <= nums[i]:\\n                stack1.pop()\\n            if stack1:\\n                ret[i] = stack1[-1]\\n            stack1.append(nums[i])\\n        return ret\\n```\\nThen consider the circular condition. When stack1 is empty, we still could try to find the next greater element from the begining of the array. The code is like this:\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):       \\n        n = len(nums)\\n        ret = [-1] * n\\n        stack1 = []\\n        stack2 = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack1 and stack1[-1] <= nums[i]:\\n                stack1.pop()\\n            if stack1:\\n                ret[i] = stack1[-1]\\n            else:\\n                while stack2 and stack2[-1] <= nums[i]:\\n                    stack2.pop()\\n                if stack2:\\n                    ret[i] = stack2[-1]                \\n            stack1.append(nums[i])\\n        return ret\\n```\\nBut there\\'s no need to distinguish stack1 and stack2, so the original code follows.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack and stack[-1] <= nums[i]:\\n                stack.pop()\\n            if stack:\\n                ret[i] = stack[-1]\\n            stack.append(nums[i])\\n        return ret\\n```\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        ret = [-1] * n\\n        stack1 = []\\n        # stack = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack1 and stack1[-1] <= nums[i]:\\n                stack1.pop()\\n            if stack1:\\n                ret[i] = stack1[-1]\\n            stack1.append(nums[i])\\n        return ret\\n```\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):       \\n        n = len(nums)\\n        ret = [-1] * n\\n        stack1 = []\\n        stack2 = nums[::-1]\\n        for i in range(n - 1, -1, -1):\\n            while stack1 and stack1[-1] <= nums[i]:\\n                stack1.pop()\\n            if stack1:\\n                ret[i] = stack1[-1]\\n            else:\\n                while stack2 and stack2[-1] <= nums[i]:\\n                    stack2.pop()\\n                if stack2:\\n                    ret[i] = stack2[-1]                \\n            stack1.append(nums[i])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832670,
                "title": "easy-stack-solution",
                "content": "\\n# Approach\\nApproach:\\n\\nThis problem can be solved easily and efficiently by using the stack data structure as it is based on the Last in First out (LIFO) principle.\\n\\nTo make it a bit easier let\\u2019s first try to solve without considering the array as circular. To find the next greater element we start traversing the given array from the right. As for the rightmost element, there is no other element at its right. Hence, we assign -1 at its index in the resultant array. Since this can be the next greater element (NGE) for some other element, we push it in the stack S. We keep checking for other elements. Let\\u2019s say we are checking for an element at index i. We keep popping from the stack until the element at the top of the stack is smaller than A[i]. The main intuition behind popping them is that these elements can never be the NGE for any element present at the left of A[i] because A[i] is greater than these elements. Now, if the top element of S is greater than A[i] then this is NGE of A[i] and we will assign it to res[i], where res is the resultant array. If the stack becomes empty then it implies that no element at the right of A[i] is greater than it and we assign -1. At last, we push A[i] in S.\\n\\nDry run: Let\\u2019s apply this algorithm for A[] = {5,7,1,2,6,0}:\\n\\n\\n\\nSo, the resultant array is {7,-1,2,6,-1,-1}. Remember that we have considered the array to be non-circular. For a circular array, the resultant array should be {7,-1,2,6,7,5}. \\n\\nNow we need to make this algorithm work for a circular array. The only difference between a circular and non-circular array is that while searching for the next greater element in a non-circular array we don\\u2019t consider the elements left to the concerned element. This can be easily done by inserting the elements of the array A at the end of A, thus making its size double. But we actually don\\u2019t require any extra space. We can just traverse the array twice. We actually run a loop 2*N times, where N is the size of the given array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(2N+2N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    stack<int>st;\\n    int n = nums.size();\\n    vector<int>ans(n,-1);\\n    for (int i = 2 * n - 1; i >= 0; i--)\\n    {\\n        while(!st.empty() && st.top() <= nums[i % n])\\n        {\\n            st.pop();\\n        }\\n        if(i<n)\\n        {\\n            if(!st.empty())\\n            {\\n                ans[i]=st.top();\\n            }\\n         \\n        }\\n                st.push(nums[i%n]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    stack<int>st;\\n    int n = nums.size();\\n    vector<int>ans(n,-1);\\n    for (int i = 2 * n - 1; i >= 0; i--)\\n    {\\n        while(!st.empty() && st.top() <= nums[i % n])\\n        {\\n            st.pop();\\n        }\\n        if(i<n)\\n        {\\n            if(!st.empty())\\n            {\\n                ans[i]=st.top();\\n            }\\n         \\n        }\\n                st.push(nums[i%n]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467325,
                "title": "java-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/7b4f2f22-6f9b-40cb-b7ab-d1a4cb42459d_1682789828.16653.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        int n = nums.length;\\n        Stack<Integer> st = new Stack<>(); // create a stack to store indices of elements\\n\\n        // first loop to find the next greater element for each element in nums (except the last one)\\n        for(int i = n-2; i >= 0; i--){\\n\\n            // while the stack is not empty and the top element is smaller than or equal to the current element in nums\\n            while(st.size() > 0 && st.peek() <= nums[i]){\\n                st.pop(); // remove the top element from stack\\n            }\\n            st.push(nums[i]); // push the current element in nums into stack\\n        }\\n\\n        int ans[] = new int[nums.length];\\n\\n        // second loop to find the next greater element for the remaining elements (including the last one)\\n        for(int i = n-1; i >= 0; i--){\\n\\n            // while the stack is not empty and the top element is smaller than or equal to the current element in nums\\n            while(st.size() > 0 && nums[i] >= st.peek()){\\n                st.pop(); // remove the top element from stack\\n            }\\n            \\n            if(st.size() == 0){\\n                ans[i] = -1; // if stack is empty, set the answer to -1 (no next greater element found)\\n            }else{\\n                ans[i] = st.peek(); // otherwise, set the answer to the top element of the stack\\n            }\\n\\n            st.push(nums[i]); // push the current element in nums into stack\\n        }\\n        return ans; // return the answer array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        int n = nums.length;\\n        Stack<Integer> st = new Stack<>(); // create a stack to store indices of elements\\n\\n        // first loop to find the next greater element for each element in nums (except the last one)\\n        for(int i = n-2; i >= 0; i--){\\n\\n            // while the stack is not empty and the top element is smaller than or equal to the current element in nums\\n            while(st.size() > 0 && st.peek() <= nums[i]){\\n                st.pop(); // remove the top element from stack\\n            }\\n            st.push(nums[i]); // push the current element in nums into stack\\n        }\\n\\n        int ans[] = new int[nums.length];\\n\\n        // second loop to find the next greater element for the remaining elements (including the last one)\\n        for(int i = n-1; i >= 0; i--){\\n\\n            // while the stack is not empty and the top element is smaller than or equal to the current element in nums\\n            while(st.size() > 0 && nums[i] >= st.peek()){\\n                st.pop(); // remove the top element from stack\\n            }\\n            \\n            if(st.size() == 0){\\n                ans[i] = -1; // if stack is empty, set the answer to -1 (no next greater element found)\\n            }else{\\n                ans[i] = st.peek(); // otherwise, set the answer to the top element of the stack\\n            }\\n\\n            st.push(nums[i]); // push the current element in nums into stack\\n        }\\n        return ans; // return the answer array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286577,
                "title": "503-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a stack to keep track of indices of elements we haven\\'t found a next greater element for.\\n\\n2. Initialize the result list to contain all -1s (assuming we won\\'t find any next greater element).\\n\\n3. Loop through the array twice (to handle circularity) and process each element:\\na. For each element i in the array:\\ni. Pop elements off the stack if they are less than the current element and update their result to the current element.\\nii. Add the current index i to the stack.\\n\\n4. Return the result list.\\n\\nThis algorithm works because it processes each element in the array twice, allowing it to handle circularity. During the first pass, it looks for next greater elements to the right of each element. During the second pass, it looks for next greater elements to the left of each element that haven\\'t been found yet. By using a stack to keep track of indices of elements we haven\\'t found a next greater element for, we can easily update their results when we find a greater element.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        # Initialize a stack to keep track of indices of elements we haven\\'t found a next greater element for\\n        stack = []\\n        \\n        # Initialize the result list to contain all -1s (assuming we won\\'t find any next greater element)\\n        result = [-1] * len(nums)\\n        \\n        # Loop through the array twice (to handle circularity) and process each element\\n        for _ in range(2):\\n            for i in range(len(nums)):\\n                # Pop elements off the stack if they are less than the current element and update their result\\n                while stack and nums[stack[-1]] < nums[i]:\\n                    result[stack.pop()] = nums[i]\\n                \\n                # Add the current index to the stack\\n                stack.append(i)\\n        \\n        # Return the result list\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        # Initialize a stack to keep track of indices of elements we haven\\'t found a next greater element for\\n        stack = []\\n        \\n        # Initialize the result list to contain all -1s (assuming we won\\'t find any next greater element)\\n        result = [-1] * len(nums)\\n        \\n        # Loop through the array twice (to handle circularity) and process each element\\n        for _ in range(2):\\n            for i in range(len(nums)):\\n                # Pop elements off the stack if they are less than the current element and update their result\\n                while stack and nums[stack[-1]] < nums[i]:\\n                    result[stack.pop()] = nums[i]\\n                \\n                # Add the current index to the stack\\n                stack.append(i)\\n        \\n        # Return the result list\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667737,
                "title": "c-2-stacks-and-1-stack-approach-98-faster-linear-time",
                "content": "[**503. Next Greater Element II**](https://leetcode.com/problems/next-greater-element-ii/)\\n\\n**1. Using Two Stacks :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(2*n)`**\\n\\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st1, st2;\\n        for(int i=nums.size()-1; i>=0; i--)st1.push(nums[i]);\\n        vector<int>ans(nums.size(), -1);\\n        for(int i=nums.size()-1; i>=0; i--){\\n            bool flag=false;\\n            while(!st2.empty()){\\n                if(st2.top()>nums[i]){\\n                    ans[i]=st2.top();\\n                    flag=true;\\n                    break;\\n                }\\n                st2.pop();\\n            }\\n            while(!flag and !st1.empty()){\\n                if(st1.top()>nums[i]){\\n                    ans[i]=st1.top();\\n                    flag=true;\\n                    break;\\n                }\\n                st1.pop();\\n            }\\n            st2.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n```\\n**2. Using One Stack :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(n)`**\\n\\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        vector<int>ans(n, -1);\\n        for(int i=0; i<2*n-1; i++){\\n            while(!st.empty() and nums[st.top()]<nums[i%n]){\\n                ans[st.top()]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return ans;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n![image](https://assets.leetcode.com/users/images/72ce6908-d90b-4027-a43e-d942c1f5f8c6_1665044202.957393.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st1, st2;\\n        for(int i=nums.size()-1; i>=0; i--)st1.push(nums[i]);\\n        vector<int>ans(nums.size(), -1);\\n        for(int i=nums.size()-1; i>=0; i--){\\n            bool flag=false;\\n            while(!st2.empty()){\\n                if(st2.top()>nums[i]){\\n                    ans[i]=st2.top();\\n                    flag=true;\\n                    break;\\n                }\\n                st2.pop();\\n            }\\n            while(!flag and !st1.empty()){\\n                if(st1.top()>nums[i]){\\n                    ans[i]=st1.top();\\n                    flag=true;\\n                    break;\\n                }\\n                st1.pop();\\n            }\\n            st2.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n```\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        vector<int>ans(n, -1);\\n        for(int i=0; i<2*n-1; i++){\\n            while(!st.empty() and nums[st.top()]<nums[i%n]){\\n                ans[st.top()]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return ans;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003709,
                "title": "next-greater-element-ii-c-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n    vector<int> nextGreaterElements(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> v(n);\\n        for (int i = 2 * n - 1; i >= 0; i--)\\n        {\\n\\n            while (!st.empty() && st.top() <= nums[i % n])\\n            {\\n                st.pop();\\n            }\\n            if (st.empty())\\n                v[i % n] = -1;\\n            else\\n                v[i % n] = st.top();\\n            st.push(nums[i % n]);\\n        }\\n\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution\\n{\\npublic:\\n    vector<int> nextGreaterElements(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> v(n);\\n        for (int i = 2 * n - 1; i >= 0; i--)\\n        {\\n\\n            while (!st.empty() && st.top() <= nums[i % n])\\n            {\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1460967,
                "title": "c-different-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int> &nums)\\n{\\n    stack<int> s;\\n    int idx = 0;\\n    int max = nums[0];\\n    for (int i = 0; i < nums.size(); i++) // Finding the maximum element in the array\\n        if (nums[i] > max)\\n        {\\n            max = nums[i];\\n            idx = i;\\n        }\\n\\n    vector<int> greater(nums.size());\\n    greater[idx] = -1;\\n    s.push(nums[idx]);\\n\\n// Finding the next greater element from the starting till the maximum element with normal apprach\\n    for (int i = idx - 1; i >= 0; i--) \\n    {\\n        while (s.size() > 0 && nums[i] >= s.top()) s.pop();\\n        greater[i] = s.size() == 0 ? -1 : s.top();\\n        s.push(nums[i]);\\n    }\\n\\n// Now we already have the previous elements from the maximum element in the stack \\n// and we will find the next greater element for remaining elements using same stack with normal approach\\n    for (int i = nums.size() - 1; i > idx; i--)\\n    {\\n        while (s.size() > 0 && nums[i] >= s.top()) s.pop();\\n        greater[i] = s.size() == 0 ? -1 : s.top();\\n        s.push(nums[i]);\\n    }\\n    return greater;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int> &nums)\\n{\\n    stack<int> s;\\n    int idx = 0;\\n    int max = nums[0];\\n    for (int i = 0; i < nums.size(); i++) // Finding the maximum element in the array\\n        if (nums[i] > max)\\n        {\\n            max = nums[i];\\n            idx = i;\\n        }\\n\\n    vector<int> greater(nums.size());\\n    greater[idx] = -1;\\n    s.push(nums[idx]);\\n\\n// Finding the next greater element from the starting till the maximum element with normal apprach\\n    for (int i = idx - 1; i >= 0; i--) \\n    {\\n        while (s.size() > 0 && nums[i] >= s.top()) s.pop();\\n        greater[i] = s.size() == 0 ? -1 : s.top();\\n        s.push(nums[i]);\\n    }\\n\\n// Now we already have the previous elements from the maximum element in the stack \\n// and we will find the next greater element for remaining elements using same stack with normal approach\\n    for (int i = nums.size() - 1; i > idx; i--)\\n    {\\n        while (s.size() > 0 && nums[i] >= s.top()) s.pop();\\n        greater[i] = s.size() == 0 ? -1 : s.top();\\n        s.push(nums[i]);\\n    }\\n    return greater;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296168,
                "title": "python-time-space-o-n-new-interesting-solution-using-hashmap-w-thought-process-explanation",
                "content": "I came with a solution that is a good candidate to be considered as a new approach. At least it would definitely help train our mind to think of data structures in ingenious ways at least for practice and training. So here goes.\\n\\nMy thought process started with finding the largest element (if many, then the last such element) and its index (assume max_el_idx), because from then I can start setting the next greater element for all by iterating to the left starting with max_el_idx - 1. So for max_el_idx will have the max_val as the greater element w/o doubt. Then for any new element the options are the prev_element or any one of the prev_elements\\' greater elements. For example, [.... 10, 7, 9, 11....] subarray, when 10 is reached while iterating to the left, these are the answers 7 -> 9,  9 -> 11 , 11-> NA ... So for 10 , the prev element 7 is lesser so we go through the links of 7 to see where 10 would find its greater element and it will be in 9-> 11. And we will not be going through this link again (i.e. 7 to 11 ) because the subsequent numbers if they are smaller will have 10 as answer, if not then we go to the greater element of 10 and then keep linking up from there. And overall we will not be having more than O(n) ops for the linking checks as well. So we can find the greater element for entire array in O(n) itself.\\n ```\\n[.... 12, 10 -> 7 -> 9 -> 11....]\\n       |--->|-------->------^ (proceeds to search after 11)\\n```\\n\\nNote: I know that if we break it down into fundamentals then it might have a resemblance to the stack strategy, but the thought process I think is a bit different.\\n\\nLet me know what you think..\\n```\\ndef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n    max_el_idx = max_val = -2<<31\\n    for i, val in enumerate(nums):\\n        if val >= max_val:\\n            max_el_idx = i; max_val = val\\n    ite = max_el_idx-1; prev_el = max_val\\n    res =[-1 for i in range(len(nums))]\\n    hm={}\\n    while len(nums) + ite != max_el_idx:\\n        if nums[ite] != max_val:\\n            if nums[ite] < prev_el:\\n                hm[nums[ite]] = res[ite] = prev_el\\n            else:\\n                while prev_el<=nums[ite]:\\n                    prev_el = hm[prev_el]\\n                hm[nums[ite]] = res[ite] = prev_el\\n        prev_el = nums[ite]\\n        ite-=1\\n    return res\\n```\\nI have used hashmap to store the greater element for the prev element and that is used to chain through till the greatest element to find out where the greater element for the current element stands.\\nTime complexity - O(n)\\nSpace complexity - O(n) for the hashmap",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[.... 12, 10 -> 7 -> 9 -> 11....]\\n       |--->|-------->------^ (proceeds to search after 11)\\n```\n```\\ndef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n    max_el_idx = max_val = -2<<31\\n    for i, val in enumerate(nums):\\n        if val >= max_val:\\n            max_el_idx = i; max_val = val\\n    ite = max_el_idx-1; prev_el = max_val\\n    res =[-1 for i in range(len(nums))]\\n    hm={}\\n    while len(nums) + ite != max_el_idx:\\n        if nums[ite] != max_val:\\n            if nums[ite] < prev_el:\\n                hm[nums[ite]] = res[ite] = prev_el\\n            else:\\n                while prev_el<=nums[ite]:\\n                    prev_el = hm[prev_el]\\n                hm[nums[ite]] = res[ite] = prev_el\\n        prev_el = nums[ite]\\n        ite-=1\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1279639,
                "title": "python-easy-solution-beats-99-43-using-stack-operation",
                "content": "```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n\\n        n=len(nums)\\n        stack= []\\n\\t\\tnext_g=[-1] * n\\n        \\n        \\n        for i in range(n):\\n            \\n            while stack and (nums[stack[-1]] < nums[i]):\\n                \\n                next_g[stack.pop()] = nums[i]\\n            \\n                \\n            stack.append(i)\\n        \\n        \\n        for i in range(n):\\n            \\n            while stack and (nums[stack[-1]] < nums[i]):\\n                \\n                next_g[stack.pop()] = nums[i]\\n                \\n            if stack == []:\\n                \\n                break\\n        \\n        return next_g\\n```\\n\\n**if you like do upvote !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n\\n        n=len(nums)\\n        stack= []\\n\\t\\tnext_g=[-1] * n\\n        \\n        \\n        for i in range(n):\\n            \\n            while stack and (nums[stack[-1]] < nums[i]):\\n                \\n                next_g[stack.pop()] = nums[i]\\n            \\n                \\n            stack.append(i)\\n        \\n        \\n        for i in range(n):\\n            \\n            while stack and (nums[stack[-1]] < nums[i]):\\n                \\n                next_g[stack.pop()] = nums[i]\\n                \\n            if stack == []:\\n                \\n                break\\n        \\n        return next_g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893345,
                "title": "java-basic-easy-to-understand-o-n-stack-solution",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=n-1;i>=0;i--)\\n            stack.push(nums[i]);\\n        for(int i=n-1;i>=0;i--){\\n            while(!stack.empty() && stack.peek()<=nums[i])\\n                stack.pop();\\n\\n            if(stack.empty())\\n                result[i] = -1;\\n            else\\n                result[i] = stack.peek();\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\\nif  u like it please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=n-1;i>=0;i--)\\n            stack.push(nums[i]);\\n        for(int i=n-1;i>=0;i--){\\n            while(!stack.empty() && stack.peek()<=nums[i])\\n                stack.pop();\\n\\n            if(stack.empty())\\n                result[i] = -1;\\n            else\\n                result[i] = stack.peek();\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439684,
                "title": "python-stack",
                "content": "```\\ndef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        size = len(nums)\\n        nums+=nums\\n        res = [-1] * size\\n        stack = []\\n        for i in list(range(size))*2:\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                res[stack.pop()] = nums[i]\\n            stack.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        size = len(nums)\\n        nums+=nums\\n        res = [-1] * size\\n        stack = []\\n        for i in list(range(size))*2:\\n            while stack and (nums[stack[-1]] < nums[i]):\\n                res[stack.pop()] = nums[i]\\n            stack.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 144302,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> value = new Stack<>();\\n        for(int i = nums.length - 1; i >= 0; --i) {\\n            value.push(nums[i]);\\n        }\\n        \\n        int[] result = new int[nums.length];\\n        for(int i = nums.length - 1; i >= 0; --i) {\\n            while(!value.isEmpty() && value.peek() <= nums[i]) {\\n                value.pop();    \\n            }\\n            \\n            int right = (value.isEmpty()) ? -1 : value.peek();\\n            result[i] = right;\\n            value.push(nums[i]);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> value = new Stack<>();\\n        for(int i = nums.length - 1; i >= 0; --i) {\\n            value.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3377592,
                "title": "super-easy-java-sol-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n        // we double the length of loop to imitate a circular array\\n        // just remember to use i%n for indexing\\n        for (int i = 2*n; i>=0; i--) {\\n            while (!s.isEmpty() && s.peek() <= nums[i%n]) {\\n                s.pop();\\n            }\\n            res[i%n] = s.isEmpty() ? -1 : s.peek();\\n            s.push(nums[i%n]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n        // we double the length of loop to imitate a circular array\\n        // just remember to use i%n for indexing\\n        for (int i = 2*n; i>=0; i--) {\\n            while (!s.isEmpty() && s.peek() <= nums[i%n]) {\\n                s.pop();\\n            }\\n            res[i%n] = s.isEmpty() ? -1 : s.peek();\\n            s.push(nums[i%n]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232711,
                "title": "next-greater-element-ii-a-brilliant-algorithmic-solution-in-java",
                "content": "## \\uD83D\\uDCA1 Intuition\\nWe can use a stack to find the next greater element of each element in the given array. We loop through the array twice to compare each element with every other element. For each element, we push its index onto the stack. If the current element is greater than the top element of the stack, we pop the stack and update the result array with the current element for the popped index. We continue this process until the stack is empty or the top element of the stack is greater than or equal to the current element. Finally, we return the result array.\\n\\n## \\uD83C\\uDFAF Approach\\n1. Create an array of size n to store the result.\\n2. Fill the result array with -1 initially.\\n3. Create a stack using ArrayDeque.\\n4. Loop through the array twice, because we need to compare each element with every other element.\\n5. Get the current element by taking modulus with n.\\n6. While the stack is not empty and the top element of the stack is less than the current element, update the result array with the current element for the popped index.\\n7. If the current index is less than n, push it onto the stack.\\n8. Return the result array.\\n\\n\\n## \\u23F0 Time Complexity\\nThe time complexity of this algorithm is `O(n)`, where n is the length of the input array.\\n\\n## \\uD83D\\uDCBE Space Complexity\\nThe space complexity of this algorithm is `O(n)`, because we are using a stack of size n and an array of size `n` to store the result.\\n\\n## \\uD83D\\uDCDD Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length; // get the length of the array nums\\n        int[] res = new int[n]; // create an array of size n to store the result\\n        Arrays.fill(res, -1); // fill the result array with -1 initially\\n        Deque<Integer> stack = new ArrayDeque<>(); // create a stack using ArrayDeque since its efficient\\n        \\n        // loop through the array twice, because we need to compare each element with every other element\\n        for (int i = 0; i < 2 * n; i++) {\\n            int num = nums[i % n]; // get the current element by taking modulus with n\\n            while (!stack.isEmpty() && nums[stack.peek()] < num) {\\n                // while stack is not empty and top element of stack is less than current element\\n                res[stack.pop()] = num; // update result array with current element for top element of stack\\n            }\\n            if (i < n) {\\n                stack.push(i); // push the current index onto the stack if i < n\\n            }\\n        }\\n        return res; // return the result array\\n    }\\n}\\n```\\n\\n#### Please Upvote if it helped !!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length; // get the length of the array nums\\n        int[] res = new int[n]; // create an array of size n to store the result\\n        Arrays.fill(res, -1); // fill the result array with -1 initially\\n        Deque<Integer> stack = new ArrayDeque<>(); // create a stack using ArrayDeque since its efficient\\n        \\n        // loop through the array twice, because we need to compare each element with every other element\\n        for (int i = 0; i < 2 * n; i++) {\\n            int num = nums[i % n]; // get the current element by taking modulus with n\\n            while (!stack.isEmpty() && nums[stack.peek()] < num) {\\n                // while stack is not empty and top element of stack is less than current element\\n                res[stack.pop()] = num; // update result array with current element for top element of stack\\n            }\\n            if (i < n) {\\n                stack.push(i); // push the current index onto the stack if i < n\\n            }\\n        }\\n        return res; // return the result array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730027,
                "title": "java-2-approaches-brute-optimal-stack",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force approach:\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = -1;\\n\\n            for (int j = 0; j < n; j++) {\\n                if (nums[(i + j) % n] > nums[i]) {\\n                    ans[i] = nums[(i + j) % n];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```\\n##### 2. Optimal approach (Stack):\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n\\n        for (int i = 0; i < 2 * n; i++) {\\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i % n]) {\\n                ans[stack.pop()] = nums[i % n];\\n            }\\n\\n            if (i < n) stack.push(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = -1;\\n\\n            for (int j = 0; j < n; j++) {\\n                if (nums[(i + j) % n] > nums[i]) {\\n                    ans[i] = nums[(i + j) % n];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n\\n        for (int i = 0; i < 2 * n; i++) {\\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i % n]) {\\n                ans[stack.pop()] = nums[i % n];\\n            }\\n\\n            if (i < n) stack.push(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685815,
                "title": "java-100-fastest-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int len = nums.length;\\n        for(int i = (2*len)-1 ; i >= 0 ; i--){\\n            while(stack.size() != 0 && stack.peek() <= nums[i%len]){\\n                stack.pop();\\n            }\\n            if(i < len){\\n                if(stack.size() != 0){\\n                    ans[i%len] = stack.peek();\\n                }\\n                else{\\n                    ans[i%len] = -1;\\n                }\\n            }\\n            stack.push(nums[i%len]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int len = nums.length;\\n        for(int i = (2*len)-1 ; i >= 0 ; i--){\\n            while(stack.size() != 0 && stack.peek() <= nums[i%len]){\\n                stack.pop();\\n            }\\n            if(i < len){\\n                if(stack.size() != 0){\\n                    ans[i%len] = stack.peek();\\n                }\\n                else{\\n                    ans[i%len] = -1;\\n                }\\n            }\\n            stack.push(nums[i%len]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559455,
                "title": "100-fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic**\\n\\n***Please upvote it you like it!!!!!***\\n\\n**Approach**\\n\\nThe approach is simple, As mentioned in problem considred given array as a cyclic, So firstly take a stack and push all the elments of given array from last to first. Take an another loop iterate from last to first index and inside this loop perform below operation.\\n* Take another loop and pop stack elements till stack top element is less than or equal to current index element and stack is not empty.\\n* after previous iterations if stack became empty then set -1 as current index element. Else set the stack top value.\\n\\n**~Time complexity: O(N)**\\n\\n**~Space complexity: O(N)**\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> st;\\n        st.push(INT_MIN);\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int curr=nums[i];\\n            while(st.top()!=INT_MIN and st.top()<=curr){\\n                st.pop();\\n            }\\n            nums[i]=st.top()==INT_MIN?-1:st.top();\\n            st.push(curr);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> st;\\n        st.push(INT_MIN);\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int curr=nums[i];\\n            while(st.top()!=INT_MIN and st.top()<=curr){\\n                st.pop();\\n            }\\n            nums[i]=st.top()==INT_MIN?-1:st.top();\\n            st.push(curr);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362858,
                "title": "check-it",
                "content": "Comment it\\'s time complexity...\\n```\\nvector<int> nextGreaterElements(vector<int>& v) \\n    {\\n        vector<int>ans(n,-1);\\n        int n=v.size();\\n        \\n        //Initialize stack \\n        stack<int>s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.push(v[i]);\\n        }\\n        \\n        \\n        // next greater element \\n        for(int i=n-1;i>=0;i--)\\n        {\\n                while((!(s.empty()))&&(s.top()<=v[i]))\\n                    s.pop();\\n                \\n                if(s.empty())\\n                {\\n                    ans[i]=-1;\\n                }\\n                else\\n                {\\n                    ans[i]=s.top();\\n                }\\n            s.push(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nvector<int> nextGreaterElements(vector<int>& v) \\n    {\\n        vector<int>ans(n,-1);\\n        int n=v.size();\\n        \\n        //Initialize stack \\n        stack<int>s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.push(v[i]);\\n        }\\n        \\n        \\n        // next greater element \\n        for(int i=n-1;i>=0;i--)\\n        {\\n                while((!(s.empty()))&&(s.top()<=v[i]))\\n                    s.pop();\\n                \\n                if(s.empty())\\n                {\\n                    ans[i]=-1;\\n                }\\n                else\\n                {\\n                    ans[i]=s.top();\\n                }\\n            s.push(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2360586,
                "title": "java-solution-using-monotonic-decreasing-stack",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int len = 2 * nums.length - 1;\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            int index = i % nums.length;\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\\n                int pop = stack.pop();\\n                result[pop] = nums[index];\\n            }\\n            stack.push(index);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int len = 2 * nums.length - 1;\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            int index = i % nums.length;\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\\n                int pop = stack.pop();\\n                result[pop] = nums[index];\\n            }\\n            stack.push(index);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159068,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>s;\\n        vector<int>v;\\n        int n = nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            while(s.size()>0&&s.top()<=nums[i])s.pop();\\n            s.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(s.size()>0&&s.top()<=nums[i])s.pop();\\n            v.push_back(s.size()==0?-1:s.top()); //if no greater element push -1.\\n            s.push(nums[i]);\\n            \\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>s;\\n        vector<int>v;\\n        int n = nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            while(s.size()>0&&s.top()<=nums[i])s.pop();\\n            s.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(s.size()>0&&s.top()<=nums[i])s.pop();\\n            v.push_back(s.size()==0?-1:s.top()); //if no greater element push -1.\\n            s.push(nums[i]);\\n            \\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099332,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "using dp, setup save with len(nums) of -1, then create a list newn in which it includes two nums lists. Iterate through nums, and then newn. If newn[j] > nums[i], change save[i] to newn[j] and then break the inner loop.  \\n\\n\\n```\\n\\n```def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        \\n        save = [-1] * len(nums)\\n        newn = nums + nums\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(newn)):\\n                if newn[j] > nums[i]:\\n                    save[i] = newn[j]\\n                    break\\n        \\n        return save",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833084,
                "title": "c-short-and-easy-to-understand-code-o-n-time-and-space",
                "content": "**Please upvote if you like this approach \\\\ solution \\uD83D\\uDE0A**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size(); \\n\\t\\t\\t\\tvector<int> v(n, -1);\\n\\t\\t\\t\\tstack<int> st; \\n\\n\\t\\t\\tfor(int i = 2*n-1; i>=0; i--) {\\n\\t\\t\\t\\twhile(!st.empty() && st.top() <= nums[i%n]) {\\n\\t\\t\\t\\t\\tst.pop(); \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv[i%n] = st.empty() ? -1 : st.top();\\n\\t\\t\\t\\tst.push(nums[i%n]);\\n\\t\\t\\t}\\n\\t\\t\\treturn v; \\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size(); \\n\\t\\t\\t\\tvector<int> v(n, -1);\\n\\t\\t\\t\\tstack<int> st; \\n\\n\\t\\t\\tfor(int i = 2*n-1; i>=0; i--) {\\n\\t\\t\\t\\twhile(!st.empty() && st.top() <= nums[i%n]) {\\n\\t\\t\\t\\t\\tst.pop(); \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1623459,
                "title": "using-stack-simple-concise-c",
                "content": "Implementation\\n\\n**Using Stack\\nTime Complexity = O(2N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;        \\n        vector<int> res(n, -1);\\n        for(int itr = 2*n-1; itr >= 0; itr--){\\n            while(!s.empty() && s.top() <= nums[itr%n]) s.pop();\\n            if(!s.empty()) res[itr%n] = s.top();\\n            s.push(nums[itr%n]);\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;        \\n        vector<int> res(n, -1);\\n        for(int itr = 2*n-1; itr >= 0; itr--){\\n            while(!s.empty() && s.top() <= nums[itr%n]) s.pop();\\n            if(!s.empty()) res[itr%n] = s.top();\\n            s.push(nums[itr%n]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661113,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int [] result = new int[nums.length];\\n        int size = nums.length;\\n        Arrays.fill(result,-1);\\n        for(int i=2*size-1; i>=0; i--){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i%size])\\n                stack.pop();\\n        \\n            if(stack.isEmpty()){\\n                stack.push(i%size);\\n            }else{\\n                result[i%size]=nums[stack.peek()];\\n                stack.push(i%size);\\n            }\\n        }\\n     return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int [] result = new int[nums.length];\\n        int size = nums.length;\\n        Arrays.fill(result,-1);\\n        for(int i=2*size-1; i>=0; i--){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i%size])\\n                stack.pop();\\n        \\n            if(stack.isEmpty()){\\n                stack.push(i%size);\\n            }else{\\n                result[i%size]=nums[stack.peek()];\\n                stack.push(i%size);\\n            }\\n        }\\n     return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341634,
                "title": "next-greater-element-ii-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] nextGreaterElements(int[] nums) {\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tint[] res = new int[len];\\n\\t\\t\\tArrays.fill(res, -1);\\n\\t\\t\\tStack<Integer> stack = new Stack<>();\\n\\n\\t\\t\\tfor (int i = 0; i < len * 2; i++) {\\n\\t\\t\\t\\tint num = nums[i % len];\\n\\t\\t\\t\\twhile (!stack.isEmpty() && nums[stack.peek()] < num) {\\n\\t\\t\\t\\t\\tres[stack.pop()] = num;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (i < len) stack.push(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] nextGreaterElements(int[] nums) {\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tint[] res = new int[len];\\n\\t\\t\\tArrays.fill(res, -1);\\n\\t\\t\\tStack<Integer> stack = new Stack<>();\\n\\n\\t\\t\\tfor (int i = 0; i < len * 2; i++) {\\n\\t\\t\\t\\tint num = nums[i % len];\\n\\t\\t\\t\\twhile (!stack.isEmpty() && nums[stack.peek()] < num) {\\n\\t\\t\\t\\t\\tres[stack.pop()] = num;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3835583,
                "title": "c-solution-without-using-stack-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncreate a new array of double size of nums. so that we can iterate over the array twice\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the first n elements of temp and find the next greater element of each element if no greater element was found push back -1 to ans vector.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> temp;\\n        vector<int> ans;\\n        temp = nums;\\n        for(int i = 0; i < nums.size();i++){\\n            temp.push_back(nums[i]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int x = temp[i];\\n            int j = i + 1;\\n            while(j < temp.size()){\\n                if(temp[j] > x){\\n                    x = temp[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(x != temp[i]) ans.push_back(x);\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> temp;\\n        vector<int> ans;\\n        temp = nums;\\n        for(int i = 0; i < nums.size();i++){\\n            temp.push_back(nums[i]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int x = temp[i];\\n            int j = i + 1;\\n            while(j < temp.size()){\\n                if(temp[j] > x){\\n                    x = temp[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(x != temp[i]) ans.push_back(x);\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797814,
                "title": "python-3-monotonic-stack-2-traversal-approaches",
                "content": "## Iteration from start to end:\\n```python3\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, L = [], len(nums)\\n        res = [-1] * L\\n\\n        for i in range(L*2):\\n            idx = i % L\\n            while stack and nums[stack[-1]] < nums[idx]:\\n                res[stack.pop()] = nums[idx]\\n            stack.append(idx)\\n        return res\\n```\\n## Iteration from end to start:\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, L = [], len(nums)\\n        res = [-1] * L\\n\\n        for i in reversed(range(L * 2 - 1)):\\n            idx = i % L\\n            while stack and stack[-1] <= nums[idx]:\\n                stack.pop()\\n            res[idx] = stack[-1] if stack else -1\\n            stack.append(nums[idx])\\n        \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```python3\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, L = [], len(nums)\\n        res = [-1] * L\\n\\n        for i in range(L*2):\\n            idx = i % L\\n            while stack and nums[stack[-1]] < nums[idx]:\\n                res[stack.pop()] = nums[idx]\\n            stack.append(idx)\\n        return res\\n```\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, L = [], len(nums)\\n        res = [-1] * L\\n\\n        for i in reversed(range(L * 2 - 1)):\\n            idx = i % L\\n            while stack and stack[-1] <= nums[idx]:\\n                stack.pop()\\n            res[idx] = stack[-1] if stack else -1\\n            stack.append(nums[idx])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662701,
                "title": "next-greater-element-ii-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n,-1),stack;\\n        for(int i=0;i<2*n;i++){\\n            while(stack.size() && nums[stack.back()] < nums[i%n]){\\n                ans[stack.back()] = nums[i%n];\\n                stack.pop_back();\\n            }\\n            stack.push_back(i%n);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e748d137-70df-4590-9d6d-ee9dfa93c743_1687283533.4526136.jpeg)\\n\\nplease upvote! if you like.\\nComment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n,-1),stack;\\n        for(int i=0;i<2*n;i++){\\n            while(stack.size() && nums[stack.back()] < nums[i%n]){\\n                ans[stack.back()] = nums[i%n];\\n                stack.pop_back();\\n            }\\n            stack.push_back(i%n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442106,
                "title": "brute-force-approach-easy-understandable-but-ugly-tc",
                "content": "# Approach\\n - We know always ```rotation = len(nums) - 1```\\n - Pick 1 no from the list in the outer loop\\n - Check from the very next element in the inner loop\\n -  -```if nums[i] < nums[j]:``` then add ```nums[j]```\\n -  -```else``` add ```-1``` at the outer loop\\n# Complexity\\n- Space complexity:\\nBeats 95%\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        flag = False\\n        for i in range(len(nums)):\\n            j = i + 1\\n            rotation = len(nums) - 1\\n            while rotation > 0:\\n                if j >= len(nums):\\n                    j = 0\\n                if nums[i] < nums[j]:\\n                    ans.append(nums[j])\\n                    flag = True\\n                    break\\n                else:\\n                    rotation -= 1\\n                    j += 1\\n                    flag = False\\n            if flag == False:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```rotation = len(nums) - 1```\n```if nums[i] < nums[j]:```\n```nums[j]```\n```else```\n```-1```\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        flag = False\\n        for i in range(len(nums)):\\n            j = i + 1\\n            rotation = len(nums) - 1\\n            while rotation > 0:\\n                if j >= len(nums):\\n                    j = 0\\n                if nums[i] < nums[j]:\\n                    ans.append(nums[j])\\n                    flag = True\\n                    break\\n                else:\\n                    rotation -= 1\\n                    j += 1\\n                    flag = False\\n            if flag == False:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332147,
                "title": "c-solution-in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we initialize the vector<int> ans by -1, ans then initialize empty stack. Then we will iterate through the array twice and store the next larger element for the first iterator and then as i > n, we will store the index and then as the next larger element will come by comparision then we will store in the ans vector.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> ans(n,-1);\\n        stack<int> st;\\n\\n        for(int i = 0 ; i<2*n;i++){\\n            int x = nums[i%n];\\n            while(!st.empty() && nums[st.top()] < x){\\n                ans[st.top()] = x;\\n                st.pop();\\n            }\\n            if(i<n)\\n                st.push(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> ans(n,-1);\\n        stack<int> st;\\n\\n        for(int i = 0 ; i<2*n;i++){\\n            int x = nums[i%n];\\n            while(!st.empty() && nums[st.top()] < x){\\n                ans[st.top()] = x;\\n                st.pop();\\n            }\\n            if(i<n)\\n                st.push(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250904,
                "title": "js-solution-explained-with-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- It is a two loops solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach used in the below code is :- \\n\\n1. To iterate over each element in the array and then for each element, iterate over all the other elements until it finds the next greater element. \\n\\n2. To handle the circular nature of the array, the index is taken modulo n (the length of the array) to wrap around to the beginning of the array.\\n\\n3. If a greater element is found, it is stored in the answer array at the current index. \\n\\n4. If no greater element is found after iterating over all the other elements, then -1 is stored in the answer array at the current index.\\n\\n5. Finally, the answer array is returned, which contains the next greater element for each element in the circular array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n1. Here n is the length of the input array.\\n\\n2. This is because for each element in the array, the algorithm iterates over all the other elements until it finds the next greater element.\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the length of the input array. \\n\\n2. This is because the algorithm creates an array to store the result, which has the same length as the input array.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    \\n    let n = nums.length;\\n    \\n    let ans = new Array(n);\\n    \\n    for (let i=0; i<n; i++) {\\n        \\n        let j = i+1;\\n        \\n        while (j % n !== i) {\\n            \\n            if (nums[j % n] > nums[i]) {\\n                \\n                ans[i] = nums[j % n];\\n                \\n                break;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        if (j % n == i) {\\n            \\n            ans[i] = -1;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```\\n\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/76e25f8e-dfee-422c-a969-ebc9bd6d6ae5_1677827905.7533722.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    \\n    let n = nums.length;\\n    \\n    let ans = new Array(n);\\n    \\n    for (let i=0; i<n; i++) {\\n        \\n        let j = i+1;\\n        \\n        while (j % n !== i) {\\n            \\n            if (nums[j % n] > nums[i]) {\\n                \\n                ans[i] = nums[j % n];\\n                \\n                break;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        if (j % n == i) {\\n            \\n            ans[i] = -1;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068624,
                "title": "simple-approach-using-stack-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        //idea is to go for next gtreater in nums+nums\\n        int n=nums.size();\\n        nums.resize(2*n);\\n        for(int i=n;i<2*n;i++){\\n            nums[i]=nums[i-n];\\n        }\\n        vector<int>res(n);\\n        stack<int>st;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(!st.empty() && nums[i]>=nums[st.top()]){\\n                st.pop();\\n            }\\n            int idx=i%n;\\n            res[idx]=st.empty()?-1:nums[st.top()];\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        //idea is to go for next gtreater in nums+nums\\n        int n=nums.size();\\n        nums.resize(2*n);\\n        for(int i=n;i<2*n;i++){\\n            nums[i]=nums[i-n];\\n        }\\n        vector<int>res(n);\\n        stack<int>st;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(!st.empty() && nums[i]>=nums[st.top()]){\\n                st.pop();\\n            }\\n            int idx=i%n;\\n            res[idx]=st.empty()?-1:nums[st.top()];\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988463,
                "title": "easy-and-optimal-solution-tc-o-n-sc-o-n",
                "content": "# Prerequisite\\n\\nThis problem is similar to [Find next greater element-1](https://leetcode.com/problems/next-greater-element-i/description/).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Finding next greater element in an array is similar to this problem.\\n- The only change here is the next greater elements can be found in circular fashion too from end to starting of array.\\n- So for elements at end of array, we can look at startin of array for it\\'s nge. SO BASICALLY THIS IS A CIRCULAR ARRAY.\\n- Notice one thing, *if we just append this array to end of this array, this problem can be solved directly using nge approach*.\\n\\n- So repeat the same process except keep in mind the indices we need for result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,-1);\\n        stack<int> st;\\n        //assume appending nums to it again but it can be done using index manipulation without actually appending\\n        for(int i=2*n-1;i>=0;--i){\\n            while(!st.empty() and st.top()<=nums[i%n]) st.pop();//remove all smaller elements\\n            if(i<n){\\n                if(!st.empty()) res[i]=st.top();\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,-1);\\n        stack<int> st;\\n        //assume appending nums to it again but it can be done using index manipulation without actually appending\\n        for(int i=2*n-1;i>=0;--i){\\n            while(!st.empty() and st.top()<=nums[i%n]) st.pop();//remove all smaller elements\\n            if(i<n){\\n                if(!st.empty()) res[i]=st.top();\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751457,
                "title": "java-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for (int i = 0; i < result.length; i ++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < 2 * result.length; i ++) {\\n            int num = nums[i % result.length];\\n            while (!stack.isEmpty() && nums[stack.peek()] < num) {\\n                result[stack.pop()] = num;\\n            }\\n            if (i < result.length) {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for (int i = 0; i < result.length; i ++) {\\n            result[i] = -1;\\n        }\\n        for (int i = 0; i < 2 * result.length; i ++) {\\n            int num = nums[i % result.length];\\n            while (!stack.isEmpty() && nums[stack.peek()] < num) {\\n                result[stack.pop()] = num;\\n            }\\n            if (i < result.length) {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651594,
                "title": "java-easy-solution-stack-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] output = new int[n];\\n        Stack<Integer> st = new Stack<Integer>();\\n        Arrays.fill(output , -1);\\n        \\n        for(int i = 0 ; i < 2*n ; i++){\\n            int idx = i%n;\\n            \\n            while(!st.empty() && nums[idx] > nums[st.peek()]){\\n                output[st.peek()] = nums[idx];\\n                st.pop();\\n            }\\n            st.push(idx);  \\n        }\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] output = new int[n];\\n        Stack<Integer> st = new Stack<Integer>();\\n        Arrays.fill(output , -1);\\n        \\n        for(int i = 0 ; i < 2*n ; i++){\\n            int idx = i%n;\\n            \\n            while(!st.empty() && nums[idx] > nums[st.peek()]){\\n                output[st.peek()] = nums[idx];\\n                st.pop();\\n            }\\n            st.push(idx);  \\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613708,
                "title": "c-monotonic-stack-503",
                "content": "```\\n vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> ele;\\n        vector<int> ans1;\\n        int i,x;\\n        int n=nums.size();\\n        for(i=0;i<n;i++)\\n        {\\n            int j=(i+1)%n;\\n            while((j)%n!=i)\\n            {\\n               if(nums[j]>nums[i])\\n               {\\n                   \\n                   ele.push(nums[j]);\\n                   break;\\n                }\\n                j=(j+1)%n;\\n             }\\n            if(!ele.empty())\\n            {\\n                 x=ele.top();\\n                 ele.pop();\\n                 ans1.push_back(x);\\n            }\\n            else\\n            {\\n           ans1.push_back(-1);\\n            }  \\n        }\\n    return ans1;\\n       \\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\n vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> ele;\\n        vector<int> ans1;\\n        int i,x;\\n        int n=nums.size();\\n        for(i=0;i<n;i++)\\n        {\\n            int j=(i+1)%n;\\n            while((j)%n!=i)\\n            {\\n               if(nums[j]>nums[i])\\n               {\\n                   \\n                   ele.push(nums[j]);\\n                   break;\\n                }\\n                j=(j+1)%n;\\n             }\\n            if(!ele.empty())\\n            {\\n                 x=ele.top();\\n                 ele.pop();\\n                 ans1.push_back(x);\\n            }\\n            else\\n            {\\n           ans1.push_back(-1);\\n            }  \\n        }\\n    return ans1;\\n       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357014,
                "title": "python-monotonic-stack-o-n-approach",
                "content": "Monotonic Decreasing Stack : reference from [here](https://leetcode.com/discuss/study-guide/2347639/a-comprehensive-guide-and-template-for-monotonic-stack-based-problems)\\n\\n|  next greater      |  decreasing (equal allowed)  |  stackTop < current     |  inside while loop    |\\n\\nconcept : same as [496. Next Greater Element I\\n](https://leetcode.com/problems/next-greater-element-i/) but perform it twice.\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        res = [-1] * len(nums)\\n        \\n        for _ in range(2):\\n            for i in range(len(nums)):\\n                while stack and nums[stack[-1]] < nums[i]:\\n                    idx = stack.pop()\\n                    res[idx] = nums[i]\\n                stack.append(i)\\n        \\n        return res\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        res = [-1] * len(nums)\\n        \\n        for _ in range(2):\\n            for i in range(len(nums)):\\n                while stack and nums[stack[-1]] < nums[i]:\\n                    idx = stack.pop()\\n                    res[idx] = nums[i]\\n                stack.append(i)\\n        \\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249457,
                "title": "java-self-explanatory-o-n",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n      Stack<Integer> st = new Stack<>();\\n      for(int i = nums.length - 1; i >= 0; i --) {\\n       st.push(nums[i]); \\n      }\\n      \\n      int ans[] = new int[nums.length];\\n      for(int i = nums.length - 1; i >= 0; i --) {\\n        while(!st.isEmpty() && st.peek() <= nums[i]) {\\n          st.pop();\\n        }\\n        ans[i] = st.empty() ? -1 : st.peek();\\n        st.push(nums[i]);\\n      }\\n      return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n      Stack<Integer> st = new Stack<>();\\n      for(int i = nums.length - 1; i >= 0; i --) {\\n       st.push(nums[i]); \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2241578,
                "title": "extending-next-greater-element-1-solution-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans= new int[nums.length];\\n        \\n\\t\\t//For Circular array adding elements from n-2 to 0\\n        //As for nth element first element is 0th element\\n        //So when we check for next greater for nth element\\n        //We should start looking from 0 to n-2\\n        for(int i=nums.length-2;i>=0;i--)\\n        stack.push(nums[i]);\\n    \\n\\t    //Next Greater Element 1 Solution\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            while(!stack.isEmpty()&&nums[i]>=stack.peek())\\n                stack.pop();\\n            \\n            if(stack.isEmpty())\\n            ans[i] = -1;\\n            else\\n            ans[i] = stack.peek();\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans= new int[nums.length];\\n        \\n\\t\\t//For Circular array adding elements from n-2 to 0\\n        //As for nth element first element is 0th element\\n        //So when we check for next greater for nth element\\n        //We should start looking from 0 to n-2\\n        for(int i=nums.length-2;i>=0;i--)\\n        stack.push(nums[i]);\\n    \\n\\t    //Next Greater Element 1 Solution\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            while(!stack.isEmpty()&&nums[i]>=stack.peek())\\n                stack.pop();\\n            \\n            if(stack.isEmpty())\\n            ans[i] = -1;\\n            else\\n            ans[i] = stack.peek();\\n            \\n            stack.push(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992662,
                "title": "python-simple-o-n-solution-monotonic-stack",
                "content": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = n * [-1]\\n        nums += nums\\n        \\n        stack = []\\n        for i, num in enumerate(nums):\\n            while stack and stack[-1][1] < num:\\n                ans[stack.pop()[0]] = num\\n            if i < n: stack.append((i, num))\\n        \\n        return ans\\n```\\n\\nn = length of nums\\nTime complexity: O(2 * n) = O(n)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = n * [-1]\\n        nums += nums\\n        \\n        stack = []\\n        for i, num in enumerate(nums):\\n            while stack and stack[-1][1] < num:\\n                ans[stack.pop()[0]] = num\\n            if i < n: stack.append((i, num))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873961,
                "title": "solution-swift-next-greater-element-ii",
                "content": "```swift\\nclass Solution {\\n    func nextGreaterElements(_ nums: [Int]) -> [Int] {\\n        let len = nums.count\\n        var arr = Array(repeating: -1, count: len)\\n        var stack: [Int] = []\\n        for i in 0..<len*2 {\\n            while !stack.isEmpty, nums[stack.last!] < nums[i % len] {\\n                arr[stack.removeLast()] = nums[i % len]\\n            }\\n            stack.append(i % len)\\n        }\\n        return arr\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.016 (0.018) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // Explanation: The first 1\\'s next greater number is 2;\\n    // The number 2 can\\'t find next greater number.\\n    // The second 1\\'s next greater number needs to search circularly, which is also 2.\\n    func test0() {\\n        let value = solution.nextGreaterElements([1,2,1])\\n        XCTAssertEqual(value, [2,-1,2])\\n    }\\n    \\n    func test1() {\\n        let value = solution.nextGreaterElements([1,2,3,4,3])\\n        XCTAssertEqual(value, [2,3,4,-1,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func nextGreaterElements(_ nums: [Int]) -> [Int] {\\n        let len = nums.count\\n        var arr = Array(repeating: -1, count: len)\\n        var stack: [Int] = []\\n        for i in 0..<len*2 {\\n            while !stack.isEmpty, nums[stack.last!] < nums[i % len] {\\n                arr[stack.removeLast()] = nums[i % len]\\n            }\\n            stack.append(i % len)\\n        }\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // Explanation: The first 1\\'s next greater number is 2;\\n    // The number 2 can\\'t find next greater number.\\n    // The second 1\\'s next greater number needs to search circularly, which is also 2.\\n    func test0() {\\n        let value = solution.nextGreaterElements([1,2,1])\\n        XCTAssertEqual(value, [2,-1,2])\\n    }\\n    \\n    func test1() {\\n        let value = solution.nextGreaterElements([1,2,3,4,3])\\n        XCTAssertEqual(value, [2,3,4,-1,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460953,
                "title": "java-easy-solution-beats-94-submission-6-ms",
                "content": "```\\n    class Solution {\\n        public int[] nextGreaterElements(int[] a) {\\n\\n\\n            // List<Integer> l=new ArrayList<>();\\n\\n            int n=a.length;     \\n            int max=a[0];\\n            int cur=0;\\n            for(int i=0;i<n;i++)\\n            {\\n            if(max<a[i])\\n            {\\n                max=a[i];\\n                cur=i;\\n            }\\n                }\\n                    int []res= new int[a.length];\\n                    Stack<Integer> s=new Stack<>();\\n                    s.push(a[cur]);\\n                    res[cur]=-1;\\n                    for(int i=cur-1;i>=0;i--)\\n                    {\\n                        while(s.size()>0 && a[i]>=s.peek())\\n                        {\\n                            s.pop();\\n                        }\\n                        if(s.size()>0)\\n                        {\\n                            res[i]=s.peek();\\n                        }\\n                        else\\n                        {\\n                            res[i]=-1;\\n                        }\\n                        s.push(a[i]);\\n                    }\\n\\n\\n\\n                    for(int i=n-1;i>cur;i--)\\n                    {\\n                        while(s.size()>0 && a[i]>=s.peek())\\n                        {\\n                            s.pop();\\n                        }\\n                        if(s.size()>0)\\n                        {\\n                            res[i]=s.peek();\\n                        }\\n                        else\\n                        {\\n                            res[i]=-1;\\n                        }\\n                        s.push(a[i]);\\n                    }\\n\\n         return res;\\n            }\\n        }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n        public int[] nextGreaterElements(int[] a) {\\n\\n\\n            // List<Integer> l=new ArrayList<>();\\n\\n            int n=a.length;     \\n            int max=a[0];\\n            int cur=0;\\n            for(int i=0;i<n;i++)\\n            {\\n            if(max<a[i])\\n            {\\n                max=a[i];\\n                cur=i;\\n            }\\n                }\\n                    int []res= new int[a.length];\\n                    Stack<Integer> s=new Stack<>();\\n                    s.push(a[cur]);\\n                    res[cur]=-1;\\n                    for(int i=cur-1;i>=0;i--)\\n                    {\\n                        while(s.size()>0 && a[i]>=s.peek())\\n                        {\\n                            s.pop();\\n                        }\\n                        if(s.size()>0)\\n                        {\\n                            res[i]=s.peek();\\n                        }\\n                        else\\n                        {\\n                            res[i]=-1;\\n                        }\\n                        s.push(a[i]);\\n                    }\\n\\n\\n\\n                    for(int i=n-1;i>cur;i--)\\n                    {\\n                        while(s.size()>0 && a[i]>=s.peek())\\n                        {\\n                            s.pop();\\n                        }\\n                        if(s.size()>0)\\n                        {\\n                            res[i]=s.peek();\\n                        }\\n                        else\\n                        {\\n                            res[i]=-1;\\n                        }\\n                        s.push(a[i]);\\n                    }\\n\\n         return res;\\n            }\\n        }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394767,
                "title": "find-the-max-element-and-use-stack-to-keep-track-o-2n-complexity",
                "content": "First find the maximum element in the array, it will always have a -1 for the answer to it\\'s next greater element because no element is greater than that in the array.\\nThen, start a loop from that index till the same index in a backward direction, and fill the stack accordingly, if stack contains any lesser elements remove them, then check if stack is empty the answer will be -1 or else the top element of stack.\\n\\nTC: O(n) for finding the max element + O(n) for finding next greater elements of every element\\nSC: O(n) at max the stack may contain n elements.\\n\\nJAVA:\\n```class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int pm = -1;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++)\\n            if (max < nums[i]) {\\n                max = nums[i];\\n                pm = i;\\n            }\\n        int[] res = new int[nums.length];\\n        Stack<Integer> stk = new Stack<>();\\n        int i = pm;\\n        res[i] = -1;\\n        stk.push(nums[i]);\\n        i--;\\n        if (i < 0)\\n            i = nums.length - 1;\\n        \\n        while (i != pm) {\\n            while (!stk.isEmpty() && stk.peek() <= nums[i]) \\n                stk.pop();\\n            if (stk.isEmpty())\\n                res[i] = -1;\\n            else\\n                res[i] = stk.peek();\\n            stk.push(nums[i]);\\n            i--;\\n            if (i < 0)\\n                i = nums.length - 1;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int pm = -1;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++)\\n            if (max < nums[i]) {\\n                max = nums[i];\\n                pm = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1367797,
                "title": "c-simple-single-loop-stack",
                "content": "Simple solution with TC: O(2*n) , just using single loop.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res(n,-1);\\n        stack<int>s;\\n        \\n\\t\\t//in worst case we have to traverse array 2n times\\n        for(int i=0;i<n*2;i++){\\n\\t\\t    // if we reach end just change the index to 0\\n            int ind = (i>=n)?i-n:i;\\n            while(!s.empty() && nums[s.top()]<nums[ind]){\\n                res[s.top()] = nums[ind];\\n                s.pop();\\n            }\\n            s.push(ind); \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nif found helpful please upvote!!!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res(n,-1);\\n        stack<int>s;\\n        \\n\\t\\t//in worst case we have to traverse array 2n times\\n        for(int i=0;i<n*2;i++){\\n\\t\\t    // if we reach end just change the index to 0\\n            int ind = (i>=n)?i-n:i;\\n            while(!s.empty() && nums[s.top()]<nums[ind]){\\n                res[s.top()] = nums[ind];\\n                s.pop();\\n            }\\n            s.push(ind); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081315,
                "title": "js-slow-2-line-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function (nums) {\\n  const arr = [...nums, ...nums.slice(0, -1)]\\n  return nums.map((n, i) => arr.slice(i).find(x => x > n) ?? -1)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function (nums) {\\n  const arr = [...nums, ...nums.slice(0, -1)]\\n  return nums.map((n, i) => arr.slice(i).find(x => x > n) ?? -1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920662,
                "title": "stack-js-solution",
                "content": "```\\n/*\\nWe are looking for the first number greater than current number. It doesn\\'t matter if the\\nposition of Next Greater Number (NGN) is before or after position of current number because\\nthe array is circular.\\n\\nWe will use a Stack. We start iterating given array from the start.\\nAt each number, we check if stack has a number smaller than current number. If so,\\ncurrent number is the Next Greater Number for that element in the stack. Hence,\\nwe keep popping smaller elements from stack and be their NGN. \\n\\nThen, we push current number into stack so that we can find our NGN (or not if there isn\\'t one).\\n\\nWe will push index instead of number into stack so that we can fill our result array.\\n\\nAlso, we will iterate through the array twice so that for every number we can scan elements on both the left side and the right side.\\n*/\\n\\nvar nextGreaterElements = function(nums) {\\n    let res = new Array(nums.length).fill(-1);\\n    let stack = [];\\n    for (let i = 0; i < nums.length * 2; i++) {\\n        let j = i % nums.length;\\n        while (stack.length > 0 && nums[stack[stack.length-1]] < nums[j]) {\\n            // current element is NGN for popped element\\n            res[stack.pop()] = nums[j];\\n        }\\n        stack.push(j);\\n    }\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nWe are looking for the first number greater than current number. It doesn\\'t matter if the\\nposition of Next Greater Number (NGN) is before or after position of current number because\\nthe array is circular.\\n\\nWe will use a Stack. We start iterating given array from the start.\\nAt each number, we check if stack has a number smaller than current number. If so,\\ncurrent number is the Next Greater Number for that element in the stack. Hence,\\nwe keep popping smaller elements from stack and be their NGN. \\n\\nThen, we push current number into stack so that we can find our NGN (or not if there isn\\'t one).\\n\\nWe will push index instead of number into stack so that we can fill our result array.\\n\\nAlso, we will iterate through the array twice so that for every number we can scan elements on both the left side and the right side.\\n*/\\n\\nvar nextGreaterElements = function(nums) {\\n    let res = new Array(nums.length).fill(-1);\\n    let stack = [];\\n    for (let i = 0; i < nums.length * 2; i++) {\\n        let j = i % nums.length;\\n        while (stack.length > 0 && nums[stack[stack.length-1]] < nums[j]) {\\n            // current element is NGN for popped element\\n            res[stack.pop()] = nums[j];\\n        }\\n        stack.push(j);\\n    }\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 852672,
                "title": "c-solution-using-stack-with-comment",
                "content": "Runtime: 52 ms, faster than 97.45% of C++ online submissions for Next Greater Element II.\\nMemory Usage: 24.6 MB, less than 24.43% of C++ online submissions for Next Greater Element II.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        stack<int>stak;\\n        int n = nums.size();\\n        vector<int>result(n);\\n        \\n        if(n==0) return result;\\n        \\n        // Fill stack with all element so that we can get the greater number which are in circular left\\n        // We loop through right to left so that the left most elements are at the top of stack\\n        for(int i=n-1;i>=0;i--)\\n            stak.push(nums[i]);\\n        \\n        // Loop through the array and set the next greater number which include both greater element at right and circular left\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stak.empty() && stak.top()<=nums[i])\\n                stak.pop();\\n\\n            if(stak.empty())\\n                result[i] = -1;\\n            else\\n                result[i] = stak.top();\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        stack<int>stak;\\n        int n = nums.size();\\n        vector<int>result(n);\\n        \\n        if(n==0) return result;\\n        \\n        // Fill stack with all element so that we can get the greater number which are in circular left\\n        // We loop through right to left so that the left most elements are at the top of stack\\n        for(int i=n-1;i>=0;i--)\\n            stak.push(nums[i]);\\n        \\n        // Loop through the array and set the next greater number which include both greater element at right and circular left\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stak.empty() && stak.top()<=nums[i])\\n                stak.pop();\\n\\n            if(stak.empty())\\n                result[i] = -1;\\n            else\\n                result[i] = stak.top();\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387362,
                "title": "easy-peasy-python-solution-similar-to-next-greater-element-1",
                "content": "\\tdef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        # run Next Greater Element I two times\\n        ln = len(nums)\\n        if ln == 0:\\n            return []\\n        rs = [-1]*ln\\n        st = []\\n        for _ in range(2):\\n            for j in range(ln-1, -1, -1):\\n                if not st:\\n                    st.append(nums[j])\\n                else:\\n                    while st and st[-1] <= nums[j]:\\n                        st.pop()\\n                    \\n                    if st:\\n                        rs[j] = st[-1]\\n                    \\n                    st.append(nums[j])\\n        \\n        return rs",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "\\tdef nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        # run Next Greater Element I two times\\n        ln = len(nums)\\n        if ln == 0:\\n            return []\\n        rs = [-1]*ln\\n        st = []\\n        for _ in range(2):\\n            for j in range(ln-1, -1, -1):\\n                if not st:\\n                    st.append(nums[j])\\n                else:\\n                    while st and st[-1] <= nums[j]:\\n                        st.pop()\\n                    \\n                    if st:\\n                        rs[j] = st[-1]\\n                    \\n                    st.append(nums[j])\\n        \\n        return rs",
                "codeTag": "Python3"
            },
            {
                "id": 290771,
                "title": "c-stack-solution-96-65-runtime-and-99-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int size = nums.size();\\n        vector<int> res(size, -1);\\n        \\n        stack<pair<int, int>> stk; // index to val\\n        \\n        for(int i = 0; i < (2*size); i++) {\\n            int temp = i;\\n            if(temp >= size) {\\n                temp %= size;\\n            }\\n            \\n            while(!stk.empty() && stk.top().second < nums[temp]) {\\n                res[stk.top().first] = nums[temp];\\n                stk.pop();\\n            }\\n            if(res[temp] == -1) {\\n                stk.push(make_pair(temp, nums[temp]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int size = nums.size();\\n        vector<int> res(size, -1);\\n        \\n        stack<pair<int, int>> stk; // index to val\\n        \\n        for(int i = 0; i < (2*size); i++) {\\n            int temp = i;\\n            if(temp >= size) {\\n                temp %= size;\\n            }\\n            \\n            while(!stk.empty() && stk.top().second < nums[temp]) {\\n                res[stk.top().first] = nums[temp];\\n                stk.pop();\\n            }\\n            if(res[temp] == -1) {\\n                stk.push(make_pair(temp, nums[temp]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98284,
                "title": "concise-c-solution-using-stack-that-beats-98",
                "content": "```   \\n vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec(n, -1);\\n        stack<int> stack;\\n        for(int i=0, j=0; i<2*n-1; i++){\\n            j = (i<n)?i:i-n;\\n            while(!stack.empty() && nums[stack.top()]<nums[j]){\\n                vec[stack.top()] = nums[j];\\n                stack.pop();\\n            }\\n            if(i<n)stack.push(i);\\n        }\\n        return vec;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec(n, -1);\\n        stack<int> stack;\\n        for(int i=0, j=0; i<2*n-1; i++){\\n            j = (i<n)?i:i-n;\\n            while(!stack.empty() && nums[stack.top()]<nums[j]){\\n                vec[stack.top()] = nums[j];\\n                stack.pop();\\n            }\\n            if(i<n)stack.push(i);\\n        }\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98303,
                "title": "python-o-n-n-time-limit-exceeded",
                "content": "From viewing other solutions I think in some other languages O(n * n) are accepted.  Can my code be improved for O(n * n) or do I have to use another language or approach?\\n\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n\\n        if not nums:\\n            return []\\n            \\n        n = len(nums)\\n        result = [-1 for _ in range(len(nums))]\\n        max_num = max(nums)\\n        \\n        for i, num in enumerate(nums):\\n\\n            if num == max_num:\\n                continue\\n\\n            j = i\\n            while nums[j] <= num:\\n                j += 1\\n                j %= n\\n            result[i] = nums[j]\\n\\n        return result",
                "solutionTags": [],
                "code": "From viewing other solutions I think in some other languages O(n * n) are accepted.  Can my code be improved for O(n * n) or do I have to use another language or approach?\\n\\n```\\nclass Solution(object):\\n    def nextGreaterElements(self, nums):\\n\\n        if not nums:\\n            return []\\n            \\n        n = len(nums)\\n        result = [-1 for _ in range(len(nums))]\\n        max_num = max(nums)\\n        \\n        for i, num in enumerate(nums):\\n\\n            if num == max_num:\\n                continue\\n\\n            j = i\\n            while nums[j] <= num:\\n                j += 1\\n                j %= n\\n            result[i] = nums[j]\\n\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 4026224,
                "title": "3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <stack>\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n     stack<int> s;\\n     vector<int> x(nums);\\n     int h=nums.size();\\n     s.push(-1);\\n     for(int i=2*h-1;i>=0;i--){\\n         while(!s.empty() && s.top()<=nums[i%h]){\\n             s.pop();\\n         }\\n         if(s.empty()){s.push(-1);}\\n         x[i%h]=s.top();\\n         s.push(nums[i%h]);\\n     }\\n     return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <stack>\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n     stack<int> s;\\n     vector<int> x(nums);\\n     int h=nums.size();\\n     s.push(-1);\\n     for(int i=2*h-1;i>=0;i--){\\n         while(!s.empty() && s.top()<=nums[i%h]){\\n             s.pop();\\n         }\\n         if(s.empty()){s.push(-1);}\\n         x[i%h]=s.top();\\n         s.push(nums[i%h]);\\n     }\\n     return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3943299,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n);\\n        stack<int> st;\\n        for(int i=2*n-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()){\\n                    res[i%n]=st.top();\\n                }\\n                else{\\n                    res[i%n]=-1;\\n                }\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n);\\n        stack<int> st;\\n        for(int i=2*n-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()){\\n                    res[i%n]=st.top();\\n                }\\n                else{\\n                    res[i%n]=-1;\\n                }\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853953,
                "title": "simple-c-solution-using-two-loops-begginers-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> res;\\n        int y=0,x=-1;\\n        for (int i=0;i<nums.size();i++){\\n            y=nums[i];\\n            for(int j=i+1;j<nums.size()+i;j++){\\n                if(nums[j%nums.size()]>y){x=0;res.push_back(nums[j%nums.size()]);break;}\\n            }\\n            if(x!=0){res.push_back(-1);}\\n            x=-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> res;\\n        int y=0,x=-1;\\n        for (int i=0;i<nums.size();i++){\\n            y=nums[i];\\n            for(int j=i+1;j<nums.size()+i;j++){\\n                if(nums[j%nums.size()]>y){x=0;res.push_back(nums[j%nums.size()]);break;}\\n            }\\n            if(x!=0){res.push_back(-1);}\\n            x=-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841473,
                "title": "c-beginner-friendly-solution-stack",
                "content": "# Intuition\\n******We need to make this algorithm work for a circular array. The only difference between a circular and non-circular array is that while searching for the next greater element in a non-circular array we don\\u2019t consider the elements left to the concerned element. This can be easily done by inserting the elements of the array A at the end of A, thus making its size double. But we actually don\\u2019t require any extra space. We can just traverse the array twice. We actually run a loop 2*N times, where N is the size of the given array.******\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>nge(n, -1);\\n        stack<int>st;\\n        for(int i=2*n-1; i>=0; i--)\\n        {\\n            while(!st.empty() && st.top()<=nums[i%n])\\n            {\\n                st.pop();\\n            }\\n\\n            if(i<n)\\n            {\\n                if(st.empty() == 0)\\n                {\\n                    nge[i] = st.top();\\n                }\\n                else\\n                nge[i] = -1;\\n                \\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n\\n        //TC = O(N)\\n        //SC = O(N)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>nge(n, -1);\\n        stack<int>st;\\n        for(int i=2*n-1; i>=0; i--)\\n        {\\n            while(!st.empty() && st.top()<=nums[i%n])\\n            {\\n                st.pop();\\n            }\\n\\n            if(i<n)\\n            {\\n                if(st.empty() == 0)\\n                {\\n                    nge[i] = st.top();\\n                }\\n                else\\n                nge[i] = -1;\\n                \\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n\\n        //TC = O(N)\\n        //SC = O(N)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791110,
                "title": "unlock-the-circular-puzzle-find-next-greater-elements",
                "content": "# Intuition:\\nThe approach to solving this problem involves using a stack to find the next greater element for each value in the circular array nums. We traverse the array in reverse order (from right to left) to account for the circular nature. For each element, we pop elements from the stack until we find an element that is greater than the current element. If there is no such element, we assign -1 as the next greater element for the current element. Otherwise, we assign the greater element as the next greater element for the current element. Finally, we reverse the result to maintain the original order of elements in the array.\\n\\n# Algorithm:\\n\\nInitialize an empty stack st to store elements while traversing the circular array in reverse order and an empty vector nqe to store the next greater elements for each value in nums.\\nTraverse the circular array nums in reverse order (from right to left) using a loop starting from 2*nums.size()-1 and decrementing by 1 in each iteration. This is done to handle the circular nature of the array, as the last element\\'s next greater element can be at the beginning of the array.\\nWhile traversing, for each element nums[i], do the following:\\na. While the stack is not empty and the current element nums[i%n] is greater than or equal to the top of the stack, pop elements from the stack. This step ensures that the stack only contains elements that are greater than nums[i%n], as we want to find the next greater element.\\nb. If the index i is less than n, it means we are in the original array, and we can directly access the top of the stack to find the next greater element. If the stack becomes empty after the while loop, it means there is no next greater element for the current element nums[i%n], so we assign -1 as the next greater element for this element in the vector nqe.\\nc. Otherwise, we are in the circular part of the array, and we need to search circularly for the next greater element. In this case, we push the next greater element\\'s value (found at the top of the stack) into the vector nqe.\\nd. Push the current element nums[i%n] onto the stack.\\nAfter completing the loop, the vector nqe will contain the next greater elements for each value in the circular array, taking the circular nature into account.\\nReverse the vector nqe to maintain the original order of elements in the array.\\nReturn the modified vector nqe as the final result.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm traverses the circular array once, which takes O(n) time, where n is the length of nums.\\n# Space Complexity:\\n The algorithm uses a stack to store at most n elements and a vector nqe to store the next greater elements, each of which takes O(n) extra space.\\n\\nOverall, the algorithm has a linear time complexity of O(n) and a linear space complexity of O(n). It efficiently finds the next greater element for each element in the circular array nums using a stack.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> nqe;\\n        stack<int> st;\\n        \\n          int n=nums.size();\\n        for(int i=2*nums.size()-1; i>=0; i--){\\n            while(!st.empty() && nums[i%n]>=st.top()){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(st.empty()==false){   \\n                nqe.push_back(st.top());\\n               }     else nqe.push_back(-1);\\n            }\\n            st.push(nums[i%n]);  \\n        }\\n        reverse(nqe.begin(),nqe.end());\\n            return nqe;\\n    }\\n};\\n```\\nIf you found my solution helpful, please consider upvoting it to show your appreciation! Your support motivates me to provide more helpful answers. Thank you!\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> nqe;\\n        stack<int> st;\\n        \\n          int n=nums.size();\\n        for(int i=2*nums.size()-1; i>=0; i--){\\n            while(!st.empty() && nums[i%n]>=st.top()){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(st.empty()==false){   \\n                nqe.push_back(st.top());\\n               }     else nqe.push_back(-1);\\n            }\\n            st.push(nums[i%n]);  \\n        }\\n        reverse(nqe.begin(),nqe.end());\\n            return nqe;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699198,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> nge(n,0);\\n        stack<int> st;\\n        for(int i=2*n-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]) st.pop();\\n            if(i<n){\\n                if(st.empty()) nge[i]=-1;\\n                else nge[i]=st.top();\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> nge(n,0);\\n        stack<int> st;\\n        for(int i=2*n-1;i>=0;i--){\\n            while(!st.empty() && st.top()<=nums[i%n]) st.pop();\\n            if(i<n){\\n                if(st.empty()) nge[i]=-1;\\n                else nge[i]=st.top();\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655445,
                "title": "using-stack-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack <Integer> s=new Stack<>();\\n        int nextGreater[]=new int[nums.length];\\n        for(int i=2*nums.length-1; i>=0; i--){\\n            while(!s.isEmpty() && s.peek()<=nums[i%nums.length]){\\n                s.pop();\\n            }\\n\\n            if(i<nums.length){\\n                if(!s.isEmpty()){\\n                nextGreater[i] = s.peek();\\n                }else{\\n                nextGreater[i]=-1;\\n            }\\n            }\\n\\n            s.push(nums[i%nums.length]);\\n        }\\n\\n        return nextGreater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack <Integer> s=new Stack<>();\\n        int nextGreater[]=new int[nums.length];\\n        for(int i=2*nums.length-1; i>=0; i--){\\n            while(!s.isEmpty() && s.peek()<=nums[i%nums.length]){\\n                s.pop();\\n            }\\n\\n            if(i<nums.length){\\n                if(!s.isEmpty()){\\n                nextGreater[i] = s.peek();\\n                }else{\\n                nextGreater[i]=-1;\\n            }\\n            }\\n\\n            s.push(nums[i%nums.length]);\\n        }\\n\\n        return nextGreater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643990,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n     int size=nums.size();\\n     vector<int> arr;\\n     for(int i=0;i<size;i++)\\n     {\\n         int element=-1;\\n         for(int j=(i+1)%size;i!=j;j=(j+1)%size)\\n         {\\n             if(nums[i]<nums[j])\\n             {\\n                element=nums[j];\\n                break; \\n             }\\n          }\\n          arr.push_back(element);\\n     }\\n     return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n     int size=nums.size();\\n     vector<int> arr;\\n     for(int i=0;i<size;i++)\\n     {\\n         int element=-1;\\n         for(int j=(i+1)%size;i!=j;j=(j+1)%size)\\n         {\\n             if(nums[i]<nums[j])\\n             {\\n                element=nums[j];\\n                break; \\n             }\\n          }\\n          arr.push_back(element);\\n     }\\n     return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602692,
                "title": "easy-to-understand-stack-brute-force-c",
                "content": "\\n\\n# Approach\\n- Brute force\\n- Using stack \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Brute force \\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> res(n,-1);\\n        \\n        for(int i=0;i<n;i++){ \\n            for(int j=i+1;j<2*n;j++){\\n                \\n                if(nums[j%n] > nums[i]){\\n                    res[i] = nums[j%n];  \\n                    break;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\n//using stack\\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        nums.resize(2*n);\\n        \\n        for(int i=n; i<2*n; i++){//concatenate the same array\\n            nums[i] = nums[i-n];\\n        }\\n        \\n        vector<int> res(n, -1); //to be returned, initialize it with -1\\n        stack<int> st;\\n        \\n        for(int i=0; i<2*n; i++){\\n            int element = nums[i];\\n            \\n            while(!st.empty() && element > nums[st.top()]){\\n\\t\\t\\t\\t//elemrent acts as NGE to the value at st.top()\\n                if(st.top() >= n){ //index should not exceed n\\n                    st.top() = st.top() - n;\\n                }\\n                \\n                res[st.top()] = element;\\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n//Brute force \\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> res(n,-1);\\n        \\n        for(int i=0;i<n;i++){ \\n            for(int j=i+1;j<2*n;j++){\\n                \\n                if(nums[j%n] > nums[i]){\\n                    res[i] = nums[j%n];  \\n                    break;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n//using stack\\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        nums.resize(2*n);\\n        \\n        for(int i=n; i<2*n; i++){//concatenate the same array\\n            nums[i] = nums[i-n];\\n        }\\n        \\n        vector<int> res(n, -1); //to be returned, initialize it with -1\\n        stack<int> st;\\n        \\n        for(int i=0; i<2*n; i++){\\n            int element = nums[i];\\n            \\n            while(!st.empty() && element > nums[st.top()]){\\n\\t\\t\\t\\t//elemrent acts as NGE to the value at st.top()\\n                if(st.top() >= n){ //index should not exceed n\\n                    st.top() = st.top() - n;\\n                }\\n                \\n                res[st.top()] = element;\\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508223,
                "title": "easiest-solution-using-max-and-stack",
                "content": "Let\\'s go through the code step by step:\\n\\nstack<int> st;: This line declares a stack data structure called st that will be used to store the indices of elements from the input vector.\\n\\nint n = nums.size();: This line stores the size of the input vector in the variable n.\\n\\nvector<int> ans(n, -1);: This line initializes the ans vector with n elements, all set to -1. This vector will store the next greater element for each element in the input vector.\\n\\nint maxI = max_element(nums.begin(), nums.end()) - nums.begin();: This line finds the index of the maximum element in the input vector nums using the max_element function from the <algorithm> library. It subtracts the beginning iterator of nums to get the index. This index will be used as a reference point for traversing the input vector.\\n\\nst.push(maxI);: This line pushes the index of the maximum element onto the stack st. This serves as a starting point for traversing the input vector.\\n\\nThe for loop from maxI - 1 to 0: This loop iterates from the element before the maximum element down to the first element of the input vector. It is used to find the next greater element for these elements.\\n\\nwhile(st.size() && nums[st.top()] <= nums[i]) st.pop();: This line checks if the stack st is not empty and if the current element nums[i] is greater than the element at the top of the stack. If both conditions are true, it means that the current element is the next greater element for the element at the top of the stack. Therefore, the element at the top of the stack is popped until a greater element is found or the stack becomes empty.\\n\\nif(!st.empty()) ans[i] = nums[st.top()];: This line checks if the stack st is not empty after the previous while loop. If it is not empty, it means that a greater element was found for the current element, so the value of the next greater element is stored in the ans vector at index i.\\n\\nst.push(i);: This line pushes the current index onto the stack st since it might be the next greater element for some subsequent elements.\\n\\nThe for loop from n - 1 to maxI + 1: This loop iterates from the element after the maximum element down to the element before the maximum element in the input vector. It is used to find the next greater element for these elements.\\n\\nThe logic inside this loop is similar to the previous for loop, where the next greater element is found and stored in the ans vector.\\nFinally, the ans vector is returned as the result of the function.\\n\\nIn summary, this code finds the next greater element for each element in the input vector by using a stack to keep track of potential next greater elements. It first finds the maximum element in the vector and then traverses the vector in two directions (from before and after the maximum element) to determine the next greater elements. The time complexity of this code is O(n), where n is the size of the input vector.\\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack <int> st; \\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        int maxI = max_element(nums.begin() , nums.end()) - nums.begin();\\n        \\n        st.push(maxI);\\n        for(int i = maxI - 1 ; i >= 0 ; --i){\\n            while(st.size() && nums[st.top()] <= nums[i])st.pop();\\n            if(!st.empty()){\\n                ans[i] = nums[st.top()];\\n            }\\n            st.push(i);\\n        }\\n        for(int i = n - 1 ; i > maxI  ; --i){\\n            while(st.size() && nums[st.top()] <= nums[i])st.pop();\\n            if(!st.empty()){\\n                ans[i] = nums[st.top()];\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        stack <int> st; \\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        int maxI = max_element(nums.begin() , nums.end()) - nums.begin();\\n        \\n        st.push(maxI);\\n        for(int i = maxI - 1 ; i >= 0 ; --i){\\n            while(st.size() && nums[st.top()] <= nums[i])st.pop();\\n            if(!st.empty()){\\n                ans[i] = nums[st.top()];\\n            }\\n            st.push(i);\\n        }\\n        for(int i = n - 1 ; i > maxI  ; --i){\\n            while(st.size() && nums[st.top()] <= nums[i])st.pop();\\n            if(!st.empty()){\\n                ans[i] = nums[st.top()];\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3401571,
                "title": "readable-c-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        int n = nums.size();\\n        for(int i = n - 1; i >= 0; i--){\\n            st.push(nums[i]);\\n        }\\n        for(int i = n - 1; i >= 0; i--){\\n            while(!st.empty() && st.top() <= nums[i]){\\n                st.pop();\\n            }\\n            if(st.size() == 0) res.push_back(-1);\\n            else res.push_back(st.top());\\n            st.push(nums[i]);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        int n = nums.size();\\n        for(int i = n - 1; i >= 0; i--){\\n            st.push(nums[i]);\\n        }\\n        for(int i = n - 1; i >= 0; i--){\\n            while(!st.empty() && st.top() <= nums[i]){\\n                st.pop();\\n            }\\n            if(st.size() == 0) res.push_back(-1);\\n            else res.push_back(st.top());\\n            st.push(nums[i]);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369245,
                "title": "next-greater-element-ii-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar nextGreaterElements = function (nums2) {\\n  const slicedArrayButLast = nums2.slice(0, nums2.length - 1)\\n  const updatedArray = [...nums2, ...slicedArrayButLast]\\n  const store = [updatedArray[updatedArray.length - 1]]\\n  const nextGreatElements = [-1]\\n  for (let index = updatedArray.length - 1 - 1; index >= 0; index--) {\\n    const tempStore = store[store.length - 1] > updatedArray[index]\\n    if (tempStore) {\\n      nextGreatElements.push(store[store.length - 1])\\n    } else {\\n      while (store[store.length - 1] <= updatedArray[index]) {\\n        store.pop()\\n        if (!store.length) {\\n          break\\n        }\\n      }\\n      if (!store.length) {\\n        nextGreatElements.push(-1)\\n      } else {\\n        nextGreatElements.push(store[store.length - 1])\\n      }\\n    }\\n    store.push(updatedArray[index])\\n  }\\n  nextGreatElements.reverse()\\n  return nextGreatElements.slice(0, nums2.length)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nvar nextGreaterElements = function (nums2) {\\n  const slicedArrayButLast = nums2.slice(0, nums2.length - 1)\\n  const updatedArray = [...nums2, ...slicedArrayButLast]\\n  const store = [updatedArray[updatedArray.length - 1]]\\n  const nextGreatElements = [-1]\\n  for (let index = updatedArray.length - 1 - 1; index >= 0; index--) {\\n    const tempStore = store[store.length - 1] > updatedArray[index]\\n    if (tempStore) {\\n      nextGreatElements.push(store[store.length - 1])\\n    } else {\\n      while (store[store.length - 1] <= updatedArray[index]) {\\n        store.pop()\\n        if (!store.length) {\\n          break\\n        }\\n      }\\n      if (!store.length) {\\n        nextGreatElements.push(-1)\\n      } else {\\n        nextGreatElements.push(store[store.length - 1])\\n      }\\n    }\\n    store.push(updatedArray[index])\\n  }\\n  nextGreatElements.reverse()\\n  return nextGreatElements.slice(0, nums2.length)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348767,
                "title": "easy-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAssume there are two array one by one.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] arr = new int[n];\\n        for(int i = 2 * n - 1; i >= 0 ; i--){\\n            while(!s.isEmpty() && s.peek() <= nums[i % n]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                arr[i % n] = -1;\\n            }\\n            else{\\n                arr[i % n] = s.peek();\\n            }\\n            s.push(nums[i % n]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] arr = new int[n];\\n        for(int i = 2 * n - 1; i >= 0 ; i--){\\n            while(!s.isEmpty() && s.peek() <= nums[i % n]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                arr[i % n] = -1;\\n            }\\n            else{\\n                arr[i % n] = s.peek();\\n            }\\n            s.push(nums[i % n]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330733,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Stack < Integer > st = new Stack < > ();\\n        for (int i = 2 * n - 1; i >= 0; i--) {\\n            while (st.isEmpty() == false && st.peek() <= nums[i%n]) {\\n                st.pop();\\n            }\\n\\n            if (i<n) {\\n                if (st.isEmpty() == false) ans[i] = st.peek();\\n                else ans[i] = -1;\\n            }\\n\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Stack < Integer > st = new Stack < > ();\\n        for (int i = 2 * n - 1; i >= 0; i--) {\\n            while (st.isEmpty() == false && st.peek() <= nums[i%n]) {\\n                st.pop();\\n            }\\n\\n            if (i<n) {\\n                if (st.isEmpty() == false) ans[i] = st.peek();\\n                else ans[i] = -1;\\n            }\\n\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311431,
                "title": "java-monotonically-increasing-stack",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a monotonically Increasing stack\\nFill the Stack from back of the Array\\nfind the next greater element for every element in the array that way\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N+ N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] nextGreaterElement = new int[n];\\n        /*\\n            we can use the same solution as the non circular array(ie. find the greater element only in the left)\\n            we just need to extend the array\\n\\n            [1, 2, 1 ] => [1, 2, 1 ,1, 2, 1]\\n            find next greater element of each element\\n                          [2, -1, 2, 2, -1, -1]\\n            the first three is the solution of the problem\\n            \\n        */\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 2*n-1; i >= 0; i--) {\\n            \\n            while(!stack.isEmpty() && stack.peek() <= nums[i%n]) stack.pop();\\n            if(i < n) {\\n                if(!stack.isEmpty()) {\\n                    nextGreaterElement[i] = stack.peek();\\n                } else {\\n                    nextGreaterElement[i] = -1;\\n                }\\n            }\\n            stack.push(nums[i%n]);\\n        }\\n        return nextGreaterElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] nextGreaterElement = new int[n];\\n        /*\\n            we can use the same solution as the non circular array(ie. find the greater element only in the left)\\n            we just need to extend the array\\n\\n            [1, 2, 1 ] => [1, 2, 1 ,1, 2, 1]\\n            find next greater element of each element\\n                          [2, -1, 2, 2, -1, -1]\\n            the first three is the solution of the problem\\n            \\n        */\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 2*n-1; i >= 0; i--) {\\n            \\n            while(!stack.isEmpty() && stack.peek() <= nums[i%n]) stack.pop();\\n            if(i < n) {\\n                if(!stack.isEmpty()) {\\n                    nextGreaterElement[i] = stack.peek();\\n                } else {\\n                    nextGreaterElement[i] = -1;\\n                }\\n            }\\n            stack.push(nums[i%n]);\\n        }\\n        return nextGreaterElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278057,
                "title": "c-easy-brute-force-approach-and-optimized-using-stack",
                "content": "# BRUTE FORCE (TLE)\\n```\\nclass Solution {\\npublic:\\nvector<int>ans;\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    for(int i=0;i<nums.size();i++){\\n        int num=nums[i];\\n        int count=0;\\n        int j=i;\\n        while(count<nums.size()){\\n            cout<<nums[j]<<\"  \"<<num<<endl;\\n            if(nums[j]>num) {\\n           ans.push_back(nums[j]);\\n           break ;\\n            }\\n            if(j == nums.size()-1) j=-1;\\n              j++;\\n            count++;\\n        }\\n        if(count == nums.size()) ans.push_back(-1);\\n    }\\n    return ans;\\n            }\\n};\\n\\n\\n```\\n# USING STACK\\n```\\nclass Solution {\\npublic:\\nvector<int>ans;\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int>st;\\n    for(int i=2*n-1;i>=0;i--)\\n    {\\n        while(st.empty()==false && nums[i%n]>=st.top())\\n        {\\n            st.pop();\\n        }\\n        \\n        if(i<n)\\n        {\\n            if(st.empty()==false)\\n            {\\n                ans.push_back(st.top());\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        st.push(nums[i%n]);\\n    }\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n            }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>ans;\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n    for(int i=0;i<nums.size();i++){\\n        int num=nums[i];\\n        int count=0;\\n        int j=i;\\n        while(count<nums.size()){\\n            cout<<nums[j]<<\"  \"<<num<<endl;\\n            if(nums[j]>num) {\\n           ans.push_back(nums[j]);\\n           break ;\\n            }\\n            if(j == nums.size()-1) j=-1;\\n              j++;\\n            count++;\\n        }\\n        if(count == nums.size()) ans.push_back(-1);\\n    }\\n    return ans;\\n            }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\nvector<int>ans;\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int>st;\\n    for(int i=2*n-1;i>=0;i--)\\n    {\\n        while(st.empty()==false && nums[i%n]>=st.top())\\n        {\\n            st.pop();\\n        }\\n        \\n        if(i<n)\\n        {\\n            if(st.empty()==false)\\n            {\\n                ans.push_back(st.top());\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        st.push(nums[i%n]);\\n    }\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n            }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3139025,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        stack<int>indst;        \\n        for(int i=0;i<n;i++){         \\n            if(indst.size()!=0){\\n                while(indst.size()>0 && nums[indst.top()]<nums[i]){\\n                    int ind=indst.top();\\n                    ans[ind]=nums[i];\\n                    indst.pop();\\n                }\\n            }\\n            indst.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(indst.size()!=0){\\n                while(indst.size()>0 && nums[indst.top()]<nums[i]){\\n                    int ind=indst.top();\\n                    ans[ind]=nums[i];\\n                    indst.pop();\\n                }\\n            }\\n        }\\n        while(indst.size()!=0){\\n            ans[indst.top()]=-1;\\n            indst.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        stack<int>indst;        \\n        for(int i=0;i<n;i++){         \\n            if(indst.size()!=0){\\n                while(indst.size()>0 && nums[indst.top()]<nums[i]){\\n                    int ind=indst.top();\\n                    ans[ind]=nums[i];\\n                    indst.pop();\\n                }\\n            }\\n            indst.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(indst.size()!=0){\\n                while(indst.size()>0 && nums[indst.top()]<nums[i]){\\n                    int ind=indst.top();\\n                    ans[ind]=nums[i];\\n                    indst.pop();\\n                }\\n            }\\n        }\\n        while(indst.size()!=0){\\n            ans[indst.top()]=-1;\\n            indst.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973382,
                "title": "c-solution-with-explanation-one-stack-beats-99-61",
                "content": "Approach:\\n\\nKey to solve this is start with greatest element and then apply algorithm of finding \"Next Greater Element\"\\n\\nStep 1: Find index with greatest element. i.e. max_idx\\n\\t\\tmake Next greatest of greatest element as -1 (as it is the greatest element from array\\nStep 2: Insert greatest element in stack\\n\\t\\tStart traversing in opposite direction i.e. right to left from max_idx (say curr_idx = max_idx)\\nStep 3: pop the element from stack until we don\\'t find greater element than curr element\\nStep 4: decrement curr_idx, if it becomes -1, initialize to nums.size() -1 as array is circular\\nStep 5: repeat step 3 and 4 until we reach the index with greatest number i.e. to initial position.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n       \\n        int curr_max = INT_MIN;\\n        int max_idx =0;\\n        \\n        for (int i =0; i < nums.size(); i++)\\n        {\\n            if (nums[i] > curr_max) {\\n                curr_max= nums[i];\\n                max_idx = i;\\n            }\\n        }\\n        \\n        vector<int> result(nums.size());\\n        result[max_idx] = -1;\\n        int curr_idx = max_idx - 1; \\n         \\n        stack<int> s;\\n        s.push(curr_max);\\n        \\n        while(curr_idx != max_idx) {\\n            \\n            if (curr_idx == -1)\\n                curr_idx = nums.size() -1;\\n           \\n            while(!s.empty() && s.top() <= nums[curr_idx]) {\\n                s.pop();\\n            }\\n            \\n            if (s.empty())\\n                result[curr_idx] = -1;\\n            else \\n                result[curr_idx] = s.top();\\n            \\n            s.push(nums[curr_idx]);\\n            \\n            curr_idx--;\\n            if (curr_idx == -1)\\n                curr_idx = nums.size() -1;\\n\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n       \\n        int curr_max = INT_MIN;\\n        int max_idx =0;\\n        \\n        for (int i =0; i < nums.size(); i++)\\n        {\\n            if (nums[i] > curr_max) {\\n                curr_max= nums[i];\\n                max_idx = i;\\n            }\\n        }\\n        \\n        vector<int> result(nums.size());\\n        result[max_idx] = -1;\\n        int curr_idx = max_idx - 1; \\n         \\n        stack<int> s;\\n        s.push(curr_max);\\n        \\n        while(curr_idx != max_idx) {\\n            \\n            if (curr_idx == -1)\\n                curr_idx = nums.size() -1;\\n           \\n            while(!s.empty() && s.top() <= nums[curr_idx]) {\\n                s.pop();\\n            }\\n            \\n            if (s.empty())\\n                result[curr_idx] = -1;\\n            else \\n                result[curr_idx] = s.top();\\n            \\n            s.push(nums[curr_idx]);\\n            \\n            curr_idx--;\\n            if (curr_idx == -1)\\n                curr_idx = nums.size() -1;\\n\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934859,
                "title": "java-easy-stack-imaginary-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have been Provided with **Crircular Queue** so instead of creating new array and doubling its size for **next graeter element** its better we create a imaginary array . Playing with N(size) and we will extensilvely use **%** here. Just Dry run it!!\\n\\n\\n# Complexity\\n- Time complexity: $$O(2n+2n)$$ i.e.$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        Stack<Integer> stack=new Stack<>();\\n        int n= nums.length;\\n        for (int i = (2*n)-1; i >=0; i--) {\\n            while (!stack.isEmpty() && stack.peek()<=nums[i%n]){\\n                stack.pop();\\n            }\\n            if (i<n){\\n                if (!stack.isEmpty()){\\n                    ans[i]=stack.peek();\\n                }else {\\n                    ans[i]=-1;\\n                }\\n            }\\n            stack.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        Stack<Integer> stack=new Stack<>();\\n        int n= nums.length;\\n        for (int i = (2*n)-1; i >=0; i--) {\\n            while (!stack.isEmpty() && stack.peek()<=nums[i%n]){\\n                stack.pop();\\n            }\\n            if (i<n){\\n                if (!stack.isEmpty()){\\n                    ans[i]=stack.peek();\\n                }else {\\n                    ans[i]=-1;\\n                }\\n            }\\n            stack.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886166,
                "title": "c-easy-to-understand-stack-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(int i=0; i<2*n; i++){\\n            while(!s.empty() && nums[i%n]>nums[s.top()]){\\n                v[s.top()] = nums[i%n];\\n                s.pop();\\n            }\\n            if(i<n){\\n                s.push(i%n);\\n            }\\n        }\\n        while(!s.empty()){\\n            v[s.top()]=-1;\\n            s.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(int i=0; i<2*n; i++){\\n            while(!s.empty() && nums[i%n]>nums[s.top()]){\\n                v[s.top()] = nums[i%n];\\n                s.pop();\\n            }\\n            if(i<n){\\n                s.push(i%n);\\n            }\\n        }\\n        while(!s.empty()){\\n            v[s.top()]=-1;\\n            s.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754164,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n    vector<int> vec;\\n         \\n    for(int i=0;i<nums.size();i++){\\n        \\n        bool flag=false;\\n        int k=i+1;\\n       int idx=INT_MIN;\\n        \\n        while(idx!=i){\\n            \\n            idx=k%nums.size();\\n            if(nums[idx]>nums[i]){\\n                flag=true;\\n                vec.push_back(nums[idx]);\\n                break;\\n            }\\n            k++;\\n           \\n        }\\n         if(!flag) vec.push_back(-1);\\n    }\\n        return vec;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n    vector<int> vec;\\n         \\n    for(int i=0;i<nums.size();i++){\\n        \\n        bool flag=false;\\n        int k=i+1;\\n       int idx=INT_MIN;\\n        \\n        while(idx!=i){\\n            \\n            idx=k%nums.size();\\n            if(nums[idx]>nums[i]){\\n                flag=true;\\n                vec.push_back(nums[idx]);\\n                break;\\n            }\\n            k++;\\n           \\n        }\\n         if(!flag) vec.push_back(-1);\\n    }\\n        return vec;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701693,
                "title": "java-easy-fast",
                "content": "\\t**Inution: since they\\'ve mentioned it\\'s a circular array we could\\'ve used linkedList but that would add more complexity instead we could perform the following steps:\\n\\t1. Store all the elements in reverse order in stack that is from nums.length-2(exclude the last element) till zero.\\n\\t2. So that we can access all next elements of the current element \\n\\t3. if the value which is at the top of the stack is greater than current element then put it in array and push it on top of the stack\\n\\t4. else remove all the elements until we find a element greater than current element\\n\\t5. if the stack is empty that indicates there is no greater element than current elment, so we put -1\\n\\t6. else if the element top of the stack is greater than current element put it in array and push the current element on top of the stack, so that current element may be the next greater element of oncoming elements\\n\\t\\t\\n\\t****DO LIKE IF IT HELPS :D****\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tpublic int[] nextGreaterElements(int[] nums) {\\n         Stack<Integer> s = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for (int i = nums.length-2; i >=0 ; i--) {\\n            s.push(nums[i]);\\n        }\\n\\n        for (int i = nums.length-1; i >=0 ; i--) {\\n            if(!s.isEmpty() && nums[i]<s.peek()){\\n                res[i]=s.peek();\\n                s.push(nums[i]);\\n            }\\n            else {\\n                while (!s.isEmpty() && nums[i]>=s.peek()){\\n                    s.pop();\\n                }\\n                if(s.isEmpty())res[i]=-1;\\n                else res[i]=s.peek();\\n                s.push(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "\\t**Inution: since they\\'ve mentioned it\\'s a circular array we could\\'ve used linkedList but that would add more complexity instead we could perform the following steps:\\n\\t1. Store all the elements in reverse order in stack that is from nums.length-2(exclude the last element) till zero.\\n\\t2. So that we can access all next elements of the current element \\n\\t3. if the value which is at the top of the stack is greater than current element then put it in array and push it on top of the stack\\n\\t4. else remove all the elements until we find a element greater than current element\\n\\t5. if the stack is empty that indicates there is no greater element than current elment, so we put -1\\n\\t6. else if the element top of the stack is greater than current element put it in array and push the current element on top of the stack, so that current element may be the next greater element of oncoming elements\\n\\t\\t\\n\\t****DO LIKE IF IT HELPS :D****\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tpublic int[] nextGreaterElements(int[] nums) {\\n         Stack<Integer> s = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for (int i = nums.length-2; i >=0 ; i--) {\\n            s.push(nums[i]);\\n        }\\n\\n        for (int i = nums.length-1; i >=0 ; i--) {\\n            if(!s.isEmpty() && nums[i]<s.peek()){\\n                res[i]=s.peek();\\n                s.push(nums[i]);\\n            }\\n            else {\\n                while (!s.isEmpty() && nums[i]>=s.peek()){\\n                    s.pop();\\n                }\\n                if(s.isEmpty())res[i]=-1;\\n                else res[i]=s.peek();\\n                s.push(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2687402,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> s = new Stack<Integer>();\\n        int[] answer = new int[nums.length];\\n        int i=1;\\n        s.push(0);\\n        \\n        while(i<nums.length) \\n        {\\n            if(!s.isEmpty())\\n            {\\n                if(nums[s.peek()]>=nums[i])\\n                {\\n                    s.push(i);\\n                }else\\n                {\\n                    answer[s.pop()]=nums[i];\\n                    continue;\\n                }\\n            }else\\n            {\\n                s.push(i);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        i=0;\\n        \\n        while(!s.isEmpty() && i<nums.length)\\n        {\\n            \\n            if(nums[i]>nums[s.peek()])\\n            {\\n                answer[s.pop()]=nums[i];\\n                \\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n       \\n        while(!s.isEmpty())\\n            answer[s.pop()]=-1;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        Stack<Integer> s = new Stack<Integer>();\\n        int[] answer = new int[nums.length];\\n        int i=1;\\n        s.push(0);\\n        \\n        while(i<nums.length) \\n        {\\n            if(!s.isEmpty())\\n            {\\n                if(nums[s.peek()]>=nums[i])\\n                {\\n                    s.push(i);\\n                }else\\n                {\\n                    answer[s.pop()]=nums[i];\\n                    continue;\\n                }\\n            }else\\n            {\\n                s.push(i);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        i=0;\\n        \\n        while(!s.isEmpty() && i<nums.length)\\n        {\\n            \\n            if(nums[i]>nums[s.peek()])\\n            {\\n                answer[s.pop()]=nums[i];\\n                \\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n       \\n        while(!s.isEmpty())\\n            answer[s.pop()]=-1;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673701,
                "title": "using-o-n-extra-space-within-time-o-n-simple-and-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        int k = n;\\n        for(i = 0; i < n-1; i++){\\n            nums.push_back(nums[i]);\\n        }\\n        stack<int> s;\\n        n = nums.size();\\n        vector<int> ans(n,-1);\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty() && s.top()<=nums[i]){\\n                s.pop();\\n            }\\n            if(!s.empty()){\\n                ans[i] = s.top();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return vector(ans.begin(),ans.begin()+k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        int k = n;\\n        for(i = 0; i < n-1; i++){\\n            nums.push_back(nums[i]);\\n        }\\n        stack<int> s;\\n        n = nums.size();\\n        vector<int> ans(n,-1);\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty() && s.top()<=nums[i]){\\n                s.pop();\\n            }\\n            if(!s.empty()){\\n                ans[i] = s.top();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return vector(ans.begin(),ans.begin()+k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596284,
                "title": "very-simple-solution-o-n-tc-python",
                "content": "class Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n\\t\\n        n=len(nums)\\n        ans=[]\\n        \\n        for i in range(2*n-1,-1,-1):\\n            num=nums[i%n]\\n            index=i+1\\n            \\n            while len(ans)>0 and ans[-1]<=num:\\n                ans.pop(-1)\\n            \\n            if i<n:\\n                if len(ans)==0:\\n                    nums[i]=-1\\n                \\n                else:\\n                    nums[i]=ans[-1]\\n             \\n            ans.append(num)\\n          \\n        return nums",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "class Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n\\t\\n        n=len(nums)\\n        ans=[]\\n        \\n        for i in range(2*n-1,-1,-1):\\n            num=nums[i%n]\\n            index=i+1\\n            \\n            while len(ans)>0 and ans[-1]<=num:\\n                ans.pop(-1)\\n            \\n            if i<n:\\n                if len(ans)==0:\\n                    nums[i]=-1\\n                \\n                else:\\n                    nums[i]=ans[-1]\\n             \\n            ans.append(num)\\n          \\n        return nums",
                "codeTag": "Java"
            },
            {
                "id": 2517214,
                "title": "java-better-brute-force-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i]=-1;\\n            for(int j=1;j<nums.length;j++){\\n                if(nums[(i+j)%nums.length]>nums[i]){\\n                    arr[i]=nums[(i+j)%nums.length];\\n                    break;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i]=-1;\\n            for(int j=1;j<nums.length;j++){\\n                if(nums[(i+j)%nums.length]>nums[i]){\\n                    arr[i]=nums[(i+j)%nums.length];\\n                    break;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474420,
                "title": "solved-using-javascript-with-only-one-while-loop",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst nextGreaterElements = function(nums) {\\n    let i = 0\\n    let output = []\\n    \\n    const incrementIndex = (index) => index === nums.length - 1 ? 0 : index + 1\\n    \\n    let startIndex = incrementIndex(i)\\n    \\n    while(output.length < nums.length) {\\n        if(nums[startIndex] > nums[i]) {\\n            output.push(nums[startIndex])\\n            i = incrementIndex(i)\\n            startIndex = incrementIndex(i)\\n        } else {\\n            if(startIndex !== i) {\\n                startIndex = incrementIndex(startIndex)\\n            } else {\\n                output.push(-1)\\n                i = incrementIndex(i)\\n                startIndex = incrementIndex(i)\\n            }\\n        } \\n    }\\n    \\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst nextGreaterElements = function(nums) {\\n    let i = 0\\n    let output = []\\n    \\n    const incrementIndex = (index) => index === nums.length - 1 ? 0 : index + 1\\n    \\n    let startIndex = incrementIndex(i)\\n    \\n    while(output.length < nums.length) {\\n        if(nums[startIndex] > nums[i]) {\\n            output.push(nums[startIndex])\\n            i = incrementIndex(i)\\n            startIndex = incrementIndex(i)\\n        } else {\\n            if(startIndex !== i) {\\n                startIndex = incrementIndex(startIndex)\\n            } else {\\n                output.push(-1)\\n                i = incrementIndex(i)\\n                startIndex = incrementIndex(i)\\n            }\\n        } \\n    }\\n    \\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347587,
                "title": "c-90-easiest-way-striver-way",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> s;\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=2*n-1;i>=0;i--){\\n               while(!s.empty() && s.top()<=nums[i%n]){\\n                   s.pop();\\n               }\\n               if(i<n){\\n               if(s.empty()) ans.push_back(-1);\\n               else ans.push_back(s.top());}\\n            s.push(nums[i%n]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> s;\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=2*n-1;i>=0;i--){\\n               while(!s.empty() && s.top()<=nums[i%n]){\\n                   s.pop();\\n               }\\n               if(i<n){\\n               if(s.empty()) ans.push_back(-1);\\n               else ans.push_back(s.top());}\\n            s.push(nums[i%n]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2345172,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\nAuthor : https://github.com/RajaKunalPandit1\\n\\n// Naive Solution :: Time : O(N^2) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<2*n;j++){\\n                \\n                if(nums[j%n] > nums[i]){\\n                    res[i] = nums[j%n];  \\n                    break;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(2N + 2N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        stack<int> st;\\n        \\n        vector<int> res(n,-1);\\n        \\n        for(int i=2*n-1;i>=0;i--){\\n            \\n            while(!st.empty() && nums[i%n] >= st.top()){\\n                st.pop();\\n            }\\n            \\n            if(i<n){\\n                if(st.empty() == false) \\n                    res[i] = st.top();\\n            }\\n            st.push(nums[i%n]);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=i+1;j<2*n;j++){\\n                \\n                if(nums[j%n] > nums[i]){\\n                    res[i] = nums[j%n];  \\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2307090,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        // declare variables\\n        int n = nums.size();\\n        vector<int> arr = nums;\\n        vector<int> b = nums;\\n        sort(b.begin(), b.end());\\n        int largest = b[n-1];\\n        int index = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n\\n                index = i+1;\\n            \\n                if(i == n-1) {\\n                    index = 0;\\n                }\\n            \\n                if(nums[i] != largest) {\\n                    \\n                    while(nums[i] >= arr[index]) {\\n\\n                    if(index == n-1) {\\n                        index = 0;\\n                    }\\n                    else   \\n                      index++;\\n                    }\\n\\n                    nums[i] = arr[index];\\n                    \\n                } else nums[i] = -1;\\n\\n            }\\n           return nums;\\n        }           \\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        // declare variables\\n        int n = nums.size();\\n        vector<int> arr = nums;\\n        vector<int> b = nums;\\n        sort(b.begin(), b.end());\\n        int largest = b[n-1];\\n        int index = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n\\n                index = i+1;\\n            \\n                if(i == n-1) {\\n                    index = 0;\\n                }\\n            \\n                if(nums[i] != largest) {\\n                    \\n                    while(nums[i] >= arr[index]) {\\n\\n                    if(index == n-1) {\\n                        index = 0;\\n                    }\\n                    else   \\n                      index++;\\n                    }\\n\\n                    nums[i] = arr[index];\\n                    \\n                } else nums[i] = -1;\\n\\n            }\\n           return nums;\\n        }           \\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182797,
                "title": "python3-onepass-o-n-o-n-runtime-323ms-48-44-memory-15-7mb-65-00",
                "content": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 323ms 48.44% Memory: 15.7mb 65.00%\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        result = [-1] * len(nums)\\n\\n        stack = list()\\n\\n        for i in range(2*len(nums)):\\n\\n            circularIdx = i % len(nums)\\n\\n            while len(stack) > 0 and nums[stack[len(stack)-1]] < nums[circularIdx]:\\n                top = stack.pop()\\n                result[top] = nums[circularIdx]\\n\\n            stack.append(circularIdx)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 323ms 48.44% Memory: 15.7mb 65.00%\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        result = [-1] * len(nums)\\n\\n        stack = list()\\n\\n        for i in range(2*len(nums)):\\n\\n            circularIdx = i % len(nums)\\n\\n            while len(stack) > 0 and nums[stack[len(stack)-1]] < nums[circularIdx]:\\n                top = stack.pop()\\n                result[top] = nums[circularIdx]\\n\\n            stack.append(circularIdx)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155580,
                "title": "c-without-using-stack-easy-to-understand-self-explanatory-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int flag=0;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            flag=0;\\n            int ele=nums[i];\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>ele)\\n                {\\n                   \\n                    arr[i]=nums[j];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n           \\n            if(flag==0)\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(nums[j]>ele)\\n                    {\\n                        arr[i]=nums[j];\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                flag=1;\\n                arr[i]=-1;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int flag=0;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            flag=0;\\n            int ele=nums[i];\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>ele)\\n                {\\n                   \\n                    arr[i]=nums[j];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n           \\n            if(flag==0)\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(nums[j]>ele)\\n                    {\\n                        arr[i]=nums[j];\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                flag=1;\\n                arr[i]=-1;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142570,
                "title": "c-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        \\n        vector<int> res(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.empty()==false and st.top()<=nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(!st.empty()){\\n                res[i]=st.top();\\n            }\\n            \\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        \\n        vector<int> res(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.empty()==false and st.top()<=nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(!st.empty()){\\n                res[i]=st.top();\\n            }\\n            \\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094675,
                "title": "c-very-easy-solution-o-n-complexity",
                "content": "***same easy question like 496 ,just add the same array after the last index;***\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st;\\n        vector<int>ans(nums.size(),-1);\\n        for(int x=0;x<nums.size()*2;x++){\\n            int i=x%nums.size();\\n            while(st.size()&&nums[st.top()]<nums[i]){\\n                ans[st.top()]=nums[i];\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# upvote if u like it .******``\\n\\n",
                "solutionTags": [
                    "Array",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>st;\\n        vector<int>ans(nums.size(),-1);\\n        for(int x=0;x<nums.size()*2;x++){\\n            int i=x%nums.size();\\n            while(st.size()&&nums[st.top()]<nums[i]){\\n                ans[st.top()]=nums[i];\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015950,
                "title": "c-stack-based-solution-efficient-solution-o-n-o-n-2",
                "content": "1. **O(N) Solution Using Stack [C++]**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n         int n = nums.size();\\n        stack<int> st;\\n        vector<int> v(n);\\n        \\n        \\n        // We have to find it in curcularly so we will push all element in stack in reverse order\\n\\t\\t// For Example we have nums=[1,2,3,4,3] our stack would be  from top to bottom [1,2,3,4,3]\\n        for(int i=n-1;i>=0;i--)\\n        st.push(nums[i]);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n\\t\\t\\t// Removing top element from stack untill greater top element found or empty stack.\\n\\t\\t\\twhile(!st.empty() && st.top() <= nums[i]) \\n            st.pop();\\n            \\n\\t\\t\\t// If our stack is not empty then top element of stack is next greater element\\n            if(!st.empty())\\n                v[i] = st.top();\\n\\t\\t\\telse    // if stack is empty then no next greater elemet so we will assign -1\\n                v[i] = -1;\\n            \\n            st.push(nums[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\\n2. **O(N^2) in Worst Case**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,-1);\\n        stack<int> s;\\n        s.push(nums[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!s.empty() && s.top()<=nums[i])\\n                s.pop();\\n            \\n            if(!s.empty())\\n                v[i]=s.top();\\n            \\n            s.push(nums[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                for(int j=i+1;j<i+n;j++)\\n                {\\n                    if(nums[i]<nums[j%n])\\n                    {\\n                        v[i]=nums[j%n];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return v;      \\n    }\\n};\\n```\\n# **If you find it helpful kindly UPVOTE**\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n         int n = nums.size();\\n        stack<int> st;\\n        vector<int> v(n);\\n        \\n        \\n        // We have to find it in curcularly so we will push all element in stack in reverse order\\n\\t\\t// For Example we have nums=[1,2,3,4,3] our stack would be  from top to bottom [1,2,3,4,3]\\n        for(int i=n-1;i>=0;i--)\\n        st.push(nums[i]);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n\\t\\t\\t// Removing top element from stack untill greater top element found or empty stack.\\n\\t\\t\\twhile(!st.empty() && st.top() <= nums[i]) \\n            st.pop();\\n            \\n\\t\\t\\t// If our stack is not empty then top element of stack is next greater element\\n            if(!st.empty())\\n                v[i] = st.top();\\n\\t\\t\\telse    // if stack is empty then no next greater elemet so we will assign -1\\n                v[i] = -1;\\n            \\n            st.push(nums[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,-1);\\n        stack<int> s;\\n        s.push(nums[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!s.empty() && s.top()<=nums[i])\\n                s.pop();\\n            \\n            if(!s.empty())\\n                v[i]=s.top();\\n            \\n            s.push(nums[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                for(int j=i+1;j<i+n;j++)\\n                {\\n                    if(nums[i]<nums[j%n])\\n                    {\\n                        v[i]=nums[j%n];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return v;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012006,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\nconst nextGreaterElements = function(nums, count = nums.length, result = []) {\\n\\tconst stack = [];\\n    \\n    const check = (i) => {\\n        while (stack.length > 0 && nums[i] >= nums[stack[stack.length - 1]]) {\\n            stack.pop();\\n        }\\n        return stack.length ? nums[stack[stack.length - 1]] : -1;\\n    }\\n\\n\\tfor (let key = 2 * (count - 1); key >= 0; key--) {\\n\\t\\tlet index = key % count;\\n\\n        result[index] = check(index);\\n\\t\\tstack.push(index);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst nextGreaterElements = function(nums, count = nums.length, result = []) {\\n\\tconst stack = [];\\n    \\n    const check = (i) => {\\n        while (stack.length > 0 && nums[i] >= nums[stack[stack.length - 1]]) {\\n            stack.pop();\\n        }\\n        return stack.length ? nums[stack[stack.length - 1]] : -1;\\n    }\\n\\n\\tfor (let key = 2 * (count - 1); key >= 0; key--) {\\n\\t\\tlet index = key % count;\\n\\n        result[index] = check(index);\\n\\t\\tstack.push(index);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2007841,
                "title": "supereasytounderstand",
                "content": "```\\nstack<int> st;\\n        int n=arr.size();\\n        vector<int> a(n);\\n        for(int i=n-1;i>=0;i--)\\n            st.push(arr[i]);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( !st.empty() && st.top()<=arr[i] )\\n                st.pop();\\n            if(st.empty())\\n                a[i]=-1;\\n            else\\n                a[i]=st.top();\\n            st.push(arr[i]);\\n\\n        }\\n        return a;\\n```",
                "solutionTags": [],
                "code": "```\\nstack<int> st;\\n        int n=arr.size();\\n        vector<int> a(n);\\n        for(int i=n-1;i>=0;i--)\\n            st.push(arr[i]);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( !st.empty() && st.top()<=arr[i] )\\n                st.pop();\\n            if(st.empty())\\n                a[i]=-1;\\n            else\\n                a[i]=st.top();\\n            st.push(arr[i]);\\n\\n        }\\n        return a;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885507,
                "title": "c-solution-using-stack-o-2n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res(nums.size());\\n        \\n        for(int i = nums.size()-1; i >= 0; i--)\\n            st.push(nums[i]);\\n        \\n        for(int i = nums.size()-1; i >= 0; i--){\\n            while(!st.empty() && st.top() <= nums[i])\\n                st.pop();\\n            \\n            if(st.empty()) res[i] = -1;\\n            else res[i] = st.top();\\n            \\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res(nums.size());\\n        \\n        for(int i = nums.size()-1; i >= 0; i--)\\n            st.push(nums[i]);\\n        \\n        for(int i = nums.size()-1; i >= 0; i--){\\n            while(!st.empty() && st.top() <= nums[i])\\n                st.pop();\\n            \\n            if(st.empty()) res[i] = -1;\\n            else res[i] = st.top();\\n            \\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867162,
                "title": "java-solution",
                "content": "Most of the solutions I saw are from right to left. Wanted to see if I can solve it left to right.\\n\\nWe could prefill the result array with -1. That should take care of this in a simpler way.\\n\\nOnly trade off is the prefill is another O(N) operation.\\n\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        \\n        Arrays.fill(result, -1);\\n        \\n        Stack<Integer> stack = new Stack();\\n        for(int i = 0; i < 2 * len; i++) {\\n            int idx = i % len;\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[idx]) {\\n                result[stack.pop()] = nums[idx];\\n            }\\n            \\n            stack.push(idx);\\n        }\\n        \\n        return result;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        \\n        Arrays.fill(result, -1);\\n        \\n        Stack<Integer> stack = new Stack();\\n        for(int i = 0; i < 2 * len; i++) {\\n            int idx = i % len;\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[idx]) {\\n                result[stack.pop()] = nums[idx];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1843145,
                "title": "c-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        stack<int> st;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            // if current element is greater than stack top then insert it and pop top of stack\\n            while(st.size()>0 && st.top() <=nums[i]) \\n            {\\n               st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(st.size()>0 && st.top() <=nums[i]) \\n            {\\n               st.pop();\\n            }\\n            // if stack is empty then no greater element then add -1 else stack top\\n            ans[i] = st.size() == 0?-1 : st.top();\\n            st.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        stack<int> st;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            // if current element is greater than stack top then insert it and pop top of stack\\n            while(st.size()>0 && st.top() <=nums[i]) \\n            {\\n               st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(st.size()>0 && st.top() <=nums[i]) \\n            {\\n               st.pop();\\n            }\\n            // if stack is empty then no greater element then add -1 else stack top\\n            ans[i] = st.size() == 0?-1 : st.top();\\n            st.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796107,
                "title": "c-o-n-time-and-space-n-stack-explanation-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n = nums.size();\\n         vector<int> ans(n);\\n        for(int i = 2*n-1; i>=0; i--)\\n            //here we are actually traversing in array two times\\n            //lets say we had an array of [1,2,3,4,3] but technically we are traversing in [1,2,3,4,3,1,2,3,4,3] array (and again this is possible using %n )\\n            \\n            //so think carefully and dry run properly!\\n        {\\n            while(!st.empty() && st.top()<=nums[i%n]) st.pop();\\n            if(st.empty()) ans[i%n] = -1;\\n            else ans[i%n] = st.top();\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n = nums.size();\\n         vector<int> ans(n);\\n        for(int i = 2*n-1; i>=0; i--)\\n            //here we are actually traversing in array two times\\n            //lets say we had an array of [1,2,3,4,3] but technically we are traversing in [1,2,3,4,3,1,2,3,4,3] array (and again this is possible using %n )\\n            \\n            //so think carefully and dry run properly!\\n        {\\n            while(!st.empty() && st.top()<=nums[i%n]) st.pop();\\n            if(st.empty()) ans[i%n] = -1;\\n            else ans[i%n] = st.top();\\n            st.push(nums[i%n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782284,
                "title": "short-clean-java-solution",
                "content": "**Time Complexity O(n^2)**\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            res[i] = -1;\\n            int j = i;\\n            while(j++ < i+nums.length){\\n                if(nums[i] < nums[j%nums.length]){\\n                   res[i] = nums[j%nums.length];\\n                   break;\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            res[i] = -1;\\n            int j = i;\\n            while(j++ < i+nums.length){\\n                if(nums[i] < nums[j%nums.length]){\\n                   res[i] = nums[j%nums.length];\\n                   break;\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780481,
                "title": "simple-java-solution-using-stack-loop-twice",
                "content": "It is just an extension of next greater element. here since we need to consider circular array it means if for any element greater element is not present at right it is possible that it is present on left.\\nso in first iteration we will keep logic as same as next greater element problem just we dont start preparing answer. rest remain same.\\nwhy? because in this after first iteration, stack will have data in exact order which we want when we want to compare elements again. i.e. stack top will point to 0 index element.\\nso now when we agian iterate from right to left. we have some data already on stack on whcih we can run exact same logic to check.\\ne.g. ->\\n[4,2,3]\\nafter first loop stack will have only element 4. as 2 and 3 from stack is deleted when 4 is inspected.\\n```\\npublic int[] nextGreaterElements(int[] nums) {\\n\\t\\tDeque<Integer> stack = new LinkedList<>();\\n\\t\\tstack.push(nums[nums.length - 1]);\\n\\t\\tint[] nge = new int[nums.length];\\n\\t\\tnge[nums.length - 1] = -1;\\n\\t\\tfor (int i = nums.length - 2; i >= 0; i--) {\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() <= nums[i]) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = nums.length - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() <= nums[i]) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (stack.isEmpty()) {\\n\\t\\t\\t\\tnge[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnge[i] = stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\t\\t}\\n\\t\\treturn nge;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int[] nextGreaterElements(int[] nums) {\\n\\t\\tDeque<Integer> stack = new LinkedList<>();\\n\\t\\tstack.push(nums[nums.length - 1]);\\n\\t\\tint[] nge = new int[nums.length];\\n\\t\\tnge[nums.length - 1] = -1;\\n\\t\\tfor (int i = nums.length - 2; i >= 0; i--) {\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() <= nums[i]) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = nums.length - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() <= nums[i]) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (stack.isEmpty()) {\\n\\t\\t\\t\\tnge[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnge[i] = stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\t\\t}\\n\\t\\treturn nge;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777457,
                "title": "c-using-stack-and-max-element",
                "content": "#include <bits/stdc++.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n= nums.size(),index=0;\\n        stack<int> st;\\n        int max=nums[0];\\n        vector<int> output(n);\\n        for(int i=1;i<n;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n                index=i;\\n            }    \\n        }\\n        st.push(nums[index]);\\n        output[index]=-1;\\n        for(int i=index-1;i!=index;i--){\\n            if(i<0){\\n                i=n;\\n                continue;\\n            }\\n            while(!st.empty() && st.top()<=nums[i]){\\n                st.pop();\\n            }\\n            if(st.empty()){\\n                output[i]=-1;\\n            }\\n            else{\\n                output[i]=st.top();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n= nums.size(),index=0;\\n        stack<int> st;\\n        int max=nums[0];\\n        vector<int> output(n);\\n        for(int i=1;i<n;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n                index=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1756365,
                "title": "next-greater-element-2-c-o-n-approach-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> ans(nums.size(),-1);\\n        stack<int> st;\\n        for(int i = 0;i < nums.size();i++){\\n            while(!st.empty() && nums[i] > nums[st.top()]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        int a = 0;\\n        while(st.size() > 1 && a < nums.size()){\\n            if(nums[a] > nums[st.top()]){\\n                ans[st.top()] = a;\\n                st.pop();\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        for(int i = 0;i < nums.size();i++){\\n            if(ans[i] != -1){\\n                ans[i] = nums[ans[i]];\\n            }\\n            else{\\n                ans[i] = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        vector<int> ans(nums.size(),-1);\\n        stack<int> st;\\n        for(int i = 0;i < nums.size();i++){\\n            while(!st.empty() && nums[i] > nums[st.top()]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        int a = 0;\\n        while(st.size() > 1 && a < nums.size()){\\n            if(nums[a] > nums[st.top()]){\\n                ans[st.top()] = a;\\n                st.pop();\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        for(int i = 0;i < nums.size();i++){\\n            if(ans[i] != -1){\\n                ans[i] = nums[ans[i]];\\n            }\\n            else{\\n                ans[i] = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752310,
                "title": "c-easy-to-understand-solution-o-2n",
                "content": "\\t**Naive- Traverse for each element circularly  to find next greater element (O(N^2))**\\n\\t\\n\\t**Optimised- Instead of actual traversal , image you have array of size 2N \\n\\t(same array append to end of given array)  now you have to traverse using mod operation\\n\\tand you will get your answer in at max 2N operation instead of N^2**\\n\\t\\n\\tTry ! Try ! Try ! ............Now you can see solution !\\n\\t\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\u2B07\\uFE0F\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\t  int n=nums.size();\\n\\t\\t\\t  vector<int> ans(n,-1);\\n\\t\\t\\t  stack<int> st;\\n\\t\\t\\t  int count=0;\\n\\t\\t\\t  for(int i=0;count<2*n;count++){\\n\\t\\t\\t\\t  while(!st.empty() && nums[st.top()]<nums[i]){\\n\\t\\t\\t\\t\\t  ans[st.top()]=nums[i];\\n\\t\\t\\t\\t\\t  st.pop();\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  st.push(i);\\n\\t\\t\\t\\t  i=(i+1)%n;\\n\\t\\t\\t  }\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> nextGreaterElements(vector<int>& nums) {\\n\\t\\t\\t  int n=nums.size();\\n\\t\\t\\t  vector<int> ans(n,-1);\\n\\t\\t\\t  stack<int> st;\\n\\t\\t\\t  int count=0;\\n\\t\\t\\t  for(int i=0;count<2*n;count++){\\n\\t\\t\\t\\t  while(!st.empty() && nums[st.top()]<nums[i]){\\n\\t\\t\\t\\t\\t  ans[st.top()]=nums[i];\\n\\t\\t\\t\\t\\t  st.pop();\\n\\t\\t\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 1702296,
                "title": "clever-solution-1-pass-only-stack-trick-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& arr){\\n        int n = arr.size();\\n        stack<int> st;\\n        \\n        int k = n-1;\\n        while(k >= 0){\\n            st.push(k--);\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while(!st.empty() and arr[st.top()] <= arr[i])  \\n                st.pop();\\n\\n            if(st.size()) ans[i] = arr[st.top()];\\n            \\n            st.push(i);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& arr){\\n        int n = arr.size();\\n        stack<int> st;\\n        \\n        int k = n-1;\\n        while(k >= 0){\\n            st.push(k--);\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while(!st.empty() and arr[st.top()] <= arr[i])  \\n                st.pop();\\n\\n            if(st.size()) ans[i] = arr[st.top()];\\n            \\n            st.push(i);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584898,
                "title": "using-stack-and-modulo-function",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> nge(n,-1);\\n        stack<int> st;\\n        for(int i=2*n-1; i>=0; i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()) nge[i]=st.top();\\n            }\\n           \\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> nge(n,-1);\\n        stack<int> st;\\n        for(int i=2*n-1; i>=0; i--){\\n            while(!st.empty() && st.top()<=nums[i%n]){\\n                st.pop();\\n            }\\n            if(i<n){\\n                if(!st.empty()) nge[i]=st.top();\\n            }\\n           \\n            st.push(nums[i%n]);\\n        }\\n        return nge;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559245,
                "title": "c-concise-solution",
                "content": "```\\npublic class Solution {\\n    public int[] NextGreaterElements(int[] nums) {\\n        var ans = new int[nums.Length];\\n        Array.Fill(ans, -1);\\n        \\n        var stack = new Stack<int>();\\n        \\n        NextGreaterElements(nums, stack, ans);\\n        NextGreaterElements(nums, stack, ans);\\n        \\n        return ans;\\n    }\\n    \\n    private void NextGreaterElements(int[] nums, Stack<int> stack, int[] ans)\\n    {\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                ans[stack.Peek()] = nums[i];\\n                stack.Pop();\\n            }\\n            \\n            stack.Push(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] NextGreaterElements(int[] nums) {\\n        var ans = new int[nums.Length];\\n        Array.Fill(ans, -1);\\n        \\n        var stack = new Stack<int>();\\n        \\n        NextGreaterElements(nums, stack, ans);\\n        NextGreaterElements(nums, stack, ans);\\n        \\n        return ans;\\n    }\\n    \\n    private void NextGreaterElements(int[] nums, Stack<int> stack, int[] ans)\\n    {\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                ans[stack.Peek()] = nums[i];\\n                stack.Pop();\\n            }\\n            \\n            stack.Push(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529824,
                "title": "python-o-n-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        lookup = [-1] * n\\n        stack = [0]\\n        i = 1\\n        \"\"\"\\n            It is similar to Next Greater Element I (https://leetcode.com/problems/next-greater-element-i/discuss/1529683/Python-or-Simple-Solutions)\\n            The only difference over here is that the array is now circular. \\n            So the max search space for an element at index j would be from j+1 to n and then from 0 to j-1. This search space can be easily encountered using modulo(%) operator as it will again reset the index from 0 after it reaches the length of array.\\n            One more thing that needs to be taken care of is, here we will not add the element directly to stack. First we will check whether its next greater elemnt has been found or not. If not found then add it to stack.\\n        \"\"\"\\n        while i < 2*n: # To handle the search space from j+1 to n and then from 0 to j-1\\n            while stack and nums[i%n] > nums[stack[-1]]:\\n                lookup[stack[-1]] = nums[i%n]\\n                stack.pop()\\n            if lookup[i%n] == -1: # If the next element of i%n is not found yet.\\n                stack.append(i%n)\\n            i += 1\\n        return lookup            \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        lookup = [-1] * n\\n        stack = [0]\\n        i = 1\\n        \"\"\"\\n            It is similar to Next Greater Element I (https://leetcode.com/problems/next-greater-element-i/discuss/1529683/Python-or-Simple-Solutions)\\n            The only difference over here is that the array is now circular. \\n            So the max search space for an element at index j would be from j+1 to n and then from 0 to j-1. This search space can be easily encountered using modulo(%) operator as it will again reset the index from 0 after it reaches the length of array.\\n            One more thing that needs to be taken care of is, here we will not add the element directly to stack. First we will check whether its next greater elemnt has been found or not. If not found then add it to stack.\\n        \"\"\"\\n        while i < 2*n: # To handle the search space from j+1 to n and then from 0 to j-1\\n            while stack and nums[i%n] > nums[stack[-1]]:\\n                lookup[stack[-1]] = nums[i%n]\\n                stack.pop()\\n            if lookup[i%n] == -1: # If the next element of i%n is not found yet.\\n                stack.append(i%n)\\n            i += 1\\n        return lookup            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529052,
                "title": "c-stack-o-2-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.insert(nums.end(),nums.begin(),nums.end());\\n        stack<int>s;\\n        for(int i=2*n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && s.top()<=nums[i])\\n                s.pop();\\n            \\n            int x=nums[i];  // Store element to push into stack,So that we dont need extra result vector\\n            if(s.empty())   // --to store answer\\n                nums[i]=-1;\\n            else\\n                nums[i]=s.top();\\n            s.push(x);\\n            \\n            \\n        }\\n        nums.resize(n);  // Remove last n elements from nums\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.insert(nums.end(),nums.begin(),nums.end());\\n        stack<int>s;\\n        for(int i=2*n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && s.top()<=nums[i])\\n                s.pop();\\n            \\n            int x=nums[i];  // Store element to push into stack,So that we dont need extra result vector\\n            if(s.empty())   // --to store answer\\n                nums[i]=-1;\\n            else\\n                nums[i]=s.top();\\n            s.push(x);\\n            \\n            \\n        }\\n        nums.resize(n);  // Remove last n elements from nums\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469358,
                "title": "c-stack-solution-with-explanation",
                "content": "1. Use a stack to keep track of all indexes where no next greater element has been found\\n2. Loop through nums once\\n2. For every iteration, we want to be setting result[i] to -1, meaning that none found yet\\n3. For every iteration, we also want to check if the stack has elements that need to be processed, if yes, then process them as long as the latest index contains a value smaller than the current value, which means that it\\'s next greater value has been found.\\n4. Make sure to do the stack checking **before** adding the current index into the stack otherwise nothing will be able to pop out!\\n5. Since this is a *circular* array, we need to loop once more again to be able to find the next greater for end elements that could not find a greater. Your result should only have -1 be in the location(s) of the largest value in the entire array.\\n\\n```\\npublic class Solution {\\n    public int[] NextGreaterElements(int[] nums) {\\n        Stack<int> stack = new Stack<int>();\\n        int[] result = new int[nums.Length];\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(stack.Count != 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                result[stack.Pop()] = nums[i];\\n            }\\n            result[i] = -1;\\n            stack.Push(i);\\n        }\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(stack.Count != 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                result[stack.Pop()] = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] NextGreaterElements(int[] nums) {\\n        Stack<int> stack = new Stack<int>();\\n        int[] result = new int[nums.Length];\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(stack.Count != 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                result[stack.Pop()] = nums[i];\\n            }\\n            result[i] = -1;\\n            stack.Push(i);\\n        }\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(stack.Count != 0 && nums[stack.Peek()] < nums[i])\\n            {\\n                result[stack.Pop()] = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405673,
                "title": "java-monotonic-stack",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for (int i=0;i<2*n;i++) {\\n            int index = i%n;\\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\\n                ans[stack.pop()] = nums[index];\\n            }\\n            stack.push(index);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for (int i=0;i<2*n;i++) {\\n            int index = i%n;\\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\\n                ans[stack.pop()] = nums[index];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1309395,
                "title": "java-o-2n-more-intuitive-than-those-ridiculous-most-upvoted-so-called-smart-solutions",
                "content": "Title may sound rude but I don\\'t regret for that because these most upvoted solutions are hard to understand even for an intermediate like me.\\n\\nSo here is my attempt to make it simpler and more intutive.\\n\\n**NOTE:** `O(2N)` is average time complexity in worst case time complexity will be `O(3N)`.\\n\\n```java\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] nextGreater = new int[n];\\n        Arrays.fill(nextGreater, -1);\\n        \\n        Stack<Integer> s = new Stack<>();\\n        \\n        // first store all the elements in a monotonic(increasing) stack from last to first\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (!s.isEmpty() && s.peek() <= nums[i])\\n                s.pop();\\n            s.push(nums[i]);\\n        }\\n        \\n        // stack is precomputed storing elements from first to last in increasing order\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.isEmpty() && s.peek() <= nums[i])\\n                s.pop();\\n            if (!s.isEmpty())\\n                nextGreater[i] = s.peek();\\n            s.push(nums[i]);\\n        }\\n        \\n        return nextGreater;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] nextGreater = new int[n];\\n        Arrays.fill(nextGreater, -1);\\n        \\n        Stack<Integer> s = new Stack<>();\\n        \\n        // first store all the elements in a monotonic(increasing) stack from last to first\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (!s.isEmpty() && s.peek() <= nums[i])\\n                s.pop();\\n            s.push(nums[i]);\\n        }\\n        \\n        // stack is precomputed storing elements from first to last in increasing order\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.isEmpty() && s.peek() <= nums[i])\\n                s.pop();\\n            if (!s.isEmpty())\\n                nextGreater[i] = s.peek();\\n            s.push(nums[i]);\\n        }\\n        \\n        return nextGreater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196253,
                "title": "single-stack-solution-easy-c",
                "content": "Please upvote if you like it\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& arr) {\\n      vector<int> v;\\n        int n = arr.size();\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            st.push(arr[i]);\\n        }\\n        for(int i=n-1; i>=0 ;i--){\\n          if(st.size() ==0){\\n                v.push_back(-1);\\n            }else if(st.size() >0 && st.top() > arr[i]){\\n                v.push_back(st.top());\\n            }else if(st.size() >0 && st.top() <= arr[i]){\\n                while(st.size() >0 && st.top() <= arr[i]){\\n                    st.pop();\\n                }\\n                if(st.size()==0){\\n                    v.push_back(-1);\\n                }else{\\n                    v.push_back(st.top());\\n                }\\n            }\\n            \\n            st.push(arr[i]);\\n        }\\n        \\n        \\n        reverse(v.begin(), v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& arr) {\\n      vector<int> v;\\n        int n = arr.size();\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            st.push(arr[i]);\\n        }\\n        for(int i=n-1; i>=0 ;i--){\\n          if(st.size() ==0){\\n                v.push_back(-1);\\n            }else if(st.size() >0 && st.top() > arr[i]){\\n                v.push_back(st.top());\\n            }else if(st.size() >0 && st.top() <= arr[i]){\\n                while(st.size() >0 && st.top() <= arr[i]){\\n                    st.pop();\\n                }\\n                if(st.size()==0){\\n                    v.push_back(-1);\\n                }else{\\n                    v.push_back(st.top());\\n                }\\n            }\\n            \\n            st.push(arr[i]);\\n        }\\n        \\n        \\n        reverse(v.begin(), v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183893,
                "title": "c-stack-repeat-twice",
                "content": "**Before solving this problem, solve [496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/http://)**\\n\\nThis problem is very similar to the first version.\\nLet\\'s see what are the modifications needed.\\n\\nIn the first problem, if there is **no greater element present ahead** we have kept **-1** at that position\\n\\nWe hate these **-1**, so we will startover again from start to find next greater element to replace thses **-1\\'s**\\n\\nNote: There will always be some -1\\'s present indicating the maximum value in the array\\n\\nHere is my stack based solution to the problem!\\n**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> next_greater(n, -1);\\n        stack<int> stk;\\n        \\n        for(int rep = 0; rep < 2; rep++) {\\n            for(int i = 0; i < n; i++) {\\n                while(!stk.empty() && nums[stk.top()] < nums[i]) {\\n                    next_greater[stk.top()] = nums[i];\\n                    stk.pop();\\n                }\\n\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return next_greater;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> next_greater(n, -1);\\n        stack<int> stk;\\n        \\n        for(int rep = 0; rep < 2; rep++) {\\n            for(int i = 0; i < n; i++) {\\n                while(!stk.empty() && nums[stk.top()] < nums[i]) {\\n                    next_greater[stk.top()] = nums[i];\\n                    stk.pop();\\n                }\\n\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return next_greater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002288,
                "title": "concise-c-solution",
                "content": "```\\nvector<int> nextGreaterElements(vector<int> arr) {\\n        int n=arr.size()*2;\\n        arr.insert(arr.end(),arr.begin(),arr.end());\\n        stack<int>s;\\n         vector<int>res;\\n         for(int i=n-1;i>=0;i--){\\n         while(!s.empty()&& s.top()<=arr[i])\\n         s.pop();\\n         if(s.empty())\\n         res.insert(res.begin(),-1);\\n         else\\n         res.insert(res.begin(),s.top());\\n         s.push(arr[i]);\\n            }\\n        res.resize(n/2);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> nextGreaterElements(vector<int> arr) {\\n        int n=arr.size()*2;\\n        arr.insert(arr.end(),arr.begin(),arr.end());\\n        stack<int>s;\\n         vector<int>res;\\n         for(int i=n-1;i>=0;i--){\\n         while(!s.empty()&& s.top()<=arr[i])\\n         s.pop();\\n         if(s.empty())\\n         res.insert(res.begin(),-1);\\n         else\\n         res.insert(res.begin(),s.top());\\n         s.push(arr[i]);\\n            }\\n        res.resize(n/2);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 994067,
                "title": "java-simple-stack-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n     \\n        if(nums == null || nums.length == 0) return nums;\\n        \\n//      find maximum element index, maxi\\n        int max = nums[0];\\n        int maxi = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                maxi = i;\\n            }\\n        }\\n        \\n        int ans[] = new int[nums.length];\\n//      stack to store indices\\n        Stack <Integer> stack = new Stack();\\n//      process from i = 0 to n\\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[i]){\\n                ans[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n//      process from i =0 to maxi\\n        for(int i = 0; i <= maxi; i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[i]){\\n                ans[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n//      elements left in stack, assign -1;\\n        while(!stack.isEmpty()){\\n            ans[stack.pop()] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n     \\n        if(nums == null || nums.length == 0) return nums;\\n        \\n//      find maximum element index, maxi\\n        int max = nums[0];\\n        int maxi = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                maxi = i;\\n            }\\n        }\\n        \\n        int ans[] = new int[nums.length];\\n//      stack to store indices\\n        Stack <Integer> stack = new Stack();\\n//      process from i = 0 to n\\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[i]){\\n                ans[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n//      process from i =0 to maxi\\n        for(int i = 0; i <= maxi; i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[i]){\\n                ans[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n//      elements left in stack, assign -1;\\n        while(!stack.isEmpty()){\\n            ans[stack.pop()] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933688,
                "title": "c-o-n-solution-with-stack",
                "content": "This follows the same logic as 496. Next Greater Element I except without the use of the unordered_map because we are returning a value for every element in our input. Instead of just visiting the values in one direction, we make our iteration length 2 * n and use the modulo operator i % n. This allows us to *split* the cycle at one element and act as if it is the starting element. It is similar to looping through twice. Refer to explanation of [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/discuss/933678/C%2B%2B-O(n)-Solution-with-Stack).\\n\\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size(), -1);\\n        int n = nums.size();\\n        stack<int> s;\\n        for(int i = 0; i < n*2; i++){\\n            int num = nums[i%n];\\n            while(!s.empty() && nums[s.top()] < num){\\n                res[s.top()] = num;\\n                s.pop();\\n            }\\n            s.push(i%n);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "This follows the same logic as 496. Next Greater Element I except without the use of the unordered_map because we are returning a value for every element in our input. Instead of just visiting the values in one direction, we make our iteration length 2 * n and use the modulo operator i % n. This allows us to *split* the cycle at one element and act as if it is the starting element. It is similar to looping through twice. Refer to explanation of [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/discuss/933678/C%2B%2B-O(n)-Solution-with-Stack).\\n\\n```\\nvector<int> nextGreaterElements(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size(), -1);\\n        int n = nums.size();\\n        stack<int> s;\\n        for(int i = 0; i < n*2; i++){\\n            int num = nums[i%n];\\n            while(!s.empty() && nums[s.top()] < num){\\n                res[s.top()] = num;\\n                s.pop();\\n            }\\n            s.push(i%n);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 926093,
                "title": "next-greater-element-circular-array-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] ans = new int[nums.length];\\n        //ans is being used because it could be possible for {100,2,1,120,5,16} =>{120,120,120,120,16,16} for first pass but in second pass we will get the last element 16 asssign with 120 but we needed to compare with original array in line 12,20 \\n        //First pass we will get the linearly to get next greater elements of array\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            while(st.size()>0 && nums[i] > nums[st.peek()] )\\n            {\\n                ans[st.pop()] = nums[i];\\n            }\\n            st.push(i);\\n        }\\n        //Second pass to check maybe the later indices could be used to getting next greater element from 0\\n        //present not used in stack\\n        for(int i=0; st.empty()==false && i<nums.length; i++)\\n        {\\n            if(nums[st.peek()] < nums[i])\\n            {\\n                ans[st.pop()]=nums[i];\\n                i--;\\n            }\\n            \\n        }\\n        //get the left elements in stack assigned with -1\\n        while(st.size()>0)\\n        {\\n            ans[st.pop()]=-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] ans = new int[nums.length];\\n        //ans is being used because it could be possible for {100,2,1,120,5,16} =>{120,120,120,120,16,16} for first pass but in second pass we will get the last element 16 asssign with 120 but we needed to compare with original array in line 12,20 \\n        //First pass we will get the linearly to get next greater elements of array\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            while(st.size()>0 && nums[i] > nums[st.peek()] )\\n            {\\n                ans[st.pop()] = nums[i];\\n            }\\n            st.push(i);\\n        }\\n        //Second pass to check maybe the later indices could be used to getting next greater element from 0\\n        //present not used in stack\\n        for(int i=0; st.empty()==false && i<nums.length; i++)\\n        {\\n            if(nums[st.peek()] < nums[i])\\n            {\\n                ans[st.pop()]=nums[i];\\n                i--;\\n            }\\n            \\n        }\\n        //get the left elements in stack assigned with -1\\n        while(st.size()>0)\\n        {\\n            ans[st.pop()]=-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799963,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int [] answer = new int[nums.length];\\n        Stack<Integer> stack = new Stack();\\n        for (int i = 2*nums.length - 1; i >= 0; i--) {\\n            // Here we take 2 * length - 1 as we need to look the cycle too\\n            while(!stack.empty() && nums[i % nums.length] >= nums[stack.peek()])\\n                stack.pop();\\n            if (!stack.empty())\\n                answer[i % nums.length] = nums[stack.peek()];\\n            else\\n                answer[i % nums.length] = -1;\\n            stack.push(i % nums.length);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int [] answer = new int[nums.length];\\n        Stack<Integer> stack = new Stack();\\n        for (int i = 2*nums.length - 1; i >= 0; i--) {\\n            // Here we take 2 * length - 1 as we need to look the cycle too\\n            while(!stack.empty() && nums[i % nums.length] >= nums[stack.peek()])\\n                stack.pop();\\n            if (!stack.empty())\\n                answer[i % nums.length] = nums[stack.peek()];\\n            else\\n                answer[i % nums.length] = -1;\\n            stack.push(i % nums.length);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792399,
                "title": "interview-friendly-smooth-explanation-for-rudimentary-version-and-then-the-optimized-one",
                "content": "Derive first version as it is easier to explain in the interview, and optimization is also not that super tricky, just need to tweak the code a little bit.\\n\\n**Explanation for first version**: \\nNeed to use 3 for loops:\\n* In first one, sing Stack, we can add the index and pop it only when we come across a greater integer. We keep popping all the indices which are smaller than the curr num we are iterating on. After popping the index, assign it in the return array as arr[i] = num. We push the curr index at the end of the loop.\\n\\n* In second for loop, \\nWe only pop the index from the stack and no push operation takes place.\\n\\n* In third loop, we can assign -1 to all the indices which are left unassigned i.e. no greater element was found for them.\\n\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.empty() && nums[i] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.empty() && nums[i] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i];\\n            }\\n        }\\n        \\n        while(!stack.empty()){\\n            res[stack.pop()] = -1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Optimization:**\\nInstead of three, we need to write only one loop.\\n* Second for loop can be scrapped, as code is almost duplicated from first for loop: only change is number of times it runs and push the index onto the stack only when i < n.\\n* Third for loop can be avoided if we fill the res arr with -1 at the time of initialization.\\n\\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < n*2; i++){\\n            while(!stack.empty() && nums[i%n] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i%n];\\n            }\\n            if(i < n) stack.push(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.empty() && nums[i] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i];\\n            }\\n            stack.push(i);\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            while(!stack.empty() && nums[i] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i];\\n            }\\n        }\\n        \\n        while(!stack.empty()){\\n            res[stack.pop()] = -1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < n*2; i++){\\n            while(!stack.empty() && nums[i%n] > nums[stack.peek()]){\\n                res[stack.pop()] = nums[i%n];\\n            }\\n            if(i < n) stack.push(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778042,
                "title": "easy-c-insert-all-elements-first-to-replicate-like-a-cylce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        stack <int> s;\\n        for (int i = n - 1; i >= 0; i--) s.push(nums[i]);\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && s.top() <= nums[i]) {\\n                s.pop();\\n            }\\n            ans[i] = s.empty() ? -1 : s.top();\\n            s.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        stack <int> s;\\n        for (int i = n - 1; i >= 0; i--) s.push(nums[i]);\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && s.top() <= nums[i]) {\\n                s.pop();\\n            }\\n            ans[i] = s.empty() ? -1 : s.top();\\n            s.push(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655369,
                "title": "c-cpp-86-faster-using-stacks-10-lines-easy-to-understand",
                "content": "This question is very similiar to [Daily Temperature](https://leetcode.com/problems/daily-temperatures/). The difference being the vector is now circular. How to proceed? Just loop twice as shown in the code. \\nThe while loop can be a bit tricky to understand since it runs until the stack is empty. Do try it on paper to understand better. \\nPlease like the post if you found it useful. Comment if there can be any improvement made to the code. Happy coding. :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n=nums.size();\\n        st.push(0);\\n        vector<int> hg(nums.size(),-1);\\n        for(int i=1;i<n*2;i++){\\n            while(!st.empty()&&nums[st.top()]<nums[i%n]){\\n                hg[st.top()]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return hg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int> st;\\n        int n=nums.size();\\n        st.push(0);\\n        vector<int> hg(nums.size(),-1);\\n        for(int i=1;i<n*2;i++){\\n            while(!st.empty()&&nums[st.top()]<nums[i%n]){\\n                hg[st.top()]=nums[i%n];\\n                st.pop();\\n            }\\n            st.push(i%n);\\n        }\\n        return hg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594726,
                "title": "simple-stack-based-soln-with-o-n-space-and-o-n-time-complexity-with-intuition-and-approach",
                "content": "Inutition:- If we carefully look at array, we can see that by just copying the original array and pasting at end of original array, we can get upto the soln.Lets take an example:-\\n`arr` - 3,4,2,1  .After copying and pasting it to end we get `newarr`- 3,4,2,1,3,4,2,1.\\nA simple 2 for loop can be used to know next greater element of the `newarr`.\\nA more thought and tadaaaaa ... the `newarr` next greater element soln can be optimised using a `stack`\\n\\nApproach:- 2 Steps\\n1 step-    -iterate throguh last element .\\n\\t\\t\\t\\t-if stack is empty then for that num[i] NGE is -1; (for simplicity we have made it to Integer.MIN_VALUE;)\\n\\t\\t\\t\\t-until num[i] > stack.peek() remove element from stack\\n\\t\\t\\t\\t-now if stack is not empty then for num[i] NGE is stack.peek();\\n\\n2 Step-   Again start from last element.\\n\\t\\t\\t if res[i] == Integer.MIN_VALUE then{\\n\\t\\t\\t\\t\\t\\t\\t-if stack is empty then for that num[i] NGE is -1; (for simplicity we have made it to Integer.MIN_VALUE;)\\n\\t\\t\\t\\t\\t\\t\\t\\t-until num[i] > stack.peek() remove element from stack\\n\\t\\t\\t\\t\\t\\t\\t\\t-now if stack is not empty then for num[i] NGE is stack.peek();\\n\\t}\\n```\\npublic int[] nextGreater(int[] nums) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for(int i= nums.length-1;i>=0;i--) {\\n            \\n            while(!stack.isEmpty() && stack.peek()<=nums[i]) {\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()) {\\n                res[i]=Integer.MIN_VALUE;\\n            }else {\\n                res[i]=stack.peek();\\n            }\\n            //System.out.println(\"firsts   \" + nums[i] + \"   \" +   res[i]);\\n            stack.push(nums[i]);\\n        }\\n        \\n        \\n        for(int i =nums.length-1;i>=0;i--) {\\n            while(!stack.isEmpty() && stack.peek()<=nums[i]) {\\n                stack.pop();\\n            }\\n                if(res[i] == Integer.MIN_VALUE) {\\n                    if(stack.isEmpty()) {\\n                        res[i]=-1;\\n                    }else {\\n                        res[i]=stack.peek();\\n                    }\\n                    stack.push(nums[i]);\\n                }\\n          \\n        }\\n        return res;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\npublic int[] nextGreater(int[] nums) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int[] res = new int[nums.length];\\n        for(int i= nums.length-1;i>=0;i--) {\\n            \\n            while(!stack.isEmpty() && stack.peek()<=nums[i]) {\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()) {\\n                res[i]=Integer.MIN_VALUE;\\n            }else {\\n                res[i]=stack.peek();\\n            }\\n            //System.out.println(\"firsts   \" + nums[i] + \"   \" +   res[i]);\\n            stack.push(nums[i]);\\n        }\\n        \\n        \\n        for(int i =nums.length-1;i>=0;i--) {\\n            while(!stack.isEmpty() && stack.peek()<=nums[i]) {\\n                stack.pop();\\n            }\\n                if(res[i] == Integer.MIN_VALUE) {\\n                    if(stack.isEmpty()) {\\n                        res[i]=-1;\\n                    }else {\\n                        res[i]=stack.peek();\\n                    }\\n                    stack.push(nums[i]);\\n                }\\n          \\n        }\\n        return res;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 542282,
                "title": "swift-solution-using-stack-with-explanation-beats-100",
                "content": "Because the given array is circular, only the maximum element doesn\\'t have next greater element. So we can start from the maximum element.\\nWe need to do in two loops, and maintain the next greater element by using stack.\\nFirst loop: from max_id to 0\\nSecond loop: from n-1 to max_id+1\\n```\\nclass Solution {\\n    func nextGreaterElements(_ nums: [Int]) -> [Int] {\\n        let n = nums.count\\n        guard n > 0 else { return [] }\\n        \\n        var ans = Array(repeating: -1, count: n)\\n        \\n        // Find the maximum num and its index\\n        var maxId = 0\\n        var max = nums[0]\\n        for i in 0..<n {\\n            if nums[i] > max {\\n                max = nums[i]\\n                maxId = i\\n            }\\n        }\\n        \\n        var stack = [Int]()\\n        \\n        func helper(_ start: Int, _ end: Int) {\\n            var i = start\\n            while i >= end {\\n                while stack.count > 0, nums[i] >= stack.last! {\\n                    stack.removeLast()\\n                }\\n                if stack.count == 0 {\\n                    ans[i] = -1\\n                } else {\\n                    ans[i] = stack.last!\\n                }\\n                stack.append(nums[i])\\n                i -= 1\\n            }\\n        }\\n        \\n        // first round: loop through from maxId to 0 index\\n        helper(maxId, 0)\\n        \\n        // second round: loop through from n-1 to maxId+1 index\\n        helper(n-1, maxId+1)\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func nextGreaterElements(_ nums: [Int]) -> [Int] {\\n        let n = nums.count\\n        guard n > 0 else { return [] }\\n        \\n        var ans = Array(repeating: -1, count: n)\\n        \\n        // Find the maximum num and its index\\n        var maxId = 0\\n        var max = nums[0]\\n        for i in 0..<n {\\n            if nums[i] > max {\\n                max = nums[i]\\n                maxId = i\\n            }\\n        }\\n        \\n        var stack = [Int]()\\n        \\n        func helper(_ start: Int, _ end: Int) {\\n            var i = start\\n            while i >= end {\\n                while stack.count > 0, nums[i] >= stack.last! {\\n                    stack.removeLast()\\n                }\\n                if stack.count == 0 {\\n                    ans[i] = -1\\n                } else {\\n                    ans[i] = stack.last!\\n                }\\n                stack.append(nums[i])\\n                i -= 1\\n            }\\n        }\\n        \\n        // first round: loop through from maxId to 0 index\\n        helper(maxId, 0)\\n        \\n        // second round: loop through from n-1 to maxId+1 index\\n        helper(n-1, maxId+1)\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361442,
                "title": "",
                "content": "```java\\n public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        Stack<Integer> stack = new Stack<Integer>();\\n        stack.push(0);\\n        for(int i=1;i<2*nums.length;i++){ //\\u4E3A\\u4E86\\u5FAA\\u73AF\\u904D\\u5386\\u6570\\u7EC4\\n            int j=i%nums.length;\\n            while(!stack.empty() && nums[stack.peek()] < nums[j]){ //\\u4E00\\u4E2A\\u9012\\u51CF\\u6808\\n                res[stack.pop()%nums.length]=nums[j];\\n            }\\n            stack.push(j);\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int[] nextGreaterElements(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        Stack<Integer> stack = new Stack<Integer>();\\n        stack.push(0);\\n        for(int i=1;i<2*nums.length;i++){ //\\u4E3A\\u4E86\\u5FAA\\u73AF\\u904D\\u5386\\u6570\\u7EC4\\n            int j=i%nums.length;\\n            while(!stack.empty() && nums[stack.peek()] < nums[j]){ //\\u4E00\\u4E2A\\u9012\\u51CF\\u6808\\n                res[stack.pop()%nums.length]=nums[j];\\n            }\\n            stack.push(j);\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 277440,
                "title": "javascript-stack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    nums = nums.concat(nums)\\n    let stack  = [],ret = new Array(nums.length).fill(-1)\\n    for (let el in nums) {\\n        while (stack.length>0&&nums[stack[0]]<nums[el]) {\\n            ret[stack.shift()] = nums[el]\\n        }\\n        stack.unshift(el)\\n    }\\n    ret.length = ret.length / 2\\n    return ret\\n};\\n```\\nusing array[0] as top of stack",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar nextGreaterElements = function(nums) {\\n    nums = nums.concat(nums)\\n    let stack  = [],ret = new Array(nums.length).fill(-1)\\n    for (let el in nums) {\\n        while (stack.length>0&&nums[stack[0]]<nums[el]) {\\n            ret[stack.shift()] = nums[el]\\n        }\\n        stack.unshift(el)\\n    }\\n    ret.length = ret.length / 2\\n    return ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195491,
                "title": "c-o-n-64ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>  s;\\n        vector<int> v(nums.size(), -1);\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!s.empty() && nums[s.top()] < nums[i]) {\\n                v[s.top()] = nums[i];\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!s.empty() && nums[s.top()] < nums[i]) {\\n                v[s.top()] = nums[i];\\n                s.pop();\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElements(vector<int>& nums) {\\n        stack<int>  s;\\n        vector<int> v(nums.size(), -1);\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!s.empty() && nums[s.top()] < nums[i]) {\\n                v[s.top()] = nums[i];\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!s.empty() && nums[s.top()] < nums[i]) {\\n                v[s.top()] = nums[i];\\n                s.pop();\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184046,
                "title": "python-solution",
                "content": "Same algorithm as 739. Daily Temperatures, but working with `augLst = nums + nums`, because `nums` is now circular. O(n) time O(n) space:\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        augLst = nums + nums\\n        stack = []\\n        res = [-1] * len(nums)\\n        for i in range(len(augLst)-1, -1, -1):\\n            while stack and stack[-1] <= augLst[i]:\\n                stack.pop()\\n            if stack:\\n                res[i % len(nums)] = stack[-1]\\n            stack.append(augLst[i])\\n        return res\\n```\\nSame idea, better implementation:\\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        stack = []\\n        res = [-1] * len(nums)\\n        for i in range(2*len(nums)-1, -1, -1):\\n            index = i % len(nums)\\n            while stack and stack[-1] <= nums[index]:\\n                stack.pop()\\n            if stack:\\n                res[index] = stack[-1]\\n            stack.append(nums[index])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        augLst = nums + nums\\n        stack = []\\n        res = [-1] * len(nums)\\n        for i in range(len(augLst)-1, -1, -1):\\n            while stack and stack[-1] <= augLst[i]:\\n                stack.pop()\\n            if stack:\\n                res[i % len(nums)] = stack[-1]\\n            stack.append(augLst[i])\\n        return res\\n```\n```\\nclass Solution:\\n    def nextGreaterElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        stack = []\\n        res = [-1] * len(nums)\\n        for i in range(2*len(nums)-1, -1, -1):\\n            index = i % len(nums)\\n            while stack and stack[-1] <= nums[index]:\\n                stack.pop()\\n            if stack:\\n                res[index] = stack[-1]\\n            stack.append(nums[index])\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573643,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1575254,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1729963,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1772232,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1980203,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 2034072,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 2037042,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1974383,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1932061,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1932007,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1573643,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1575254,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1729963,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1772232,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1980203,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 2034072,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 2037042,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1974383,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1932061,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            },
            {
                "id": 1932007,
                "content": [
                    {
                        "username": "alex3898",
                        "content": "Input:\\n[1,8,-1,-100,-1,222,1111111,-111111]\\nOutput:\\n[8,222,222,1,222,1111111,-1,1]\\nExpected:\\n[8,222,222,-1,222,1111111,-1,1]\\nwhy for -100 ans is -1 it should be 1 because we are considering circular fashion??please help"
                    },
                    {
                        "username": "Sam002",
                        "content": "It should be -1, because here we are taking the NEXT GREATER element. So, in the array the next element that will be greater than -100 would be pushed into the array. In this case it should be -1."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Seems like the test case caught you on comparison with -1 somewhere, I feel your pain .."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "we need the number greater than the current number as near as possible. we don\\'t care about how greater. so -1. I also think that the 2nd index shouldn\\'t be 222. As we need numbers greater than current.\\n\\nTell me if it helps or not. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "chanmanman202109",
                        "content": "-100 < -1, the first num greater -100 is -1"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This blog post explains pretty well why the stack based algorithm (correctness) works . It is for computing the previous smaller element but uses the exact same concept.\\nhttps://medium.com/algorithms-digest/previous-smaller-element-e3996fb8be3c"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) Please stop spamming this crap here"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/2949123/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "iRYO400",
                        "content": "Why it feels like it is easier than the first?"
                    },
                    {
                        "username": "John_Wick15",
                        "content": "it is!"
                    },
                    {
                        "username": "shivanigam",
                        "content": "That First One Was Containing extra nums array that might be reason for its difficulty."
                    },
                    {
                        "username": "user7924KL",
                        "content": "No way, this one is tough, at least for me"
                    },
                    {
                        "username": "valeriya17",
                        "content": "Input:\\n[5,4,3,2,1]\\nOutput:\\n[-1,5,4,3,2]\\nExpected:\\n[-1,5,5,5,5] \\n\\nI dont understand why my output is wrong. Can someone please explain "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "[@swarooppppp](/swarooppppp)  but it says in example - 2 to do so\\n"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@prakhar32](/prakhar32)  //second iteration\\n      --> from i-1 to 0{\\n           //pop until and unless the nums[j] is greater than the peek element;\\n             \\n            int temp = nums[j];\\n    \\n            if(!stack.empty()){\\n            nums[j]=stack.peek();\\n           \\n            }\\n            else{\\n                nums[j]=-1;\\n            }\\n\\n//do not do the pop here..\\n\\n            stack.push(temp);\\n            }\\n\\n            return nums;\\n            }"
                    },
                    {
                        "username": "prakhar32",
                        "content": "[@R__M](/R__M)  There is the catch, even if you encounter the next greater just nearby, you need to look ahead. This is pretty vague though as far as the questions basket (revolving around stack is considered). It is what it is i guess. \\n\\nRemoving the extra pop line while making the stack push solved for me."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "I have same doubt\\n"
                    },
                    {
                        "username": "swarooppppp",
                        "content": "You are trying to print the very next greatest number of a current one. But we just have to print the greatest number that we encounter first while traversing through the array circularly."
                    },
                    {
                        "username": "calm27",
                        "content": "perhaps you move pointer from 0 to n-1, and reverse, but it is wrong. \\nevery new cycle starts from 0-index. "
                    },
                    {
                        "username": "R__M",
                        "content": "You find next elem in wrong direction. You need to find next right element greater than current."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "WHENEVER there is circular arr, do nothing more! just create a newarr with size double of the original arr and just copy the original arr twice in the newarr, so we can do the circular arr traversal in single loop, no back pointer, EASY! this question can be easily solved without stack, by the above-mentioned approach!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "wont the time complexity be O(n^2) without using any stack"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`-1` is not only an exceptional return but also a valid answer. what a weird programing mindset!"
                    },
                    {
                        "username": "Vithesh",
                        "content": "the question sounds tough...but its not that difficult. If you solved the first one then you can solve this one..."
                    },
                    {
                        "username": "X_Yashu",
                        "content": "  public int[] nextGreaterElements(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int num:nums){\\n            if(!st.isEmpty() && num>st.peek()){\\n                map.put(st.pop(),num);\\n            }\\n            st.push(num);\\n\\u2026        }\\n        return ans;\\n       \\n    }\\n\\n\\n\\nwhy this solution is not working ? please help\\n[5,4,3,2,1] this test case not passed but why ?\\n"
                    },
                    {
                        "username": "Manjusha_1_7",
                        "content": "test case = [5,4,3,2,1]\\noutput = [-1,5,4,3,2]\\nexpected = [-1,5,5,5,5]\\n\\nwhy for 3, 2, 1 ans is 5, 5, 5 not 2, 3, 4 resp. plss help\\n"
                    },
                    {
                        "username": "premranjn",
                        "content": "[@er_tanmay_btech](/er_tanmay_btech)  for the test case = [5,4,3,2,1], the circular fashion will lead to [5, 4, 3, 2, 1, 5, 4, 3, 2, 1] here you can see that for 3, 2, 1 the next greater element is 5, 5, 5 respectively  [5, 4, 3, 2, 1, \"5\",  4, 3, 2, 1]"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "understand the term \"next greater\" it doesn\\'t mean \"next greater in value\" Instead it means \" start traversing from the next and whichever u find greater than our element that is next greater\" hope it helps u..."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++. Only S.C=O(1) Solution.\\n\\nApproach\\nPretend the given array like circular array. i.e think combining the given array 2 times. By using mod operation we can do that.\\n\\nComplexity\\nTime complexity:\\nT.C=O(2*n)\\n\\nSpace complexity:\\nO(1) no stack used. Only using greaterElementArray.\\nPlease Upvote. If understand the concept.\\nSolution link:\\n\\nhttps://leetcode.com/problems/next-greater-element-ii/solutions/3645612/c-only-s-c-o-1-solution/"
                    }
                ]
            }
        ]
    }
]