[
    {
        "title": "Equal Row and Column Pairs",
        "question_content": "Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\n&nbsp;\nExample 1:\n\nInput: grid = [[3,2,1],[1,7,6],[2,7,7]]\nOutput: 1\nExplanation: There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]\n\nExample 2:\n\nInput: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\nOutput: 3\nExplanation: There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n\n&nbsp;\nConstraints:\n\n\tn == grid.length == grid[i].length\n\t1 <= n <= 200\n\t1 <= grid[i][j] <= 105",
        "solutions": [
            {
                "id": 2324872,
                "title": "100-fast-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324688,
                "title": "cubic-432-vs-three-map-95-vs-trie-137",
                "content": "`n` is small, so a Cubic solution should do for the contest.\\n\\nLater, I solved this problem using the Trie and Tree Map approaches, which are Quadratic.\\n\\n#### Cubic (432 ms)\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\\n\\n#### Three Map (95 ms)\\nNote that we need to use a three map (ordered map) instead of hash map. For a vector, the three map stops matching when bumps into a discrepancy, while hash map process all elements first to compute a hash.\\n\\nNote how we optimize the memory usage here. To check if a row exists in map, we are using existing rows. That way, we do not build an entire vector only to find out we have a mismatch on the first element.\\n\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\\n\\n#### Trie (137 ms)\\nThis is similar to the Three Map solution above, but here we build it ourselves.\\n\\nFirst, we populate Trie for columns, and then count matching rows.\\n\\n**C++**\\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630812,
                "title": "java-c-python-easy-to-understand",
                "content": "# Guys Please Vote up )):\\nTo solve this problem, we can iterate through each row and column of the grid and check if they contain the same elements in the same order. If they do, we increment a counter. Finally, we return the value of the counter.\\n\\n# Approach\\nHere\\'s the approach to solve the problem:\\n\\n    Initialize a variable count to 0 to keep track of the number of equal row-column pairs.\\n    Iterate through each row ri from 0 to n-1:\\n    a. Iterate through each column cj from 0 to n-1:\\n    i. Check if the row ri and column cj are equal by comparing the corresponding elements.\\n    ii. If they are equal, increment the count variable by 1.\\n    Return the value of count.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n^3) because we have three nested loops: one for iterating through rows, one for iterating through columns, and one for comparing the elements. \\n\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of extra space.\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\\n# C++ Code\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python3 Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328910,
                "title": "python3-3-lines-transpose-ctr-w-explanation-t-m-97-100",
                "content": "\\nConsider this grid for an example:\\n```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```    \\nHere\\'s the plan:\\n- Determine`tpse`, the transpose of`grid`(using`zip(*grid)`):\\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\\n- The problem now is to determine the pairs of identical rows, one row in `tpse`and the other in` grid`. We hash`grid`and`tspe`:\\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```            \\n   \\u2022 Finally, we determine the number of pairs:\\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\\nHere\\'s the code:\\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```\\n[https://leetcode.com/problems/equal-row-and-column-pairs/submissions/939711156/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(grid)`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324750,
                "title": "java-python-3-o-n-2-codes-w-brief-explanation-and-analysis",
                "content": "Count row hash values then traverse col hash values to count the required pairs.\\n\\n----\\n\\nConvert rows and cols into strings, then use them as hash values.\\n\\nNote: \\n`cnt.merge(Arrays.toString(row), 1, Integer::sum);` is same as \\n```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\\n\\n`Arrays.toString(row)/value` is `key/value` binding of HashMap `cnt`;\\n\\n`Integer::sum` here means that the method `sum` of `Integer` is used to increase by `1` the `value` corresponding to `key`: `Arrays.toString(row)`. The default `value` is `0` in case the `key` is absent.\\n\\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\\n\\n----\\n\\nConvert the rows and cols into tuples, then use them as hash values.\\n\\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n ^ 2)`, where `n = grid.length`.\\n\\n----\\n\\n**Q & A**\\n\\nQ: Can someone explain why do we need to convert it to tuple in python code ?\\nA: List is unhashable! can\\'t use as Key in dict and can\\'t store in set as value.\\nso... we need to convert it to tuple. -- Credit to **@I_and_Me**.\\n\\n**End of Q & A**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631209,
                "title": "c-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d3301764-7132-4285-9a92-9f6415c050da_1686626781.0602562.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325191,
                "title": "java-two-pass-clean-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            sToFreq.put(s, sToFreq.getOrDefault(s, 0) + 1);\\n        }\\n        \\n\\t\\t//convert the numbers in each col to string and find the matches\\n        for (int j = 0; j < n; j++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < n; i++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            if (sToFreq.containsKey(s)) {\\n                res += sToFreq.get(s);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3630977,
                "title": "c-map-fast-solution-w-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2*logn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![ex1.jpg](https://assets.leetcode.com/users/images/41456c5f-1cde-4366-a7f6-74aec6f0f623_1686620000.3283463.jpeg)\\n# Step by Step\\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\\n- We use this to hold the value of each row as a key. To see if a column list is equal to the row key. Since we are comparing rows to columns only one needs to be the key\\n- Example of this for loop\\n    - counter[{3,2,1}] = 1;\\n    - counter[{1,7,6}] = 1;\\n    - counter[{2,7,7}] = 1;\\n\\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\\n- This is getting each list of column values. Since we do not have an array list of column values like row values, we need to create the list ourselves.\\n- Example\\n    - column_list = {3,1,2};\\n    - column_list = {2,7,7};\\n    - column_list = {1,6,7};\\n```\\nans += counter[column_list];\\n```\\n- Now take the values we just got and see if it matches the row keys we created.\\n- Example\\n    - counter[{3,1,2}] = 0;\\n    - counter[{2,7,7}] = 1;\\n    - counter[{1,6,7}] = 0;\\n- ans = 1\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\n```\\nans += counter[column_list];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781858,
                "title": "c-5-or-so-different-approaches-fast-54ms-100",
                "content": "<!---\\nTitle: C++ || a few different approaches with some variants || fast (54ms, 100%)\\nProblem: 2352\\nURL: \\n-->\\n\\nI had quite some fun solving this problem in a few different ways and trying some variants for different approaches. Please let me know if you have another idea or a suggestion for one of the approaches below.\\n\\n**TODO(heder): The complexity analysis isn\\'t complete for all of the approaches below.**\\n# Approach 1: nested loops (490ms)\\n\\nThe first approach is to just check each row against each column, which leads to $$O(n^3)$$ runtime.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n@harsh_negi_07 posted a [neat variant of this idea](https://leetcode.com/problems/equal-row-and-column-pairs/discuss/2781858/c-5-or-so-different-approaches-fast-54ms-100) which is creating the column vectors and then just using ```std::count``` to compare against the rows of the ```grid```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n^3)$$\\n  * Space Complexity: $$O(1)$$\\n\\n\\n# Approach 2: map of vectors (82ms)\\n\\nFirst we count the frequency of each row vector. Then we build a column vector and check in map how many matching row vectors we have got.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\nInstead of\\n\\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\\n\\nwe could just do\\n\\n```cpp\\n            ans += m[column];\\n```\\n\\nwhich would be more compact code, however we would inserting the column vectors into the map as well which is unnecessary.\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): I need to think about this a bit more. We are inserting $$n$$ vectors into map and then we are looking up $$n$$ vectors in this map, but how expensive are these inserts and lookups?\\n  * Space Complexity: $$O(n^2)$$ for the map of vectors. We have up to $$n$$ row vectors and each of them is $$n$$ long. The column vector requires only $$n$$ space.\\n\\n\\n# Approach 3: hash map of std::string_view (54ms, 100%)\\n\\nFor approach 2 you are maybe wondering: Could we use ```std::unordered_map``` instead of  ```std::map```? Well, not out of the box, because the STL doesn\\'t define a hash function for a ```vector<int>```. Now what? One way to work around this is to treat the underlying raw data as the content of a ```std::string_view```. For ```std::string_view``` the STL defines a hash function. A ```std::vector``` guarantees that the underlying storage is contiguous so only the necessary ```reinterpret_cast<>``` makes it a big ugly, but other than that this should all be safe and sound and it\\'s fast.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): Think about this some more. $$O(n^2)$$ because we need to compute the hash for all rows and each of them is $$O(n)$$ long. The insert into the hash map should be $$O(1)$$, but if we have a hash collision we need to compare up to $$n$$ integers. Similar for the columns.\\n  * Space Complexity: $$O(n)$$ for the hash map. This isn\\'t $$O(n^2)$$ as we are only allocating a few bytes per row for the ```string_view```.\\n\\n\\n# Approach 4: hash map of vector with custom hash function (70ms)\\n\\nAnother approach to use a ```std::unordered_map``` here is to provide a custom hash function for ```std::vector<int>```. With the following setup code:\\n\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\\n\\nWe can use the same code for approach 2, but using ```std::unordered_map``` instead of ```std::map```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Approach 5: only compute hashes (not 100% correct) (70ms)\\n\\n**WARNING:** This approach passes all test cases, but is not 100% correct as it doesn\\'t handle hash collisions.\\n\\nWe use the same ```hash_combine``` from the boost library:\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\\n\\n... and then:\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIt\\'s basically the same as approach 3.\\n\\n# Approach 6: trie\\n\\nI saw a solution using a trie instead of a (hash) map. Time permitting I\\'ll give that a trie^Wtry too.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```std::count```\n```grid```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\n```cpp\\n            ans += m[column];\\n```\n```std::unordered_map```\n```std::map```\n```vector<int>```\n```std::string_view```\n```std::string_view```\n```std::vector```\n```reinterpret_cast<>```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```string_view```\n```std::unordered_map```\n```std::vector<int>```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\n```std::unordered_map```\n```std::map```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```hash_combine```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324850,
                "title": "cpp-easy-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324751,
                "title": "find-pairs-using-hashing-o-n-2-solution",
                "content": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3630895,
                "title": "beat-100-o-n-2-o-n-optimal-solution-art-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn my previous [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3564106/beat-100-o-n-2-optimal-solution-true-hash-map/) I explained the basic way for solving this problem. However we needed to copy `vector`s around and that is very expensive. In this solution we are going to use a C++ technique to avoid the copying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a data type `RowOrColumn` that only takes reference to the actual data, not copying them. We then define our own equality operator and hash for it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\nWe no longer copies the data so the extra space needed is only $N$ rather than $N^2$.\\n\\n# Code\\n```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```\\n\\n# Appendix: About the Hash Function.\\nIt is basically copied from the [boost `hash_combine`](https://www.boost.org/doc/libs/1_82_0/libs/container_hash/doc/html/hash.html#notes_hash_combine)\\n\\nIf you are wondering where this magic number `0x9e3779b9` comes from? It comes from the golden ratio:\\n$$\\n\\\\phi = \\\\frac{1 + \\\\sqrt{5}}{2} \\\\\\\\\\n\\\\frac{2^{32}}{\\\\phi} = \\\\text{0x9e3779b9}\\n$$",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324649,
                "title": "java-hashmap",
                "content": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3035336,
                "title": "easy-concise-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631869,
                "title": "c-easy-explanation-maps",
                "content": "# Approach\\nStoring Rows as KEY in Hashmaps\\nChecking through each Column to find Similar rows \\nIf found add the Freq of Row\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325190,
                "title": "count-the-array-column-wise-c-easiest-solution",
                "content": "***Find the transpose of matrix and count the number of equal arrays***\\n***Given Matrix Grid is Treated as Row-Wise***\\n***Transpose Matrix T is treated as Colmun-Wise***\\n\\n***Example***\\n***Grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]***\\nRow-wise (same as Given)\\n3  1  2  2 \\n1  4  4  5 \\n2  4  2  2 \\n2  4  2  2\\n\\nColumn-wise (Transpose of matrix , For explaination)\\n3  1  2  2 \\n1  4  4  4 \\n2  4  2  2 \\n2  5  2  2  \\n\\n***Iterate in Grid and make a array COLUMN-WISE of grid in each iteration***\\n\\n***1st iteration we get -> 3 1 2 2***\\nCount its occurrences in Grid -> 1\\n***2nd iteration we get -> 1 4 4 4***\\ncount its occurrences in Grid -> 0\\n***3rd iteration we get ->2 4 2 2***\\ncount its occurrences in Grid -> 2\\n***4th iteration we get ->2 5 2 2***\\ncount its occurrences in Grid -> 0\\n\\n***Final Answer = 3***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630850,
                "title": "hash-table-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are given a `0-indexed` `n x n` integer matrix grid, we want to `return the number of pairs (ri, cj)` such that `row ri` and `column cj` are `equal`.\\n\\n### Explanation\\n\\nThis problem basically wants us to traverse through the matrix and check which row and columns contains the same pair values and then increment our counter once found.\\n\\nTo do that, we can traverse through our matrix row and use `hash table` to first store the frequencies of each row, converting each row into string representation to create unique keys using `tuple` or `JSON.stringify()` to make it hashable\\n\\nWe then traverse over each column of our matrix, and for each column, we create a string representation by extracting the elements from that current column using `lists`.\\n\\nAfter extracting the current column, we now check if it exists in our hash table. If so, we increment count by its frequency\\n\\nBy using `hash table`, all we need to do is iterate over each row and column once\\n\\n\\n# Code\\n\\n**Python**\\n\\n```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```\\n### Time Complexity: `O(n^2)`\\n### Space Complexity: `O(n^2)`\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2325049,
                "title": "dont-think-too-much",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633511,
                "title": "simple-java-solution-hashmap-easy-to-understand-3-ms-beats-99",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631261,
                "title": "best-c-solution-map-fully-optimized-possible-solution",
                "content": "# Approach\\n- The function initializes an integer variable \"ans\" to zero and a map called \"mp\" with vector<int> as its key and integer as its value.\\n\\n- The first for loop iterates through the rows of the \"grid\" and increments the value of the corresponding key in the map \"mp\" by 1.\\n\\n- The second for loop iterates through the columns of the \"grid\". For each column, it creates a new vector called \"v\" and fills it with the values of that column. It then adds the value of the corresponding key in the map \"mp\" to the variable \"ans\".\\n\\n- Finally, the function returns the value of \"ans\".\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/18f3e1d4-778b-4148-bac1-580b6a4b2f6c_1686627741.015125.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324718,
                "title": "c-simple-solution",
                "content": "**Approach-1:** Compare each row with every column \\n**TC: O(N^3) SC: O(1)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach-2:** Store row and its occurences in a hashmap. Then, store column in a vector and check whether that column is in the hashmap, if it is increase the count by its occurrences.\\n\\n**TC: O(N^2) SC: O(N^2)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631860,
                "title": "c-easy-explanation-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCertainly! Here\\'s the intuition behind my code in simpler terms:\\n\\n1. The code counts the occurrences of rows and columns in a grid using two maps: `pq` for rows and `col` for columns.\\n\\n2. It iterates over each row and increments its count in the `pq` map.\\n\\n3. It extracts the values of each column and stores them in the `col` map, incrementing their count.\\n\\n4. Then, it iterates over the rows and checks if the corresponding column exists in the `col` map.\\n\\n5. If a matching column is found, it calculates the count of equal pairs by multiplying the counts of the row and column.\\n\\n6. It adds this count to the total count of equal pairs.\\n\\n7. Finally, it returns the total count of equal pairs.\\n\\nThe code efficiently counts the occurrences of rows and columns and determines the count of equal pairs by comparing the maps.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }\\n        \\n        map<vector<int>,int> col;  // Map to count occurrences of each column\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);  // Extracting column values and storing them in a vector\\n            }\\n            \\n            col[temp]++;  // Count occurrences of each column\\n        }\\n        \\n        int count=0;\\n        for(auto &i:pq)\\n        {\\n            if(col.find(i.first)!=col.end())  // Check if the column exists in the map\\n            {\\n                count += (i.second)* col[i.first];  // Calculate the count of equal pairs\\n            }\\n        }\\n        return count;  // Return the count of equal pairs\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3630920,
                "title": "hashmap-solution-video-java-c-python",
                "content": "# Brute force and arriving at hashMap\\n1. Brute force: we can go through each row and column of the grid and see if they have the same elements in the same order. If they do, we increase the count. \\nThe problem with this approach is we will be checking twice for column with same values: eg 2, 5, 2, 2 occurs 2 times and we will be rechecking this. This can be avoided using a hashMap to store the row.\\n\\nStore each row as key in the hashMap i.e array 1,2,2,1 will be key and the value will be the count of 1,2,2,1 in rows\\n\\nIterate through the columns and increment the count by value if its Present in the hashMap.\\n\\n\\n# Appoach.\\n1. Create hashMap <String, Integer> hashMap.\\nwhy String?? As array hash is based on reference we convert it to string and store.\\n2. For each row in grid. convert row to String and store in hashMap. increase count if already existing.\\n3. For every column convert the col to String and check if present in hashMap, incerase the ans by value in hashMap.\\n4. return count\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pcH-Ym3EWLU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342273,
                "title": "java-simple-solution-100-fast",
                "content": "I have seen many solutions using hashmap, but we can easily solve this question without complex approach.\\n1) Transpose the matrix\\n2) Iterate through grid, and check for matching cols.\\n\\nTC : `O( N x N) `\\nSpace : `O( N x N) `\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325162,
                "title": "python-2-line-solution",
                "content": "# **Explanation**\\nFirst, Counts all columns frequency.\\nSedcone, iterate rows and accumulate the number of same.\\n<br>\\n\\n# **Complexity**\\nTime `O(n * n)`\\nSpace `O(n * n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631774,
                "title": "c-easy-solution-hash-table",
                "content": "# Intuition\\nWe need to count the pairs of same rows and columns. We can make use of map.\\n\\n# Approach\\nLet us initialise map of vector to int which stores the frequency of a row vector.\\n**map<vector<int>,int>mppr**\\n\\nFirst for every row store the frequency of the row vector.\\n\\nNow for every column vector add the frequency of that vector to ans from mppr.\\n\\nFinally return ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2logn)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537821,
                "title": "c-trie-try-new-approach-easy",
                "content": "---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---\\n# Code\\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448832,
                "title": "python-simple-clean-code-3-solutions",
                "content": "# Code\\n\\n## Using Numpy - having bad TC\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\\n\\n## using Dictionary - Better TC\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\\n\\n## Best of 3\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643204,
                "title": "python-elegant-short-o-n-3-vs-o-n-2-hashing",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324846,
                "title": "easy-solution-using-transpose-of-the-matrix",
                "content": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2324684,
                "title": "c-simple-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633109,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\nTo count the number of pairs (ri, cj) such that row ri and column cj are equal, we need to iterate over each row and column pair and check if they contain the same elements in the same order. If they do, we increment a counter.\\n# Approach\\n\\n1. Initialize a variable `count` to 0 to keep track of the number of equal row-column pairs.\\n2. Iterate over each row `ri` in the range [0, n), where `len` is the size of the grid.\\n    - Inside the outer loop, iterate over each column `cj` in the range [0, len).\\n        - Inside the inner loop, check if the row `ri` and column `cj` in the grid are equal by comparing the elements of the corresponding row and column.\\n        - If the row and column are equal, increment the `count` variable.\\n3. After the loops finish, return the value of `count` as the result.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe solution uses three nested loops: one for iterating over the rows, one for iterating over the columns, and one for comparing the elements of the row and column. The time complexity is \\'**O(n^3)**\\', where n is the size of the grid. In the worst case, when n is large, the time complexity can be considered cubic.\\n\\n- Space complexity:\\n\\nThe solution uses a constant amount of extra space for variables. Hence, the space complexity is **\\'O(1)\\'**.\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632741,
                "title": "c-solution-with-explanatory-comments-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```\\n**Please Upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630904,
                "title": "w-explanation-c-solutions-using-unordered-map-with-own-hashes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn C++, it is hard to use unordered_map for arrays as keys.\\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\\n\\nIn second solution, we build own hash and unordered_map over vector<int> is applicable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\\n# Use Own Hash to use unordered_map over arrays, and faster\\nRuntime 99 ms Beats 85.41%\\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630834,
                "title": "easy-clear-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630816,
                "title": "java-trie-beats-78-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Scan through one row at a time and construct a trie data structure using the values in sequence in the rows.\\n2. The leaf nodes in the trie must store the number of paths that follow the same set of nodes (i.e. the rows containing the exact same elements).\\n3. Now scan through one column at a time and try to traverse the trie using the sequence of values in each column.\\n4. We will either reach a leaf node in the trie, in which case we add the count in the leaf node to our final answer, or we won\\'t find a match at some point and have to break out of the trie traversal for each column.\\n5. Return the final answer which is the summation of the counts of all leaf nodes reached.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630779,
                "title": "daily-leetcoding-challenge-june-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Map\n\n  \n**Approach 3:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3502709,
                "title": "javascript-96-8-runtime-and-81-37-memory",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814071,
                "title": "simple-solution-o-n-3-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642277,
                "title": "best-solution",
                "content": "# Approach\\nUsing Map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634451,
                "title": "easy-optimal-solution-like-no-one-else-custom-rolling-hash-function-used-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile I was reading this question, a few approaches immediately popped in my mind. The first was obviously the BRUTE force approach where you check ever element in every row and column but it takes a lot of time to do that. Now here, I remembered about the concept of Dynamic Programming where the ideology is to NOT repeat calculations. So that is how I thought of using HASH functions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat you do here is... For every row, A hash value is computed using a rolling hash function (Here it is defined as hash()). The hash value depends on the ORDER of elements and their numeric value or \"weight\". Each row gets a unique hash value which can be regenerated by an array having same elements in the same order.\\n\\nNow, the problem is that the input grid[][] may have duplicate rows. So what I thought of was to keep a frequency count of the row in a hashmap where the key is the hash value computed.\\n\\nOnce the map is ready, we calculate the hash value for ALL columns which unfortunately takes O(n^2) because we first construct the array (Done only once, after that we just replace the values) to compute hash value for every column.\\n\\nIf a match is found, we then simply add the frequency to the result because the column matches with BOTH rows (which are identical)\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (O(k))\\n&emsp; *Where k is max(row, column)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634405,
                "title": "c-o-n-2-transpose-method",
                "content": "# Intuition\\nFirstly tranpose the given matrix and then compare the rows of the given matrix and the transpose matrix.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity:O(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633733,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n\\n# Approach\\n->First traverse on the grid in row wise manner & keep on adding elements in the vector  after each row push it in map.\\n-> Then traverse again but this time in column wise manner & now try to find that column array in the map. \\n-> If you get it increase the count \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632398,
                "title": "detailed-python-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\"Please UP-VOTE Friends\"\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631592,
                "title": "python-shortest-1-liners-multiple-solutions-functional-programming",
                "content": "# Approach 1: Brute force\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\\n\\n---\\n# Approach 1: Hashmap\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\nAnother 1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631483,
                "title": "easiest-python-solution-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem aims to count the number of equal pairs in the given grid. One way to approach this is to compare each row in the grid with the first row and check if they are equal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Store the first row of the grid in the variable column_starts_with.\\n\\n2.Initialize an empty list called columns to store the columns of the grid.\\n\\n3.Iterate through each row in the grid.\\n\\n4.For each row, iterate through each element and append it to the corresponding column in the columns list using the enumerate function.\\n\\n5.After iterating through all the rows, the columns list contains the columns of the grid.\\n\\n6.Initialize a variable called equal_pairs to keep track of the count of equal pairs.\\n\\n7.Iterate through each row in the grid.\\n\\n8.For each row, iterate through each element in the column_starts_with list.\\n\\n9.Check if the first element of the row is equal to the element in the corresponding column.\\n\\n10.If the condition is met, compare the entire row with the column to determine if they are equal.\\n\\n11.If the row is equal to the column, increment the count of equal_pairs.\\nFinally, return the count of equal_pairs.\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631470,
                "title": "best-c-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the code, it appears that the `equalPairs` function takes a 2D grid represented by a vector of vectors (`grid`) as input. The function aims to count the number of equal pairs in the grid.\\n\\n\\nThis solution leverages a map to count the frequency of each vector in the grid, allowing us to efficiently find the number of equal pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem, the approach followed by the given code is as follows:\\n\\n1. Initialize a variable `ans` to keep track of the count of equal pairs.\\n2. Create a `map` called `mp` to store the frequency of each vector in the `grid`.\\n3. Iterate over each row (`i`) in the `grid` using a for loop.\\n   - Inside the loop, access the current row of the `grid` and increment the frequency of that row\\'s vector in the `mp` map.\\n4. Iterate over each column (`j`) in the `grid` using a nested for loop.\\n   - Inside the nested loop, perform the following steps:\\n     - Create an empty vector `v` to store the values of the column.\\n     - Iterate over each row (`i`) in the `grid` using another for loop.\\n       - Inside this loop, access the value at column `j` of the current row and append it to the vector `v`.\\n     - After the inner loop ends, increment `ans` by the frequency of vector `v` in the `mp` map.\\n5. After both loops complete, return the final count `ans`.\\n\\nThe approach essentially counts the occurrences of each row vector in the `grid` using a map, and then counts the occurrences of each column vector by transposing the grid. Finally, it sums up the frequencies of equal pairs and returns the count.\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> where M and N are the dimensions of the grid.\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->where M and N are the dimensions of the grid. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/abf00482-9fde-4cf1-9911-a767b8732f15_1686631415.479188.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631290,
                "title": "java-solution-for-equal-row-and-column-pairs-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to iterate through each row of the grid and keep track of the frequency of each row using a map. Then, for each column, construct a temporary array by extracting the elements of the column. Convert this array to a string and check its frequency in the row frequency map. Add the frequency to the total count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count variable to 0 and the size of the grid, n.\\n1. Create a map called rowCounter to keep track of the frequency of each row.\\n1. Iterate through each row of the grid:\\n- Convert the row array to a string using Arrays.toString().\\n- Increment the frequency of the row string in the rowCounter map.\\n4. Iterate through each column of the grid:\\n- Create a temporary array called colArray to store the elements of the column.\\n- Extract the elements of the column by iterating through the rows and accessing the corresponding element.\\n- Convert the colArray to a string using Arrays.toString().\\n- Retrieve the frequency of the column string from the rowCounter map using getOrDefault().\\n- Add the frequency to the count variable.\\n5. Return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the size of the grid. The code iterates through each row and column of the grid once, and the operations performed within the loops are constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2). It uses additional space to store the rowCounter map, which can contain up to n^2 entries in the worst case.\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631059,
                "title": "simplest-python-solution-take-transpose-of-matrix",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630973,
                "title": "brute-force-m-3-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630899,
                "title": "o-n-3-o-n-2-solution-c",
                "content": "#Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324784,
                "title": "just-do-what-it-says-easy-solution",
                "content": "Just do what the question asks.\\n\\nFor a single `row, col` position iterate the whole row and the whole column, and check whether the elements are equal and in the same order.\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784119,
                "title": "python-3-tuple-dict-and-transpose-matrix-using-zip-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```\\n![Screenshot 2023-07-18 at 20.06.44.png](https://assets.leetcode.com/users/images/3d8310a3-d6e3-4a22-8a43-0dec42ff4ee1_1689700226.718251.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634601,
                "title": "python-dictionary-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$, where n is the number of cells in the grid\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632254,
                "title": "c-java-beginner-friendly",
                "content": "# Intuition\\nJust move every rows in a map and count them then compare it with the cols,if they are equals then increase the result value\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If i did it in brute force approach then we have to take a row and compare it with all the columns (comparing done by element by element) so the total time complexity would be $$O(n^3)$$ (n*n for compare row and col and n * n *n to compare element by element)\\n2. But In optimal approach we store the row-wise value as a string format in a map,But we have to join the numbers by some special character like ($$#,$,@ etc$$) cause lets take a case a row-wise value is 2,2,1,0 and if i joined it without special char then the string would be like \"2211\" and suppose in col-wise the value is 22,1,1 and after joining without special chars the string would be like \"2211\",Now both the strings are same and it will increase our result,but thats not true. So thats why we put a special char between every number.\\n3. After apply the logic the strings look like this row-wise=\"2@2@1@1\" col-wise=\"22@1@1\" ,now both are not same.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:Brute force->$$O(n^3)$$\\n                  Optimal approach->$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ for storing the rows in a map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**If you enjoyed the solution \\uD83D\\uDE01, an upvote would be greatly appreciated! Your support motivates me to share more helpful solutions. Thank you!**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631695,
                "title": "no-map-no-trie-two-o-n-3-approach-c",
                "content": "# Intuition and Approach\\nWe are Simply creating a new vector<vector<string>> and then storing elements in it column-wise and rowWise\\nso now we have two vectors gc-gridColumnWise , gr-gridRowWise\\n\\nwe iterate through them and equate them to see if any pairs of vector is same in both of them\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - Less than O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code - O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631010,
                "title": "easy-to-understand-c-solution-python-solution-fastest",
                "content": "# Approach : Map\\n<!-- Describe your approach to solving the problem. -->\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n# Code 2\\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Approach : Simple Comparison { Python}\\n<!-- Describe your approach to solving the problem. -->\\n# Code 3\\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564106,
                "title": "beat-100-o-n-2-optimal-solution-true-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use hash map for most problems of *finding the number of pairs*.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe tricky part here is that we are dealing with rows and column. The rows are already `vector<int>`. We can dump columns into `vector<int>` as well and use a custom hash function for it.\\n\\n**DO NOT USE `std::map` FOR HASH MAP USAGE CASES**\\n`std::map` is both suboptimal in big O and practically quite slow.\\n\\n# Better Solution\\nI added another [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/) that is an improved version of this one by not copying any data.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473341,
                "title": "easy-solution-using-2-maps",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[j][i]);\\n\\t\\t\\t\\tcol[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto x: row){\\n\\t\\t\\t\\tif(col.find(x.first)!=col.end())\\n\\t\\t\\t\\t\\tres+=(x.second*col[x.first]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2344176,
                "title": "c-easy-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        { \\n            vector<int>chk;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n            chk.push_back(grid[j][i]);\\n            ans+=mp[chk];\\n            }\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2324818,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324772,
                "title": "python3-freq-table-o-n-2",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324671,
                "title": "c-equal-row-and-column-pairs-easy-solution",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731477,
                "title": "java-easy-solution-using-hashmap-and-string-patterns",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636433,
                "title": "simple-easy-approach-with-beats-52-42-in-runtime-and-95-31-in-memory",
                "content": "# Intuition\\nVery simple logic I followed, go ahead with the checking untill you got diffrent numbers.\\n\\n# Approach\\n1. Take two pointers for the row and column [ ex: `r`& `c` ]\\n2. Start a while loop for untill your pointer for row and column touches the length of the grid means `n`.\\n3. Take another two pointers for itreating the rows and cols [ ex: `i` & `j` ]\\n4. Check `grid[r][i] === grid[j][c]`, untill it dismatch, go ahead and if you find that your `i` & `j` reaches `n` means grid\\'s length then `increment/++` the count of the equal Row and Cols\\n5. After this, just do `column++ / c++`. And If you reach in the last column then restart the column number from 0 like `c=0` and increase the value of the row `row++ / r++`\\n6. Now you\\'ve the no of equal rows and cols, just return it outside of your loops;\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n![Beats.PNG](https://assets.leetcode.com/users/images/e3ea9158-de0d-4065-94ce-3b81c9ca9ba5_1686729479.15648.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634899,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634864,
                "title": "c-u16string-hashing-vs-trie-100-time-58ms-85-space-24-1mb",
                "content": "My first intuition was that it would be rather easy to hash each row, count the frequency of each hash and then do the for each column, adding the frequency previously found to the result for each match.\\n\\nIn order to do so, a normal `string` would not cut it, since `char`s go with `7` bits and cut out the rest, so we will get tons of collisions from that. But with `16` bits, we can cover almost completely the full range (to go up to `10e5` we would have needed `17`, but with `16` we do well enough to avoid any collisions with all the test cases, although you might argue that a few such cases might be created to let us slip with this approach).\\n\\nWe will start `using` `u16String` as our `hashType`, then declaring our usual support variables:\\n* `hashFreq` will map hashes to their respective frequence;\\n* `res` is our usual accumulator variable, initially set to `0`;\\n* `len` will store the size of the provided `grid`;\\n* `tmp` is our helper string, preset to be `len` characters.\\n\\nWe will start parsing the rows first and for each `row` in `grid`, we will:\\n* declare our writer pointer `w` with initial value of `0`;\\n* loop through each value `c` in `row` and:\\n    * write it in `tmp[w]`;\\n    * advance `w` by `1`, ready to write in the next cell;\\n* increase `hashFreq[tmp]` by `1`.\\n\\nWith our hashes so computed for each row, time to do the same for each column `x` in grid and we will:\\n* loop through each row `y` in `grid` and write `grid[y][c]` in `tmp[y]`;\\n* assign the result of `hashFreq.find(tmp)` to `it`;\\n* if we ever found such a value (ie: `it != end(hashFreq)`), we will then increase `res` by that value (ie: `it->second`).\\n\\nOnce done, we can finally `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/30054297-a35b-49b2-8dc1-25591b39578a_1686687724.9152997.png)\\n\\n\\nNext I tried my other idea, a `Trie` approach, since this again goes well when you need to check your matches in a given dictionary and in a way I was doing that with my string hashing, but could have been done MAYBE better with something like this DS.\\n\\nIn this approach we will create a `Trie` `struct` which will just have two properties:\\n* `matches`, initially set to `0`, will store all the matches we have for a given chain (it will be increased only for the end-of-chain nodes);\\n* `children` is a set of `bucketSize` pointers we will use to connect each node to its descendents on a chain.\\n\\nIn our main function we will proceed similarly to the previous approach, declaring a first `Trie` node `root` and a `Trie` pointer `curr` instead of `tmp`.\\n\\nFor the rows we will then proceed for each character `row` and:\\n* `reset` `curr` to be `root`;\\n* for each value `c`, we will:\\n    * try to get its modulo `bucketSize` by consistently subtracting it `while` `c >= bucketSize` (see the third solution here for my thoughts on actually using `%`);\\n    * check if we do not have `curr->children[c]` and if so, we will create it as a new `Trie` node;\\n    * advance `curr` to be `curr->children[c]`;\\n* finally, having reached the last node of this chain, we will increase `curr->matches` by `1`.\\n\\nAgain, we will proceed specularly for each column, getting `grid[y][x]` as `c` and with two sole differences:\\n* whenever we do not find a node to advance next (ie: `curr->children[c] == NULL`) we will `break`;\\n* at the end of each inner loop, we will increase `res` by `curr->matches` (which is going to be `0` every time we hit `break` before reaching the end of a previously created chain).\\n\\nTweaking `bucketSize` has a MASSIVE effect on performance and turns out using a small enough number (initially I tried `1337`, but quickly run out of memory; it was slow but working with `137` and rather fast for other significantly smaller values, while still burning way more memory than the string hashing approach):\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n- \\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAs a proof of how expensive is to compute a modulo, this alternative version while I don\\'t just use repeated subtraction to reduce all the numbers above `bucketSize` ran actually a bit slower after several tests (I am sure it would be the opposite with `grid` being populated with larger numbers, but that is really telling):\\n\\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNeedless to say, I wanted to try also with a hashmap for `children`; boring, and way slower and more inefficient than expected:\\n\\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Trie",
                    "Hash Function"
                ],
                "code": "```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633184,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632259,
                "title": "simple-and-explained-solution",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the number of equal pairs.\\n2. Iterate over each row in the grid.\\n3. For each row, iterate over each column in the grid.\\n4. Compare the current row with the corresponding column using the getColumn helper function.\\n5. If the row and column are equal (i.e., they contain the same elements in the same order), increment the count variable.\\n6. After iterating over all rows and columns, return the final value of count.\\n\\nThe getColumn helper function extracts the elements from a specific column in the grid and returns them as a separate vector. It loops over each row and retrieves the element at the specified column index, constructing a vector representing the column.\\n\\nBy comparing each row with each corresponding column, the solution correctly counts the number of pairs where a row and column are equal.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631921,
                "title": "java-python-most-easy-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts of solving this problem was to mantain a data structure to store the value vertically and then compare it horizontally\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap data structure is used to store the value of array in form of String along with their counts i.e. how many times they occur vertically. Then same approach is used while traversing horizontally and after each iteration value of String is fetched from map and added to count.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631670,
                "title": "doubt-regarding-hashmap-solution",
                "content": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3631552,
                "title": "clean-java-solution",
                "content": "\\n# Approach\\nLoop on each row, col index; then compare each element in the row with the col. \\nEx(grid[row][i] == grid[i][column])\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631299,
                "title": "finding-the-transpose",
                "content": "### Find the transpose of given grid and solve by comparing each row of grid with each col of the transpose of that grid matrix.\\n---\\n# Python Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631034,
                "title": "c-fast-code-88-beat-most-optimal-approach-o-n-2-updated-97-beat-correct-solution",
                "content": "We have to compare rows and arrays, instead of comparing element by element can we do it in O(1) operation?\\nHere in this approach i have used a pair that uniquely identifies each array, the first value of pair is the addition of each value multiplied by its index and the second value is sum of the array.\\nComparing based on this value, we can find the ans in N^2 time instead of N^3 time.\\n(88% beat code)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N*(log N + N)) = O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Updated:\\nThis approach fails for some test cases that are not present in the leetcode test cases, for ex  [[2,3,4],[6,1,7],[8,5,9]]\\nThanks to @yjian012 for the correction.\\nSo, the correct approach would be use whole vector as key. The code for the same is below (97% beat)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631004,
                "title": "2-liner-beats-93-simple-python-code-using-zip",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`zip` will allow us to easily convert the grid into an iterable column\\n\\nWe simply use tuples to store the rows into the hash map and we then check the column tuples against the row hash map and count the number of matches.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n When we construct the initial `rows` hashmap it is $O(n^2)$ since we go through each row and to construct each tuple $O(n)$(? im not sure)\\n\\nLikewise it is $O(n^2)$ for when we are checking and also the time complexity of `zip` (If all the tuple conversion time complexity is $O(n)$)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends on the implementation of the hash map\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\\n\\n## 2 Liner\\nUsing `Counter` as well as list comprehension we can get a significantly shorter piece of code that can run fast\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630966,
                "title": "rust-elixir-hash-map-solution",
                "content": "Elixir\\'s code is very simple for doing this kind of operations.\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3630965,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "\\n# Approach\\nBrute force\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Approach\\nNo extra Space two pointer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630907,
                "title": "c-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630785,
                "title": "short-ruby-solution-with-explanation",
                "content": "# Intuition\\nCount how often each row appears.  Total the number of rows matching each column.\\n\\n# Approach\\n1. Create a hash where rows are keys and their frequencies are values.  (We\\'re using a hash instead of a set because a row can appear multiple times.)\\n2. Initialize total to 0.\\n3. Transpose the grid to iterate through the columns.  For each column, add the number of matching rows to total.\\n4. Return the total.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3586137,
                "title": "golang-map-solution-without-using-strings-conversion-fast-and-memory-effective",
                "content": "# Intuition\\nTo find number of pairs it is enough to count all variants for rows, and then compare it with columns\\n# Approach\\nTo faster comparison we use golang map. We can not use slice as key, so replace it with array $[200]int$ ( other variant is to convert slice in some string). We add every row in map, and then we run through all columns and look for it in map.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ to build all columns\\n\\n- Space complexity:\\n $$O(n)$$ - we use map with mostly $n$ different keys\\n\\n# Code\\n```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552258,
                "title": "golang-trie",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497467,
                "title": "c-easy-approach-brut-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420644,
                "title": "python3",
                "content": "![image.png](https://assets.leetcode.com/users/images/11c9dc60-d43c-47a3-98f7-2bbb206ba35f_1681579473.8935993.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282176,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\\n\\nOr\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264514,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3239054,
                "title": "c-simple-clear-concise-easy-to-understand-single-hashmap-matrix-code-quality",
                "content": "\\n# Code\\n**Bruteforce:-**\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Optimized:-**\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169755,
                "title": "javascript-solution-with-hashmap",
                "content": "### Want to say thank you if you give me a thumbs up\\n###### this solution is $$O(n^2)$$ time and space, if I found more better solution I\\'ll come back and update it.\\n# Intuition\\n1. Question to find row has same value with column\\n2. We can use each row join as key, then  column join as value to check has same value with row\\n3. Here have issues\\n    >* **What if a row shows in 2 or more times**\\n     -> answer we set value as an array store two value [rowShowTime - 1, columnMetcahRowTimes]\\n    >* **What if we have [11,1] [1,11] when join they are all equal to 111 but 11,1 != 1,11**\\n    -> answer we join with \\',\\' so  [11,1] [1,11] will became \"11,1\" and \"1,11\"\\n\\n4. Then we just return result += hashMap.value(value[0] * value[1]) why * not +, because the value[0] is show times\\n\\n# Approach\\nHere we use hashMap\\n1. initial hashMap, then loop through grid assign to hashMap key as row.join(\\',\\') value = [0,0] if that key already exist value[0] += 1\\n2. loop through grid i = 0; i < grid[0].length; i++, because its grid, so each subarray has same length (we want each the column += eachRow[j][i] to get column sum).\\n    * let column = [] //use array not string because in js string is immutable, evertime string += 1 need to create a new string.\\n    * while loop j < grid.length //idea is to loop vertically which is column\\n        * column.push(eachRow[j][i]) \\n        * j++\\n        * column = column.join(\\',\\')\\n        * check if hashMap has value then value += 1 else continue\\n\\n3. finally we just have to loop through hashMap value\\n    * result += value[0] * value[1]\\n4. return result\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900905,
                "title": "java-2-hashmaps-clean-and-simple",
                "content": "# Please Upvote :D\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/51265fcd-5172-4e47-a6ae-2fb7c55b8eb0_1670755996.5962312.png)\\n\\n---\\n\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773068,
                "title": "c-easy-to-understand-10-faster-than-most-voted",
                "content": "#  **Please upvote if it helps!!\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444509,
                "title": "c-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403516,
                "title": "c-rust-c-rolling-hash-o-n-2-time-o-n-space",
                "content": "##### C++\\n\\n```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n---\\n\\n##### Rust\\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n\\n---\\n\\n##### C#\\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#",
                    "Rolling Hash"
                ],
                "code": "```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356230,
                "title": "c-easy-solution",
                "content": "**Pls upvote if it\\'s helpful**\\n```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352684,
                "title": "python-radix-sort-solution-explained-o-n-2",
                "content": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2352409,
                "title": "c-easy-solution-please-upvote",
                "content": "//STORE EACH ROW  AND ITS COUNT  THEN MATCH WITH EACH COLUMN \\n// FOR MATCHING ROW COL  , INCREMENT ANS = ANS + NO OF TIMES( ROW)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1});\\n            }\\n            else\\n            {\\n              s[grid[i]]++;  \\n            }\\n        }\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n            for(int j =0;j<grid.size();j++)\\n            {\\n                 temp.push_back(grid[j][i]);\\n                \\n            }\\n            if(s.find(temp)!=s.end())\\n            {\\n                res= res+s[temp];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1}",
                "codeTag": "Java"
            },
            {
                "id": 2344208,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339230,
                "title": "rust-hashmap",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc2352)\\n\\n<b>Problem List</b>\\n#HashMap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/map/hashmap)\\n#CountOccurrences - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_topic/count_occurrences.txt)\\n#MatrixManipulation - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array/by_topic/manipulation/matrix)\\n#Trie - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/tree/by_data_structure/trie.txt)\\n\\n```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336822,
                "title": "faster-than-80-java-solution-using-hashmap-stringbuilder",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            hmap.put(dummy,hmap.getOrDefault(dummy,0)+1);\\n        }\\n        int c=0;\\n        for(int j=0;j<grid[0].length;j++)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                sb.append(grid[i][j]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            if(hmap.get(dummy)!=null)\\n            {\\n                c+=hmap.get(dummy);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2327741,
                "title": "i-love-this-solution-o-n-3",
                "content": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2326298,
                "title": "c-easy-map-with-approach",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326136,
                "title": "java-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325221,
                "title": "typescript-hashmap",
                "content": "\\n```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325047,
                "title": "c-easy-hashmap-o-n-2-solution-o-n-space",
                "content": "**Logic**\\nStore every rows in hashmap as a string of number separted by underscore, For an example if row contain following [2,44,5,9] then key of hashmap will be \"2_44_5_9_\"\\n\\nNow iterate over each column and convert them to string in same way and add check if key is in map then add key -> value to ans .\\n\\n```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324873,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324832,
                "title": "javascript-solution",
                "content": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324686,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }\\n                    else\\n                    {\\n                        break;                // If an unequal element is found check for next column.\\n                    }\\n                    \\n                    if(count==n)              // If all the elements of that row and column are equal increase the answer.\\n                        ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4031071,
                "title": "java-easy-to-understand-97-faster",
                "content": "# Complexity\\n- Time complexity: \\n1st Code - O(n^2)\\n2nd Code - O(n^3)\\n\\n\\n# Code\\n- Space complexity: O(n^2)\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n- Space Complexity = O(1)\\n```\\nclass Solution {\\n    public boolean check(int[][] grid, int row, int column){\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            if(grid[i][row]!=grid[column][i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int equalPairs(int[][] grid) {\\n        int ans=0;\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                if(grid[0][i]==grid[y][0]){\\n                    if(check(grid, i, y)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024091,
                "title": "c-using-map-easy-and-straightforward-code",
                "content": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N^2)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924219,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826240,
                "title": "c-beats-99-34-runtime-set-unordered-map",
                "content": "# Intuition\\nUse a set to keep track of duplicate rows and use an unordered map to keep track of each multiple duplicate rows\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3724518,
                "title": "easy-java-solution-clean-code-easy-understanding",
                "content": "# Intuition\\nTo solve this problem, we need to compare each row with each column. However, doing this directly would be inefficient. An idea is to convert rows and columns to strings (with a separator for each element) and store them in two separate hashmaps, counting the frequency of each unique row and column. Then, we iterate through the keys in the hashmap for rows, and for each row that is also a column (i.e., exists in the hashmap for columns), we multiply their counts from both hashmaps, which gives the number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n\\n# Approach\\n1. Initialize two hashmaps, rowMap and colMap.\\n2. Iterate over the matrix to populate rowMap and colMap with the counts of unique rows and columns, respectively. For each row or column, we create a string representation (with a separator to handle multi-digit integers correctly) and increment the corresponding count in the appropriate hashmap.\\n3. Initialize a variable count to store the total number of pairs (ri, cj) where row ri and column cj are equal.\\n4. Iterate over the keys in rowMap. For each key that also exists in colMap, add the product of their counts in both hashmaps to count.\\n5. Return count as the total number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n# Complexity\\n**Time complexity:** The time complexity is O(n^2) because we have to iterate through the matrix to populate rowMap and colMap, which takes O(n^2) time. We then iterate through the keys in rowMap (in the worst case, there are n keys), and for each key, we check its existence in colMap and retrieve the count, which takes O(1) time. So the total time complexity is O(n^2) + O(n) = O(n^2).\\n**Space complexity:** The space complexity is O(n^2) because in the worst case, if all rows and columns are unique, we store n keys in both rowMap and colMap, and each key is a string representation of a row or a column, which has length n. So the total space complexity is O(n^2) + O(n^2) = O(n^2).\\n\\nUpvote if you like the solution and explaination! \\uD83D\\uDC4D\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670344,
                "title": "c-hashing-maps",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659438,
                "title": "super-fast-and-simple-javascript-solution-beats-99-8",
                "content": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636603,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636373,
                "title": "c-brute-force-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a `temp` matrix & copy `grid` into it \\n2. **Rotate the temp matrix** \\n3. *Compare the rows* of both the matrices now\\n4. If row of grid & temp matrix is same then *increase the count* \\n5. **Return count** in the end\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/34f022a6-57c6-486e-aea8-7a98397b0fd3_1686728313.9694998.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636026,
                "title": "sipmle-python-solution-100-faster-then-you",
                "content": "# Intuition\\nI like rotate matrix :) \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634590,
                "title": "java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare every element with every element\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Compare every row with every column.**Bold**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634484,
                "title": "easiest-c-code-with-o-n-2-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is quiet simple first we copy the original matrix then transpose the original matrix after transpose row become column and column become row now we will check the row of transpose and copied matrix using loop if rows of both the matrix are same then we will do cnt++ and then return cnt\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease Upvote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634482,
                "title": "c-easy-and-readable-solution-less-than-84",
                "content": "![image.png](https://assets.leetcode.com/users/images/f46f1a9c-4a0d-4880-9711-3d55b82b3c76_1686679900.7108681.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634454,
                "title": "easy-to-understand-c-code-complete-explanation-o-n-2-time-complexity-hashmap",
                "content": "# Intuition\\nWe will use mashmap for this problem.\\nconvert every row of the matrix into a string and store it as a key value in an **unordered** map.\\nincrement value of map corresponding to key value each time you find a string in each row.\\nNow iterate over each columns and similarly convert it into string and add the corresponding value found in rowmap to the answer,\\nreturn the result.\\n\\nKindly upvote if you like the solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634370,
                "title": "c-using-hashmaps",
                "content": "First we will create a map of rows being the key.Then we will create a vector of columns and check if the vector is presented in the map. If yes we will add it to count.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634366,
                "title": "daily-challenge-6-13-2023-python3-easy-solution",
                "content": "# Intuition\\nTo approach this, simply make a rotated grid and compare each rows see if they are duplicate. \\nRuntime 496 ms Beats 72.9%\\nMemory 21.3 MB Beats 82.96%\\n\\n# Approach\\n1.  Using zip() to make a rotation grid.\\n    rotatedgrid = list(zip(*grid)):\\n    [3,2,1]->[3,1,2]\\n    [1,7,6]->[2,7,7]\\n    [2,7,7]->[1,6,7]\\n\\n2.  Store each row as Tuple in a dictionary.\\n    In case there are duplicate rows in grid, save tuple(row) as key and counts as value in dictionary.\\n\\n3.  Loop \"rotatedgrid\" check if row is in the dictionary, add the value to answer.\\n(value means how many times it duplicate with origin  rows)\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634327,
                "title": "magical-solution-using-string-and",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634271,
                "title": "easy-code-no-complication",
                "content": "just simply run loops to put all the rows as String in hashMap\\nthen check if columns exist in hashMap or not\\n\\nas easy as that\\n\\ndo not know why people are over-complicating this question\\n\\nthe code should be self explanatory\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634066,
                "title": "easy-solution-3-loop-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633822,
                "title": "c-solution-using-ordered-map-of-vector-and-int",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633794,
                "title": "c-super-cool-easy-to-grasp-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633741,
                "title": "hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633546,
                "title": "beginner-friendly-easy-to-understand-solution-c-o-n-2",
                "content": "# Intuition\\nThis solution is only for understanding better. Just you need to know about vectors in STL C++.\\n\\n# Approach\\nWe are aldready having row vectors in grid, so take column vectors in another 2D array type, and compare both of them. If found similar, increase the answer by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). As this is Beginner friendly, it takes O(n^2) time to solve the problem \\n\\n- Space complexity:\\nO(n^2). It takes one 2D vector, to store. So O(n^2) space complexity.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633465,
                "title": "python-solution",
                "content": "# Intuition\\nFirstly, one would need to check that for each row, how many of the same amount of columns are there. However this solution takes too long due to us having to reiterate each row/col multiple times. \\n\\n# Approach\\nTherefore, it may be better to use a hashmap or dictionary in python to store the rows and columns. This way, since the access time is O(1) and there is no need to reiterate the same problem multiple times. For each possible rows and columns in a grid, we would then store the number of times it appears.\\nAfter computing every row and column, we would then take the multiplication of the number of rows with the number of columns to find all equal row/cols pair and add it to our final answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633430,
                "title": "python-beats-100-optimised-solution",
                "content": "# Intuition\\nThe code counts the number of equal pairs of subgrids in a given grid. It uses a dictionary to store the frequency of encountered subgrids and iterates through the grid to construct and compare subgrids, incrementing the count when equal pairs are found.\\n\\n# Approach\\n1. Initialize an empty dictionary dic to store the frequency of subgrids and a variable count to keep track of the number of equal pairs.\\n\\n2. Iterate through each row i in the grid list:\\na. Convert the current row i to a string representation using str(i).\\nb. Use the get() method of the dictionary dic to retrieve the frequency of the current row. If the row is not present in the dictionary, it returns 0, to which 1 is added. Then, update the dictionary with the new frequency.\\n\\n3. Iterate over a range from 0 to the length of the grid list:\\na. Initialize an empty list temp_lst to store the current column\\'s elements.\\nb. Iterate over a range from 0 to the length of the grid list:\\n-Append the j-th element of the grid list\\'s j-th row to the temp_lst.\\nc. Convert the temp_lst to a string representation using str(temp_lst).\\nd. Use the get() method of the dictionary dic to retrieve the frequency of the current column. If the column is not present in the dictionary, it returns 0.\\ne. Add the obtained frequency to the count variable.\\nReturn the final value of the count variable, which represents the number of equal pairs of subgrids in the grid.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633420,
                "title": "c-easiest-and-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633270,
                "title": "java-beginner-friendly-for-while-loops-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni -> Iterator for the rows(ex: 0,1,2).\\nj-> Iterator for columns..resets to 0 when reaches n( ex:0,1,2 (reaches n so 0,1,2...until i reaches n) ) //Basically we compare a row with each column.\\nk->Iterates through the elements. If not equal breaks. Else if k==n which implies all elements were equal so we increment final ans c. then go to next column j++;\\nif(j reaches n) -> we go to next row and compare with all columns by reseting j to 0;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633208,
                "title": "c-o-n-2-tc-and-o-n-sc",
                "content": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633198,
                "title": "java-solution-o-2-n-2-o-n-using-hashmap",
                "content": "# Intuition\\ni thought we can simply go through each row and store the numbers as a string in a HashMap with their frequency. And then we can traverse through each column and store the number of column in a string to compare it with the HashMap elements after each column iteration ends.\\n\\n# Approach\\n1- I created a HashMap to Store each row elements as a String with their frequencies. \\n2- I started with row wise traversal where i used a StringBuilder to easily concatenate the values as a String.\\n**The reason i used \\'#\\' to append after each value is due to the case where in a row there might be all same digit numbers such as in example [[11,1],[1,11]] where when you will store the number as String without appending \\'#\\' you will get 111 and 111 which is completely wrong.**\\n3- Then i am just updating the frequencies.\\n4- Now i started with column wise traversal and storing every column as a string and then looking if the column string is present in the hashmap.\\n5- if it is present in the hashmap ,then add their frequencies to the count\\n\\n# Complexity\\n- Time complexity:\\nfrom my analysis it is -\\n\\n1. O(N^2) for row traversal \\n2. O(N^2) for column traversal \\n3. O(N) for hashMap lookup and Insertions \\n4. //correct me if i am wrong  \\n\\n- Space complexity:\\nAs i took a hashMap ,it can go as long as O(N) space complexity\\n//correct me if i am wrong\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633158,
                "title": "equal-row-and-column-pairs",
                "content": "# Intuition\\nWe can optimize this approach by using a hash map data structure to reduce the time complexity.\\n\\n# Approach\\nIn this approach, we can consider each row as the key and store it in a hash map. The corresponding value for each key would be the frequency of that row in the grid. Then, we can traverse through each column of the grid and increment the answer by the frequency of the equivalent row in the hash map.\\n\\n# Complexity\\n- Time complexity:   O(n^2)\\nWe iterate over each row and column only once, converting one array of length n into a hashable object takes O(n) time.\\nOperations like adding or checking on hash map take O(1) time.\\n\\n- Space complexity:   O(n^2)\\nWe store each row of the grid in the hash map, in the worst-case scenario, row_counter might contains nnn distinct rows of length n.\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633097,
                "title": "2-approach-c-o-n-1-space-and-o-n-3-time-o-n-2-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn equal pair is formed by two rows in the grid that have the same elements in corresponding positions.\\nWe need to count the number of such equal pairs in the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map **gridRow** to store the **frequency** of each row in the grid.\\nThe **key** of the map is a vector representing a row, and the value is the frequency of that row in the grid.\\n```\\n map<vector<int>,int> gridRow;\\n```\\n- Iterate through each row in the grid and update the frequency in the gridRow map.\\nFor each row row in the grid, increment gridRow[row] by 1.\\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\\n- Create a temporary vector temp to store the elements of each column.\\n```\\n vector<int>temp;\\n```\\n- Iterate through each column in the grid.\\n\\n For each column, iterate through the rows and store the   corresponding elements in the temp vector.\\n This step effectively transposes the grid, allowing us to treat columns as rows\\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\\n- Check if the temp vector exists as a key in the gridRow map.\\n\\nIf it does, increment ans by the frequency of the column stored in gridRow[temp].\\nClear the temp vector to prepare it for the next column.\\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\\n# Complexity\\n- Time complexity:**O(N^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\\n# Code 2\\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n map<vector<int>,int> gridRow;\\n```\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\n```\\n vector<int>temp;\\n```\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633018,
                "title": "easy-c-solution-o-n2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632977,
                "title": "c-2-solutions-easy-methods-bruteforce-and-map",
                "content": "# Approach I\\nThe bruteforce method would be to compare each row with each column taking $$ O(n^3) $$ time and constant space.\\n\\n\\n# Approach II\\n<!-- Describe your approach to solving the problem. -->\\nBy using map (for using vector directly) or unordered map (by converting vector to string) to map every row, and then comparing every column with it.\\nIt takes $$ O(n^2) $$ time and $$ O(n^2) $$ space \\n\\nConversion to string takes extra time and memory, so its better you make your own hash function and use it with <unordered_map> (you can\\'t use vector with unordered map)\\n\\n# Code I\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# Code II\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632828,
                "title": "maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632721,
                "title": "2352-equal-row-and-column-pairs-mapping",
                "content": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632595,
                "title": "c-trie-o-n-2",
                "content": "If you are not familiar with `Trie` data structure you can solve [this](https://leetcode.com/problems/implement-trie-prefix-tree/) leetcode problem on trie and see [this](https://youtu.be/oobqoCJlHA0) video\\n[https://youtu.be/oobqoCJlHA0]()\\n```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632583,
                "title": "easiest-approach-o-n-2-explained-in-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632488,
                "title": "easy-c-solution-with-explanation-runtime-99-ms-space-28-1-mb",
                "content": "# Intuition\\n\\n# Approach\\nThere are three approaches to solve this question\\nFirst is Brute force\\nWe check each row with each column and if they are the same, we add one to the count\\nSecond is also Brute force but reduces some comparisons\\nWe store the sum of each row and column in another vector and only compare the row and column if there sums are equal\\nThird approach is using maps\\nPush all the row vectors into a map, \\nThen increment the count by the frequency of how many times a column appears in the map\\n# Complexity\\n- Time complexity:\\n    O(n^2), as we go over the whole matrix\\n- Space complexity:\\n    O(n) \\n###    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632466,
                "title": "python-o-n-2-time-o-n-space-breadth-first-sequence-trie",
                "content": "# Intuition\\nI wanted to try for a solution that skipped unneccesary comparisons at the earliest possible moment, and minimized storage.\\n\\nThe approach that jumped out as a way to do this was to collect matches for each element in a sequence, then only continue to check rows and columns that continued to match. For example, collecting all the rows and columns that match for the 1st element of the sequence. Then, when we moved on to the 2nd element, we need only check that the existing matches continue to have matches with each other.\\n\\nA Trie is well suited for this task, but how it was used in this solution is very different than the suggestion in the editorial. A Breadth First approach to both constructing and validating the trie would discard invalid cases at the earliest opportunity, minimizing best case time needed. The trie nodes only representing valid matches would allow us to only store each index a maximum of 2 times each level, once for row, and once for column. This is key to the better space demands, as we don\\'t need to keep trie nodes we\\'ve already processed.\\n\\n# Approach\\nAt the end of the function, we\\'d need to return the count of the pairs. We start with a variable at the outer scope we can add to later:\\n\\n\\n```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\\n\\nAs an overview, I wanted to construct a Trie.\\n\\nThe keys for the children along a path down the tree would represent the values for the sequence, and the value for the key would recursively be another TrieNode\\n\\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\\n\\nThe children need to be populated. Our breadth first approach demands we collect rows and columns. We\\'ll start by iterating through the first row. \\n\\nEach element in the first row represents the first value in the sequence of a column. This element\\'s value will be the key for child nodes. We can\\'t know yet if there is going to be a match in rows, so for every new value we see, we create a new child node.\\n\\nIn order for us to contine testing matches along this sequence, we need to be able to continue validating along the same column. We will store all the column indexes in lists in the children TrieNodes, but if it\\'s a grid value we\\'ve already seen, it gets added to the existing node.\\n\\nWe also will need to remember which index we are on in the sequence, just the column isn\\'t enough. We will provide that to the TrieNode and store it with the constructor.\\n\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nWe do something similar for the rows by iterating through the first column. \\nThe row indexes get stored in lists the children nodes too. The TrieNode index is the same, 0th element in matching sequence so nothing changes there.\\n\\nThere is a slight difference when it comes to finding grid values we haven\\'t yet seen. One way to do it would be identical to the columns, just create new children as needed and add all rows in. If we think for a moment though, this doesn\\'t make sense. Only matches are relevant and anything new doesn\\'t have a column match. Every child we created at this point would be discarded at the next step. For that reason, it is slightly better to just skip creating children for grid values we haven\\'t already seen.\\n\\nI threw in some functions that will allow us to use `print()` for TrieNode as well, which I used to help troubleshoot issues as they arose.\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nAt this point, we have a root node of the Trie. The index is 0, and the keys for the children are the 1st number of the sequence. The values of the children contain the lists of row and column grid indexes that belong to that sequence and an sequence index value of 1. Their children\\'s children are emtpy, as we haven\\'t gotten to them yet, that\\'s what we need to do next. Since the plan is breadth first, we will create a queue and add the children to it. We use deque, with appendleft() and pop() for a FIFO queue.\\n\\nWhile we are adding, we will also validate. There needs to be rows and columns for a valid sequence. If either are missing, then we are finished with this sequence as this can\\'t lead to matching rows and columns. Every node will have columns, since every columns first sequence value had a node created for it, and none were created for row values with empty columns. Not every node will have rows, as there is no guarantee that they matched, so we validate that matches exist by checking that there are some positive number of rows before adding it to the queue.\\n\\n\\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\\n\\nNow that we have all the child nodes in a FIFO queue, Breadth First is just taking items out of the queue, then processing each child node in a way very similar to what we did with root earlier, including adding thier children. The main change is dropping the hardcoded values. The index represents both the level in the tree the node sits at, and the index in the sequence for the rows and columns that have matched so far. Up to now, we have hardcoded the index.\\n\\nWhen iterating over the columns, the way to get the `i`th element for the sequence of the column `c` from the grid is `grid[i][c]` and for row `r` its reverse, `grid[r][i]` . The formula for it\\'s change between parent and child couldn\\'t be simpler, it just increments by 1. The node index we stored with the constructor earlier is this sequence index we need. Since it\\'s availible on the node we are working with, we have what we need for these dynamic values.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\\n\\nAt this point, if there are any valid matches, our loop will run over the end of the grid, and try to access invalid indexes. We need to test for reaching the end of sequences, and then act by adding the valid pair amount to the `pairs_count`. The amount of pairs to add is multiplication, each column matches with every row. Critically, we can\\'t let it attempt anything else in the loop for this sequence, as we want to avoid both accessing out of bound indexes, and stop adding children. We don\\'t want to break the loop though, there could still be valid pairs to process in the queue, so we `continue` to skip to the next node. Each node remaining will get processed without adding children until the queue is empty, exiting the loop.\\n\\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\\n\\nJust one more thing to add... One of the main benefits to this method is the reduced need to store data, but if you are paying attention, so far we have n levels in the tree which each have up to 2n values. That\\'s O(n<sup>2</sup>) which doesn\\'t save space at all. But, after putting all the children into the queue, we never revisit that node ever again. The node can be discarded. If we do, we will almost always have the equivalent of one level of the trie in memory during the breadth first processing. The one exception is when we have added the rows and columns to the children and are adding them to the queue. \\n\\nWe will evaluate 2 bad cases, one where all grid values are identical, and one where each row matches a different column:\\n\\nOne case, where all values in the grid are identical, each level will be 1 node with 2 lists, each having n values for 2n space. While creating and appending the children to the queue, we would have the lists for at most 2 levels in memory, for an upper limit of 4n grid index values, 2 indexes, and 1 int key, in addition to 2 ints and the deque with 2 items. O(4n + ~7) is O(n)\\n\\nAn alternative, where each row matches a different column, would have n nodes at each level of the trie, each with 1 match. Thats n items in the queue, n index values, 1 keys for children and 2n + 2 items in node lists, in addition to the 2 outer scope ints. I think this evalutates closer to O(3n + 4). Still O(n)\\n\\nAny other cases should get better space results than the worst of these 2.\\nThis gets O(n) space.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\\n\\n\\n# Complexity\\nWhere n is the length of a side of the grid.\\n- Time complexity:\\nO(n<sup>2</sup>)\\nWorst case is all rows and columns have matches. A grid with every value identical, or some alternative patterns where the sequences are different but every sequence has a match would have each element of the grid visted twice with this solution. Some value of O(n<sup>2</sup>) should be the minimum, as in this worst case any algorithm would need to visit and check every element, and there are n<sup>2</sup> elements.\\nBest case, at each index in range(n), all sequences that stop matching are discarded, leaving unneccesary elements never visited.\\n\\n- Space complexity:\\nO(n)\\nA tree of n levels is created, and each levels nodes contain arrays. if the entire level had that levels arrays concatenated, worst case would be 2n per level.\\nIf the entire tree was kept, that would be O(n<sup>2</sup>), but nodes are discarded after processing, with worst case 1 full level of the tree and 1 nodes children in memory. For a grid with identical values, that\\'s a cap of 2 levels: 4 lists with n length, but 4n is O(n), far better than O(n<sup>2</sup>) for large n\\'s\\n\\n\\n# Code\\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632449,
                "title": "c-intuitive-and-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create another vector of vector named v such that the columns of original grid are the rows of \\'v\\'.\\nAfter that we compare the rows of the original grid to each row of the new grid and increment the count if both the rows are totally same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632359,
                "title": "two-nested-loops-in-one-line-python",
                "content": "# Intuition\\nTranspose of a matrix and compare rows.\\n\\n# Approach\\nTwo nested loops.\\n\\n# Complexity\\n- Time complexity:  O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632207,
                "title": "easy-java-solution-javith-sadham-hussain",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632197,
                "title": "2-solutions-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 2 Solutions \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation \\uD83D\\uDE08\\n\\n## Solution - 1\\n\\n```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n\\n## Solution - 2\\n\\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```\\n### [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Dart",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632182,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n## Intuition\\nThe problem requires us to find the number of pairs `(ri, cj)` such that row `ri` and column `cj` are equal. We can use a hash table to store the `frequency` of each row. Then we can iterate over each column and check if it matches any row in the hash table.\\n\\n## Approach\\n1. Create a hash table to store the frequency of each row.\\n2. Iterate over each column and check if it matches any row in the hash table.\\n3. If it matches, add the frequency of that row to the `count`.\\n\\n\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632179,
                "title": "c-easy-understanding-and-easy-to-implement-clean-matrcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a matrix that are Transpose of the initial matrix and compare each row of initial matrix to each row of its transpose matrix when its equal just increment ans.\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927296,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1947166,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927568,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927314,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1949055,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1932258,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927857,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927467,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2059722,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2046804,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2045650,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 2001818,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1991924,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1975685,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1972771,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1965066,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1963877,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1959722,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1950408,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1929521,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1928642,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928454,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928180,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928179,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928166,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928148,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927831,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927763,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927748,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927714,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927696,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927659,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927607,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927575,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927496,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927301,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927276,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927154,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1907173,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1706555,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            }
        ]
    }
]